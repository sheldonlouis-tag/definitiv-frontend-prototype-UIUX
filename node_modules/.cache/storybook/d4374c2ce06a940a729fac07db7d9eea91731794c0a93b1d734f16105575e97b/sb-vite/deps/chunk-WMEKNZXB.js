import {
  check_target,
  component,
  hmr,
  if_block,
  legacy_api,
  spread_props,
  wrap_snippet
} from "./chunk-FRZCO2ZW.js";
import {
  append,
  comment,
  mount,
  unmount
} from "./chunk-OIZRCF3F.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  fallback,
  first_child,
  get,
  pop,
  proxy,
  push,
  set,
  tag,
  tag_proxy,
  user_derived,
  user_effect
} from "./chunk-ITKELFPS.js";
import {
  dedent
} from "./chunk-JLBFQ2EK.js";
import {
  require_core_events
} from "./chunk-QFCKH4KW.js";
import {
  __export
} from "./chunk-GEPAX6R6.js";
import {
  ya
} from "./chunk-OSCUPILM.js";
import {
  require_client_logger
} from "./chunk-LJWBQW54.js";
import {
  require_preview_api
} from "./chunk-EA2IITB3.js";
import {
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@storybook/svelte/dist/components/DecoratorHandler.svelte
DecoratorHandler[FILENAME] = "node_modules/@storybook/svelte/dist/components/DecoratorHandler.svelte";
function DecoratorHandler($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DecoratorHandler);
  let propsWithoutDocgenEvents = tag(user_derived(() => Object.fromEntries(Object.entries($$props.props).filter(([key]) => !key.startsWith("event_")))), "propsWithoutDocgenEvents");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => component(node_1, () => $$props.decorator.Component, ($$anchor3, decorator_Component) => {
          decorator_Component($$anchor3, spread_props(() => $$props.decorator.props, {
            children: wrap_snippet(DecoratorHandler, ($$anchor4, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => component(node_2, () => $$props.Component, ($$anchor5, Component_1) => {
                  Component_1($$anchor5, spread_props(() => get(propsWithoutDocgenEvents)));
                }),
                "component",
                DecoratorHandler,
                16,
                4,
                { componentTag: "Component" }
              );
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          }));
        }),
        "component",
        DecoratorHandler,
        15,
        2,
        { componentTag: "decorator.Component" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      add_svelte_meta(
        () => component(node_3, () => $$props.Component, ($$anchor3, Component_2) => {
          Component_2($$anchor3, spread_props(() => get(propsWithoutDocgenEvents)));
        }),
        "component",
        DecoratorHandler,
        19,
        2,
        { componentTag: "Component" }
      );
      append($$anchor2, fragment_3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.decorator) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      DecoratorHandler,
      14,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DecoratorHandler = hmr(DecoratorHandler, () => DecoratorHandler[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DecoratorHandler[HMR].source;
    set(DecoratorHandler[HMR].source, module.default[HMR].original);
  });
}
var DecoratorHandler_default = DecoratorHandler;

// node_modules/@storybook/svelte/dist/components/PreviewRender.svelte
PreviewRender[FILENAME] = "node_modules/@storybook/svelte/dist/components/PreviewRender.svelte";
function PreviewRender($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PreviewRender);
  let $$d = tag(
    user_derived(
      /** @type {import('svelte').SvelteComponent} */
      () => {
        return $$props.storyFn();
      }
    ),
    "[$derived object]"
  ), Component = tag(user_derived(() => get($$d).Component), "Component"), props = tag(user_derived(() => fallback(get($$d).props, () => ({}), true)), "props");
  user_effect(() => {
    if (!get(Component)) {
      $$props.showError({
        title: `Expecting a Svelte component from the story: "${$$props.name}" of "${$$props.title}".`,
        description: dedent`
        Did you forget to return the Svelte component configuration from the story?
        Use "() => ({ Component: YourComponent, props: {} })"
        when defining the story.
      `
      });
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => DecoratorHandler_default(node, {
      get Component() {
        return get(Component);
      },
      get props() {
        return get(props);
      }
    }),
    "component",
    PreviewRender,
    29,
    0,
    { componentTag: "DecoratorHandler" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PreviewRender = hmr(PreviewRender, () => PreviewRender[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PreviewRender[HMR].source;
    set(PreviewRender[HMR].source, module.default[HMR].original);
  });
}
var PreviewRender_default = PreviewRender;

// node_modules/@storybook/svelte/dist/createReactiveProps.svelte.js
var createReactiveProps = (data) => {
  const props = tag_proxy(proxy(data), "props");
  return props;
};

// node_modules/@storybook/svelte/dist/chunk-TTEVCAEV.mjs
var import_client_logger = __toESM(require_client_logger(), 1);
var import_core_events = __toESM(require_core_events(), 1);
var import_preview_api = __toESM(require_preview_api(), 1);
var entry_preview_exports = {};
__export(entry_preview_exports, { applyDecorators: () => decorateStory, argTypesEnhancers: () => argTypesEnhancers, mount: () => mount2, parameters: () => parameters, render: () => render, renderToCanvas: () => renderToCanvas });
function hasKeyword(keyword, keywords) {
  return keywords ? keywords.find((k) => k.name === keyword) != null : false;
}
var extractArgTypes = (component2) => {
  try {
    let docgen = component2.__docgen;
    if (docgen) return createArgTypes(docgen);
  } catch (err) {
    import_client_logger.logger.log(`Error extracting argTypes: ${err}`);
  }
  return {};
};
var createArgTypes = (docgen) => {
  let results = {};
  return docgen.data && docgen.data.forEach((item) => {
    results[item.name] = { ...parseTypeToControl(item.type), name: item.name, description: item.description || void 0, type: { required: hasKeyword("required", item.keywords || []), name: item.type?.text === "{}" ? "object" : item.type?.text }, table: { type: { summary: item.type?.text }, defaultValue: { summary: item.defaultValue }, category: "properties" } };
  }), docgen.events && docgen.events.forEach((item) => {
    results[`event_${item.name}`] = { name: item.name, action: item.name, control: false, ...item.description ? { description: item.description } : {}, table: { category: "events" } };
  }), docgen.slots && docgen.slots.forEach((item) => {
    results[`slot_${item.name}`] = { name: item.name, control: false, description: [item.description, item.params?.map((p) => `\`${p.name}\``).join(" ")].filter((p) => p).join(`

`), table: { category: "slots" } };
  }), results;
};
var parseTypeToControl = (type) => {
  if (!type) return null;
  if (type.kind === "type") switch (type.type) {
    case "string":
      return { control: { type: "text" } };
    case "any":
      return { control: { type: "object" } };
    default:
      return { control: { type: type.type } };
  }
  else if (type.kind === "union") {
    if (Array.isArray(type.type) && !type.type.some((t) => t.kind !== "const" || !["string", "number", "null", "undefined"].includes(t.type))) {
      let options = type.type.map((t) => t.value);
      return { control: { type: "radio" }, options };
    }
  } else if (type.kind === "function") return { control: null };
  return null;
};
function extractComponentDescription(component2) {
  return component2?.__docgen?.description || "";
}
var storyIdsToRemountFromResetArgsEvent = /* @__PURE__ */ new Set();
import_preview_api.addons.getChannel().on(import_core_events.RESET_STORY_ARGS, ({ storyId }) => {
  storyIdsToRemountFromResetArgsEvent.add(storyId);
});
var componentsByDomElement = /* @__PURE__ */ new Map();
function renderToCanvas({ storyFn, title, name, showMain, showError, storyContext, forceRemount }, canvasElement) {
  function unmount2(canvasElementToUnmount) {
    let { mountedComponent } = componentsByDomElement.get(canvasElementToUnmount) ?? {};
    mountedComponent && (unmount(mountedComponent), componentsByDomElement.delete(canvasElementToUnmount));
  }
  let existingComponent = componentsByDomElement.get(canvasElement), remount = forceRemount;
  if (storyIdsToRemountFromResetArgsEvent.has(storyContext.id) && (remount = true, storyIdsToRemountFromResetArgsEvent.delete(storyContext.id)), remount && unmount2(canvasElement), !existingComponent || remount) {
    let props = createReactiveProps({ storyFn, storyContext, name, title, showError }), mountedComponent = mount(PreviewRender_default, { target: canvasElement, props });
    componentsByDomElement.set(canvasElement, { mountedComponent, props });
  } else Object.assign(existingComponent.props, { storyFn, storyContext, name, title, showError });
  return showMain(), () => {
    unmount2(canvasElement);
  };
}
var render = (args, context) => {
  let { id, component: Component } = context;
  if (!Component) throw new Error(`Unable to render story ${id} as the component annotation is missing from the default export`);
  return { Component, props: args };
};
function unWrap(obj) {
  return obj && typeof obj == "object" && "default" in obj ? obj.default : obj;
}
function prepareStory(context, rawStory, rawInnerStory) {
  let story = unWrap(rawStory), innerStory = rawInnerStory && unWrap(rawInnerStory), preparedStory;
  return !story || Object.keys(story).length === 0 ? preparedStory = { Component: context.component } : story.Component ? preparedStory = story : preparedStory = { Component: story }, innerStory ? { Component: DecoratorHandler_default, props: { ...innerStory, decorator: preparedStory } } : { ...preparedStory, argTypes: context.argTypes };
}
function decorateStory(storyFn, decorators) {
  return decorators.reduce((decorated, decorator) => (context) => {
    let story, decoratedStory = decorator((update) => (story = decorated({ ...context, ...(0, import_preview_api.sanitizeStoryContextUpdate)(update) }), story), context);
    return story || (story = decorated(context)), decoratedStory === story ? story : prepareStory(context, decoratedStory, story);
  }, (context) => prepareStory(context, storyFn(context)));
}
var mount2 = (context) => async (Component, options) => (Component && (context.originalStoryFn = () => ({ Component, props: options && "props" in options ? options?.props : options })), await context.renderToCanvas(), context.canvas);
var parameters = { renderer: "svelte", docs: { story: { inline: true }, extractArgTypes, extractComponentDescription } };
var argTypesEnhancers = [ya];

export {
  PreviewRender_default,
  createReactiveProps,
  entry_preview_exports,
  renderToCanvas,
  render,
  decorateStory,
  mount2,
  parameters,
  argTypesEnhancers
};
//# sourceMappingURL=chunk-WMEKNZXB.js.map
