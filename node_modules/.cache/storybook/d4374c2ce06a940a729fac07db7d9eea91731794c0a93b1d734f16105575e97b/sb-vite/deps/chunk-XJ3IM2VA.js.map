{
  "version": 3,
  "sources": ["../../../../../svelte-toolbelt/dist/utils/compose-handlers.js", "../../../../../svelte-toolbelt/dist/utils/strings.js", "../../../../../svelte-toolbelt/dist/utils/css-to-style-obj.js", "../../../../../svelte-toolbelt/dist/utils/is.js", "../../../../../svelte-toolbelt/dist/utils/execute-callbacks.js", "../../../../../svelte-toolbelt/dist/utils/style-to-css.js", "../../../../../svelte-toolbelt/dist/utils/style.js", "../../../../../svelte-toolbelt/dist/utils/event-list.js", "../../../../../svelte-toolbelt/dist/utils/merge-props.js", "../../../../../svelte-toolbelt/dist/box/box.svelte.js", "../../../../../runed/dist/utilities/context/context.js", "../../../../../runed/dist/utilities/watch/watch.svelte.js", "../../../../../runed/dist/utilities/previous/previous.svelte.js", "../../../../../runed/dist/internal/configurable-globals.js", "../../../../../runed/dist/internal/utils/dom.js", "../../../../../runed/dist/utilities/active-element/active-element.svelte.js", "../../../../../runed/dist/internal/utils/is.js", "../../../../../runed/dist/utilities/extract/extract.svelte.js", "../../../../../runed/dist/utilities/use-debounce/use-debounce.svelte.js", "../../../../../runed/dist/internal/utils/get.js", "../../../../../runed/dist/utilities/element-size/element-size.svelte.js", "../../../../../runed/dist/utilities/is-mounted/is-mounted.svelte.js", "../../../../../runed/dist/utilities/resource/resource.svelte.js", "../../../../../svelte-toolbelt/dist/utils/dom.js", "../../../../../svelte-toolbelt/dist/utils/dom-context.svelte.js", "../../../../../svelte-toolbelt/dist/utils/attach-ref.js", "../../../../../svelte-toolbelt/dist/utils/events.js", "../../../../../svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js", "../../../../../svelte-toolbelt/dist/utils/after-sleep.js", "../../../../../svelte-toolbelt/dist/utils/after-tick.js", "../../../../../svelte-toolbelt/dist/utils/on-mount-effect.svelte.js"],
  "sourcesContent": ["/**\n * Composes event handlers into a single function that can be called with an event.\n * If the previous handler cancels the event using `event.preventDefault()`, the handlers\n * that follow will not be called.\n */\nexport function composeHandlers(...handlers) {\n    return function (e) {\n        for (const handler of handlers) {\n            if (!handler)\n                continue;\n            if (e.defaultPrevented)\n                return;\n            if (typeof handler === \"function\") {\n                handler.call(this, e);\n            }\n            else {\n                handler.current?.call(this, e);\n            }\n        }\n    };\n}\n", "const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n    if (NUMBER_CHAR_RE.test(char))\n        return undefined;\n    return char !== char.toLowerCase();\n}\nfunction splitByCase(str) {\n    const parts = [];\n    let buff = \"\";\n    let previousUpper;\n    let previousSplitter;\n    for (const char of str) {\n        // Splitter\n        const isSplitter = STR_SPLITTERS.includes(char);\n        if (isSplitter === true) {\n            parts.push(buff);\n            buff = \"\";\n            previousUpper = undefined;\n            continue;\n        }\n        const isUpper = isUppercase(char);\n        if (previousSplitter === false) {\n            // Case rising edge\n            if (previousUpper === false && isUpper === true) {\n                parts.push(buff);\n                buff = char;\n                previousUpper = isUpper;\n                continue;\n            }\n            // Case falling edge\n            if (previousUpper === true && isUpper === false && buff.length > 1) {\n                const lastChar = buff.at(-1);\n                parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n                buff = lastChar + char;\n                previousUpper = isUpper;\n                continue;\n            }\n        }\n        // Normal char\n        buff += char;\n        previousUpper = isUpper;\n        previousSplitter = isSplitter;\n    }\n    parts.push(buff);\n    return parts;\n}\nexport function pascalCase(str) {\n    if (!str)\n        return \"\";\n    return splitByCase(str)\n        .map((p) => upperFirst(p))\n        .join(\"\");\n}\nexport function camelCase(str) {\n    return lowerFirst(pascalCase(str || \"\"));\n}\nexport function kebabCase(str) {\n    return str\n        ? splitByCase(str)\n            .map((p) => p.toLowerCase())\n            .join(\"-\")\n        : \"\";\n}\nfunction upperFirst(str) {\n    return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n    return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\n", "import parse from \"style-to-object\";\nimport { camelCase, pascalCase } from \"./strings.js\";\nexport function cssToStyleObj(css) {\n    if (!css)\n        return {};\n    const styleObj = {};\n    function iterator(name, value) {\n        if (name.startsWith(\"-moz-\") ||\n            name.startsWith(\"-webkit-\") ||\n            name.startsWith(\"-ms-\") ||\n            name.startsWith(\"-o-\")) {\n            styleObj[pascalCase(name)] = value;\n            return;\n        }\n        if (name.startsWith(\"--\")) {\n            styleObj[name] = value;\n            return;\n        }\n        styleObj[camelCase(name)] = value;\n    }\n    parse(css, iterator);\n    return styleObj;\n}\n", "export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nconst CLASS_VALUE_PRIMITIVE_TYPES = [\"string\", \"number\", \"bigint\", \"boolean\"];\nexport function isClassValue(value) {\n    // handle primitive types\n    if (value === null || value === undefined)\n        return true;\n    if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))\n        return true;\n    // handle arrays (ClassArray)\n    if (Array.isArray(value))\n        return value.every((item) => isClassValue(item));\n    // handle objects (ClassDictionary)\n    if (typeof value === \"object\") {\n        // ensure it's a plain object and not some other object type\n        if (Object.getPrototypeOf(value) !== Object.prototype)\n            return false;\n        return true;\n    }\n    return false;\n}\n", "/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param callbacks array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n", "function createParser(matcher, replacer) {\n    const regex = RegExp(matcher, \"g\");\n    return (str) => {\n        // throw an error if not a string\n        if (typeof str !== \"string\") {\n            throw new TypeError(`expected an argument of type string, but got ${typeof str}`);\n        }\n        // if no match between string and matcher\n        if (!str.match(regex))\n            return str;\n        // executes the replacer function for each match\n        return str.replace(regex, replacer);\n    };\n}\nconst camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);\nexport function styleToCSS(styleObj) {\n    if (!styleObj || typeof styleObj !== \"object\" || Array.isArray(styleObj)) {\n        throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);\n    }\n    return Object.keys(styleObj)\n        .map((property) => `${camelToKebab(property)}: ${styleObj[property]};`)\n        .join(\"\\n\");\n}\n", "import { styleToCSS } from \"./style-to-css.js\";\nexport function styleToString(style = {}) {\n    return styleToCSS(style).replace(\"\\n\", \" \");\n}\nexport const srOnlyStyles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    padding: \"0\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    borderWidth: \"0\",\n    transform: \"translateX(-100%)\"\n};\nexport const srOnlyStylesString = styleToString(srOnlyStyles);\n", "const EVENT_LIST = [\n    \"onabort\",\n    \"onanimationcancel\",\n    \"onanimationend\",\n    \"onanimationiteration\",\n    \"onanimationstart\",\n    \"onauxclick\",\n    \"onbeforeinput\",\n    \"onbeforetoggle\",\n    \"onblur\",\n    \"oncancel\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"onchange\",\n    \"onclick\",\n    \"onclose\",\n    \"oncompositionend\",\n    \"oncompositionstart\",\n    \"oncompositionupdate\",\n    \"oncontextlost\",\n    \"oncontextmenu\",\n    \"oncontextrestored\",\n    \"oncopy\",\n    \"oncuechange\",\n    \"oncut\",\n    \"ondblclick\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onended\",\n    \"onerror\",\n    \"onfocus\",\n    \"onfocusin\",\n    \"onfocusout\",\n    \"onformdata\",\n    \"ongotpointercapture\",\n    \"oninput\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeyup\",\n    \"onload\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadstart\",\n    \"onlostpointercapture\",\n    \"onmousedown\",\n    \"onmouseenter\",\n    \"onmouseleave\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onpaste\",\n    \"onpause\",\n    \"onplay\",\n    \"onplaying\",\n    \"onpointercancel\",\n    \"onpointerdown\",\n    \"onpointerenter\",\n    \"onpointerleave\",\n    \"onpointermove\",\n    \"onpointerout\",\n    \"onpointerover\",\n    \"onpointerup\",\n    \"onprogress\",\n    \"onratechange\",\n    \"onreset\",\n    \"onresize\",\n    \"onscroll\",\n    \"onscrollend\",\n    \"onsecuritypolicyviolation\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onselectionchange\",\n    \"onselectstart\",\n    \"onslotchange\",\n    \"onstalled\",\n    \"onsubmit\",\n    \"onsuspend\",\n    \"ontimeupdate\",\n    \"ontoggle\",\n    \"ontouchcancel\",\n    \"ontouchend\",\n    \"ontouchmove\",\n    \"ontouchstart\",\n    \"ontransitioncancel\",\n    \"ontransitionend\",\n    \"ontransitionrun\",\n    \"ontransitionstart\",\n    \"onvolumechange\",\n    \"onwaiting\",\n    \"onwebkitanimationend\",\n    \"onwebkitanimationiteration\",\n    \"onwebkitanimationstart\",\n    \"onwebkittransitionend\",\n    \"onwheel\"\n];\nexport const EVENT_LIST_SET = new Set(EVENT_LIST);\n", "/**\n * Modified from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts (see NOTICE.txt for source)\n */\nimport { clsx } from \"clsx\";\nimport { composeHandlers } from \"./compose-handlers.js\";\nimport { cssToStyleObj } from \"./css-to-style-obj.js\";\nimport { isClassValue } from \"./is.js\";\nimport { executeCallbacks } from \"./execute-callbacks.js\";\nimport { styleToString } from \"./style.js\";\nimport { EVENT_LIST_SET } from \"./event-list.js\";\nfunction isEventHandler(key) {\n    return EVENT_LIST_SET.has(key);\n}\n/**\n * Given a list of prop objects, merges them into a single object.\n * - Automatically composes event handlers (e.g. `onclick`, `oninput`, etc.)\n * - Chains regular functions with the same name so they are called in order\n * - Merges class strings with `clsx`\n * - Merges style objects and converts them to strings\n * - Handles a bug with Svelte where setting the `hidden` attribute to `false` doesn't remove it\n * - Overrides other values with the last one\n */\nexport function mergeProps(...args) {\n    const result = { ...args[0] };\n    for (let i = 1; i < args.length; i++) {\n        const props = args[i];\n        if (!props)\n            continue;\n        // Handle string keys\n        for (const key of Object.keys(props)) {\n            const a = result[key];\n            const b = props[key];\n            const aIsFunction = typeof a === \"function\";\n            const bIsFunction = typeof b === \"function\";\n            // compose event handlers\n            if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {\n                // handle merging of event handlers\n                const aHandler = a;\n                const bHandler = b;\n                result[key] = composeHandlers(aHandler, bHandler);\n            }\n            else if (aIsFunction && bIsFunction) {\n                // chain non-event handler functions\n                result[key] = executeCallbacks(a, b);\n            }\n            else if (key === \"class\") {\n                // handle merging acceptable class values from clsx\n                const aIsClassValue = isClassValue(a);\n                const bIsClassValue = isClassValue(b);\n                if (aIsClassValue && bIsClassValue) {\n                    result[key] = clsx(a, b);\n                }\n                else if (aIsClassValue) {\n                    result[key] = clsx(a);\n                }\n                else if (bIsClassValue) {\n                    result[key] = clsx(b);\n                }\n            }\n            else if (key === \"style\") {\n                const aIsObject = typeof a === \"object\";\n                const bIsObject = typeof b === \"object\";\n                const aIsString = typeof a === \"string\";\n                const bIsString = typeof b === \"string\";\n                if (aIsObject && bIsObject) {\n                    // both are style objects, merge them\n                    result[key] = { ...a, ...b };\n                }\n                else if (aIsObject && bIsString) {\n                    // a is style object, b is string, convert b to style object and merge\n                    const parsedStyle = cssToStyleObj(b);\n                    result[key] = { ...a, ...parsedStyle };\n                }\n                else if (aIsString && bIsObject) {\n                    // a is string, b is style object, convert a to style object and merge\n                    const parsedStyle = cssToStyleObj(a);\n                    result[key] = { ...parsedStyle, ...b };\n                }\n                else if (aIsString && bIsString) {\n                    // both are strings, convert both to objects and merge\n                    const parsedStyleA = cssToStyleObj(a);\n                    const parsedStyleB = cssToStyleObj(b);\n                    result[key] = { ...parsedStyleA, ...parsedStyleB };\n                }\n                else if (aIsObject) {\n                    result[key] = a;\n                }\n                else if (bIsObject) {\n                    result[key] = b;\n                }\n                else if (aIsString) {\n                    result[key] = a;\n                }\n                else if (bIsString) {\n                    result[key] = b;\n                }\n            }\n            else {\n                // override other values\n                result[key] = b !== undefined ? b : a;\n            }\n        }\n        // handle symbol keys (mostly for `Attachments`)\n        for (const key of Object.getOwnPropertySymbols(props)) {\n            const a = result[key];\n            const b = props[key];\n            // for matching symbols, we just override\n            result[key] = b !== undefined ? b : a;\n        }\n    }\n    // convert style object to string\n    if (typeof result.style === \"object\") {\n        result.style = styleToString(result.style).replaceAll(\"\\n\", \" \");\n    }\n    // handle weird svelte bug where `hidden` is not removed when set to `false`\n    if (result.hidden !== true) {\n        result.hidden = undefined;\n        delete result.hidden;\n    }\n    // handle weird svelte bug where `disabled` is not removed when set to `false`\n    if (result.disabled !== true) {\n        result.disabled = undefined;\n        delete result.disabled;\n    }\n    return result;\n}\n", "import { isFunction, isObject } from \"../utils/is.js\";\nconst BoxSymbol = Symbol(\"box\");\nconst isWritableSymbol = Symbol(\"is-writable\");\n/**\n * @returns Whether the value is a Box\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isBox(value) {\n    return isObject(value) && BoxSymbol in value;\n}\n/**\n * @returns Whether the value is a WritableBox\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isWritableBox(value) {\n    return box.isBox(value) && isWritableSymbol in value;\n}\nexport function box(initialValue) {\n    let current = $state(initialValue);\n    return {\n        [BoxSymbol]: true,\n        [isWritableSymbol]: true,\n        get current() {\n            return current;\n        },\n        set current(v) {\n            current = v;\n        }\n    };\n}\nfunction boxWith(getter, setter) {\n    const derived = $derived.by(getter);\n    if (setter) {\n        return {\n            [BoxSymbol]: true,\n            [isWritableSymbol]: true,\n            get current() {\n                return derived;\n            },\n            set current(v) {\n                setter(v);\n            }\n        };\n    }\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return getter();\n        }\n    };\n}\nfunction boxFrom(value) {\n    if (box.isBox(value))\n        return value;\n    if (isFunction(value))\n        return box.with(value);\n    return box(value);\n}\n/**\n * Function that gets an object of boxes, and returns an object of reactive values\n *\n * @example\n * const count = box(0)\n * const flat = box.flatten({ count, double: box.with(() => count.current) })\n * // type of flat is { count: number, readonly double: number }\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction boxFlatten(boxes) {\n    return Object.entries(boxes).reduce((acc, [key, b]) => {\n        if (!box.isBox(b)) {\n            return Object.assign(acc, { [key]: b });\n        }\n        if (box.isWritableBox(b)) {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                },\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                set(v) {\n                    b.current = v;\n                }\n            });\n        }\n        else {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                }\n            });\n        }\n        return acc;\n    }, {});\n}\n/**\n * Function that converts a box to a readonly box.\n *\n * @example\n * const count = box(0) // WritableBox<number>\n * const countReadonly = box.readonly(count) // ReadableBox<number>\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction toReadonlyBox(b) {\n    if (!box.isWritableBox(b))\n        return b;\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return b.current;\n        }\n    };\n}\nbox.from = boxFrom;\nbox.with = boxWith;\nbox.flatten = boxFlatten;\nbox.readonly = toReadonlyBox;\nbox.isBox = isBox;\nbox.isWritableBox = isWritableBox;\n", "import { getContext, hasContext, setContext } from \"svelte\";\nexport class Context {\n    #name;\n    #key;\n    /**\n     * @param name The name of the context.\n     * This is used for generating the context key and error messages.\n     */\n    constructor(name) {\n        this.#name = name;\n        this.#key = Symbol(name);\n    }\n    /**\n     * The key used to get and set the context.\n     *\n     * It is not recommended to use this value directly.\n     * Instead, use the methods provided by this class.\n     */\n    get key() {\n        return this.#key;\n    }\n    /**\n     * Checks whether this has been set in the context of a parent component.\n     *\n     * Must be called during component initialisation.\n     */\n    exists() {\n        return hasContext(this.#key);\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component.\n     *\n     * Must be called during component initialisation.\n     *\n     * @throws An error if the context does not exist.\n     */\n    get() {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            throw new Error(`Context \"${this.#name}\" not found`);\n        }\n        return context;\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component,\n     * or the given fallback value if the context does not exist.\n     *\n     * Must be called during component initialisation.\n     */\n    getOr(fallback) {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            return fallback;\n        }\n        return context;\n    }\n    /**\n     * Associates the given value with the current component and returns it.\n     *\n     * Must be called during component initialisation.\n     */\n    set(context) {\n        return setContext(this.#key, context);\n    }\n}\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { watch } from \"../watch/watch.svelte.js\";\n/**\n * Holds the previous value of a getter.\n *\n * @see {@link https://runed.dev/docs/utilities/previous}\n */\nexport class Previous {\n    #previous = $state(undefined);\n    constructor(getter, initialValue) {\n        if (initialValue !== undefined)\n            this.#previous = initialValue;\n        watch(() => getter(), (_, v) => {\n            this.#previous = v;\n        });\n    }\n    get current() {\n        return this.#previous;\n    }\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nexport function isElement(value) {\n    return value instanceof Element;\n}\n", "import { isFunction } from \"../../internal/utils/is.js\";\nexport function extract(value, defaultValue) {\n    if (isFunction(value)) {\n        const getter = value;\n        const gotten = getter();\n        if (gotten === undefined)\n            return defaultValue;\n        return gotten;\n    }\n    if (value === undefined)\n        return defaultValue;\n    return value;\n}\n", "import { extract } from \"../extract/extract.svelte.js\";\n/**\n * Function that takes a callback, and returns a debounced version of it.\n * When calling the debounced function, it will wait for the specified time\n * before calling the original callback. If the debounced function is called\n * again before the time has passed, the timer will be reset.\n *\n * You can await the debounced function to get the value when it is eventually\n * called.\n *\n * The second parameter is the time to wait before calling the original callback.\n * Alternatively, it can also be a getter function that returns the time to wait.\n *\n * @see {@link https://runed.dev/docs/utilities/use-debounce}\n *\n * @param callback The callback to call when the time has passed.\n * @param wait The length of time to wait in ms, defaults to 250.\n */\nexport function useDebounce(callback, wait) {\n    let context = $state(null);\n    const wait$ = $derived(extract(wait, 250));\n    function debounced(...args) {\n        if (context) {\n            // Old context will be reused so callers awaiting the promise will get the\n            // new value\n            if (context.timeout) {\n                clearTimeout(context.timeout);\n            }\n        }\n        else {\n            // No old context, create a new one\n            let resolve;\n            let reject;\n            const promise = new Promise((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            context = {\n                timeout: null,\n                runner: null,\n                promise,\n                resolve: resolve,\n                reject: reject,\n            };\n        }\n        context.runner = async () => {\n            // Grab the context and reset it\n            // -> new debounced calls will create a new context\n            if (!context)\n                return;\n            const ctx = context;\n            context = null;\n            try {\n                ctx.resolve(await callback.apply(this, args));\n            }\n            catch (error) {\n                ctx.reject(error);\n            }\n        };\n        context.timeout = setTimeout(context.runner, wait$);\n        return context.promise;\n    }\n    debounced.cancel = async () => {\n        if (!context || context.timeout === null) {\n            // Wait one event loop to see if something triggered the debounced function\n            await new Promise((resolve) => setTimeout(resolve, 0));\n            if (!context || context.timeout === null)\n                return;\n        }\n        clearTimeout(context.timeout);\n        context.reject(\"Cancelled\");\n        context = null;\n    };\n    debounced.runScheduledNow = async () => {\n        if (!context || !context.timeout) {\n            // Wait one event loop to see if something triggered the debounced function\n            await new Promise((resolve) => setTimeout(resolve, 0));\n            if (!context || !context.timeout)\n                return;\n        }\n        clearTimeout(context.timeout);\n        context.timeout = null;\n        await context.runner?.();\n    };\n    Object.defineProperty(debounced, \"pending\", {\n        enumerable: true,\n        get() {\n            return !!context?.timeout;\n        },\n    });\n    return debounced;\n}\n", "import { isFunction } from \"./is.js\";\nexport function get(value) {\n    if (isFunction(value)) {\n        return value();\n    }\n    return value;\n}\n", "import { defaultWindow } from \"../../internal/configurable-globals.js\";\nimport { get } from \"../../internal/utils/get.js\";\nimport { createSubscriber } from \"svelte/reactivity\";\n/**\n * Returns a reactive value holding the size of `node`.\n *\n * Accepts an `options` object with the following properties:\n * - `initialSize`: The initial size of the element. Defaults to `{ width: 0, height: 0 }`.\n * - `box`: The box model to use. Can be either `\"content-box\"` or `\"border-box\"`. Defaults to `\"border-box\"`.\n *\n * @returns an object with `width` and `height` properties.\n *\n * @see {@link https://runed.dev/docs/utilities/element-size}\n */\nexport class ElementSize {\n    // no need to use `$state` here since we are using createSubscriber\n    #size = {\n        width: 0,\n        height: 0,\n    };\n    #observed = false;\n    #options;\n    #node;\n    #window;\n    // we use a derived here to extract the width so that if the width doesn't change we don't get a state update\n    // which we would get if we would just use a getter since the version of the subscriber will be changing\n    #width = $derived.by(() => {\n        this.#subscribe?.();\n        return this.getSize().width;\n    });\n    // we use a derived here to extract the height so that if the height doesn't change we don't get a state update\n    // which we would get if we would just use a getter since the version of the subscriber will be changing\n    #height = $derived.by(() => {\n        this.#subscribe?.();\n        return this.getSize().height;\n    });\n    // we need to use a derived here because the class will be created before the node is bound to the ref\n    #subscribe = $derived.by(() => {\n        const node$ = get(this.#node);\n        if (!node$)\n            return;\n        return createSubscriber((update) => {\n            if (!this.#window)\n                return;\n            const observer = new this.#window.ResizeObserver((entries) => {\n                this.#observed = true;\n                for (const entry of entries) {\n                    const boxSize = this.#options.box === \"content-box\" ? entry.contentBoxSize : entry.borderBoxSize;\n                    const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];\n                    this.#size.width = boxSizeArr.reduce((acc, size) => Math.max(acc, size.inlineSize), 0);\n                    this.#size.height = boxSizeArr.reduce((acc, size) => Math.max(acc, size.blockSize), 0);\n                }\n                update();\n            });\n            observer.observe(node$);\n            return () => {\n                this.#observed = false;\n                observer.disconnect();\n            };\n        });\n    });\n    constructor(node, options = { box: \"border-box\" }) {\n        this.#window = options.window ?? defaultWindow;\n        this.#options = options;\n        this.#node = node;\n        this.#size = {\n            width: 0,\n            height: 0,\n        };\n    }\n    calculateSize() {\n        const element = get(this.#node);\n        // no element or no window, return undefined, we will return 0x0 in the getSize method\n        if (!element || !this.#window) {\n            return;\n        }\n        const offsetWidth = element.offsetWidth;\n        const offsetHeight = element.offsetHeight;\n        // easy mode, just return offsets\n        if (this.#options.box === \"border-box\") {\n            return {\n                width: offsetWidth,\n                height: offsetHeight,\n            };\n        }\n        // hard mode, we need to calculate the content size\n        const style = this.#window.getComputedStyle(element);\n        const paddingWidth = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n        const paddingHeight = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);\n        const borderWidth = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n        const borderHeight = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n        const contentWidth = offsetWidth - paddingWidth - borderWidth;\n        const contentHeight = offsetHeight - paddingHeight - borderHeight;\n        return {\n            width: contentWidth,\n            height: contentHeight,\n        };\n    }\n    getSize() {\n        // if the resize observer already run we can just return the size\n        // otherwise we calculate the size if possible or we return the initial size\n        return this.#observed ? this.#size : (this.calculateSize() ?? this.#size);\n    }\n    get current() {\n        this.#subscribe?.();\n        return this.getSize();\n    }\n    get width() {\n        return this.#width;\n    }\n    get height() {\n        return this.#height;\n    }\n}\n", "import { untrack } from \"svelte\";\n/**\n * Returns an object with the mounted state of the component\n * that invokes this function.\n *\n * @see {@link https://runed.dev/docs/utilities/is-mounted}\n */\nexport class IsMounted {\n    #isMounted = $state(false);\n    constructor() {\n        $effect(() => {\n            untrack(() => (this.#isMounted = true));\n            return () => {\n                this.#isMounted = false;\n            };\n        });\n    }\n    get current() {\n        return this.#isMounted;\n    }\n}\n", "import { watch } from \"../watch/index.js\";\n// Helper functions for debounce and throttle\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction debounce(fn, delay) {\n    let timeoutId;\n    let lastResolve = null;\n    return (...args) => {\n        return new Promise((resolve) => {\n            if (lastResolve) {\n                lastResolve(undefined);\n            }\n            lastResolve = resolve;\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(async () => {\n                const result = await fn(...args);\n                if (lastResolve) {\n                    lastResolve(result);\n                    lastResolve = null;\n                }\n            }, delay);\n        });\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(fn, delay) {\n    let lastRun = 0;\n    let lastPromise = null;\n    return (...args) => {\n        const now = Date.now();\n        if (lastRun && now - lastRun < delay) {\n            return lastPromise ?? Promise.resolve(undefined);\n        }\n        lastRun = now;\n        lastPromise = fn(...args);\n        return lastPromise;\n    };\n}\nfunction runResource(source, fetcher, options = {}, effectFn) {\n    const { lazy = false, once = false, initialValue, debounce: debounceTime, throttle: throttleTime, } = options;\n    // Create state\n    let current = $state(initialValue);\n    let loading = $state(false);\n    let error = $state(undefined);\n    let cleanupFns = $state([]);\n    // Helper function to run cleanup functions\n    const runCleanup = () => {\n        cleanupFns.forEach((fn) => fn());\n        cleanupFns = [];\n    };\n    // Helper function to register cleanup\n    const onCleanup = (fn) => {\n        cleanupFns = [...cleanupFns, fn];\n    };\n    // Create the base fetcher function\n    const baseFetcher = async (value, previousValue, refetching = false) => {\n        try {\n            loading = true;\n            error = undefined;\n            runCleanup();\n            // Create new AbortController for this fetch\n            const controller = new AbortController();\n            onCleanup(() => controller.abort());\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const result = await fetcher(value, previousValue, {\n                data: current,\n                refetching,\n                onCleanup,\n                signal: controller.signal,\n            });\n            current = result;\n            return result;\n        }\n        catch (e) {\n            if (!(e instanceof DOMException && e.name === \"AbortError\")) {\n                error = e;\n            }\n            return undefined;\n        }\n        finally {\n            loading = false;\n        }\n    };\n    // Apply debounce or throttle if specified\n    const runFetcher = debounceTime\n        ? debounce(baseFetcher, debounceTime)\n        : throttleTime\n            ? throttle(baseFetcher, throttleTime)\n            : baseFetcher;\n    // Setup effect\n    const sources = Array.isArray(source) ? source : [source];\n    let prevValues;\n    effectFn((values, previousValues) => {\n        // Skip if once and already ran\n        if (once && prevValues) {\n            return;\n        }\n        prevValues = values;\n        runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);\n    }, { lazy });\n    return {\n        get current() {\n            return current;\n        },\n        get loading() {\n            return loading;\n        },\n        get error() {\n            return error;\n        },\n        mutate: (value) => {\n            current = value;\n        },\n        refetch: (info) => {\n            const values = sources.map((s) => s());\n            return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);\n        },\n    };\n}\n// Implementation\nexport function resource(source, fetcher, options) {\n    return runResource(source, fetcher, options, (fn, options) => {\n        const sources = Array.isArray(source) ? source : [source];\n        const getters = () => sources.map((s) => s());\n        watch(getters, (values, previousValues) => {\n            fn(values, previousValues ?? []);\n        }, options);\n    });\n}\n// Implementation\nexport function resourcePre(source, fetcher, options) {\n    return runResource(source, fetcher, options, (fn, options) => {\n        const sources = Array.isArray(source) ? source : [source];\n        const getter = () => sources.map((s) => s());\n        watch.pre(getter, (values, previousValues) => {\n            fn(values, previousValues ?? []);\n        }, options);\n    });\n}\nresource.pre = resourcePre;\n", "import { isObject } from \"./is.js\";\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_NODE = 9;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nexport function isHTMLElement(node) {\n    return isObject(node) && node.nodeType === ELEMENT_NODE && typeof node.nodeName === \"string\";\n}\nexport function isDocument(node) {\n    return isObject(node) && node.nodeType === DOCUMENT_NODE;\n}\nexport function isWindow(node) {\n    return isObject(node) && node.constructor?.name === \"VisualViewport\";\n}\nexport function getNodeName(node) {\n    if (isHTMLElement(node))\n        return node.localName ?? \"\";\n    return \"#document\";\n}\nexport function isNode(node) {\n    return isObject(node) && node.nodeType !== undefined;\n}\nexport function isShadowRoot(node) {\n    return isNode(node) && node.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in node;\n}\nexport function contains(parent, child) {\n    if (!parent || !child)\n        return false;\n    if (!isHTMLElement(parent) || !isHTMLElement(child))\n        return false;\n    const rootNode = child.getRootNode?.();\n    if (parent === child)\n        return true;\n    if (parent.contains(child))\n        return true;\n    if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        while (next) {\n            if (parent === next)\n                return true;\n            // @ts-expect-error - host is not typed\n            next = next.parentNode || next.host;\n        }\n    }\n    return false;\n}\nexport function getDocument(node) {\n    if (isDocument(node))\n        return node;\n    if (isWindow(node))\n        return node.document;\n    return node?.ownerDocument ?? document;\n}\nexport function getDocumentElement(node) {\n    return getDocument(node).documentElement;\n}\nexport function getWindow(node) {\n    if (isShadowRoot(node))\n        return getWindow(node.host);\n    if (isDocument(node))\n        return node.defaultView ?? window;\n    if (isHTMLElement(node))\n        return node.ownerDocument?.defaultView ?? window;\n    return window;\n}\nexport function getActiveElement(rootNode) {\n    let activeElement = rootNode.activeElement;\n    while (activeElement?.shadowRoot) {\n        const el = activeElement.shadowRoot.activeElement;\n        if (el === activeElement)\n            break;\n        else\n            activeElement = el;\n    }\n    return activeElement;\n}\nexport function getParentNode(node) {\n    if (getNodeName(node) === \"html\")\n        return node;\n    const result = \n    // @ts-expect-error - assignedSlot is not typed\n    node.assignedSlot ||\n        node.parentNode ||\n        (isShadowRoot(node) && node.host) ||\n        getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\n", "import { box } from \"../box/box.svelte.js\";\nimport { getActiveElement, getDocument } from \"./dom.js\";\nexport class DOMContext {\n    element;\n    root = $derived.by(() => {\n        if (!this.element.current)\n            return document;\n        const rootNode = this.element.current.getRootNode() ?? document;\n        return rootNode;\n    });\n    constructor(element) {\n        if (typeof element === \"function\") {\n            this.element = box.with(element);\n        }\n        else {\n            this.element = element;\n        }\n    }\n    getDocument = () => {\n        return getDocument(this.root);\n    };\n    getWindow = () => {\n        return this.getDocument().defaultView ?? window;\n    };\n    getActiveElement = () => {\n        return getActiveElement(this.root);\n    };\n    isActiveElement = (node) => {\n        return node === this.getActiveElement();\n    };\n    getElementById(id) {\n        return this.root.getElementById(id);\n    }\n    querySelector = (selector) => {\n        if (!this.root)\n            return null;\n        return this.root.querySelector(selector);\n    };\n    querySelectorAll = (selector) => {\n        if (!this.root)\n            return [];\n        return this.root.querySelectorAll(selector);\n    };\n    setTimeout = (callback, delay) => {\n        return this.getWindow().setTimeout(callback, delay);\n    };\n    clearTimeout = (timeoutId) => {\n        return this.getWindow().clearTimeout(timeoutId);\n    };\n}\n", "import { untrack } from \"svelte\";\nimport { box } from \"../box/box.svelte.js\";\nimport { createAttachmentKey } from \"svelte/attachments\";\n/**\n * Creates a Svelte Attachment that attaches a DOM element to a ref.\n * The ref can be either a WritableBox or a callback function.\n *\n * @param ref - Either a WritableBox to store the element in, or a callback function that receives the element\n * @param onChange - Optional callback that fires when the ref changes\n * @returns An object with a spreadable attachment key that should be spread onto the element\n *\n * @example\n * // Using with WritableBox\n * const ref = box<HTMLDivElement | null>(null);\n * <div {...attachRef(ref)}>Content</div>\n *\n * @example\n * // Using with callback\n * <div {...attachRef((node) => myNode = node)}>Content</div>\n *\n * @example\n * // Using with onChange\n * <div {...attachRef(ref, (node) => console.log(node))}>Content</div>\n */\nexport function attachRef(ref, onChange) {\n    return {\n        [createAttachmentKey()]: (node) => {\n            if (box.isBox(ref)) {\n                ref.current = node;\n                untrack(() => onChange?.(node));\n                return () => {\n                    // we don't want to detach the node if it's still connected\n                    if (\"isConnected\" in node && node.isConnected)\n                        return;\n                    ref.current = null;\n                    onChange?.(null);\n                };\n            }\n            ref(node);\n            untrack(() => onChange?.(node));\n            return () => {\n                // we don't want to detach the node if it's still connected\n                if (\"isConnected\" in node && node.isConnected)\n                    return;\n                ref(null);\n                onChange?.(null);\n            };\n        }\n    };\n}\n", "/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n", "export function onDestroyEffect(fn) {\n    $effect(() => {\n        return () => {\n            fn();\n        };\n    });\n}\n", "/**\n * A utility function that executes a callback after a specified number of milliseconds.\n */\nexport function afterSleep(ms, cb) {\n    return setTimeout(cb, ms);\n}\n", "import { tick } from \"svelte\";\nexport function afterTick(fn) {\n    tick().then(fn);\n}\n", "import { untrack } from \"svelte\";\nexport function onMountEffect(fn) {\n    $effect(() => {\n        const cleanup = untrack(() => fn());\n        return cleanup;\n    });\n}\n"],
  "mappings": "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",
  "names": ["document", "activeElement", "window", "document", "isFunction", "isFunction", "get", "isFunction", "get", "options", "getActiveElement", "activeElement", "getActiveElement"]
}
