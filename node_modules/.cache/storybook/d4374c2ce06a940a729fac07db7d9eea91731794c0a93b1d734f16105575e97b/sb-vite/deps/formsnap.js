import {
  esm_default
} from "./chunk-NRMMMDUL.js";
import {
  fromStore
} from "./chunk-BYJZDOBD.js";
import "./chunk-6LD3WD6G.js";
import {
  add_locations,
  attribute_effect,
  check_target,
  each,
  hmr,
  if_block,
  index,
  legacy_api,
  prop,
  rest_props,
  snippet,
  validate_snippet_args,
  wrap_snippet
} from "./chunk-FRZCO2ZW.js";
import {
  clsx
} from "./chunk-ZYTAZ2LT.js";
import {
  append,
  comment,
  from_html,
  set_text
} from "./chunk-OIZRCF3F.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  first_child,
  get,
  getContext,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  state,
  strict_equals,
  tag,
  template_effect,
  untrack,
  user_derived,
  user_effect
} from "./chunk-ITKELFPS.js";
import "./chunk-HXIGQYEZ.js";
import "./chunk-E62QTSXI.js";
import "./chunk-P6TGDP3C.js";
import "./chunk-PR4QN5HX.js";

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          // eslint-disable-next-line ts/no-explicit-any
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        handler.current?.call(this, e);
      }
    }
  };
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p) => upperFirst(p)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  esm_default(css, iterator);
  return styleObj;
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  return key.length > 2 && key.startsWith("on") && key[2] === key[2]?.toLowerCase();
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    for (const key in props) {
      const a = result[key];
      const b = props[key];
      const aIsFunction = typeof a === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a, b);
      } else if (key === "class") {
        const aIsClassValue = isClassValue(a);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key] = clsx(a, b);
        } else if (aIsClassValue) {
          result[key] = clsx(a);
        } else if (bIsClassValue) {
          result[key] = clsx(b);
        }
      } else if (key === "style") {
        const aIsObject = typeof a === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a;
        } else if (bIsObject) {
          result[key] = b;
        } else if (aIsString) {
          result[key] = a;
        } else if (bIsString) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a;
      }
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/use-ref-by-id.svelte.js
function useRefById({
  id,
  ref,
  deps = () => true,
  onRefChange = () => {
  },
  getRootNode = () => strict_equals(typeof document, "undefined", false) ? document : void 0
}) {
  const dependencies = tag(user_derived(() => deps()), "dependencies");
  const rootNode = tag(user_derived(() => getRootNode()), "rootNode");
  user_effect(() => {
    id.current;
    get(dependencies);
    get(rootNode);
    return untrack(() => {
      const node = get(rootNode)?.getElementById(id.current);
      if (node) {
        ref.current = node;
      } else {
        ref.current = null;
      }
      onRefChange(ref.current);
    });
  });
  user_effect(() => {
    return () => {
      ref.current = null;
      onRefChange(null);
    };
  });
}

// node_modules/formsnap/node_modules/svelte-toolbelt/dist/utils/use-on-change.svelte.js
function useOnChange(getDep, onChange) {
  const dep = tag(user_derived(getDep), "dep");
  user_effect(() => {
    get(dep);
    untrack(() => onChange(get(dep)));
  });
}

// node_modules/formsnap/dist/internal/utils/errors.js
function extractErrorArray(errors) {
  if (Array.isArray(errors))
    return [...errors];
  if (typeof errors === "object" && "_errors" in errors) {
    if (errors._errors !== void 0)
      return [...errors._errors];
  }
  return [];
}

// node_modules/formsnap/dist/internal/utils/path.js
function getValueAtPath(path, obj) {
  const keys = path.split(/[[\].]/).filter(Boolean);
  let value = obj;
  for (const key of keys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key];
  }
  return value;
}

// node_modules/formsnap/dist/internal/utils/attributes.js
function getAriaDescribedBy({ fieldErrorsId = void 0, descriptionId = void 0, errors }) {
  let describedBy = "";
  if (descriptionId) {
    describedBy += `${descriptionId} `;
  }
  if (errors.length && fieldErrorsId) {
    describedBy += fieldErrorsId;
  }
  return describedBy ? describedBy.trim() : void 0;
}
function getAriaRequired(constraints) {
  if (!("required" in constraints))
    return void 0;
  return constraints.required ? "true" : void 0;
}
function getAriaInvalid(errors) {
  return errors && errors.length ? "true" : void 0;
}
function getDataFsError(errors) {
  return errors && errors.length ? "" : void 0;
}

// node_modules/formsnap/dist/internal/utils/id.js
var count = 0;
function useId(prefix = "formsnap") {
  count++;
  return `${prefix}-${count}`;
}

// node_modules/formsnap/dist/formsnap.svelte.js
var FormFieldState = class {
  #name;
  #formErrors;
  #formConstraints;
  #formTainted;
  #formData;
  form;
  #_name = tag(user_derived(() => this.#name.current), "FormFieldState.name");
  get name() {
    return get(this.#_name);
  }
  set name(value) {
    set(this.#_name, value);
  }
  #errors = tag(user_derived(() => extractErrorArray(getValueAtPath(this.#name.current, structuredClone(this.#formErrors.current)))), "FormFieldState.errors");
  get errors() {
    return get(this.#errors);
  }
  set errors(value) {
    set(this.#errors, value);
  }
  #constraints = tag(user_derived(() => getValueAtPath(this.#name.current, structuredClone(this.#formConstraints.current)) ?? {}), "FormFieldState.constraints");
  get constraints() {
    return get(this.#constraints);
  }
  set constraints(value) {
    set(this.#constraints, value);
  }
  #tainted = tag(
    user_derived(() => this.#formTainted.current ? strict_equals(getValueAtPath(this.#name.current, structuredClone(this.#formTainted.current)), true) : false),
    "FormFieldState.tainted"
  );
  get tainted() {
    return get(this.#tainted);
  }
  set tainted(value) {
    set(this.#tainted, value);
  }
  #errorNode = tag(state(null), "FormFieldState.errorNode");
  get errorNode() {
    return get(this.#errorNode);
  }
  set errorNode(value) {
    set(this.#errorNode, value, true);
  }
  #descriptionNode = tag(state(null), "FormFieldState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #errorId = tag(state(), "FormFieldState.errorId");
  get errorId() {
    return get(this.#errorId);
  }
  set errorId(value) {
    set(this.#errorId, value, true);
  }
  #descriptionId = tag(state(), "FormFieldState.descriptionId");
  get descriptionId() {
    return get(this.#descriptionId);
  }
  set descriptionId(value) {
    set(this.#descriptionId, value, true);
  }
  constructor(props) {
    this.#name = props.name;
    this.form = props.form.current;
    this.#formErrors = fromStore(props.form.current.errors);
    this.#formConstraints = fromStore(props.form.current.constraints);
    this.#formTainted = fromStore(props.form.current.tainted);
    this.#formData = fromStore(props.form.current.form);
    user_effect(() => {
      if (this.errorNode && this.errorNode.id) {
        this.errorId = this.errorNode.id;
      }
    });
    user_effect(() => {
      if (this.descriptionNode && this.descriptionNode.id) {
        this.descriptionId = this.descriptionNode.id;
      }
    });
  }
  #snippetProps = tag(
    user_derived(() => ({
      value: this.#formData.current[this.#name.current],
      errors: this.errors,
      tainted: this.tainted,
      constraints: this.constraints
    })),
    "FormFieldState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
};
var ElementFieldState = class {
  #name;
  #formErrors;
  #formConstraints;
  #formTainted;
  #formData;
  #field;
  form;
  #_name = tag(
    user_derived(() => {
      const [path] = splitArrayPath(this.#name.current);
      return path;
    }),
    "ElementFieldState.name"
  );
  get name() {
    return get(this.#_name);
  }
  set name(value) {
    set(this.#_name, value);
  }
  #errors = tag(user_derived(() => extractErrorArray(getValueAtPath(this.#name.current, this.#formErrors.current))), "ElementFieldState.errors");
  get errors() {
    return get(this.#errors);
  }
  set errors(value) {
    set(this.#errors, value);
  }
  #constraints = tag(user_derived(() => getValueAtPath(this.#name.current, this.#formConstraints.current) ?? {}), "ElementFieldState.constraints");
  get constraints() {
    return get(this.#constraints);
  }
  set constraints(value) {
    set(this.#constraints, value);
  }
  #tainted = tag(
    user_derived(() => this.#formTainted.current ? strict_equals(getValueAtPath(this.#name.current, this.#formTainted.current), true) : false),
    "ElementFieldState.tainted"
  );
  get tainted() {
    return get(this.#tainted);
  }
  set tainted(value) {
    set(this.#tainted, value);
  }
  #errorNode = tag(state(null), "ElementFieldState.errorNode");
  get errorNode() {
    return get(this.#errorNode);
  }
  set errorNode(value) {
    set(this.#errorNode, value, true);
  }
  #descriptionNode = tag(state(null), "ElementFieldState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #derivedDescriptionNode = tag(
    user_derived(() => {
      if (this.descriptionNode) return this.descriptionNode;
      if (this.#field.descriptionNode) return this.#field.descriptionNode;
      return null;
    }),
    "ElementFieldState.derivedDescriptionNode"
  );
  get derivedDescriptionNode() {
    return get(this.#derivedDescriptionNode);
  }
  set derivedDescriptionNode(value) {
    set(this.#derivedDescriptionNode, value);
  }
  #value = tag(
    user_derived(() => {
      return getValueAtPath(this.#name.current, this.#formData.current);
    }),
    "ElementFieldState.value"
  );
  get value() {
    return get(this.#value);
  }
  set value(value) {
    set(this.#value, value);
  }
  #errorId = tag(state(), "ElementFieldState.errorId");
  get errorId() {
    return get(this.#errorId);
  }
  set errorId(value) {
    set(this.#errorId, value, true);
  }
  #descriptionId = tag(state(), "ElementFieldState.descriptionId");
  get descriptionId() {
    return get(this.#descriptionId);
  }
  set descriptionId(value) {
    set(this.#descriptionId, value, true);
  }
  constructor(props, field) {
    this.#name = props.name;
    this.form = props.form.current;
    this.#formErrors = fromStore(props.form.current.errors);
    this.#formConstraints = fromStore(props.form.current.constraints);
    this.#formTainted = fromStore(props.form.current.tainted);
    this.#formData = fromStore(props.form.current.form);
    this.#field = field;
    useOnChange(() => this.errorNode, (v) => {
      if (v && v.id) {
        this.errorId = v.id;
      }
    });
    useOnChange(() => this.descriptionNode, (v) => {
      if (v && v.id) {
        this.descriptionId = v.id;
      }
    });
  }
  #snippetProps = tag(
    user_derived(() => ({
      value: this.#formData.current[this.#name.current],
      errors: this.errors,
      tainted: this.tainted,
      constraints: (
        // @ts-expect-error - this type is wonky
        this.#formConstraints.current[this.#name.current] ?? {}
      )
    })),
    "ElementFieldState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
};
var FieldErrorsState = class {
  #ref;
  #id;
  field;
  #errorAttr = tag(user_derived(() => getDataFsError(this.field.errors)), "FieldErrorsState.#errorAttr");
  constructor(props, field) {
    this.#ref = props.ref;
    this.#id = props.id;
    this.field = field;
    useRefById({
      id: this.#id,
      ref: this.#ref,
      onRefChange: (node) => {
        this.field.errorNode = node;
      }
    });
  }
  #snippetProps = tag(user_derived(() => ({ errors: this.field.errors, errorProps: this.errorProps })), "FieldErrorsState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #fieldErrorsProps = tag(
    user_derived(() => ({
      id: this.#id.current,
      "data-fs-error": get(this.#errorAttr),
      "data-fs-field-errors": "",
      "aria-live": "assertive"
    })),
    "FieldErrorsState.fieldErrorsProps"
  );
  get fieldErrorsProps() {
    return get(this.#fieldErrorsProps);
  }
  set fieldErrorsProps(value) {
    set(this.#fieldErrorsProps, value);
  }
  #errorProps = tag(
    user_derived(() => ({
      "data-fs-field-error": "",
      "data-fs-error": get(this.#errorAttr)
    })),
    "FieldErrorsState.errorProps"
  );
  get errorProps() {
    return get(this.#errorProps);
  }
  set errorProps(value) {
    set(this.#errorProps, value);
  }
};
var DescriptionState = class {
  #ref;
  #id;
  field;
  constructor(props, field) {
    this.#ref = props.ref;
    this.#id = props.id;
    this.field = field;
    useRefById({
      id: this.#id,
      ref: this.#ref,
      onRefChange: (node) => {
        this.field.descriptionNode = node;
      }
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.#id.current,
      "data-fs-error": getDataFsError(this.field.errors),
      "data-fs-description": ""
    })),
    "DescriptionState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ControlState = class {
  #id;
  field;
  labelId = box(useId());
  #_id = tag(state(proxy(useId())), "ControlState.id");
  get id() {
    return get(this.#_id);
  }
  set id(value) {
    set(this.#_id, value, true);
  }
  constructor(props, field) {
    this.#id = props.id;
    this.field = field;
    useOnChange(() => this.#id.current, (v) => {
      this.id = v;
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.id,
      name: this.field.name,
      "data-fs-error": getDataFsError(this.field.errors),
      "aria-describedby": getAriaDescribedBy({
        fieldErrorsId: this.field.errorId,
        descriptionId: this.field.descriptionId,
        errors: this.field.errors
      }),
      "aria-invalid": getAriaInvalid(this.field.errors),
      "aria-required": getAriaRequired(this.field.constraints),
      "data-fs-control": ""
    })),
    "ControlState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  #labelProps = tag(
    user_derived(() => ({
      id: this.labelId.current,
      "data-fs-label": "",
      "data-fs-error": getDataFsError(this.field.errors),
      for: this.id
    })),
    "ControlState.labelProps"
  );
  get labelProps() {
    return get(this.#labelProps);
  }
  set labelProps(value) {
    set(this.#labelProps, value);
  }
};
var LabelState = class {
  #ref;
  #id;
  control;
  constructor(props, control) {
    this.#ref = props.ref;
    this.#id = props.id;
    this.control = control;
    this.control.labelId = this.#id;
    useRefById({ id: this.#id, ref: this.#ref });
  }
  get props() {
    return this.control.labelProps;
  }
};
var LegendState = class {
  #ref;
  #id;
  field;
  constructor(props, field) {
    this.#ref = props.ref;
    this.#id = props.id;
    this.field = field;
    useRefById({ id: this.#id, ref: this.#ref });
  }
  #props = tag(
    user_derived(() => ({
      id: this.#id.current,
      "data-fs-error": getDataFsError(this.field.errors),
      "data-fs-legend": ""
    })),
    "LegendState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var FORM_FIELD_CTX = Symbol.for("formsnap.form-field");
var FORM_CONTROL_CTX = Symbol.for("formsnap.form-control");
function useField(props) {
  return setContext(FORM_FIELD_CTX, new FormFieldState(props));
}
function useElementField(props) {
  const formField = getField();
  return setContext(FORM_FIELD_CTX, new ElementFieldState(props, formField));
}
function getField() {
  return getContext(FORM_FIELD_CTX);
}
function useFieldErrors(props) {
  return new FieldErrorsState(props, getField());
}
function useDescription(props) {
  return new DescriptionState(props, getField());
}
function useControl(props) {
  return setContext(FORM_CONTROL_CTX, new ControlState(props, getField()));
}
function _getFormControl() {
  return getContext(FORM_CONTROL_CTX);
}
function useLabel(props) {
  return new LabelState(props, _getFormControl());
}
function useLegend(props) {
  return new LegendState(props, getField());
}
function splitArrayPath(name) {
  const [path, index2] = name.split(/[[\]]/);
  return [path, index2];
}
function useFormField(props) {
  const fieldState = getContext(FORM_FIELD_CTX);
  const form = fieldState.form;
  const errorsId = tag(user_derived(() => props.errorsId ? props.errorsId() : void 0), "errorsId");
  const descriptionId = tag(user_derived(() => props.descriptionId ? props.descriptionId() : void 0), "descriptionId");
  useOnChange(() => get(errorsId), (v) => {
    if (v) {
      fieldState.errorId = v;
    }
  });
  useOnChange(() => get(descriptionId), (v) => {
    if (v) {
      fieldState.descriptionId = v;
    }
  });
  return {
    form,
    get name() {
      return fieldState.name;
    },
    get errors() {
      return fieldState.errors;
    },
    get constraints() {
      return fieldState.constraints;
    },
    get tainted() {
      return fieldState.tainted;
    },
    get errorsId() {
      return fieldState.errorId;
    },
    get descriptionId() {
      return fieldState.descriptionId;
    }
  };
}
function useFormControl(props) {
  const controlState = getContext(FORM_CONTROL_CTX);
  const id = tag(user_derived(() => props.id ? props.id() : void 0), "id");
  useOnChange(() => get(id), (v) => {
    if (v) {
      controlState.id = v;
    }
  });
  return {
    get id() {
      return controlState.id;
    },
    get labelProps() {
      return controlState.labelProps;
    },
    get props() {
      return controlState.props;
    }
  };
}
var getFormControl = useFormControl;
var getFormField = useFormField;

// node_modules/formsnap/dist/components/description.svelte
Description[FILENAME] = "node_modules/formsnap/dist/components/description.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Description[FILENAME], [[37, 1]]);
function Description($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Description);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const descriptionState = useDescription({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, descriptionState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Description, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Description, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Description,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Description = hmr(Description, () => Description[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Description[HMR].source;
    set(Description[HMR].source, module.default[HMR].original);
  });
}
var description_default = Description;

// node_modules/formsnap/dist/components/field.svelte
Field[FILENAME] = "node_modules/formsnap/dist/components/field.svelte";
function Field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Field);
  const fieldState = useField({
    form: box.with(() => $$props.form),
    name: box.with(() => $$props.name)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => fieldState.snippetProps), "render", Field, 37, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Field = hmr(Field, () => Field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Field[HMR].source;
    set(Field[HMR].source, module.default[HMR].original);
  });
}
var field_default = Field;

// node_modules/formsnap/dist/components/control.svelte
Control[FILENAME] = "node_modules/formsnap/dist/components/control.svelte";
function Control($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Control);
  let id = prop($$props, "id", 19, useId);
  const controlState = useControl({ id: box.with(() => id()) });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ props: controlState.props })), "render", Control, 34, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Control = hmr(Control, () => Control[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Control[HMR].source;
    set(Control[HMR].source, module.default[HMR].original);
  });
}
var control_default = Control;

// node_modules/formsnap/dist/components/label.svelte
Label[FILENAME] = "node_modules/formsnap/dist/components/label.svelte";
var root_22 = add_locations(from_html(`<label><!></label>`), Label[FILENAME], [[51, 1]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Label);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = useLabel({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Label, 49, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_22();
      attribute_effect(label, () => ({ ...get(mergedProps) }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Label, 52, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label,
      48,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Label = hmr(Label, () => Label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Label[HMR].source;
    set(Label[HMR].source, module.default[HMR].original);
  });
}
var label_default = Label;

// node_modules/formsnap/dist/components/field-errors.svelte
Field_errors[FILENAME] = "node_modules/formsnap/dist/components/field-errors.svelte";
var root_5 = add_locations(from_html(`<div> </div>`), Field_errors[FILENAME], [[51, 4]]);
var root_23 = add_locations(from_html(`<div><!></div>`), Field_errors[FILENAME], [[46, 1]]);
function Field_errors($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Field_errors);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const fieldErrorsState = useFieldErrors({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, fieldErrorsState.fieldErrorsProps)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...fieldErrorsState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Field_errors, 41, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var div = root_23();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children, () => fieldErrorsState.snippetProps), "render", Field_errors, 48, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          add_svelte_meta(
            () => each(node_4, 17, () => fieldErrorsState.field.errors, index, ($$anchor4, error) => {
              var div_1 = root_5();
              attribute_effect(div_1, () => ({ ...fieldErrorsState.errorProps }));
              var text = child(div_1, true);
              reset(div_1);
              template_effect(() => set_text(text, get(error)));
              append($$anchor4, div_1);
            }),
            "each",
            Field_errors,
            50,
            3
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Field_errors,
          47,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Field_errors,
      40,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Field_errors = hmr(Field_errors, () => Field_errors[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Field_errors[HMR].source;
    set(Field_errors[HMR].source, module.default[HMR].original);
  });
}
var field_errors_default = Field_errors;

// node_modules/formsnap/dist/components/fieldset.svelte
Fieldset[FILENAME] = "node_modules/formsnap/dist/components/fieldset.svelte";
var root_3 = add_locations(from_html(`<fieldset><!></fieldset>`), Fieldset[FILENAME], [[69, 3]]);
function Fieldset($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Fieldset);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "form",
      "name",
      "child",
      "children"
    ],
    "restProps"
  );
  useRefById({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, { id: id(), "data-fs-fieldset": "" })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Fieldset, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let value = () => $$arg0?.().value;
      value();
      let errors = () => $$arg0?.().errors;
      errors();
      let tainted = () => $$arg0?.().tainted;
      tainted();
      let constraints = () => $$arg0?.().constraints;
      constraints();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => snippet(node_2, () => $$props.child, () => ({
              props: get(mergedProps),
              value: value(),
              errors: errors(),
              tainted: tainted(),
              constraints: constraints()
            })),
            "render",
            Fieldset,
            61,
            3
          );
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fieldset = root_3();
          attribute_effect(fieldset, ($0) => ({ ...get(mergedProps), "data-fs-error": $0 }), [() => getDataFsError(errors())]);
          var node_3 = child(fieldset);
          add_svelte_meta(
            () => snippet(node_3, () => $$props.children ?? noop, () => ({
              value: value(),
              errors: errors(),
              tainted: tainted(),
              constraints: constraints()
            })),
            "render",
            Fieldset,
            70,
            4
          );
          reset(fieldset);
          append($$anchor3, fieldset);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Fieldset,
          60,
          2
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => field_default(node, {
        get form() {
          return $$props.form;
        },
        get name() {
          return $$props.name;
        },
        children,
        $$slots: { default: true }
      }),
      "component",
      Fieldset,
      58,
      0,
      { componentTag: "Field" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Fieldset = hmr(Fieldset, () => Fieldset[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Fieldset[HMR].source;
    set(Fieldset[HMR].source, module.default[HMR].original);
  });
}
var fieldset_default = Fieldset;

// node_modules/formsnap/dist/components/legend.svelte
Legend[FILENAME] = "node_modules/formsnap/dist/components/legend.svelte";
var root_24 = add_locations(from_html(`<legend><!></legend>`), Legend[FILENAME], [[40, 1]]);
function Legend($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Legend);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const legendState = useLegend({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, legendState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Legend, 38, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var legend = root_24();
      attribute_effect(legend, () => ({ ...get(mergedProps) }));
      var node_2 = child(legend);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Legend, 41, 2);
      reset(legend);
      append($$anchor2, legend);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Legend,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Legend = hmr(Legend, () => Legend[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Legend[HMR].source;
    set(Legend[HMR].source, module.default[HMR].original);
  });
}
var legend_default = Legend;

// node_modules/formsnap/dist/components/element-field.svelte
Element_field[FILENAME] = "node_modules/formsnap/dist/components/element-field.svelte";
function Element_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Element_field);
  const elementFieldState = useElementField({
    form: box.with(() => $$props.form),
    name: box.with(() => $$props.name)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => elementFieldState.snippetProps), "render", Element_field, 37, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Element_field = hmr(Element_field, () => Element_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Element_field[HMR].source;
    set(Element_field[HMR].source, module.default[HMR].original);
  });
}
var element_field_default = Element_field;
export {
  control_default as Control,
  description_default as Description,
  element_field_default as ElementField,
  field_default as Field,
  field_errors_default as FieldErrors,
  fieldset_default as Fieldset,
  label_default as Label,
  legend_default as Legend,
  getFormControl,
  getFormField,
  useFormControl,
  useFormField
};
//# sourceMappingURL=formsnap.js.map
