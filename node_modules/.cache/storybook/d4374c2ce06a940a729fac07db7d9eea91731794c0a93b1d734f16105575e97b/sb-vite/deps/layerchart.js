import {
  extendTailwindMerge
} from "./chunk-AJSGGGP7.js";
import {
  Spring,
  Tween
} from "./chunk-ZZG674SH.js";
import {
  MediaQuery,
  SvelteSet
} from "./chunk-WL7JBLBF.js";
import "./chunk-OEZDBU4I.js";
import "./chunk-BYJZDOBD.js";
import {
  draw,
  fade
} from "./chunk-PSEX4MBS.js";
import "./chunk-7RQDXF5S.js";
import {
  cubicIn,
  cubicInOut
} from "./chunk-GJW62LPM.js";
import "./chunk-6LD3WD6G.js";
import {
  CLASS,
  STYLE,
  add_locations,
  append_styles,
  assign,
  attribute_effect,
  bind_element_size,
  bind_this,
  check_target,
  cleanup_styles,
  clsx,
  component,
  create_ownership_validator,
  each,
  hmr,
  if_block,
  index,
  key,
  legacy_api,
  log_if_contains_state,
  onMount,
  prop,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  snippet,
  spread_props,
  transition,
  validate_each_keys,
  validate_snippet_args,
  wrap_snippet
} from "./chunk-FRZCO2ZW.js";
import {
  clsx_default
} from "./chunk-ZYTAZ2LT.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  props_id,
  set_text,
  text
} from "./chunk-OIZRCF3F.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  apply,
  child,
  createSubscriber,
  delegate,
  effect_root,
  equals,
  event,
  first_child,
  get,
  getContext,
  hasContext,
  noop,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  to_array,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-ITKELFPS.js";
import "./chunk-HXIGQYEZ.js";
import {
  true_default
} from "./chunk-E62QTSXI.js";
import "./chunk-P6TGDP3C.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@dagrejs/graphlib/lib/graph.js
var require_graph = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/graph.js"(exports2, module2) {
    "use strict";
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    var Graph = class {
      _isDirected = true;
      _isMultigraph = false;
      _isCompound = false;
      // Label for the graph itself
      _label;
      // Defaults to be set when creating a new node
      _defaultNodeLabelFn = () => void 0;
      // Defaults to be set when creating a new edge
      _defaultEdgeLabelFn = () => void 0;
      // v -> label
      _nodes = {};
      // v -> edgeObj
      _in = {};
      // u -> v -> Number
      _preds = {};
      // v -> edgeObj
      _out = {};
      // v -> w -> Number
      _sucs = {};
      // e -> edgeObj
      _edgeObjs = {};
      // e -> label
      _edgeLabels = {};
      /* Number of nodes in the graph. Should only be changed by the implementation. */
      _nodeCount = 0;
      /* Number of edges in the graph. Should only be changed by the implementation. */
      _edgeCount = 0;
      _parent;
      _children;
      constructor(opts) {
        if (opts) {
          this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : true;
          this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : false;
          this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : false;
        }
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
      }
      /* === Graph functions ========= */
      /**
       * Whether graph was created with 'directed' flag set to true or not.
       */
      isDirected() {
        return this._isDirected;
      }
      /**
       * Whether graph was created with 'multigraph' flag set to true or not.
       */
      isMultigraph() {
        return this._isMultigraph;
      }
      /**
       * Whether graph was created with 'compound' flag set to true or not.
       */
      isCompound() {
        return this._isCompound;
      }
      /**
       * Sets the label of the graph.
       */
      setGraph(label) {
        this._label = label;
        return this;
      }
      /**
       * Gets the graph label.
       */
      graph() {
        return this._label;
      }
      /* === Node functions ========== */
      /**
       * Sets the default node label. If newDefault is a function, it will be
       * invoked ach time when setting a label for a node. Otherwise, this label
       * will be assigned as default label in case if no label was specified while
       * setting a node.
       * Complexity: O(1).
       */
      setDefaultNodeLabel(newDefault) {
        this._defaultNodeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultNodeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of nodes in the graph.
       * Complexity: O(1).
       */
      nodeCount() {
        return this._nodeCount;
      }
      /**
       * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
       * not included in list.
       * Complexity: O(1).
       */
      nodes() {
        return Object.keys(this._nodes);
      }
      /**
       * Gets list of nodes without in-edges.
       * Complexity: O(|V|).
       */
      sources() {
        var self2 = this;
        return this.nodes().filter((v2) => Object.keys(self2._in[v2]).length === 0);
      }
      /**
       * Gets list of nodes without out-edges.
       * Complexity: O(|V|).
       */
      sinks() {
        var self2 = this;
        return this.nodes().filter((v2) => Object.keys(self2._out[v2]).length === 0);
      }
      /**
       * Invokes setNode method for each node in names list.
       * Complexity: O(|names|).
       */
      setNodes(vs, value2) {
        var args = arguments;
        var self2 = this;
        vs.forEach(function(v2) {
          if (args.length > 1) {
            self2.setNode(v2, value2);
          } else {
            self2.setNode(v2);
          }
        });
        return this;
      }
      /**
       * Creates or updates the value for the node v in the graph. If label is supplied
       * it is set as the value for the node. If label is not supplied and the node was
       * created by this call then the default node label will be assigned.
       * Complexity: O(1).
       */
      setNode(v2, value2) {
        if (Object.hasOwn(this._nodes, v2)) {
          if (arguments.length > 1) {
            this._nodes[v2] = value2;
          }
          return this;
        }
        this._nodes[v2] = arguments.length > 1 ? value2 : this._defaultNodeLabelFn(v2);
        if (this._isCompound) {
          this._parent[v2] = GRAPH_NODE;
          this._children[v2] = {};
          this._children[GRAPH_NODE][v2] = true;
        }
        this._in[v2] = {};
        this._preds[v2] = {};
        this._out[v2] = {};
        this._sucs[v2] = {};
        ++this._nodeCount;
        return this;
      }
      /**
       * Gets the label of node with specified name.
       * Complexity: O(|V|).
       */
      node(v2) {
        return this._nodes[v2];
      }
      /**
       * Detects whether graph has a node with specified name or not.
       */
      hasNode(v2) {
        return Object.hasOwn(this._nodes, v2);
      }
      /**
       * Remove the node with the name from the graph or do nothing if the node is not in
       * the graph. If the node was removed this function also removes any incident
       * edges.
       * Complexity: O(1).
       */
      removeNode(v2) {
        var self2 = this;
        if (Object.hasOwn(this._nodes, v2)) {
          var removeEdge = (e) => self2.removeEdge(self2._edgeObjs[e]);
          delete this._nodes[v2];
          if (this._isCompound) {
            this._removeFromParentsChildList(v2);
            delete this._parent[v2];
            this.children(v2).forEach(function(child2) {
              self2.setParent(child2);
            });
            delete this._children[v2];
          }
          Object.keys(this._in[v2]).forEach(removeEdge);
          delete this._in[v2];
          delete this._preds[v2];
          Object.keys(this._out[v2]).forEach(removeEdge);
          delete this._out[v2];
          delete this._sucs[v2];
          --this._nodeCount;
        }
        return this;
      }
      /**
       * Sets node p as a parent for node v if it is defined, or removes the
       * parent for v if p is undefined. Method throws an exception in case of
       * invoking it in context of noncompound graph.
       * Average-case complexity: O(1).
       */
      setParent(v2, parent2) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (parent2 === void 0) {
          parent2 = GRAPH_NODE;
        } else {
          parent2 += "";
          for (var ancestor = parent2; ancestor !== void 0; ancestor = this.parent(ancestor)) {
            if (ancestor === v2) {
              throw new Error("Setting " + parent2 + " as parent of " + v2 + " would create a cycle");
            }
          }
          this.setNode(parent2);
        }
        this.setNode(v2);
        this._removeFromParentsChildList(v2);
        this._parent[v2] = parent2;
        this._children[parent2][v2] = true;
        return this;
      }
      _removeFromParentsChildList(v2) {
        delete this._children[this._parent[v2]][v2];
      }
      /**
       * Gets parent node for node v.
       * Complexity: O(1).
       */
      parent(v2) {
        if (this._isCompound) {
          var parent2 = this._parent[v2];
          if (parent2 !== GRAPH_NODE) {
            return parent2;
          }
        }
      }
      /**
       * Gets list of direct children of node v.
       * Complexity: O(1).
       */
      children(v2 = GRAPH_NODE) {
        if (this._isCompound) {
          var children = this._children[v2];
          if (children) {
            return Object.keys(children);
          }
        } else if (v2 === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v2)) {
          return [];
        }
      }
      /**
       * Return all nodes that are predecessors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      predecessors(v2) {
        var predsV = this._preds[v2];
        if (predsV) {
          return Object.keys(predsV);
        }
      }
      /**
       * Return all nodes that are successors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      successors(v2) {
        var sucsV = this._sucs[v2];
        if (sucsV) {
          return Object.keys(sucsV);
        }
      }
      /**
       * Return all nodes that are predecessors or successors of the specified node or undefined if
       * node v is not in the graph.
       * Complexity: O(|V|).
       */
      neighbors(v2) {
        var preds = this.predecessors(v2);
        if (preds) {
          const union4 = new Set(preds);
          for (var succ of this.successors(v2)) {
            union4.add(succ);
          }
          return Array.from(union4.values());
        }
      }
      isLeaf(v2) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v2);
        } else {
          neighbors = this.neighbors(v2);
        }
        return neighbors.length === 0;
      }
      /**
       * Creates new graph with nodes filtered via filter. Edges incident to rejected node
       * are also removed. In case of compound graph, if parent is rejected by filter,
       * than all its children are rejected too.
       * Average-case complexity: O(|E|+|V|).
       */
      filterNodes(filter4) {
        var copy3 = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy3.setGraph(this.graph());
        var self2 = this;
        Object.entries(this._nodes).forEach(function([v2, value2]) {
          if (filter4(v2)) {
            copy3.setNode(v2, value2);
          }
        });
        Object.values(this._edgeObjs).forEach(function(e) {
          if (copy3.hasNode(e.v) && copy3.hasNode(e.w)) {
            copy3.setEdge(e, self2.edge(e));
          }
        });
        var parents = {};
        function findParent(v2) {
          var parent2 = self2.parent(v2);
          if (parent2 === void 0 || copy3.hasNode(parent2)) {
            parents[v2] = parent2;
            return parent2;
          } else if (parent2 in parents) {
            return parents[parent2];
          } else {
            return findParent(parent2);
          }
        }
        if (this._isCompound) {
          copy3.nodes().forEach((v2) => copy3.setParent(v2, findParent(v2)));
        }
        return copy3;
      }
      /* === Edge functions ========== */
      /**
       * Sets the default edge label or factory function. This label will be
       * assigned as default label in case if no label was specified while setting
       * an edge or this function will be invoked each time when setting an edge
       * with no label specified and returned value * will be used as a label for edge.
       * Complexity: O(1).
       */
      setDefaultEdgeLabel(newDefault) {
        this._defaultEdgeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultEdgeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of edges in the graph.
       * Complexity: O(1).
       */
      edgeCount() {
        return this._edgeCount;
      }
      /**
       * Gets edges of the graph. In case of compound graph subgraphs are not considered.
       * Complexity: O(|E|).
       */
      edges() {
        return Object.values(this._edgeObjs);
      }
      /**
       * Establish an edges path over the nodes in nodes list. If some edge is already
       * exists, it will update its label, otherwise it will create an edge between pair
       * of nodes with label provided or default label if no label provided.
       * Complexity: O(|nodes|).
       */
      setPath(vs, value2) {
        var self2 = this;
        var args = arguments;
        vs.reduce(function(v2, w) {
          if (args.length > 1) {
            self2.setEdge(v2, w, value2);
          } else {
            self2.setEdge(v2, w);
          }
          return w;
        });
        return this;
      }
      /**
       * Creates or updates the label for the edge (v, w) with the optionally supplied
       * name. If label is supplied it is set as the value for the edge. If label is not
       * supplied and the edge was created by this call then the default edge label will
       * be assigned. The name parameter is only useful with multigraphs.
       */
      setEdge() {
        var v2, w, name, value2;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v2 = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value2 = arguments[1];
            valueSpecified = true;
          }
        } else {
          v2 = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value2 = arguments[2];
            valueSpecified = true;
          }
        }
        v2 = "" + v2;
        w = "" + w;
        if (name !== void 0) {
          name = "" + name;
        }
        var e = edgeArgsToId(this._isDirected, v2, w, name);
        if (Object.hasOwn(this._edgeLabels, e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value2;
          }
          return this;
        }
        if (name !== void 0 && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v2);
        this.setNode(w);
        this._edgeLabels[e] = valueSpecified ? value2 : this._defaultEdgeLabelFn(v2, w, name);
        var edgeObj = edgeArgsToObj(this._isDirected, v2, w, name);
        v2 = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w], v2);
        incrementOrInitEntry(this._sucs[v2], w);
        this._in[w][e] = edgeObj;
        this._out[v2][e] = edgeObj;
        this._edgeCount++;
        return this;
      }
      /**
       * Gets the label for the specified edge.
       * Complexity: O(1).
       */
      edge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        return this._edgeLabels[e];
      }
      /**
       * Gets the label for the specified edge and converts it to an object.
       * Complexity: O(1)
       */
      edgeAsObj() {
        const edge = this.edge(...arguments);
        if (typeof edge !== "object") {
          return { label: edge };
        }
        return edge;
      }
      /**
       * Detects whether the graph contains specified edge or not. No subgraphs are considered.
       * Complexity: O(1).
       */
      hasEdge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        return Object.hasOwn(this._edgeLabels, e);
      }
      /**
       * Removes the specified edge from the graph. No subgraphs are considered.
       * Complexity: O(1).
       */
      removeEdge(v2, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w, name);
        var edge = this._edgeObjs[e];
        if (edge) {
          v2 = edge.v;
          w = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w], v2);
          decrementOrRemoveEntry(this._sucs[v2], w);
          delete this._in[w][e];
          delete this._out[v2][e];
          this._edgeCount--;
        }
        return this;
      }
      /**
       * Return all edges that point to the node v. Optionally filters those edges down to just those
       * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      inEdges(v2, u4) {
        var inV = this._in[v2];
        if (inV) {
          var edges = Object.values(inV);
          if (!u4) {
            return edges;
          }
          return edges.filter((edge) => edge.v === u4);
        }
      }
      /**
       * Return all edges that are pointed at by node v. Optionally filters those edges down to just
       * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      outEdges(v2, w) {
        var outV = this._out[v2];
        if (outV) {
          var edges = Object.values(outV);
          if (!w) {
            return edges;
          }
          return edges.filter((edge) => edge.w === w);
        }
      }
      /**
       * Returns all edges to or from node v regardless of direction. Optionally filters those edges
       * down to just those between nodes v and w regardless of direction.
       * Complexity: O(|E|).
       */
      nodeEdges(v2, w) {
        var inEdges = this.inEdges(v2, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v2, w));
        }
      }
    };
    function incrementOrInitEntry(map7, k3) {
      if (map7[k3]) {
        map7[k3]++;
      } else {
        map7[k3] = 1;
      }
    }
    function decrementOrRemoveEntry(map7, k3) {
      if (!--map7[k3]) {
        delete map7[k3];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w = "" + w_;
      if (!isDirected && v2 > w) {
        var tmp = v2;
        v2 = w;
        w = tmp;
      }
      return v2 + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
    }
    function edgeArgsToObj(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w = "" + w_;
      if (!isDirected && v2 > w) {
        var tmp = v2;
        v2 = w;
        w = tmp;
      }
      var edgeObj = { v: v2, w };
      if (name) {
        edgeObj.name = name;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
    module2.exports = Graph;
  }
});

// node_modules/@dagrejs/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/version.js"(exports2, module2) {
    module2.exports = "2.2.4";
  }
});

// node_modules/@dagrejs/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/index.js"(exports2, module2) {
    module2.exports = {
      Graph: require_graph(),
      version: require_version()
    };
  }
});

// node_modules/@dagrejs/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/json.js"(exports2, module2) {
    var Graph = require_graph();
    module2.exports = {
      write,
      read
    };
    function write(g) {
      var json = {
        options: {
          directed: g.isDirected(),
          multigraph: g.isMultigraph(),
          compound: g.isCompound()
        },
        nodes: writeNodes(g),
        edges: writeEdges(g)
      };
      if (g.graph() !== void 0) {
        json.value = structuredClone(g.graph());
      }
      return json;
    }
    function writeNodes(g) {
      return g.nodes().map(function(v2) {
        var nodeValue = g.node(v2);
        var parent2 = g.parent(v2);
        var node = { v: v2 };
        if (nodeValue !== void 0) {
          node.value = nodeValue;
        }
        if (parent2 !== void 0) {
          node.parent = parent2;
        }
        return node;
      });
    }
    function writeEdges(g) {
      return g.edges().map(function(e) {
        var edgeValue = g.edge(e);
        var edge = { v: e.v, w: e.w };
        if (e.name !== void 0) {
          edge.name = e.name;
        }
        if (edgeValue !== void 0) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read(json) {
      var g = new Graph(json.options).setGraph(json.value);
      json.nodes.forEach(function(entry) {
        g.setNode(entry.v, entry.value);
        if (entry.parent) {
          g.setParent(entry.v, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/components.js"(exports2, module2) {
    module2.exports = components;
    function components(g) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs(v2) {
        if (Object.hasOwn(visited, v2)) return;
        visited[v2] = true;
        cmpt.push(v2);
        g.successors(v2).forEach(dfs);
        g.predecessors(v2).forEach(dfs);
      }
      g.nodes().forEach(function(v2) {
        cmpt = [];
        dfs(v2);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/data/priority-queue.js"(exports2, module2) {
    var PriorityQueue = class {
      _arr = [];
      _keyIndices = {};
      /**
       * Returns the number of elements in the queue. Takes `O(1)` time.
       */
      size() {
        return this._arr.length;
      }
      /**
       * Returns the keys that are in the queue. Takes `O(n)` time.
       */
      keys() {
        return this._arr.map(function(x4) {
          return x4.key;
        });
      }
      /**
       * Returns `true` if **key** is in the queue and `false` if not.
       */
      has(key2) {
        return Object.hasOwn(this._keyIndices, key2);
      }
      /**
       * Returns the priority for **key**. If **key** is not present in the queue
       * then this function returns `undefined`. Takes `O(1)` time.
       *
       * @param {Object} key
       */
      priority(key2) {
        var index4 = this._keyIndices[key2];
        if (index4 !== void 0) {
          return this._arr[index4].priority;
        }
      }
      /**
       * Returns the key for the minimum element in this queue. If the queue is
       * empty this function throws an Error. Takes `O(1)` time.
       */
      min() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      }
      /**
       * Inserts a new key into the priority queue. If the key already exists in
       * the queue this function returns `false`; otherwise it will return `true`.
       * Takes `O(n)` time.
       *
       * @param {Object} key the key to add
       * @param {Number} priority the initial priority for the key
       */
      add(key2, priority) {
        var keyIndices = this._keyIndices;
        key2 = String(key2);
        if (!Object.hasOwn(keyIndices, key2)) {
          var arr = this._arr;
          var index4 = arr.length;
          keyIndices[key2] = index4;
          arr.push({ key: key2, priority });
          this._decrease(index4);
          return true;
        }
        return false;
      }
      /**
       * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
       */
      removeMin() {
        this._swap(0, this._arr.length - 1);
        var min7 = this._arr.pop();
        delete this._keyIndices[min7.key];
        this._heapify(0);
        return min7.key;
      }
      /**
       * Decreases the priority for **key** to **priority**. If the new priority is
       * greater than the previous priority, this function will throw an Error.
       *
       * @param {Object} key the key for which to raise priority
       * @param {Number} priority the new priority for the key
       */
      decrease(key2, priority) {
        var index4 = this._keyIndices[key2];
        if (priority > this._arr[index4].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key2 + " Old: " + this._arr[index4].priority + " New: " + priority);
        }
        this._arr[index4].priority = priority;
        this._decrease(index4);
      }
      _heapify(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      }
      _decrease(index4) {
        var arr = this._arr;
        var priority = arr[index4].priority;
        var parent2;
        while (index4 !== 0) {
          parent2 = index4 >> 1;
          if (arr[parent2].priority < priority) {
            break;
          }
          this._swap(index4, parent2);
          index4 = parent2;
        }
      }
      _swap(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      }
    };
    module2.exports = PriorityQueue;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js"(exports2, module2) {
    var PriorityQueue = require_priority_queue();
    module2.exports = dijkstra;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function dijkstra(g, source, weightFn, edgeFn) {
      return runDijkstra(
        g,
        String(source),
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v2) {
          return g.outEdges(v2);
        }
      );
    }
    function runDijkstra(g, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v2, vEntry;
      var updateNeighbors = function(edge) {
        var w = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results[w];
        var weight = weightFn(edge);
        var distance = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance < wEntry.distance) {
          wEntry.distance = distance;
          wEntry.predecessor = v2;
          pq.decrease(w, distance);
        }
      };
      g.nodes().forEach(function(v3) {
        var distance = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v3] = { distance };
        pq.add(v3, distance);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results[v2];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js"(exports2, module2) {
    var dijkstra = require_dijkstra();
    module2.exports = dijkstraAll;
    function dijkstraAll(g, weightFunc, edgeFunc) {
      return g.nodes().reduce(function(acc, v2) {
        acc[v2] = dijkstra(g, v2, weightFunc, edgeFunc);
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/tarjan.js"(exports2, module2) {
    module2.exports = tarjan;
    function tarjan(g) {
      var index4 = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs(v2) {
        var entry = visited[v2] = {
          onStack: true,
          lowlink: index4,
          index: index4++
        };
        stack.push(v2);
        g.successors(v2).forEach(function(w2) {
          if (!Object.hasOwn(visited, w2)) {
            dfs(w2);
            entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
          } else if (visited[w2].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w;
          do {
            w = stack.pop();
            visited[w].onStack = false;
            cmpt.push(w);
          } while (v2 !== w);
          results.push(cmpt);
        }
      }
      g.nodes().forEach(function(v2) {
        if (!Object.hasOwn(visited, v2)) {
          dfs(v2);
        }
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js"(exports2, module2) {
    var tarjan = require_tarjan();
    module2.exports = findCycles;
    function findCycles(g) {
      return tarjan(g).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js"(exports2, module2) {
    module2.exports = floydWarshall;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function floydWarshall(g, weightFn, edgeFn) {
      return runFloydWarshall(
        g,
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v2) {
          return g.outEdges(v2);
        }
      );
    }
    function runFloydWarshall(g, weightFn, edgeFn) {
      var results = {};
      var nodes = g.nodes();
      nodes.forEach(function(v2) {
        results[v2] = {};
        results[v2][v2] = { distance: 0 };
        nodes.forEach(function(w) {
          if (v2 !== w) {
            results[v2][w] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v2).forEach(function(edge) {
          var w = edge.v === v2 ? edge.w : edge.v;
          var d = weightFn(edge);
          results[v2][w] = { distance: d, predecessor: v2 };
        });
      });
      nodes.forEach(function(k3) {
        var rowK = results[k3];
        nodes.forEach(function(i) {
          var rowI = results[i];
          nodes.forEach(function(j) {
            var ik = rowI[k3];
            var kj = rowK[j];
            var ij = rowI[j];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/topsort.js"(exports2, module2) {
    function topsort(g) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (Object.hasOwn(stack, node)) {
          throw new CycleException();
        }
        if (!Object.hasOwn(visited, node)) {
          stack[node] = true;
          visited[node] = true;
          g.predecessors(node).forEach(visit);
          delete stack[node];
          results.push(node);
        }
      }
      g.sinks().forEach(visit);
      if (Object.keys(visited).length !== g.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    var CycleException = class extends Error {
      constructor() {
        super(...arguments);
      }
    };
    module2.exports = topsort;
    topsort.CycleException = CycleException;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js"(exports2, module2) {
    var topsort = require_topsort();
    module2.exports = isAcyclic;
    function isAcyclic(g) {
      try {
        topsort(g);
      } catch (e) {
        if (e instanceof topsort.CycleException) {
          return false;
        }
        throw e;
      }
      return true;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dfs.js"(exports2, module2) {
    module2.exports = dfs;
    function dfs(g, vs, order) {
      if (!Array.isArray(vs)) {
        vs = [vs];
      }
      var navigation = g.isDirected() ? (v2) => g.successors(v2) : (v2) => g.neighbors(v2);
      var orderFunc = order === "post" ? postOrderDfs : preOrderDfs;
      var acc = [];
      var visited = {};
      vs.forEach((v2) => {
        if (!g.hasNode(v2)) {
          throw new Error("Graph does not have node: " + v2);
        }
        orderFunc(v2, navigation, visited, acc);
      });
      return acc;
    }
    function postOrderDfs(v2, navigation, visited, acc) {
      var stack = [[v2, false]];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (curr[1]) {
          acc.push(curr[0]);
        } else {
          if (!Object.hasOwn(visited, curr[0])) {
            visited[curr[0]] = true;
            stack.push([curr[0], true]);
            forEachRight2(navigation(curr[0]), (w) => stack.push([w, false]));
          }
        }
      }
    }
    function preOrderDfs(v2, navigation, visited, acc) {
      var stack = [v2];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (!Object.hasOwn(visited, curr)) {
          visited[curr] = true;
          acc.push(curr);
          forEachRight2(navigation(curr), (w) => stack.push(w));
        }
      }
    }
    function forEachRight2(array3, iteratee2) {
      var length = array3.length;
      while (length--) {
        iteratee2(array3[length], length, array3);
      }
      return array3;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/postorder.js"(exports2, module2) {
    var dfs = require_dfs();
    module2.exports = postorder;
    function postorder(g, vs) {
      return dfs(g, vs, "post");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/preorder.js"(exports2, module2) {
    var dfs = require_dfs();
    module2.exports = preorder;
    function preorder(g, vs) {
      return dfs(g, vs, "pre");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/prim.js"(exports2, module2) {
    var Graph = require_graph();
    var PriorityQueue = require_priority_queue();
    module2.exports = prim;
    function prim(g, weightFunc) {
      var result2 = new Graph();
      var parents = {};
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w] = v2;
            pq.decrease(w, edgeWeight);
          }
        }
      }
      if (g.nodeCount() === 0) {
        return result2;
      }
      g.nodes().forEach(function(v3) {
        pq.add(v3, Number.POSITIVE_INFINITY);
        result2.setNode(v3);
      });
      pq.decrease(g.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        if (Object.hasOwn(parents, v2)) {
          result2.setEdge(v2, parents[v2]);
        } else if (init) {
          throw new Error("Input graph is not connected: " + g);
        } else {
          init = true;
        }
        g.nodeEdges(v2).forEach(updateNeighbors);
      }
      return result2;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/index.js"(exports2, module2) {
    module2.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/@dagrejs/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/@dagrejs/graphlib/index.js"(exports2, module2) {
    var lib = require_lib();
    module2.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/@dagrejs/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/@dagrejs/dagre/lib/data/list.js"(exports2, module2) {
    var List = class {
      constructor() {
        let sentinel = {};
        sentinel._next = sentinel._prev = sentinel;
        this._sentinel = sentinel;
      }
      dequeue() {
        let sentinel = this._sentinel;
        let entry = sentinel._prev;
        if (entry !== sentinel) {
          unlink(entry);
          return entry;
        }
      }
      enqueue(entry) {
        let sentinel = this._sentinel;
        if (entry._prev && entry._next) {
          unlink(entry);
        }
        entry._next = sentinel._next;
        sentinel._next._prev = entry;
        sentinel._next = entry;
        entry._prev = sentinel;
      }
      toString() {
        let strs = [];
        let sentinel = this._sentinel;
        let curr = sentinel._prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks));
          curr = curr._prev;
        }
        return "[" + strs.join(", ") + "]";
      }
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k3, v2) {
      if (k3 !== "_next" && k3 !== "_prev") {
        return v2;
      }
    }
    module2.exports = List;
  }
});

// node_modules/@dagrejs/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@dagrejs/dagre/lib/greedy-fas.js"(exports2, module2) {
    var Graph = require_graphlib().Graph;
    var List = require_list();
    module2.exports = greedyFAS;
    var DEFAULT_WEIGHT_FN = () => 1;
    function greedyFAS(g, weightFn) {
      if (g.nodeCount() <= 1) {
        return [];
      }
      let state2 = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
      let results = doGreedyFAS(state2.graph, state2.buckets, state2.zeroIdx);
      return results.flatMap((e) => g.outEdges(e.v, e.w));
    }
    function doGreedyFAS(g, buckets, zeroIdx) {
      let results = [];
      let sources = buckets[buckets.length - 1];
      let sinks = buckets[0];
      let entry;
      while (g.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
          for (let i = buckets.length - 2; i > 0; --i) {
            entry = buckets[i].dequeue();
            if (entry) {
              results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
      let results = collectPredecessors ? [] : void 0;
      g.inEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let uEntry = g.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      g.outEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let w = edge.w;
        let wEntry = g.node(w);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g.removeNode(entry.v);
      return results;
    }
    function buildState(g, weightFn) {
      let fasGraph = new Graph();
      let maxIn = 0;
      let maxOut = 0;
      g.nodes().forEach((v2) => {
        fasGraph.setNode(v2, { v: v2, "in": 0, out: 0 });
      });
      g.edges().forEach((e) => {
        let prevWeight = fasGraph.edge(e.v, e.w) || 0;
        let weight = weightFn(e);
        let edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
      });
      let buckets = range4(maxOut + maxIn + 3).map(() => new List());
      let zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach((v2) => {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
    function range4(limit) {
      const range5 = [];
      for (let i = 0; i < limit; i++) {
        range5.push(i);
      }
      return range5;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/@dagrejs/dagre/lib/util.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    module2.exports = {
      addBorderNode,
      addDummyNode,
      applyWithChunking,
      asNonCompoundGraph,
      buildLayerMatrix,
      intersectRect,
      mapValues: mapValues2,
      maxRank,
      normalizeRanks,
      notime,
      partition: partition2,
      pick: pick3,
      predecessorWeights,
      range: range4,
      removeEmptyRanks,
      simplify,
      successorWeights,
      time: time2,
      uniqueId: uniqueId2,
      zipObject: zipObject2
    };
    function addDummyNode(g, type, attrs, name) {
      var v2 = name;
      while (g.hasNode(v2)) {
        v2 = uniqueId2(name);
      }
      attrs.dummy = type;
      g.setNode(v2, attrs);
      return v2;
    }
    function simplify(g) {
      let simplified = new Graph().setGraph(g.graph());
      g.nodes().forEach((v2) => simplified.setNode(v2, g.node(v2)));
      g.edges().forEach((e) => {
        let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
        let label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g) {
      let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
      g.nodes().forEach((v2) => {
        if (!g.children(v2).length) {
          simplified.setNode(v2, g.node(v2));
        }
      });
      g.edges().forEach((e) => {
        simplified.setEdge(e, g.edge(e));
      });
      return simplified;
    }
    function successorWeights(g) {
      let weightMap = g.nodes().map((v2) => {
        let sucs = {};
        g.outEdges(v2).forEach((e) => {
          sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
        });
        return sucs;
      });
      return zipObject2(g.nodes(), weightMap);
    }
    function predecessorWeights(g) {
      let weightMap = g.nodes().map((v2) => {
        let preds = {};
        g.inEdges(v2).forEach((e) => {
          preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
      });
      return zipObject2(g.nodes(), weightMap);
    }
    function intersectRect(rect, point10) {
      let x4 = rect.x;
      let y4 = rect.y;
      let dx = point10.x - x4;
      let dy = point10.y - y4;
      let w = rect.width / 2;
      let h = rect.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      let sx, sy;
      if (Math.abs(dy) * w > Math.abs(dx) * h) {
        if (dy < 0) {
          h = -h;
        }
        sx = h * dx / dy;
        sy = h;
      } else {
        if (dx < 0) {
          w = -w;
        }
        sx = w;
        sy = w * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    }
    function buildLayerMatrix(g) {
      let layering = range4(maxRank(g) + 1).map(() => []);
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        let rank2 = node.rank;
        if (rank2 !== void 0) {
          layering[rank2][node.order] = v2;
        }
      });
      return layering;
    }
    function normalizeRanks(g) {
      let nodeRanks = g.nodes().map((v2) => {
        let rank2 = g.node(v2).rank;
        if (rank2 === void 0) {
          return Number.MAX_VALUE;
        }
        return rank2;
      });
      let min7 = applyWithChunking(Math.min, nodeRanks);
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (Object.hasOwn(node, "rank")) {
          node.rank -= min7;
        }
      });
    }
    function removeEmptyRanks(g) {
      let nodeRanks = g.nodes().map((v2) => g.node(v2).rank);
      let offset = applyWithChunking(Math.min, nodeRanks);
      let layers = [];
      g.nodes().forEach((v2) => {
        let rank2 = g.node(v2).rank - offset;
        if (!layers[rank2]) {
          layers[rank2] = [];
        }
        layers[rank2].push(v2);
      });
      let delta = 0;
      let nodeRankFactor = g.graph().nodeRankFactor;
      Array.from(layers).forEach((vs, i) => {
        if (vs === void 0 && i % nodeRankFactor !== 0) {
          --delta;
        } else if (vs !== void 0 && delta) {
          vs.forEach((v2) => g.node(v2).rank += delta);
        }
      });
    }
    function addBorderNode(g, prefix, rank2, order) {
      let node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank2;
        node.order = order;
      }
      return addDummyNode(g, "border", node, prefix);
    }
    function splitToChunks(array3, chunkSize = CHUNKING_THRESHOLD) {
      const chunks = [];
      for (let i = 0; i < array3.length; i += chunkSize) {
        const chunk3 = array3.slice(i, i + chunkSize);
        chunks.push(chunk3);
      }
      return chunks;
    }
    var CHUNKING_THRESHOLD = 65535;
    function applyWithChunking(fn, argsArray) {
      if (argsArray.length > CHUNKING_THRESHOLD) {
        const chunks = splitToChunks(argsArray);
        return fn.apply(null, chunks.map((chunk3) => fn.apply(null, chunk3)));
      } else {
        return fn.apply(null, argsArray);
      }
    }
    function maxRank(g) {
      const nodes = g.nodes();
      const nodeRanks = nodes.map((v2) => {
        let rank2 = g.node(v2).rank;
        if (rank2 === void 0) {
          return Number.MIN_VALUE;
        }
        return rank2;
      });
      return applyWithChunking(Math.max, nodeRanks);
    }
    function partition2(collection, fn) {
      let result2 = { lhs: [], rhs: [] };
      collection.forEach((value2) => {
        if (fn(value2)) {
          result2.lhs.push(value2);
        } else {
          result2.rhs.push(value2);
        }
      });
      return result2;
    }
    function time2(name, fn) {
      let start = Date.now();
      try {
        return fn();
      } finally {
        console.log(name + " time: " + (Date.now() - start) + "ms");
      }
    }
    function notime(name, fn) {
      return fn();
    }
    var idCounter2 = 0;
    function uniqueId2(prefix) {
      var id = ++idCounter2;
      return prefix + ("" + id);
    }
    function range4(start, limit, step = 1) {
      if (limit == null) {
        limit = start;
        start = 0;
      }
      let endCon = (i) => i < limit;
      if (step < 0) {
        endCon = (i) => limit < i;
      }
      const range5 = [];
      for (let i = start; endCon(i); i += step) {
        range5.push(i);
      }
      return range5;
    }
    function pick3(source, keys3) {
      const dest = {};
      for (const key2 of keys3) {
        if (source[key2] !== void 0) {
          dest[key2] = source[key2];
        }
      }
      return dest;
    }
    function mapValues2(obj, funcOrProp) {
      let func = funcOrProp;
      if (typeof funcOrProp === "string") {
        func = (val) => val[funcOrProp];
      }
      return Object.entries(obj).reduce((acc, [k3, v2]) => {
        acc[k3] = func(v2, k3);
        return acc;
      }, {});
    }
    function zipObject2(props, values2) {
      return props.reduce((acc, key2, i) => {
        acc[key2] = values2[i];
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@dagrejs/dagre/lib/acyclic.js"(exports2, module2) {
    "use strict";
    var greedyFAS = require_greedy_fas();
    var uniqueId2 = require_util().uniqueId;
    module2.exports = {
      run,
      undo
    };
    function run(g) {
      let fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
      fas.forEach((e) => {
        let label = g.edge(e);
        g.removeEdge(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, uniqueId2("rev"));
      });
      function weightFn(g2) {
        return (e) => {
          return g2.edge(e).weight;
        };
      }
    }
    function dfsFAS(g) {
      let fas = [];
      let stack = {};
      let visited = {};
      function dfs(v2) {
        if (Object.hasOwn(visited, v2)) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        g.outEdges(v2).forEach((e) => {
          if (Object.hasOwn(stack, e.w)) {
            fas.push(e);
          } else {
            dfs(e.w);
          }
        });
        delete stack[v2];
      }
      g.nodes().forEach(dfs);
      return fas;
    }
    function undo(g) {
      g.edges().forEach((e) => {
        let label = g.edge(e);
        if (label.reversed) {
          g.removeEdge(e);
          let forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g.setEdge(e.w, e.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@dagrejs/dagre/lib/normalize.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = {
      run,
      undo
    };
    function run(g) {
      g.graph().dummyChains = [];
      g.edges().forEach((edge) => normalizeEdge(g, edge));
    }
    function normalizeEdge(g, e) {
      let v2 = e.v;
      let vRank = g.node(v2).rank;
      let w = e.w;
      let wRank = g.node(w).rank;
      let name = e.name;
      let edgeLabel = g.edge(e);
      let labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1) return;
      g.removeEdge(e);
      let dummy, attrs, i;
      for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e,
          rank: vRank
        };
        dummy = util.addDummyNode(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i === 0) {
          g.graph().dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g.setEdge(v2, w, { weight: edgeLabel.weight }, name);
    }
    function undo(g) {
      g.graph().dummyChains.forEach((v2) => {
        let node = g.node(v2);
        let origLabel = node.edgeLabel;
        let w;
        g.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w = g.successors(v2)[0];
          g.removeNode(v2);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v2 = w;
          node = g.node(v2);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/util.js"(exports2, module2) {
    "use strict";
    var { applyWithChunking } = require_util();
    module2.exports = {
      longestPath,
      slack
    };
    function longestPath(g) {
      var visited = {};
      function dfs(v2) {
        var label = g.node(v2);
        if (Object.hasOwn(visited, v2)) {
          return label.rank;
        }
        visited[v2] = true;
        let outEdgesMinLens = g.outEdges(v2).map((e) => {
          if (e == null) {
            return Number.POSITIVE_INFINITY;
          }
          return dfs(e.w) - g.edge(e).minlen;
        });
        var rank2 = applyWithChunking(Math.min, outEdgesMinLens);
        if (rank2 === Number.POSITIVE_INFINITY) {
          rank2 = 0;
        }
        return label.rank = rank2;
      }
      g.sources().forEach(dfs);
    }
    function slack(g, e) {
      return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var slack = require_util2().slack;
    module2.exports = feasibleTree;
    function feasibleTree(g) {
      var t = new Graph({ directed: false });
      var start = g.nodes()[0];
      var size2 = g.nodeCount();
      t.setNode(start, {});
      var edge, delta;
      while (tightTree(t, g) < size2) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
        shiftRanks(t, g, delta);
      }
      return t;
    }
    function tightTree(t, g) {
      function dfs(v2) {
        g.nodeEdges(v2).forEach((e) => {
          var edgeV = e.v, w = v2 === edgeV ? e.w : edgeV;
          if (!t.hasNode(w) && !slack(g, e)) {
            t.setNode(w, {});
            t.setEdge(v2, w, {});
            dfs(w);
          }
        });
      }
      t.nodes().forEach(dfs);
      return t.nodeCount();
    }
    function findMinSlackEdge(t, g) {
      const edges = g.edges();
      return edges.reduce((acc, edge) => {
        let edgeSlack = Number.POSITIVE_INFINITY;
        if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
          edgeSlack = slack(g, edge);
        }
        if (edgeSlack < acc[0]) {
          return [edgeSlack, edge];
        }
        return acc;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function shiftRanks(t, g, delta) {
      t.nodes().forEach((v2) => g.node(v2).rank += delta);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/network-simplex.js"(exports2, module2) {
    "use strict";
    var feasibleTree = require_feasible_tree();
    var slack = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib().alg.preorder;
    var postorder = require_graphlib().alg.postorder;
    var simplify = require_util().simplify;
    module2.exports = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g) {
      g = simplify(g);
      initRank(g);
      var t = feasibleTree(g);
      initLowLimValues(t);
      initCutValues(t, g);
      var e, f2;
      while (e = leaveEdge(t)) {
        f2 = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f2);
      }
    }
    function initCutValues(t, g) {
      var vs = postorder(t, t.nodes());
      vs = vs.slice(0, vs.length - 1);
      vs.forEach((v2) => assignCutValue(t, g, v2));
    }
    function assignCutValue(t, g, child2) {
      var childLab = t.node(child2);
      var parent2 = childLab.parent;
      t.edge(child2, parent2).cutvalue = calcCutValue(t, g, child2);
    }
    function calcCutValue(t, g, child2) {
      var childLab = t.node(child2);
      var parent2 = childLab.parent;
      var childIsTail = true;
      var graphEdge = g.edge(child2, parent2);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edge(parent2, child2);
      }
      cutValue = graphEdge.weight;
      g.nodeEdges(child2).forEach((e) => {
        var isOutEdge = e.v === child2, other = isOutEdge ? e.w : e.v;
        if (other !== parent2) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t, child2, other)) {
            var otherCutValue = t.edge(child2, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree, root26) {
      if (arguments.length < 2) {
        root26 = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root26);
    }
    function dfsAssignLowLim(tree, visited, nextLim, v2, parent2) {
      var low = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      tree.neighbors(v2).forEach((w) => {
        if (!Object.hasOwn(visited, w)) {
          nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v2);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent2) {
        label.parent = parent2;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree) {
      return tree.edges().find((e) => tree.edge(e).cutvalue < 0);
    }
    function enterEdge(t, g, edge) {
      var v2 = edge.v;
      var w = edge.w;
      if (!g.hasEdge(v2, w)) {
        v2 = edge.w;
        w = edge.v;
      }
      var vLabel = t.node(v2);
      var wLabel = t.node(w);
      var tailLabel = vLabel;
      var flip2 = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip2 = true;
      }
      var candidates = g.edges().filter((edge2) => {
        return flip2 === isDescendant(t, t.node(edge2.v), tailLabel) && flip2 !== isDescendant(t, t.node(edge2.w), tailLabel);
      });
      return candidates.reduce((acc, edge2) => {
        if (slack(g, edge2) < slack(g, acc)) {
          return edge2;
        }
        return acc;
      });
    }
    function exchangeEdges(t, g, e, f2) {
      var v2 = e.v;
      var w = e.w;
      t.removeEdge(v2, w);
      t.setEdge(f2.v, f2.w, {});
      initLowLimValues(t);
      initCutValues(t, g);
      updateRanks(t, g);
    }
    function updateRanks(t, g) {
      var root26 = t.nodes().find((v2) => !g.node(v2).parent);
      var vs = preorder(t, root26);
      vs = vs.slice(1);
      vs.forEach((v2) => {
        var parent2 = t.node(v2).parent, edge = g.edge(v2, parent2), flipped = false;
        if (!edge) {
          edge = g.edge(parent2, v2);
          flipped = true;
        }
        g.node(v2).rank = g.node(parent2).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree, u4, v2) {
      return tree.hasEdge(u4, v2);
    }
    function isDescendant(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/index.js"(exports2, module2) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = require_feasible_tree();
    var networkSimplex = require_network_simplex();
    module2.exports = rank2;
    function rank2(g) {
      var ranker = g.graph().ranker;
      if (ranker instanceof Function) {
        return ranker(g);
      }
      switch (g.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g);
          break;
        case "tight-tree":
          tightTreeRanker(g);
          break;
        case "longest-path":
          longestPathRanker(g);
          break;
        case "none":
          break;
        default:
          networkSimplexRanker(g);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g) {
      longestPath(g);
      feasibleTree(g);
    }
    function networkSimplexRanker(g) {
      networkSimplex(g);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js"(exports2, module2) {
    module2.exports = parentDummyChains;
    function parentDummyChains(g) {
      let postorderNums = postorder(g);
      g.graph().dummyChains.forEach((v2) => {
        let node = g.node(v2);
        let edgeObj = node.edgeObj;
        let pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        let path3 = pathData.path;
        let lca = pathData.lca;
        let pathIdx = 0;
        let pathV = path3[pathIdx];
        let ascending2 = true;
        while (v2 !== edgeObj.w) {
          node = g.node(v2);
          if (ascending2) {
            while ((pathV = path3[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending2 = false;
            }
          }
          if (!ascending2) {
            while (pathIdx < path3.length - 1 && g.node(pathV = path3[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path3[pathIdx];
          }
          g.setParent(v2, pathV);
          v2 = g.successors(v2)[0];
        }
      });
    }
    function findPath(g, postorderNums, v2, w) {
      let vPath = [];
      let wPath = [];
      let low = Math.min(postorderNums[v2].low, postorderNums[w].low);
      let lim = Math.max(postorderNums[v2].lim, postorderNums[w].lim);
      let parent2;
      let lca;
      parent2 = v2;
      do {
        parent2 = g.parent(parent2);
        vPath.push(parent2);
      } while (parent2 && (postorderNums[parent2].low > low || lim > postorderNums[parent2].lim));
      lca = parent2;
      parent2 = w;
      while ((parent2 = g.parent(parent2)) !== lca) {
        wPath.push(parent2);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g) {
      let result2 = {};
      let lim = 0;
      function dfs(v2) {
        let low = lim;
        g.children(v2).forEach(dfs);
        result2[v2] = { low, lim: lim++ };
      }
      g.children().forEach(dfs);
      return result2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/nesting-graph.js"(exports2, module2) {
    var util = require_util();
    module2.exports = {
      run,
      cleanup
    };
    function run(g) {
      let root26 = util.addDummyNode(g, "root", {}, "_root");
      let depths = treeDepths(g);
      let depthsArr = Object.values(depths);
      let height = util.applyWithChunking(Math.max, depthsArr) - 1;
      let nodeSep = 2 * height + 1;
      g.graph().nestingRoot = root26;
      g.edges().forEach((e) => g.edge(e).minlen *= nodeSep);
      let weight = sumWeights(g) + 1;
      g.children().forEach((child2) => dfs(g, root26, nodeSep, weight, height, depths, child2));
      g.graph().nodeRankFactor = nodeSep;
    }
    function dfs(g, root26, nodeSep, weight, height, depths, v2) {
      let children = g.children(v2);
      if (!children.length) {
        if (v2 !== root26) {
          g.setEdge(root26, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      let top = util.addBorderNode(g, "_bt");
      let bottom = util.addBorderNode(g, "_bb");
      let label = g.node(v2);
      g.setParent(top, v2);
      label.borderTop = top;
      g.setParent(bottom, v2);
      label.borderBottom = bottom;
      children.forEach((child2) => {
        dfs(g, root26, nodeSep, weight, height, depths, child2);
        let childNode = g.node(child2);
        let childTop = childNode.borderTop ? childNode.borderTop : child2;
        let childBottom = childNode.borderBottom ? childNode.borderBottom : child2;
        let thisWeight = childNode.borderTop ? weight : 2 * weight;
        let minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g.setEdge(top, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g.setEdge(childBottom, bottom, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g.parent(v2)) {
        g.setEdge(root26, top, { weight: 0, minlen: height + depths[v2] });
      }
    }
    function treeDepths(g) {
      var depths = {};
      function dfs2(v2, depth) {
        var children = g.children(v2);
        if (children && children.length) {
          children.forEach((child2) => dfs2(child2, depth + 1));
        }
        depths[v2] = depth;
      }
      g.children().forEach((v2) => dfs2(v2, 1));
      return depths;
    }
    function sumWeights(g) {
      return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
    }
    function cleanup(g) {
      var graphLabel = g.graph();
      g.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.nestingEdge) {
          g.removeEdge(e);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@dagrejs/dagre/lib/add-border-segments.js"(exports2, module2) {
    var util = require_util();
    module2.exports = addBorderSegments;
    function addBorderSegments(g) {
      function dfs(v2) {
        let children = g.children(v2);
        let node = g.node(v2);
        if (children.length) {
          children.forEach(dfs);
        }
        if (Object.hasOwn(node, "minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (let rank2 = node.minRank, maxRank = node.maxRank + 1; rank2 < maxRank; ++rank2) {
            addBorderNode(g, "borderLeft", "_bl", v2, node, rank2);
            addBorderNode(g, "borderRight", "_br", v2, node, rank2);
          }
        }
      }
      g.children().forEach(dfs);
    }
    function addBorderNode(g, prop2, prefix, sg, sgNode, rank2) {
      let label = { width: 0, height: 0, rank: rank2, borderType: prop2 };
      let prev = sgNode[prop2][rank2 - 1];
      let curr = util.addDummyNode(g, "border", label, prefix);
      sgNode[prop2][rank2] = curr;
      g.setParent(curr, sg);
      if (prev) {
        g.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@dagrejs/dagre/lib/coordinate-system.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      adjust,
      undo
    };
    function adjust(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
      }
    }
    function undo(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
      }
    }
    function swapWidthHeight(g) {
      g.nodes().forEach((v2) => swapWidthHeightOne(g.node(v2)));
      g.edges().forEach((e) => swapWidthHeightOne(g.edge(e)));
    }
    function swapWidthHeightOne(attrs) {
      let w = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w;
    }
    function reverseY(g) {
      g.nodes().forEach((v2) => reverseYOne(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(reverseYOne);
        if (Object.hasOwn(edge, "y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g) {
      g.nodes().forEach((v2) => swapXYOne(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(swapXYOne);
        if (Object.hasOwn(edge, "x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      let x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/init-order.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = initOrder;
    function initOrder(g) {
      let visited = {};
      let simpleNodes = g.nodes().filter((v2) => !g.children(v2).length);
      let simpleNodesRanks = simpleNodes.map((v2) => g.node(v2).rank);
      let maxRank = util.applyWithChunking(Math.max, simpleNodesRanks);
      let layers = util.range(maxRank + 1).map(() => []);
      function dfs(v2) {
        if (visited[v2]) return;
        visited[v2] = true;
        let node = g.node(v2);
        layers[node.rank].push(v2);
        g.successors(v2).forEach(dfs);
      }
      let orderedVs = simpleNodes.sort((a5, b) => g.node(a5).rank - g.node(b).rank);
      orderedVs.forEach(dfs);
      return layers;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/cross-count.js"(exports2, module2) {
    "use strict";
    var zipObject2 = require_util().zipObject;
    module2.exports = crossCount;
    function crossCount(g, layering) {
      let cc2 = 0;
      for (let i = 1; i < layering.length; ++i) {
        cc2 += twoLayerCrossCount(g, layering[i - 1], layering[i]);
      }
      return cc2;
    }
    function twoLayerCrossCount(g, northLayer, southLayer) {
      let southPos = zipObject2(southLayer, southLayer.map((v2, i) => i));
      let southEntries = northLayer.flatMap((v2) => {
        return g.outEdges(v2).map((e) => {
          return { pos: southPos[e.w], weight: g.edge(e).weight };
        }).sort((a5, b) => a5.pos - b.pos);
      });
      let firstIndex = 1;
      while (firstIndex < southLayer.length) firstIndex <<= 1;
      let treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      let tree = new Array(treeSize).fill(0);
      let cc2 = 0;
      southEntries.forEach((entry) => {
        let index4 = entry.pos + firstIndex;
        tree[index4] += entry.weight;
        let weightSum = 0;
        while (index4 > 0) {
          if (index4 % 2) {
            weightSum += tree[index4 + 1];
          }
          index4 = index4 - 1 >> 1;
          tree[index4] += entry.weight;
        }
        cc2 += entry.weight * weightSum;
      });
      return cc2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/barycenter.js"(exports2, module2) {
    module2.exports = barycenter;
    function barycenter(g, movable = []) {
      return movable.map((v2) => {
        let inV = g.inEdges(v2);
        if (!inV.length) {
          return { v: v2 };
        } else {
          let result2 = inV.reduce((acc, e) => {
            let edge = g.edge(e), nodeU = g.node(e.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v: v2,
            barycenter: result2.sum / result2.weight,
            weight: result2.weight
          };
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = resolveConflicts;
    function resolveConflicts(entries2, cg) {
      let mappedEntries = {};
      entries2.forEach((entry, i) => {
        let tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i
        };
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      cg.edges().forEach((e) => {
        let entryV = mappedEntries[e.v];
        let entryW = mappedEntries[e.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e.w]);
        }
      });
      let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      let entries2 = [];
      function handleIn(vEntry) {
        return (uEntry) => {
          if (uEntry.merged) {
            return;
          }
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return (wEntry) => {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        let entry = sourceSet.pop();
        entries2.push(entry);
        entry["in"].reverse().forEach(handleIn(entry));
        entry.out.forEach(handleOut(entry));
      }
      return entries2.filter((entry) => !entry.merged).map((entry) => {
        return util.pick(entry, ["vs", "i", "barycenter", "weight"]);
      });
    }
    function mergeEntries(target, source) {
      let sum7 = 0;
      let weight = 0;
      if (target.weight) {
        sum7 += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum7 += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum7 / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort.js
var require_sort = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort.js"(exports2, module2) {
    var util = require_util();
    module2.exports = sort3;
    function sort3(entries2, biasRight) {
      let parts = util.partition(entries2, (entry) => {
        return Object.hasOwn(entry, "barycenter");
      });
      let sortable = parts.lhs, unsortable = parts.rhs.sort((a5, b) => b.i - a5.i), vs = [], sum7 = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable.forEach((entry) => {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum7 += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      let result2 = { vs: vs.flat(true) };
      if (weight) {
        result2.barycenter = sum7 / weight;
        result2.weight = weight;
      }
      return result2;
    }
    function consumeUnsortable(vs, unsortable, index4) {
      let last2;
      while (unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= index4) {
        unsortable.pop();
        vs.push(last2.vs);
        index4++;
      }
      return index4;
    }
    function compareWithBias(bias) {
      return (entryV, entryW) => {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js"(exports2, module2) {
    var barycenter = require_barycenter();
    var resolveConflicts = require_resolve_conflicts();
    var sort3 = require_sort();
    module2.exports = sortSubgraph;
    function sortSubgraph(g, v2, cg, biasRight) {
      let movable = g.children(v2);
      let node = g.node(v2);
      let bl = node ? node.borderLeft : void 0;
      let br = node ? node.borderRight : void 0;
      let subgraphs = {};
      if (bl) {
        movable = movable.filter((w) => w !== bl && w !== br);
      }
      let barycenters = barycenter(g, movable);
      barycenters.forEach((entry) => {
        if (g.children(entry.v).length) {
          let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (Object.hasOwn(subgraphResult, "barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      let entries2 = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries2, subgraphs);
      let result2 = sort3(entries2, biasRight);
      if (bl) {
        result2.vs = [bl, result2.vs, br].flat(true);
        if (g.predecessors(bl).length) {
          let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
          if (!Object.hasOwn(result2, "barycenter")) {
            result2.barycenter = 0;
            result2.weight = 0;
          }
          result2.barycenter = (result2.barycenter * result2.weight + blPred.order + brPred.order) / (result2.weight + 2);
          result2.weight += 2;
        }
      }
      return result2;
    }
    function expandSubgraphs(entries2, subgraphs) {
      entries2.forEach((entry) => {
        entry.vs = entry.vs.flatMap((v2) => {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        });
      });
    }
    function mergeBarycenters(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js"(exports2, module2) {
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = buildLayerGraph;
    function buildLayerGraph(g, rank2, relationship) {
      let root26 = createRootNode(g), result2 = new Graph({ compound: true }).setGraph({ root: root26 }).setDefaultNodeLabel((v2) => g.node(v2));
      g.nodes().forEach((v2) => {
        let node = g.node(v2), parent2 = g.parent(v2);
        if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
          result2.setNode(v2);
          result2.setParent(v2, parent2 || root26);
          g[relationship](v2).forEach((e) => {
            let u4 = e.v === v2 ? e.w : e.v, edge = result2.edge(u4, v2), weight = edge !== void 0 ? edge.weight : 0;
            result2.setEdge(u4, v2, { weight: g.edge(e).weight + weight });
          });
          if (Object.hasOwn(node, "minRank")) {
            result2.setNode(v2, {
              borderLeft: node.borderLeft[rank2],
              borderRight: node.borderRight[rank2]
            });
          }
        }
      });
      return result2;
    }
    function createRootNode(g) {
      var v2;
      while (g.hasNode(v2 = util.uniqueId("_root"))) ;
      return v2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js"(exports2, module2) {
    module2.exports = addSubgraphConstraints;
    function addSubgraphConstraints(g, cg, vs) {
      let prev = {}, rootPrev;
      vs.forEach((v2) => {
        let child2 = g.parent(v2), parent2, prevChild;
        while (child2) {
          parent2 = g.parent(child2);
          if (parent2) {
            prevChild = prev[parent2];
            prev[parent2] = child2;
          } else {
            prevChild = rootPrev;
            rootPrev = child2;
          }
          if (prevChild && prevChild !== child2) {
            cg.setEdge(prevChild, child2);
            return;
          }
          child2 = parent2;
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/index.js"(exports2, module2) {
    "use strict";
    var initOrder = require_init_order();
    var crossCount = require_cross_count();
    var sortSubgraph = require_sort_subgraph();
    var buildLayerGraph = require_build_layer_graph();
    var addSubgraphConstraints = require_add_subgraph_constraints();
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = order;
    function order(g, opts) {
      if (opts && typeof opts.customOrder === "function") {
        opts.customOrder(g, order);
        return;
      }
      let maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");
      let layering = initOrder(g);
      assignOrder(g, layering);
      if (opts && opts.disableOptimalOrderHeuristic) {
        return;
      }
      let bestCC = Number.POSITIVE_INFINITY, best;
      for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
        layering = util.buildLayerMatrix(g);
        let cc2 = crossCount(g, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = Object.assign({}, layering);
          bestCC = cc2;
        }
      }
      assignOrder(g, best);
    }
    function buildLayerGraphs(g, ranks, relationship) {
      return ranks.map(function(rank2) {
        return buildLayerGraph(g, rank2, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      let cg = new Graph();
      layerGraphs.forEach(function(lg) {
        let root26 = lg.graph().root;
        let sorted = sortSubgraph(lg, root26, cg, biasRight);
        sorted.vs.forEach((v2, i) => lg.node(v2).order = i);
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g, layering) {
      Object.values(layering).forEach((layer) => layer.forEach((v2, i) => g.node(v2).order = i));
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/bk.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g, layering) {
      let conflicts = {};
      function visitLayer(prevLayer, layer) {
        let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
        layer.forEach((v2, i) => {
          let w = findOtherInnerSegmentNode(g, v2), k1 = w ? g.node(w).order : prevLayerLength;
          if (w || v2 === lastNode) {
            layer.slice(scanPos, i + 1).forEach((scanNode) => {
              g.predecessors(scanNode).forEach((u4) => {
                let uLabel = g.node(u4), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                  addConflict(conflicts, u4, scanNode);
                }
              });
            });
            scanPos = i + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g, layering) {
      let conflicts = {};
      function scan3(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        let v2;
        util.range(southPos, southEnd).forEach((i) => {
          v2 = south[i];
          if (g.node(v2).dummy) {
            g.predecessors(v2).forEach((u4) => {
              let uNode = g.node(u4);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u4, v2);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        let prevNorthPos = -1, nextNorthPos, southPos = 0;
        south.forEach((v2, southLookahead) => {
          if (g.node(v2).dummy === "border") {
            let predecessors = g.predecessors(v2);
            if (predecessors.length) {
              nextNorthPos = g.node(predecessors[0]).order;
              scan3(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan3(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g, v2) {
      if (g.node(v2).dummy) {
        return g.predecessors(v2).find((u4) => g.node(u4).dummy);
      }
    }
    function addConflict(conflicts, v2, w) {
      if (v2 > w) {
        let tmp = v2;
        v2 = w;
        w = tmp;
      }
      let conflictsV = conflicts[v2];
      if (!conflictsV) {
        conflicts[v2] = conflictsV = {};
      }
      conflictsV[w] = true;
    }
    function hasConflict(conflicts, v2, w) {
      if (v2 > w) {
        let tmp = v2;
        v2 = w;
        w = tmp;
      }
      return !!conflicts[v2] && Object.hasOwn(conflicts[v2], w);
    }
    function verticalAlignment(g, layering, conflicts, neighborFn) {
      let root26 = {}, align = {}, pos = {};
      layering.forEach((layer) => {
        layer.forEach((v2, order) => {
          root26[v2] = v2;
          align[v2] = v2;
          pos[v2] = order;
        });
      });
      layering.forEach((layer) => {
        let prevIdx = -1;
        layer.forEach((v2) => {
          let ws = neighborFn(v2);
          if (ws.length) {
            ws = ws.sort((a5, b) => pos[a5] - pos[b]);
            let mp = (ws.length - 1) / 2;
            for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
              let w = ws[i];
              if (align[v2] === v2 && prevIdx < pos[w] && !hasConflict(conflicts, v2, w)) {
                align[w] = v2;
                align[v2] = root26[v2] = root26[w];
                prevIdx = pos[w];
              }
            }
          }
        });
      });
      return { root: root26, align };
    }
    function horizontalCompaction(g, layering, root26, align, reverseSep) {
      let xs = {}, blockG = buildBlockGraph(g, layering, root26, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        let stack = blockG.nodes();
        let elem = stack.pop();
        let visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce((acc, e) => {
          return Math.max(acc, xs[e.v] + blockG.edge(e));
        }, 0);
      }
      function pass2(elem) {
        let min7 = blockG.outEdges(elem).reduce((acc, e) => {
          return Math.min(acc, xs[e.w] - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        let node = g.node(elem);
        if (min7 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min7);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      Object.keys(align).forEach((v2) => xs[v2] = xs[root26[v2]]);
      return xs;
    }
    function buildBlockGraph(g, layering, root26, reverseSep) {
      let blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering.forEach((layer) => {
        let u4;
        layer.forEach((v2) => {
          let vRoot = root26[v2];
          blockGraph.setNode(vRoot);
          if (u4) {
            var uRoot = root26[u4], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v2, u4), prevMax || 0));
          }
          u4 = v2;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g, xss) {
      return Object.values(xss).reduce((currentMinAndXs, xs) => {
        let max7 = Number.NEGATIVE_INFINITY;
        let min7 = Number.POSITIVE_INFINITY;
        Object.entries(xs).forEach(([v2, x4]) => {
          let halfWidth = width(g, v2) / 2;
          max7 = Math.max(x4 + halfWidth, max7);
          min7 = Math.min(x4 - halfWidth, min7);
        });
        const newMin = max7 - min7;
        if (newMin < currentMinAndXs[0]) {
          currentMinAndXs = [newMin, xs];
        }
        return currentMinAndXs;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function alignCoordinates(xss, alignTo) {
      let alignToVals = Object.values(alignTo), alignToMin = util.applyWithChunking(Math.min, alignToVals), alignToMax = util.applyWithChunking(Math.max, alignToVals);
      ["u", "d"].forEach((vert) => {
        ["l", "r"].forEach((horiz) => {
          let alignment = vert + horiz, xs = xss[alignment];
          if (xs === alignTo) return;
          let xsVals = Object.values(xs);
          let delta = alignToMin - util.applyWithChunking(Math.min, xsVals);
          if (horiz !== "l") {
            delta = alignToMax - util.applyWithChunking(Math.max, xsVals);
          }
          if (delta) {
            xss[alignment] = util.mapValues(xs, (x4) => x4 + delta);
          }
        });
      });
    }
    function balance(xss, align) {
      return util.mapValues(xss.ul, (num, v2) => {
        if (align) {
          return xss[align.toLowerCase()][v2];
        } else {
          let xs = Object.values(xss).map((xs2) => xs2[v2]).sort((a5, b) => a5 - b);
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g) {
      let layering = util.buildLayerMatrix(g);
      let conflicts = Object.assign(
        findType1Conflicts(g, layering),
        findType2Conflicts(g, layering)
      );
      let xss = {};
      let adjustedLayering;
      ["u", "d"].forEach((vert) => {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach((horiz) => {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map((inner) => {
              return Object.values(inner).reverse();
            });
          }
          let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
          let align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
          let xs = horizontalCompaction(
            g,
            adjustedLayering,
            align.root,
            align.align,
            horiz === "r"
          );
          if (horiz === "r") {
            xs = util.mapValues(xs, (x4) => -x4);
          }
          xss[vert + horiz] = xs;
        });
      });
      let smallestWidth = findSmallestWidthAlignment(g, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return (g, v2, w) => {
        let vLabel = g.node(v2);
        let wLabel = g.node(w);
        let sum7 = 0;
        let delta;
        sum7 += vLabel.width / 2;
        if (Object.hasOwn(vLabel, "labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum7 += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum7 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum7 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum7 += wLabel.width / 2;
        if (Object.hasOwn(wLabel, "labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum7 += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum7;
      };
    }
    function width(g, v2) {
      return g.node(v2).width;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/index.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var positionX = require_bk().positionX;
    module2.exports = position;
    function position(g) {
      g = util.asNonCompoundGraph(g);
      positionY(g);
      Object.entries(positionX(g)).forEach(([v2, x4]) => g.node(v2).x = x4);
    }
    function positionY(g) {
      let layering = util.buildLayerMatrix(g);
      let rankSep = g.graph().ranksep;
      let prevY = 0;
      layering.forEach((layer) => {
        const maxHeight = layer.reduce((acc, v2) => {
          const height = g.node(v2).height;
          if (acc > height) {
            return acc;
          } else {
            return height;
          }
        }, 0);
        layer.forEach((v2) => g.node(v2).y = prevY + maxHeight / 2);
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/layout.js
var require_layout = __commonJS({
  "node_modules/@dagrejs/dagre/lib/layout.js"(exports2, module2) {
    "use strict";
    var acyclic = require_acyclic();
    var normalize2 = require_normalize();
    var rank2 = require_rank();
    var normalizeRanks = require_util().normalizeRanks;
    var parentDummyChains = require_parent_dummy_chains();
    var removeEmptyRanks = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order = require_order();
    var position = require_position();
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = layout;
    function layout(g, opts) {
      let time2 = opts && opts.debugTiming ? util.time : util.notime;
      time2("layout", () => {
        let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
        time2("  runLayout", () => runLayout(layoutGraph, time2, opts));
        time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
      });
    }
    function runLayout(g, time2, opts) {
      time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g));
      time2("    removeSelfEdges", () => removeSelfEdges(g));
      time2("    acyclic", () => acyclic.run(g));
      time2("    nestingGraph.run", () => nestingGraph.run(g));
      time2("    rank", () => rank2(util.asNonCompoundGraph(g)));
      time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g));
      time2("    removeEmptyRanks", () => removeEmptyRanks(g));
      time2("    nestingGraph.cleanup", () => nestingGraph.cleanup(g));
      time2("    normalizeRanks", () => normalizeRanks(g));
      time2("    assignRankMinMax", () => assignRankMinMax(g));
      time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g));
      time2("    normalize.run", () => normalize2.run(g));
      time2("    parentDummyChains", () => parentDummyChains(g));
      time2("    addBorderSegments", () => addBorderSegments(g));
      time2("    order", () => order(g, opts));
      time2("    insertSelfEdges", () => insertSelfEdges(g));
      time2("    adjustCoordinateSystem", () => coordinateSystem.adjust(g));
      time2("    position", () => position(g));
      time2("    positionSelfEdges", () => positionSelfEdges(g));
      time2("    removeBorderNodes", () => removeBorderNodes(g));
      time2("    normalize.undo", () => normalize2.undo(g));
      time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g));
      time2("    undoCoordinateSystem", () => coordinateSystem.undo(g));
      time2("    translateGraph", () => translateGraph(g));
      time2("    assignNodeIntersects", () => assignNodeIntersects(g));
      time2("    reversePoints", () => reversePointsForReversedEdges(g));
      time2("    acyclic.undo", () => acyclic.undo(g));
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach((v2) => {
        let inputLabel = inputGraph.node(v2);
        let layoutLabel = layoutGraph.node(v2);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel.rank = layoutLabel.rank;
          if (layoutGraph.children(v2).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach((e) => {
        let inputLabel = inputGraph.edge(e);
        let layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel.points;
        if (Object.hasOwn(layoutLabel, "x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height", "rank"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      let g = new Graph({ multigraph: true, compound: true });
      let graph = canonicalize(inputGraph.graph());
      g.setGraph(Object.assign(
        {},
        graphDefaults,
        selectNumberAttrs(graph, graphNumAttrs),
        util.pick(graph, graphAttrs)
      ));
      inputGraph.nodes().forEach((v2) => {
        let node = canonicalize(inputGraph.node(v2));
        const newNode = selectNumberAttrs(node, nodeNumAttrs);
        Object.keys(nodeDefaults).forEach((k3) => {
          if (newNode[k3] === void 0) {
            newNode[k3] = nodeDefaults[k3];
          }
        });
        g.setNode(v2, newNode);
        g.setParent(v2, inputGraph.parent(v2));
      });
      inputGraph.edges().forEach((e) => {
        let edge = canonicalize(inputGraph.edge(e));
        g.setEdge(e, Object.assign(
          {},
          edgeDefaults,
          selectNumberAttrs(edge, edgeNumAttrs),
          util.pick(edge, edgeAttrs)
        ));
      });
      return g;
    }
    function makeSpaceForEdgeLabels(g) {
      let graph = g.graph();
      graph.ranksep /= 2;
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.width && edge.height) {
          let v2 = g.node(e.v);
          let w = g.node(e.w);
          let label = { rank: (w.rank - v2.rank) / 2 + v2.rank, e };
          util.addDummyNode(g, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g) {
      let maxRank = 0;
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (node.borderTop) {
          node.minRank = g.node(node.borderTop).rank;
          node.maxRank = g.node(node.borderBottom).rank;
          maxRank = Math.max(maxRank, node.maxRank);
        }
      });
      g.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g) {
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        if (node.dummy === "edge-proxy") {
          g.edge(node.e).labelRank = node.rank;
          g.removeNode(v2);
        }
      });
    }
    function translateGraph(g) {
      let minX = Number.POSITIVE_INFINITY;
      let maxX = 0;
      let minY = Number.POSITIVE_INFINITY;
      let maxY = 0;
      let graphLabel = g.graph();
      let marginX = graphLabel.marginx || 0;
      let marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        let x4 = attrs.x;
        let y4 = attrs.y;
        let w = attrs.width;
        let h = attrs.height;
        minX = Math.min(minX, x4 - w / 2);
        maxX = Math.max(maxX, x4 + w / 2);
        minY = Math.min(minY, y4 - h / 2);
        maxY = Math.max(maxY, y4 + h / 2);
      }
      g.nodes().forEach((v2) => getExtremes(g.node(v2)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (Object.hasOwn(edge, "x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g.nodes().forEach((v2) => {
        let node = g.node(v2);
        node.x -= minX;
        node.y -= minY;
      });
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach((p) => {
          p.x -= minX;
          p.y -= minY;
        });
        if (Object.hasOwn(edge, "x")) {
          edge.x -= minX;
        }
        if (Object.hasOwn(edge, "y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    }
    function assignNodeIntersects(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        let nodeV = g.node(e.v);
        let nodeW = g.node(e.w);
        let p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (Object.hasOwn(edge, "x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g) {
      g.nodes().forEach((v2) => {
        if (g.children(v2).length) {
          let node = g.node(v2);
          let t = g.node(node.borderTop);
          let b = g.node(node.borderBottom);
          let l = g.node(node.borderLeft[node.borderLeft.length - 1]);
          let r = g.node(node.borderRight[node.borderRight.length - 1]);
          node.width = Math.abs(r.x - l.x);
          node.height = Math.abs(b.y - t.y);
          node.x = l.x + node.width / 2;
          node.y = t.y + node.height / 2;
        }
      });
      g.nodes().forEach((v2) => {
        if (g.node(v2).dummy === "border") {
          g.removeNode(v2);
        }
      });
    }
    function removeSelfEdges(g) {
      g.edges().forEach((e) => {
        if (e.v === e.w) {
          var node = g.node(e.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e, label: g.edge(e) });
          g.removeEdge(e);
        }
      });
    }
    function insertSelfEdges(g) {
      var layers = util.buildLayerMatrix(g);
      layers.forEach((layer) => {
        var orderShift = 0;
        layer.forEach((v2, i) => {
          var node = g.node(v2);
          node.order = i + orderShift;
          (node.selfEdges || []).forEach((selfEdge) => {
            util.addDummyNode(g, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges(g) {
      g.nodes().forEach((v2) => {
        var node = g.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g.setEdge(node.e, node.label);
          g.removeNode(v2);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { x: x4 + dx, y: y4 },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return util.mapValues(util.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      if (attrs) {
        Object.entries(attrs).forEach(([k3, v2]) => {
          if (typeof k3 === "string") {
            k3 = k3.toLowerCase();
          }
          newAttrs[k3] = v2;
        });
      }
      return newAttrs;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/@dagrejs/dagre/lib/debug.js"(exports2, module2) {
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = {
      debugOrdering
    };
    function debugOrdering(g) {
      let layerMatrix = util.buildLayerMatrix(g);
      let h = new Graph({ compound: true, multigraph: true }).setGraph({});
      g.nodes().forEach((v2) => {
        h.setNode(v2, { label: v2 });
        h.setParent(v2, "layer" + g.node(v2).rank);
      });
      g.edges().forEach((e) => h.setEdge(e.v, e.w, {}, e.name));
      layerMatrix.forEach((layer, i) => {
        let layerV = "layer" + i;
        h.setNode(layerV, { rank: "same" });
        layer.reduce((u4, v2) => {
          h.setEdge(u4, v2, { style: "invis" });
          return v2;
        });
      });
      return h;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/version.js"(exports2, module2) {
    module2.exports = "1.1.5";
  }
});

// node_modules/@dagrejs/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@dagrejs/dagre/index.js"(exports2, module2) {
    module2.exports = {
      graphlib: require_graphlib(),
      layout: require_layout(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// node_modules/d3-array/src/ascending.js
function ascending(a5, b) {
  return a5 == null || b == null ? NaN : a5 < b ? -1 : a5 > b ? 1 : a5 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a5, b) {
  return a5 == null || b == null ? NaN : b < a5 ? -1 : b > a5 ? 1 : b >= a5 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x4) => ascending(f2(d), x4);
    delta = (d, x4) => f2(d) - x4;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left2(a5, x4, lo = 0, hi = a5.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a5[mid], x4) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a5, x4, lo = 0, hi = a5.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a5[mid], x4) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a5, x4, lo = 0, hi = a5.length) {
    const i = left2(a5, x4, lo, hi - 1);
    return i > lo && delta(a5[i - 1], x4) > -delta(a5[i], x4) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x4) {
  return x4 === null ? NaN : +x4;
}
function* numbers(values2, valueof) {
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values2, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values2.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values2, width, height);
      blurh(blurx, values2, temp, width, height);
      blurh(blurx, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
      blurv(blury, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values2, temp, width, height);
      blurh(blurx, temp, values2, width, height);
      blurh(blurx, values2, temp, width, height);
    } else if (blury) {
      blurv(blury, values2, temp, width, height);
      blurv(blury, temp, values2, width, height);
      blurv(blury, values2, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y4 = 0, n = w * h; y4 < n; ) {
    blur3(T, S, y4, y4 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x4 = 0, n = w * h; x4 < w; ++x4) {
    blur3(T, S, x4, x4 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop2, step) => {
    start <<= 2, stop2 <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop2 + 0, step);
    blur3(T, S, start + 1, stop2 + 1, step);
    blur3(T, S, start + 2, stop2 + 2, step);
    blur3(T, S, start + 3, stop2 + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start)) return;
    let sum7 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum7 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum7 += S[Math.min(stop2, i + s0)];
      T[i] = (sum7 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop2, i + s1)])) / w;
      sum7 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start)) return;
    let sum7 = radius * S[start];
    const s3 = step * radius;
    for (let i = start, j = start + s3; i < j; i += step) {
      sum7 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum7 += S[Math.min(stop2, i + s3)];
      T[i] = sum7 / w;
      sum7 -= S[Math.max(start, i - s3)];
    }
  };
}

// node_modules/d3-array/src/extent.js
function extent(values2, valueof) {
  let min7;
  let max7;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null) {
        if (min7 === void 0) {
          if (value2 >= value2) min7 = max7 = value2;
        } else {
          if (min7 > value2) min7 = value2;
          if (max7 < value2) max7 = value2;
        }
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null) {
        if (min7 === void 0) {
          if (value2 >= value2) min7 = max7 = value2;
        } else {
          if (min7 > value2) min7 = value2;
          if (max7 < value2) max7 = value2;
        }
      }
    }
  }
  return [min7, max7];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x4) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
      if (lo) p[i++] = lo;
      x4 = hi;
    }
    p[i] = x4;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x4, y4, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x4 = hi;
        y4 = p[--n];
        hi = x4 + y4;
        lo = y4 - (hi - x4);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y4 = lo * 2;
        x4 = hi + y4;
        if (y4 == x4 - hi) hi = x4;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries2, key2 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
    if (entries2 != null) for (const [key3, value2] of entries2) this.set(key3, value2);
  }
  get(key2) {
    return super.get(intern_get(this, key2));
  }
  has(key2) {
    return super.has(intern_get(this, key2));
  }
  set(key2, value2) {
    return super.set(intern_set(this, key2), value2);
  }
  delete(key2) {
    return super.delete(intern_delete(this, key2));
  }
};
var InternSet = class extends Set {
  constructor(values2, key2 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
    if (values2 != null) for (const value2 of values2) this.add(value2);
  }
  has(value2) {
    return super.has(intern_get(this, value2));
  }
  add(value2) {
    return super.add(intern_set(this, value2));
  }
  delete(value2) {
    return super.delete(intern_delete(this, value2));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key2 = _key(value2);
  return _intern.has(key2) ? _intern.get(key2) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2)) return _intern.get(key2);
  _intern.set(key2, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2)) {
    value2 = _intern.get(key2);
    _intern.delete(key2);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity(x4) {
  return x4;
}

// node_modules/d3-array/src/group.js
function group(values2, ...keys3) {
  return nest(values2, identity, identity, keys3);
}
function groups(values2, ...keys3) {
  return nest(values2, Array.from, identity, keys3);
}
function flatten(groups3, keys3) {
  for (let i = 1, n = keys3.length; i < n; ++i) {
    groups3 = groups3.flatMap((g) => g.pop().map(([key2, value2]) => [...g, key2, value2]));
  }
  return groups3;
}
function flatGroup(values2, ...keys3) {
  return flatten(groups(values2, ...keys3), keys3);
}
function rollup(values2, reduce4, ...keys3) {
  return nest(values2, identity, reduce4, keys3);
}
function index2(values2, ...keys3) {
  return nest(values2, identity, unique, keys3);
}
function unique(values2) {
  if (values2.length !== 1) throw new Error("duplicate key");
  return values2[0];
}
function nest(values2, map7, reduce4, keys3) {
  return function regroup(values3, i) {
    if (i >= keys3.length) return reduce4(values3);
    const groups3 = new InternMap();
    const keyof2 = keys3[i++];
    let index4 = -1;
    for (const value2 of values3) {
      const key2 = keyof2(value2, ++index4, values3);
      const group3 = groups3.get(key2);
      if (group3) group3.push(value2);
      else groups3.set(key2, [value2]);
    }
    for (const [key2, values4] of groups3) {
      groups3.set(key2, regroup(values4, i));
    }
    return map7(groups3);
  }(values2, 0);
}

// node_modules/d3-array/src/sort.js
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a5, b) => {
    const x4 = compare(a5, b);
    if (x4 || x4 === 0) return x4;
    return (compare(b, b) === 0) - (compare(a5, a5) === 0);
  };
}
function ascendingDefined(a5, b) {
  return (a5 == null || !(a5 >= a5)) - (b == null || !(b >= b)) || (a5 < b ? -1 : a5 > b ? 1 : 0);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop2, count4) {
  const step = (stop2 - start) / Math.max(0, count4), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop2 * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop2) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop2 / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop2) --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start, stop2, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop2, count4) {
  stop2 = +stop2, start = +start, count4 = +count4;
  if (!(count4 > 0)) return [];
  if (start === stop2) return [start];
  const reverse4 = stop2 < start, [i1, i2, inc] = reverse4 ? tickSpec(stop2, start, count4) : tickSpec(start, stop2, count4);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse4) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop2, count4) {
  stop2 = +stop2, start = +start, count4 = +count4;
  return tickSpec(start, stop2, count4)[2];
}
function tickStep(start, stop2, count4) {
  stop2 = +stop2, start = +start, count4 = +count4;
  const reverse4 = stop2 < start, inc = reverse4 ? tickIncrement(stop2, start, count4) : tickIncrement(start, stop2, count4);
  return (reverse4 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max(values2, valueof) {
  let max7;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  }
  return max7;
}

// node_modules/d3-array/src/min.js
function min(values2, valueof) {
  let min7;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  }
  return min7;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array3, k3, left2 = 0, right2 = Infinity, compare) {
  k3 = Math.floor(k3);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array3.length - 1, right2));
  if (!(left2 <= k3 && k3 <= right2)) return array3;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m3 = k3 - left2 + 1;
      const z = Math.log(n);
      const s3 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k3 - m3 * s3 / n + sd));
      const newRight = Math.min(right2, Math.floor(k3 + (n - m3) * s3 / n + sd));
      quickselect(array3, k3, newLeft, newRight, compare);
    }
    const t = array3[k3];
    let i = left2;
    let j = right2;
    swap(array3, left2, k3);
    if (compare(array3[right2], t) > 0) swap(array3, left2, right2);
    while (i < j) {
      swap(array3, i, j), ++i, --j;
      while (compare(array3[i], t) < 0) ++i;
      while (compare(array3[j], t) > 0) --j;
    }
    if (compare(array3[left2], t) === 0) swap(array3, left2, j);
    else ++j, swap(array3, j, right2);
    if (j <= k3) left2 = j + 1;
    if (k3 <= j) right2 = j - 1;
  }
  return array3;
}
function swap(array3, i, j) {
  const t = array3[i];
  array3[i] = array3[j];
  array3[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values2, compare = ascending) {
  let max7;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values2) {
      const value2 = compare(element);
      if (defined ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max7 = element;
        maxValue = value2;
        defined = true;
      }
    }
  } else {
    for (const value2 of values2) {
      if (defined ? compare(value2, max7) > 0 : compare(value2, value2) === 0) {
        max7 = value2;
        defined = true;
      }
    }
  }
  return max7;
}

// node_modules/d3-array/src/quantile.js
function quantile(values2, p, valueof) {
  values2 = Float64Array.from(numbers(values2, valueof));
  if (!(n = values2.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min(values2);
  if (p >= 1) return max(values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/merge.js
function* flatten2(arrays) {
  for (const array3 of arrays) {
    yield* array3;
  }
}
function merge(arrays) {
  return Array.from(flatten2(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range4 = new Array(n);
  while (++i < n) {
    range4[i] = start + i * step;
  }
  return range4;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random2) {
  return function shuffle3(array3, i0 = 0, i1 = array3.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random2() * m3-- | 0, t = array3[m3 + i0];
      array3[m3 + i0] = array3[i + i0];
      array3[i + i0] = t;
    }
    return array3;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values2, valueof) {
  let sum7 = 0;
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 = +value2) {
        sum7 += value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if (value2 = +valueof(value2, ++index4, values2)) {
        sum7 += value2;
      }
    }
  }
  return sum7;
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty.call(value2, symToStringTag), tag2 = value2[symToStringTag];
  try {
    value2[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag] = tag2;
    } else {
      delete value2[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value2) {
  return nativeObjectToString2.call(value2);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag_default(value2) : objectToString_default(value2);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike_default(value2) && baseGetTag_default(value2) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN;
  }
  return +value2;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array3, iteratee2) {
  var index4 = -1, length = array3 == null ? 0 : array3.length, result2 = Array(length);
  while (++index4 < length) {
    result2[index4] = iteratee2(array3[index4], index4, array3);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray_default(value2)) {
    return arrayMap_default(value2, baseToString) + "";
  }
  if (isSymbol_default(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value2, other) {
    var result2;
    if (value2 === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value2 !== void 0) {
      result2 = value2;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value2 == "string" || typeof other == "string") {
        value2 = baseToString_default(value2);
        other = baseToString_default(other);
      } else {
        value2 = baseToNumber_default(value2);
        other = baseToNumber_default(other);
      }
      result2 = operator(value2, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index4 = string.length;
  while (index4-- && reWhitespace.test(string.charAt(index4))) {
  }
  return index4;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN2;
  }
  if (isObject_default(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject_default(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim_default(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN2 : +value2;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber_default(value2);
  if (value2 === INFINITY2 || value2 === -INFINITY2) {
    var sign5 = value2 < 0 ? -1 : 1;
    return sign5 * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value2) {
  var result2 = toFinite_default(value2), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity2(value2) {
  return value2;
}
var identity_default = identity2;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject_default(value2)) {
    return false;
  }
  var tag2 = baseGetTag_default(value2);
  return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject_default(value2) || isMasked_default(value2)) {
    return false;
  }
  var pattern = isFunction_default(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value2));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object2, key2) {
  return object2 == null ? void 0 : object2[key2];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object2, key2) {
  var value2 = getValue_default(object2, key2);
  return baseIsNative_default(value2) ? value2 : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result2 = new object2();
    object2.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply2;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array3, placeholder) {
  var length = array3.length, result2 = 0;
  while (length--) {
    if (array3[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value2) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop2() {
}
var noop_default = noop2;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array3 = realNames_default[result2], length = hasOwnProperty3.call(realNames_default, result2) ? array3.length : 0;
  while (length--) {
    var data = array3[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value2, chainAll) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array3) {
  var index4 = -1, length = source.length;
  array3 || (array3 = Array(length));
  while (++index4 < length) {
    array3[index4] = source[index4];
  }
  return array3;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value2) {
  if (isObjectLike_default(value2) && !isArray_default(value2) && !(value2 instanceof LazyWrapper_default)) {
    if (value2 instanceof LodashWrapper_default) {
      return value2;
    }
    if (hasOwnProperty4.call(value2, "__wrapped__")) {
      return wrapperClone_default(value2);
    }
  }
  return new LodashWrapper_default(value2);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count4 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count4 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count4 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant2(value2) {
  return function() {
    return value2;
  };
}
var constant_default = constant2;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array3, iteratee2) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  while (++index4 < length) {
    if (iteratee2(array3[index4], index4, array3) === false) {
      break;
    }
  }
  return array3;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array3, predicate, fromIndex, fromRight) {
  var length = array3.length, index4 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index4-- : ++index4 < length) {
    if (predicate(array3[index4], index4, array3)) {
      return index4;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value2) {
  return value2 !== value2;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array3, value2, fromIndex) {
  var index4 = fromIndex - 1, length = array3.length;
  while (++index4 < length) {
    if (array3[index4] === value2) {
      return index4;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array3, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf_default(array3, value2, fromIndex) : baseFindIndex_default(array3, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array3, value2) {
  var length = array3 == null ? 0 : array3.length;
  return !!length && baseIndexOf_default(array3, value2, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value2 = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value2)) {
      details.push(value2);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object2 = func;
  return object2.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array3, indexes3) {
  var arrLength = array3.length, length = nativeMin(indexes3.length, arrLength), oldArray = copyArray_default(array3);
  while (length--) {
    var index4 = indexes3[length];
    array3[length] = isIndex_default(index4, arrLength) ? oldArray[index4] : void 0;
  }
  return array3;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array3, placeholder) {
  var index4 = -1, length = array3.length, resIndex = 0, result2 = [];
  while (++index4 < length) {
    var value2 = array3[index4];
    if (value2 === placeholder || value2 === PLACEHOLDER) {
      array3[index4] = PLACEHOLDER;
      result2[resIndex++] = index4;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index4 = length;
    while (index4--) {
      args[index4] = arguments[index4];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index4 = length, placeholder = getHolder_default(wrapper);
    while (index4--) {
      args[index4] = arguments[index4];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value2 = source[3];
  if (value2) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value2, source[4]) : value2;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value2 = source[5];
  if (value2) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value2, source[6]) : value2;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value2 = source[7];
  if (value2) {
    data[7] = value2;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object2, key2, value2) {
  if (key2 == "__proto__" && defineProperty_default) {
    defineProperty_default(object2, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key2] = value2;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object2, key2, value2) {
  var objValue = object2[key2];
  if (!(hasOwnProperty5.call(object2, key2) && eq_default(objValue, value2)) || value2 === void 0 && !(key2 in object2)) {
    baseAssignValue_default(object2, key2, value2);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index4 = -1, length = props.length;
  while (++index4 < length) {
    var key2 = props[index4];
    var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue_default(object2, key2, newValue);
    } else {
      assignValue_default(object2, key2, newValue);
    }
  }
  return object2;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index4 = -1, length = nativeMax4(args.length - start, 0), array3 = Array(length);
    while (++index4 < length) {
      array3[index4] = args[start + index4];
    }
    index4 = -1;
    var otherArgs = Array(start + 1);
    while (++index4 < start) {
      otherArgs[index4] = args[index4];
    }
    otherArgs[start] = transform2(array3);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value2) {
  return value2 != null && isLength_default(value2.length) && !isFunction_default(value2);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value2, index4, object2) {
  if (!isObject_default(object2)) {
    return false;
  }
  var type = typeof index4;
  if (type == "number" ? isArrayLike_default(object2) && isIndex_default(index4, object2.length) : type == "string" && index4 in object2) {
    return eq_default(object2[index4], value2);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object2, sources) {
    var index4 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index4 < length) {
      var source = sources[index4];
      if (source) {
        assigner(object2, source, index4, customizer);
      }
    }
    return object2;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value2 === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index4 = -1, result2 = Array(n);
  while (++index4 < n) {
    result2[index4] = iteratee2(index4);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value2) {
  return isObjectLike_default(value2) && hasOwnProperty6.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike_default(value2) && isLength_default(value2.length) && !!typedArrayTags[baseGetTag_default(value2)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray_default(value2), isArg = !isArr && isArguments_default(value2), isBuff = !isArr && !isArg && isBuffer_default(value2), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes_default(value2.length, String) : [], length = result2.length;
  for (var key2 in value2) {
    if ((inherited || hasOwnProperty7.call(value2, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex_default(key2, length)))) {
      result2.push(key2);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype_default(object2)) {
    return nativeKeys_default(object2);
  }
  var result2 = [];
  for (var key2 in Object(object2)) {
    if (hasOwnProperty8.call(object2, key2) && key2 != "constructor") {
      result2.push(key2);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys;

// node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var assign2 = createAssigner_default(function(object2, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object2);
    return;
  }
  for (var key2 in source) {
    if (hasOwnProperty9.call(source, key2)) {
      assignValue_default(object2, key2, source[key2]);
    }
  }
});
var assign_default = assign2;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object2) {
  var result2 = [];
  if (object2 != null) {
    for (var key2 in Object(object2)) {
      result2.push(key2);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject_default(object2)) {
    return nativeKeysIn_default(object2);
  }
  var isProto = isPrototype_default(object2), result2 = [];
  for (var key2 in object2) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty10.call(object2, key2)))) {
      result2.push(key2);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2, true) : baseKeysIn_default(object2);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object2, source) {
  copyObject_default(source, keysIn_default(source), object2);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object2, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object2, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object2, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object2, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value2, object2) {
  if (isArray_default(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_default(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key2) {
  var result2 = this.has(key2) && delete this.__data__[key2];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key2];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty11.call(data, key2) ? data[key2] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate_default ? data[key2] !== void 0 : hasOwnProperty12.call(data, key2);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key2, value2) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate_default && value2 === void 0 ? HASH_UNDEFINED2 : value2;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries2) {
  var index4 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index4 < length) {
    var entry = entries2[index4];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array3, key2) {
  var length = array3.length;
  while (length--) {
    if (eq_default(array3[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index4 = assocIndexOf_default(data, key2);
  if (index4 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index4 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index4, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key2) {
  var data = this.__data__, index4 = assocIndexOf_default(data, key2);
  return index4 < 0 ? void 0 : data[index4][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key2) {
  return assocIndexOf_default(this.__data__, key2) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key2, value2) {
  var data = this.__data__, index4 = assocIndexOf_default(data, key2);
  if (index4 < 0) {
    ++this.size;
    data.push([key2, value2]);
  } else {
    data[index4][1] = value2;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries2) {
  var index4 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index4 < length) {
    var entry = entries2[index4];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map7, key2) {
  var data = map7.__data__;
  return isKeyable_default(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key2) {
  var result2 = getMapData_default(this, key2)["delete"](key2);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key2) {
  return getMapData_default(this, key2).get(key2);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key2) {
  return getMapData_default(this, key2).has(key2);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key2, value2) {
  var data = getMapData_default(this, key2), size2 = data.size;
  data.set(key2, value2);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries2) {
  var index4 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index4 < length) {
    var entry = entries2[index4];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache.set(key2, result2) || cache;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match, number4, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value2) {
  return value2 == null ? "" : baseToString_default(value2);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value2, object2) {
  if (isArray_default(value2)) {
    return value2;
  }
  return isKey_default(value2, object2) ? [value2] : stringToPath_default(toString_default(value2));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol_default(value2)) {
    return value2;
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object2, path3) {
  path3 = castPath_default(path3, object2);
  var index4 = 0, length = path3.length;
  while (object2 != null && index4 < length) {
    object2 = object2[toKey_default(path3[index4++])];
  }
  return index4 && index4 == length ? object2 : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get2(object2, path3, defaultValue) {
  var result2 = object2 == null ? void 0 : baseGet_default(object2, path3);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get2;

// node_modules/lodash-es/_baseAt.js
function baseAt(object2, paths) {
  var index4 = -1, length = paths.length, result2 = Array(length), skip = object2 == null;
  while (++index4 < length) {
    result2[index4] = skip ? void 0 : get_default(object2, paths[index4]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array3, values2) {
  var index4 = -1, length = values2.length, offset = array3.length;
  while (++index4 < length) {
    array3[offset + index4] = values2[index4];
  }
  return array3;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray_default(value2) || isArguments_default(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array3, depth, predicate, isStrict, result2) {
  var index4 = -1, length = array3.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index4 < length) {
    var value2 = array3[index4];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value2);
      }
    } else if (!isStrict) {
      result2[result2.length] = value2;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten3(array3) {
  var length = array3 == null ? 0 : array3.length;
  return length ? baseFlatten_default(array3, 1) : [];
}
var flatten_default = flatten3;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value2) {
  if (!isObjectLike_default(value2) || baseGetTag_default(value2) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value2) {
  if (!isObjectLike_default(value2)) {
    return false;
  }
  var tag2 = baseGetTag_default(value2);
  return tag2 == errorTag2 || tag2 == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject_default(value2);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object2, methodNames) {
  arrayEach_default(methodNames, function(key2) {
    key2 = toKey_default(key2);
    baseAssignValue_default(object2, key2, bind_default(object2[key2], object2));
  });
  return object2;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object2, key2, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key2, bitmask, object2, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array3, start, end) {
  var index4 = -1, length = array3.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length);
  while (++index4 < length) {
    result2[index4] = array3[index4 + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array3, start, end) {
  var length = array3.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array3 : baseSlice_default(array3, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array3, iteratee2, accumulator, initAccum) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  if (initAccum && length) {
    accumulator = array3[++index4];
  }
  while (++index4 < length) {
    accumulator = iteratee2(accumulator, array3[index4], index4, array3);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object2) {
  return function(key2) {
    return object2 == null ? void 0 : object2[key2];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "['’]";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index4) {
  word = word.toLowerCase();
  return result2 + (index4 ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value2 = arguments[0];
  return isArray_default(value2) ? value2 : [value2];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number4, precision) {
    number4 = toNumber_default(number4);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number4)) {
      var pair = (toString_default(number4) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value2) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number4);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// node_modules/lodash-es/chain.js
function chain(value2) {
  var result2 = wrapperLodash_default(value2);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array3, size2, guard) {
  if (guard ? isIterateeCall_default(array3, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax5(toInteger_default(size2), 0);
  }
  var length = array3 == null ? 0 : array3.length;
  if (!length || size2 < 1) {
    return [];
  }
  var index4 = 0, resIndex = 0, result2 = Array(nativeCeil(length / size2));
  while (index4 < length) {
    result2[resIndex++] = baseSlice_default(array3, index4, index4 += size2);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number4, lower, upper) {
  if (number4 === number4) {
    if (upper !== void 0) {
      number4 = number4 <= upper ? number4 : upper;
    }
    if (lower !== void 0) {
      number4 = number4 >= lower ? number4 : lower;
    }
  }
  return number4;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp(number4, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number4), lower, upper);
}
var clamp_default = clamp;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key2) {
  var data = this.__data__, result2 = data["delete"](key2);
  this.size = data.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key2) {
  return this.__data__.get(key2);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key2) {
  return this.__data__.has(key2);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value2) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs3 = data.__data__;
    if (!Map_default || pairs3.length < LARGE_ARRAY_SIZE - 1) {
      pairs3.push([key2, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs3);
  }
  data.set(key2, value2);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries2) {
  var data = this.__data__ = new ListCache_default(entries2);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object2, source) {
  return object2 && copyObject_default(source, keys_default(source), object2);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object2, source) {
  return object2 && copyObject_default(source, keysIn_default(source), object2);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array3, predicate) {
  var index4 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result2 = [];
  while (++index4 < length) {
    var value2 = array3[index4];
    if (predicate(value2, index4, array3)) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter_default(nativeGetSymbols(object2), function(symbol) {
    return propertyIsEnumerable2.call(object2, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object2) {
  return copyObject_default(source, getSymbols_default(source), object2);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object2) {
  var result2 = [];
  while (object2) {
    arrayPush_default(result2, getSymbols_default(object2));
    object2 = getPrototype_default(object2);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object2) {
  return copyObject_default(source, getSymbolsIn_default(source), object2);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object2);
  return isArray_default(object2) ? result2 : arrayPush_default(result2, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object2) {
  return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object2) {
  return baseGetAllKeys_default(object2, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value2) {
    var result2 = baseGetTag_default(value2), Ctor = result2 == objectTag3 ? value2.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty14 = objectProto17.hasOwnProperty;
function initCloneArray(array3) {
  var length = array3.length, result2 = new array3.constructor(length);
  if (length && typeof array3[0] == "string" && hasOwnProperty14.call(array3, "index")) {
    result2.index = array3.index;
    result2.input = array3.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object2, tag2, isDeep) {
  var Ctor = object2.constructor;
  switch (tag2) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object2);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object2);
    case dataViewTag3:
      return cloneDataView_default(object2, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object2, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object2);
    case regexpTag2:
      return cloneRegExp_default(object2);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object2);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype_default(object2) ? baseCreate_default(getPrototype_default(object2)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value2, bitmask, customizer, key2, object2, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object2 ? customizer(value2, key2, object2, stack) : customizer(value2);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value2)) {
    return value2;
  }
  var isArr = isArray_default(value2);
  if (isArr) {
    result2 = initCloneArray_default(value2);
    if (!isDeep) {
      return copyArray_default(value2, result2);
    }
  } else {
    var tag2 = getTag_default(value2), isFunc = tag2 == funcTag3 || tag2 == genTag2;
    if (isBuffer_default(value2)) {
      return cloneBuffer_default(value2, isDeep);
    }
    if (tag2 == objectTag4 || tag2 == argsTag3 || isFunc && !object2) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value2, baseAssignIn_default(result2, value2)) : copySymbols_default(value2, baseAssign_default(result2, value2));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object2 ? value2 : {};
      }
      result2 = initCloneByTag_default(value2, tag2, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result2);
  if (isSet_default(value2)) {
    value2.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap_default(value2)) {
    value2.forEach(function(subValue, key3) {
      result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach_default(props || value2, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value2[key3];
    }
    assignValue_default(result2, key3, baseClone(subValue, bitmask, customizer, key3, value2, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value2) {
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value2) {
  return baseClone_default(value2, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array3) {
  var index4 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result2 = [];
  while (++index4 < length) {
    var value2 = array3[index4];
    if (value2) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array3 = arguments[0], index4 = length;
  while (index4--) {
    args[index4 - 1] = arguments[index4];
  }
  return arrayPush_default(isArray_default(array3) ? copyArray_default(array3) : [array3], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index4 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index4 < length) {
    this.add(values2[index4]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array3, predicate) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  while (++index4 < length) {
    if (predicate(array3[index4], index4, array3)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key2) {
  return cache.has(key2);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array3, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array3.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array3);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array3;
  }
  var index4 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array3, other);
  stack.set(other, array3);
  while (++index4 < arrLength) {
    var arrValue = array3[index4], othValue = other[index4];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index4, other, array3, stack) : customizer(arrValue, othValue, index4, array3, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array3);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map7) {
  var index4 = -1, result2 = Array(map7.size);
  map7.forEach(function(value2, key2) {
    result2[++index4] = [key2, value2];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set5) {
  var index4 = -1, result2 = Array(set5.size);
  set5.forEach(function(value2) {
    result2[++index4] = value2;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object2, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag5:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object2), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object2, +other);
    case errorTag4:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object2 == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object2, other);
      var result2 = equalArrays_default(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object2) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object2), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index4 = objLength;
  while (index4--) {
    var key2 = objProps[index4];
    if (!(isPartial ? key2 in other : hasOwnProperty15.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result2 = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index4 < objLength) {
    key2 = objProps[index4];
    var objValue = object2[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object2), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object2), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object2)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object2) ? equalArrays_default(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object2, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike_default(value2) && !isObjectLike_default(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep_default(value2, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
  var index4 = matchData.length, length = index4, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index4--) {
    var data = matchData[index4];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index4 < length) {
    data = matchData[index4];
    var key2 = data[0], objValue = object2[key2], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key2 in object2)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key2, object2, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value2) {
  return value2 === value2 && !isObject_default(value2);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object2) {
  var result2 = keys_default(object2), length = result2.length;
  while (length--) {
    var key2 = result2[length], value2 = object2[key2];
    result2[length] = [key2, value2, isStrictComparable_default(value2)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key2, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object2));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch_default(object2, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object2, key2) {
  return object2 != null && key2 in Object(object2);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object2, path3, hasFunc) {
  path3 = castPath_default(path3, object2);
  var index4 = -1, length = path3.length, result2 = false;
  while (++index4 < length) {
    var key2 = toKey_default(path3[index4]);
    if (!(result2 = object2 != null && hasFunc(object2, key2))) {
      break;
    }
    object2 = object2[key2];
  }
  if (result2 || ++index4 != length) {
    return result2;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength_default(length) && isIndex_default(key2, length) && (isArray_default(object2) || isArguments_default(object2));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object2, path3) {
  return object2 != null && hasPath_default(object2, path3, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path3, srcValue) {
  if (isKey_default(path3) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path3), srcValue);
  }
  return function(object2) {
    var objValue = get_default(object2, path3);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object2, path3) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key2) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key2];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path3) {
  return function(object2) {
    return baseGet_default(object2, path3);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path3) {
  return isKey_default(path3) ? baseProperty_default(toKey_default(path3)) : basePropertyDeep_default(path3);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity_default;
  }
  if (typeof value2 == "object") {
    return isArray_default(value2) ? baseMatchesProperty_default(value2[0], value2[1]) : baseMatches_default(value2);
  }
  return property_default(value2);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs3) {
  var length = pairs3 == null ? 0 : pairs3.length, toIteratee = baseIteratee_default;
  pairs3 = !length ? [] : arrayMap_default(pairs3, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index4 = -1;
    while (++index4 < length) {
      var pair = pairs3[index4];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object2, source, props) {
  var length = props.length;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (length--) {
    var key2 = props[length], predicate = source[key2], value2 = object2[key2];
    if (value2 === void 0 && !(key2 in object2) || !predicate(value2)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object2) {
    return baseConformsTo_default(object2, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object2, source) {
  return source == null || baseConformsTo_default(object2, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array3, setter, iteratee2, accumulator) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  while (++index4 < length) {
    var value2 = array3[index4];
    setter(accumulator, value2, iteratee2(value2), array3);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object2, iteratee2, keysFunc) {
    var index4 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key2 = props[fromRight ? length : ++index4];
      if (iteratee2(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object2, iteratee2) {
  return object2 && baseFor_default(object2, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index4 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index4-- : ++index4 < length) {
      if (iteratee2(iterable[index4], index4, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value2, key2, collection2) {
    setter(accumulator, value2, iteratee2(value2), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty17 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value2, key2) {
  if (hasOwnProperty17.call(result2, key2)) {
    ++result2[key2];
  } else {
    baseAssignValue_default(result2, key2, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result2;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now_default();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time2 = now_default(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value2, defaultValue) {
  return value2 == null || value2 !== value2 ? defaultValue : value2;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty18 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object2, sources) {
  object2 = Object(object2);
  var index4 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index4 < length) {
    var source = sources[index4];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key2 = props[propsIndex];
      var value2 = object2[key2];
      if (value2 === void 0 || eq_default(value2, objectProto21[key2]) && !hasOwnProperty18.call(object2, key2)) {
        object2[key2] = source[key2];
      }
    }
  }
  return object2;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object2, key2, value2) {
  if (value2 !== void 0 && !eq_default(object2[key2], value2) || value2 === void 0 && !(key2 in object2)) {
    baseAssignValue_default(object2, key2, value2);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value2) {
  return isObjectLike_default(value2) && isArrayLike_default(value2);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object2, key2) {
  if (key2 === "constructor" && typeof object2[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object2[key2];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value2) {
  return copyObject_default(value2, keysIn_default(value2));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object2, source, key2, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object2, key2), srcValue = safeGet_default(source, key2), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object2, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object2, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object2, key2, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object2, source, srcIndex, customizer, stack) {
  if (object2 === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key2) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object2, source, key2, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object2, key2), srcValue, key2 + "", object2, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object2, key2, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key2, object2, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object2, source, srcIndex, customizer) {
  baseMerge_default(object2, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array3, value2, comparator) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  while (++index4 < length) {
    if (comparator(value2, array3[index4])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array3, values2, iteratee2, comparator) {
  var index4 = -1, includes2 = arrayIncludes_default, isCommon = true, length = array3.length, result2 = [], valuesLength = values2.length;
  if (!length) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index4 < length) {
      var value2 = array3[index4], computed = iteratee2 == null ? value2 : iteratee2(value2);
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value2);
      } else if (!includes2(values2, computed, comparator)) {
        result2.push(value2);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference2 = baseRest_default(function(array3, values2) {
  return isArrayLikeObject_default(array3) ? baseDifference_default(array3, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference2;

// node_modules/lodash-es/last.js
function last(array3) {
  var length = array3 == null ? 0 : array3.length;
  return length ? array3[length - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array3, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array3) ? baseDifference_default(array3, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array3, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array3) ? baseDifference_default(array3, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array3, n, guard) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array3, n < 0 ? 0 : n, length);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array3, n, guard) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array3, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array3, predicate, isDrop, fromRight) {
  var length = array3.length, index4 = fromRight ? length : -1;
  while ((fromRight ? index4-- : ++index4 < length) && predicate(array3[index4], index4, array3)) {
  }
  return isDrop ? baseSlice_default(array3, fromRight ? 0 : index4, fromRight ? index4 + 1 : length) : baseSlice_default(array3, fromRight ? index4 + 1 : 0, fromRight ? length : index4);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array3, predicate) {
  return array3 && array3.length ? baseWhile_default(array3, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array3, predicate) {
  return array3 && array3.length ? baseWhile_default(array3, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value2) {
  return typeof value2 == "function" ? value2 : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array3, iteratee2) {
  var length = array3 == null ? 0 : array3.length;
  while (length--) {
    if (iteratee2(array3[length], length, array3) === false) {
      break;
    }
  }
  return array3;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object2, iteratee2) {
  return object2 && baseForRight_default(object2, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length = string.length;
  position = position === void 0 ? length : baseClamp_default(toInteger_default(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object2, props) {
  return arrayMap_default(props, function(key2) {
    return [key2, object2[key2]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set5) {
  var index4 = -1, result2 = Array(set5.size);
  set5.forEach(function(value2) {
    result2[++index4] = [value2, value2];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object2) {
    var tag2 = getTag_default(object2);
    if (tag2 == mapTag7) {
      return mapToArray_default(object2);
    }
    if (tag2 == setTag7) {
      return setToPairs_default(object2);
    }
    return baseToPairs_default(object2, keysFunc(object2));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array3, predicate) {
  var index4 = -1, length = array3 == null ? 0 : array3.length;
  while (++index4 < length) {
    if (!predicate(array3[index4], index4, array3)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value2, index4, collection2) {
    result2 = !!predicate(value2, index4, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every2(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every2;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array3, value2, start, end) {
  var length = array3.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger_default(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array3[start++] = value2;
  }
  return array3;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array3, value2, start, end) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array3, value2, start)) {
    start = 0;
    end = length;
  }
  return baseFill_default(array3, value2, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value2, index4, collection2) {
    if (predicate(value2, index4, collection2)) {
      result2.push(value2);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter2(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter2;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key2) {
        return iteratee2(iterable[key2], key2, iterable);
      };
    }
    var index4 = findIndexFunc(collection, predicate, fromIndex);
    return index4 > -1 ? iterable[iteratee2 ? collection[index4] : index4] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array3, predicate, fromIndex) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return -1;
  }
  var index4 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index4 < 0) {
    index4 = nativeMax7(length + index4, 0);
  }
  return baseFindIndex_default(array3, baseIteratee_default(predicate, 3), index4);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value2, key2, collection2) {
    if (predicate(value2, key2, collection2)) {
      result2 = key2;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object2, predicate) {
  return baseFindKey_default(object2, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array3, predicate, fromIndex) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return -1;
  }
  var index4 = length - 1;
  if (fromIndex !== void 0) {
    index4 = toInteger_default(fromIndex);
    index4 = fromIndex < 0 ? nativeMax8(length + index4, 0) : nativeMin5(index4, length - 1);
  }
  return baseFindIndex_default(array3, baseIteratee_default(predicate, 3), index4, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object2, predicate) {
  return baseFindKey_default(object2, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array3) {
  return array3 && array3.length ? array3[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index4 = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2, key2, collection2) {
    result2[++index4] = iteratee2(value2, key2, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map3(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map3;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array3) {
  var length = array3 == null ? 0 : array3.length;
  return length ? baseFlatten_default(array3, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array3, depth) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array3, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index4 = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index4--) {
      var func = funcs[index4];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index4 = wrapper ? index4 : length;
    while (++index4 < length) {
      func = funcs[index4];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value2 = args[0];
      if (wrapper && args.length == 1 && isArray_default(value2)) {
        return wrapper.plant(value2).value();
      }
      var index5 = 0, result2 = length ? funcs[index5].apply(this, args) : value2;
      while (++index5 < length) {
        result2 = funcs[index5].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object2, iteratee2) {
  return object2 == null ? object2 : baseFor_default(object2, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object2, iteratee2) {
  return object2 == null ? object2 : baseForRight_default(object2, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object2, iteratee2) {
  return object2 && baseForOwn_default(object2, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object2, iteratee2) {
  return object2 && baseForOwnRight_default(object2, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs3) {
  var index4 = -1, length = pairs3 == null ? 0 : pairs3.length, result2 = {};
  while (++index4 < length) {
    var pair = pairs3[index4];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object2, props) {
  return arrayFilter_default(props, function(key2) {
    return isFunction_default(object2[key2]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object2) {
  return object2 == null ? [] : baseFunctions_default(object2, keys_default(object2));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object2) {
  return object2 == null ? [] : baseFunctions_default(object2, keysIn_default(object2));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty19 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value2, key2) {
  if (hasOwnProperty19.call(result2, key2)) {
    result2[key2].push(value2);
  } else {
    baseAssignValue_default(result2, key2, [value2]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value2, other) {
  return value2 > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value2, other) {
    if (!(typeof value2 == "string" && typeof other == "string")) {
      value2 = toNumber_default(value2);
      other = toNumber_default(other);
    }
    return operator(value2, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value2, other) {
  return value2 >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty20 = objectProto23.hasOwnProperty;
function baseHas(object2, key2) {
  return object2 != null && hasOwnProperty20.call(object2, key2);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object2, path3) {
  return object2 != null && hasPath_default(object2, path3, baseHas_default);
}
var has_default = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number4, start, end) {
  return number4 >= nativeMin6(start, end) && number4 < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number4, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number4 = toNumber_default(number4);
  return baseInRange_default(number4, start, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value2) {
  return typeof value2 == "string" || !isArray_default(value2) && isObjectLike_default(value2) && baseGetTag_default(value2) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object2, props) {
  return arrayMap_default(props, function(key2) {
    return object2[key2];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object2) {
  return object2 == null ? [] : baseValues_default(object2, keys_default(object2));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value2, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value2, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array3, value2, fromIndex) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return -1;
  }
  var index4 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index4 < 0) {
    index4 = nativeMax11(length + index4, 0);
  }
  return baseIndexOf_default(array3, value2, index4);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial(array3) {
  var length = array3 == null ? 0 : array3.length;
  return length ? baseSlice_default(array3, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array3 = arrays[othIndex];
    if (othIndex && iteratee2) {
      array3 = arrayMap_default(array3, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array3.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array3.length >= 120) ? new SetCache_default(othIndex && array3) : void 0;
  }
  array3 = arrays[0];
  var index4 = -1, seen = caches[0];
  outer:
    while (++index4 < length && result2.length < maxLength) {
      var value2 = array3[index4], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value2) {
  return isArrayLikeObject_default(value2) ? value2 : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection2 = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection2;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object2, setter, iteratee2, accumulator) {
  baseForOwn_default(object2, function(value2, key2, object3) {
    setter(accumulator, iteratee2(value2), key2, object3);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object2, iteratee2) {
    return baseInverter_default(object2, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value2, key2) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString3.call(value2);
  }
  result2[value2] = key2;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty21 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value2, key2) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString4.call(value2);
  }
  if (hasOwnProperty21.call(result2, value2)) {
    result2[value2].push(key2);
  } else {
    result2[value2] = [key2];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object2, path3) {
  return path3.length < 2 ? object2 : baseGet_default(object2, baseSlice_default(path3, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object2, path3, args) {
  path3 = castPath_default(path3, object2);
  object2 = parent_default(object2, path3);
  var func = object2 == null ? object2 : object2[toKey_default(last_default(path3))];
  return func == null ? void 0 : apply_default(func, object2, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path3, args) {
  var index4 = -1, isFunc = typeof path3 == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2) {
    result2[++index4] = isFunc ? apply_default(path3, value2, args) : baseInvoke_default(value2, path3, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value2) {
  return value2 === true || value2 === false || isObjectLike_default(value2) && baseGetTag_default(value2) == boolTag5;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement(value2) {
  return isObjectLike_default(value2) && value2.nodeType === 1 && !isPlainObject_default(value2);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty22 = objectProto26.hasOwnProperty;
function isEmpty(value2) {
  if (value2 == null) {
    return true;
  }
  if (isArrayLike_default(value2) && (isArray_default(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer_default(value2) || isTypedArray_default(value2) || isArguments_default(value2))) {
    return !value2.length;
  }
  var tag2 = getTag_default(value2);
  if (tag2 == mapTag8 || tag2 == setTag8) {
    return !value2.size;
  }
  if (isPrototype_default(value2)) {
    return !baseKeys_default(value2).length;
  }
  for (var key2 in value2) {
    if (hasOwnProperty22.call(value2, key2)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/isEqual.js
function isEqual(value2, other) {
  return baseIsEqual_default(value2, other);
}
var isEqual_default = isEqual;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value2, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value2, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value2, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite2(value2) {
  return typeof value2 == "number" && nativeIsFinite2(value2);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger(value2) {
  return typeof value2 == "number" && value2 == toInteger_default(value2);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object2, source) {
  return object2 === source || baseIsMatch_default(object2, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object2, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object2, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value2) {
  return typeof value2 == "number" || isObjectLike_default(value2) && baseGetTag_default(value2) == numberTag5;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value2) {
  return isNumber_default(value2) && value2 != +value2;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value2) {
  if (isMaskable_default(value2)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value2);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value2) {
  return value2 == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value2) {
  return value2 === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value2) {
  return isInteger_default(value2) && value2 >= -MAX_SAFE_INTEGER3 && value2 <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value2) {
  return value2 === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array3, separator) {
  return array3 == null ? "" : nativeJoin.call(array3, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index4) {
  return result2 + (index4 ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value2, key2) {
  baseAssignValue_default(result2, key2, value2);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array3, value2, fromIndex) {
  var index4 = fromIndex + 1;
  while (index4--) {
    if (array3[index4] === value2) {
      return index4;
    }
  }
  return index4;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array3, value2, fromIndex) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return -1;
  }
  var index4 = length;
  if (fromIndex !== void 0) {
    index4 = toInteger_default(fromIndex);
    index4 = index4 < 0 ? nativeMax12(length + index4, 0) : nativeMin8(index4, length - 1);
  }
  return value2 === value2 ? strictLastIndexOf_default(array3, value2, index4) : baseFindIndex_default(array3, baseIsNaN_default, index4, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index4) {
  return result2 + (index4 ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value2, other) {
  return value2 < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value2, other) {
  return value2 <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object2, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object2, function(value2, key2, object3) {
    baseAssignValue_default(result2, iteratee2(value2, key2, object3), value2);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object2, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object2, function(value2, key2, object3) {
    baseAssignValue_default(result2, key2, iteratee2(value2, key2, object3));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path3, srcValue) {
  return baseMatchesProperty_default(path3, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array3, iteratee2, comparator) {
  var index4 = -1, length = array3.length;
  while (++index4 < length) {
    var value2 = array3[index4], current = iteratee2(value2);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value2;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max2(array3) {
  return array3 && array3.length ? baseExtremum_default(array3, identity_default, baseGt_default) : void 0;
}
var max_default = max2;

// node_modules/lodash-es/maxBy.js
function maxBy(array3, iteratee2) {
  return array3 && array3.length ? baseExtremum_default(array3, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array3, iteratee2) {
  var result2, index4 = -1, length = array3.length;
  while (++index4 < length) {
    var current = iteratee2(array3[index4]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array3, iteratee2) {
  var length = array3 == null ? 0 : array3.length;
  return length ? baseSum_default(array3, iteratee2) / length : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean2(array3) {
  return baseMean_default(array3, identity_default);
}
var mean_default = mean2;

// node_modules/lodash-es/meanBy.js
function meanBy(array3, iteratee2) {
  return baseMean_default(array3, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge2 = createAssigner_default(function(object2, source, srcIndex) {
  baseMerge_default(object2, source, srcIndex);
});
var merge_default = merge2;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path3, args) {
  return function(object2) {
    return baseInvoke_default(object2, path3, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object2, args) {
  return function(path3) {
    return baseInvoke_default(object2, path3, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min2(array3) {
  return array3 && array3.length ? baseExtremum_default(array3, identity_default, baseLt_default) : void 0;
}
var min_default = min2;

// node_modules/lodash-es/minBy.js
function minBy(array3, iteratee2) {
  return array3 && array3.length ? baseExtremum_default(array3, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object2, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object2);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object2[methodName] = func;
    if (isFunc) {
      object2.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object2 });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object2, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object2;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value2) {
  if (!value2) {
    return [];
  }
  if (isArrayLike_default(value2)) {
    return isString_default(value2) ? stringToArray_default(value2) : copyArray_default(value2);
  }
  if (symIterator && value2[symIterator]) {
    return iteratorToArray_default(value2[symIterator]());
  }
  var tag2 = getTag_default(value2), func = tag2 == mapTag9 ? mapToArray_default : tag2 == setTag9 ? setToArray_default : values_default;
  return func(value2);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value2 = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value2 };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array3, n) {
  var length = array3.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex_default(n, length) ? array3[n] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array3, n) {
  return array3 && array3.length ? baseNth_default(array3, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object2, path3) {
  path3 = castPath_default(path3, object2);
  object2 = parent_default(object2, path3);
  return object2 == null || delete object2[toKey_default(last_default(path3))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value2) {
  return isPlainObject_default(value2) ? void 0 : value2;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object2, paths) {
  var result2 = {};
  if (object2 == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path3) {
    path3 = castPath_default(path3, object2);
    isDeep || (isDeep = path3.length > 1);
    return path3;
  });
  copyObject_default(object2, getAllKeysIn_default(object2), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length = paths.length;
  while (length--) {
    baseUnset_default(result2, paths[length]);
  }
  return result2;
});
var omit_default = omit;

// node_modules/lodash-es/_baseSet.js
function baseSet(object2, path3, value2, customizer) {
  if (!isObject_default(object2)) {
    return object2;
  }
  path3 = castPath_default(path3, object2);
  var index4 = -1, length = path3.length, lastIndex = length - 1, nested = object2;
  while (nested != null && ++index4 < length) {
    var key2 = toKey_default(path3[index4]), newValue = value2;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object2;
    }
    if (index4 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path3[index4 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key2, newValue);
    nested = nested[key2];
  }
  return object2;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object2, paths, predicate) {
  var index4 = -1, length = paths.length, result2 = {};
  while (++index4 < length) {
    var path3 = paths[index4], value2 = baseGet_default(object2, path3);
    if (predicate(value2, path3)) {
      baseSet_default(result2, castPath_default(path3, object2), value2);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object2, predicate) {
  if (object2 == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object2), function(prop2) {
    return [prop2];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object2, props, function(value2, path3) {
    return predicate(value2, path3[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object2, predicate) {
  return pickBy_default(object2, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array3, comparer) {
  var length = array3.length;
  array3.sort(comparer);
  while (length--) {
    array3[length] = array3[length].value;
  }
  return array3;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value2, other) {
  if (value2 !== other) {
    var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol_default(value2);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object2, other, orders) {
  var index4 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index4 < length) {
    var result2 = compareAscending_default(objCriteria[index4], othCriteria[index4]);
    if (result2) {
      if (index4 >= ordersLength) {
        return result2;
      }
      var order = orders[index4];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object2.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value2) {
          return baseGet_default(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index4 = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value2, key2, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value2);
    });
    return { "criteria": criteria, "index": ++index4, "value": value2 };
  });
  return baseSortBy_default(result2, function(object2, other) {
    return compareMultiple_default(object2, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index4 = -1, length = nativeMin9(args.length, funcsLength);
    while (++index4 < length) {
      args[index4] = transforms[index4].call(this, args[index4]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length).join("") : result2.slice(0, length);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad;

// node_modules/lodash-es/padEnd.js
function padEnd(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? string + createPadding_default(length - strLength, chars) : string;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value2, key2) {
  result2[key2 ? 0 : 1].push(value2);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object2, paths) {
  return basePickBy_default(object2, paths, function(value2, path3) {
    return hasIn_default(object2, path3);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object2, paths) {
  return object2 == null ? {} : basePick_default(object2, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value2) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value2;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object2) {
  return function(path3) {
    return object2 == null ? void 0 : baseGet_default(object2, path3);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array3, value2, fromIndex, comparator) {
  var index4 = fromIndex - 1, length = array3.length;
  while (++index4 < length) {
    if (comparator(array3[index4], value2)) {
      return index4;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array3, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index4 = -1, length = values2.length, seen = array3;
  if (array3 === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array3, baseUnary_default(iteratee2));
  }
  while (++index4 < length) {
    var fromIndex = 0, value2 = values2[index4], computed = iteratee2 ? iteratee2(value2) : value2;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array3) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array3, fromIndex, 1);
    }
  }
  return array3;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array3, values2) {
  return array3 && array3.length && values2 && values2.length ? basePullAll_default(array3, values2) : array3;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array3, values2, iteratee2) {
  return array3 && array3.length && values2 && values2.length ? basePullAll_default(array3, values2, baseIteratee_default(iteratee2, 2)) : array3;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array3, values2, comparator) {
  return array3 && array3.length && values2 && values2.length ? basePullAll_default(array3, values2, void 0, comparator) : array3;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array3, indexes3) {
  var length = array3 ? indexes3.length : 0, lastIndex = length - 1;
  while (length--) {
    var index4 = indexes3[length];
    if (length == lastIndex || index4 !== previous) {
      var previous = index4;
      if (isIndex_default(index4)) {
        splice3.call(array3, index4, 1);
      } else {
        baseUnset_default(array3, index4);
      }
    }
  }
  return array3;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array3, indexes3) {
  var length = array3 == null ? 0 : array3.length, result2 = baseAt_default(array3, indexes3);
  basePullAt_default(array3, arrayMap_default(indexes3, function(index4) {
    return isIndex_default(index4, length) ? +index4 : index4;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index4 = -1, length = nativeMax13(nativeCeil4((end - start) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index4] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range2 = createRange_default();
var range_default = range2;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes3) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes3);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value2, index4, collection2) {
    accumulator = initAccum ? (initAccum = false, value2) : iteratee2(accumulator, value2, index4, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce2(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce2;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array3, iteratee2, accumulator, initAccum) {
  var length = array3 == null ? 0 : array3.length;
  if (initAccum && length) {
    accumulator = array3[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array3[length], length, array3);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove(array3, predicate) {
  var result2 = [];
  if (!(array3 && array3.length)) {
    return result2;
  }
  var index4 = -1, indexes3 = [], length = array3.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index4 < length) {
    var value2 = array3[index4];
    if (predicate(value2, index4, array3)) {
      result2.push(value2);
      indexes3.push(index4);
    }
  }
  basePullAt_default(array3, indexes3);
  return result2;
}
var remove_default = remove;

// node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object2, path3, defaultValue) {
  path3 = castPath_default(path3, object2);
  var index4 = -1, length = path3.length;
  if (!length) {
    length = 1;
    object2 = void 0;
  }
  while (++index4 < length) {
    var value2 = object2 == null ? void 0 : object2[toKey_default(path3[index4])];
    if (value2 === void 0) {
      index4 = length;
      value2 = defaultValue;
    }
    object2 = isFunction_default(value2) ? value2.call(object2) : value2;
  }
  return object2;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse2(array3) {
  return array3 == null ? array3 : nativeReverse.call(array3);
}
var reverse_default = reverse2;

// node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// node_modules/lodash-es/_arraySample.js
function arraySample(array3) {
  var length = array3.length;
  return length ? array3[baseRandom_default(0, length - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array3, size2) {
  var index4 = -1, length = array3.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index4 < size2) {
    var rand = baseRandom_default(index4, lastIndex), value2 = array3[rand];
    array3[rand] = array3[index4];
    array3[index4] = value2;
  }
  array3.length = size2;
  return array3;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array3, n) {
  return shuffleSelf_default(copyArray_default(array3), baseClamp_default(n, 0, array3.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array3 = values_default(collection);
  return shuffleSelf_default(array3, baseClamp_default(n, 0, array3.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set2(object2, path3, value2) {
  return object2 == null ? object2 : baseSet_default(object2, path3, value2);
}
var set_default = set2;

// node_modules/lodash-es/setWith.js
function setWith(object2, path3, value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object2 == null ? object2 : baseSet_default(object2, path3, value2, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array3) {
  return shuffleSelf_default(copyArray_default(array3));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default2 = shuffle;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag2 = getTag_default(collection);
  if (tag2 == mapTag10 || tag2 == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// node_modules/lodash-es/slice.js
function slice2(array3, start, end) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array3, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length : toInteger_default(end);
  }
  return baseSlice_default(array3, start, end);
}
var slice_default = slice2;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index4) {
  return result2 + (index4 ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value2, index4, collection2) {
    result2 = predicate(value2, index4, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some2(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some2;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array3, value2, iteratee2, retHighest) {
  var low = 0, high = array3 == null ? 0 : array3.length;
  if (high === 0) {
    return 0;
  }
  value2 = iteratee2(value2);
  var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol_default(value2), valIsUndefined = value2 === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array3[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value2 : computed < value2;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array3, value2, retHighest) {
  var low = 0, high = array3 == null ? low : array3.length;
  if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array3[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value2 : computed < value2)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array3, value2, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array3, value2) {
  return baseSortedIndex_default(array3, value2);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array3, value2, iteratee2) {
  return baseSortedIndexBy_default(array3, value2, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array3, value2) {
  var length = array3 == null ? 0 : array3.length;
  if (length) {
    var index4 = baseSortedIndex_default(array3, value2);
    if (index4 < length && eq_default(array3[index4], value2)) {
      return index4;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array3, value2) {
  return baseSortedIndex_default(array3, value2, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array3, value2, iteratee2) {
  return baseSortedIndexBy_default(array3, value2, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array3, value2) {
  var length = array3 == null ? 0 : array3.length;
  if (length) {
    var index4 = baseSortedIndex_default(array3, value2, true) - 1;
    if (eq_default(array3[index4], value2)) {
      return index4;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array3, iteratee2) {
  var index4 = -1, length = array3.length, resIndex = 0, result2 = [];
  while (++index4 < length) {
    var value2 = array3[index4], computed = iteratee2 ? iteratee2(value2) : value2;
    if (!index4 || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value2 === 0 ? 0 : value2;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array3) {
  return array3 && array3.length ? baseSortedUniq_default(array3) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array3, iteratee2) {
  return array3 && array3.length ? baseSortedUniq_default(array3, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array3 = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array3) {
      arrayPush_default(otherArgs, array3);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index4) {
  return result2 + (index4 ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum2(array3) {
  return array3 && array3.length ? baseSum_default(array3, identity_default) : 0;
}
var sum_default = sum2;

// node_modules/lodash-es/sumBy.js
function sumBy(array3, iteratee2) {
  return array3 && array3.length ? baseSum_default(array3, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array3) {
  var length = array3 == null ? 0 : array3.length;
  return length ? baseSlice_default(array3, 1, length) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array3, n, guard) {
  if (!(array3 && array3.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array3, 0, n < 0 ? 0 : n);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array3, n, guard) {
  var length = array3 == null ? 0 : array3.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array3, n < 0 ? 0 : n, length);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array3, predicate) {
  return array3 && array3.length ? baseWhile_default(array3, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array3, predicate) {
  return array3 && array3.length ? baseWhile_default(array3, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value2, interceptor) {
  interceptor(value2);
  return value2;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto27 = Object.prototype;
var hasOwnProperty23 = objectProto27.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key2, object2) {
  if (objValue === void 0 || eq_default(objValue, objectProto27[key2]) && !hasOwnProperty23.call(object2, key2)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto28 = Object.prototype;
var hasOwnProperty24 = objectProto28.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index4 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty24.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index4, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index4 = offset + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty24.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/thru.js
function thru(value2, interceptor) {
  return interceptor(value2);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index4 = MAX_ARRAY_LENGTH6, length = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length, iteratee2);
  while (++index4 < n) {
    iteratee2(index4);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value2, actions) {
  var result2 = value2;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value2) {
  return toString_default(value2).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value2) {
  if (isArray_default(value2)) {
    return arrayMap_default(value2, toKey_default);
  }
  return isSymbol_default(value2) ? [value2] : copyArray_default(stringToPath_default(toString_default(value2)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value2 === 0 ? value2 : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value2) {
  return toString_default(value2).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform(object2, iteratee2, accumulator) {
  var isArr = isArray_default(object2), isArrLike = isArr || isBuffer_default(object2) || isTypedArray_default(object2);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object2 && object2.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object2)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object2)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object2, function(value2, index4, object3) {
    return iteratee2(accumulator, value2, index4, object3);
  });
  return accumulator;
}
var transform_default = transform;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index4 = strSymbols.length;
  while (index4-- && baseIndexOf_default(chrSymbols, strSymbols[index4], 0) > -1) {
  }
  return index4;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index4 = -1, length = strSymbols.length;
  while (++index4 < length && baseIndexOf_default(chrSymbols, strSymbols[index4], 0) > -1) {
  }
  return index4;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length = "length" in options ? toInteger_default(options.length) : length;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index4 = result2.lastIndexOf(separator);
    if (index4 > -1) {
      result2 = result2.slice(0, index4);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array3, iteratee2, comparator) {
  var index4 = -1, includes2 = arrayIncludes_default, length = array3.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set5 = iteratee2 ? null : createSet_default(array3);
    if (set5) {
      return setToArray_default(set5);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index4 < length) {
      var value2 = array3[index4], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value2);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union2 = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union2;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq(array3) {
  return array3 && array3.length ? baseUniq_default(array3) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array3, iteratee2) {
  return array3 && array3.length ? baseUniq_default(array3, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array3, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array3 && array3.length ? baseUniq_default(array3, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object2, path3) {
  return object2 == null ? true : baseUnset_default(object2, path3);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array3) {
  if (!(array3 && array3.length)) {
    return [];
  }
  var length = 0;
  array3 = arrayFilter_default(array3, function(group3) {
    if (isArrayLikeObject_default(group3)) {
      length = nativeMax15(group3.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index4) {
    return arrayMap_default(array3, baseProperty_default(index4));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array3, iteratee2) {
  if (!(array3 && array3.length)) {
    return [];
  }
  var result2 = unzip_default(array3);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group3) {
    return apply_default(iteratee2, void 0, group3);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object2, path3, updater, customizer) {
  return baseSet_default(object2, path3, updater(baseGet_default(object2, path3)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update(object2, path3, updater) {
  return object2 == null ? object2 : baseUpdate_default(object2, path3, castFunction_default(updater));
}
var update_default = update;

// node_modules/lodash-es/updateWith.js
function updateWith(object2, path3, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object2 == null ? object2 : baseUpdate_default(object2, path3, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index4) {
  return result2 + (index4 ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object2) {
  return object2 == null ? [] : baseValues_default(object2, keysIn_default(object2));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array3, values2) {
  return isArrayLikeObject_default(array3) ? baseDifference_default(array3, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value2, wrapper) {
  return partial_default(castFunction_default(wrapper), value2);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length = paths.length, start = length ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object2) {
    return baseAt_default(object2, paths);
  };
  if (length > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value2 = value2.slice(start, +start + (length ? 1 : 0));
  value2.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value2, this.__chain__).thru(function(array3) {
    if (length && !array3.length) {
      array3.push(void 0);
    }
    return array3;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value2 = this.__wrapped__;
  if (value2 instanceof LazyWrapper_default) {
    var wrapped = value2;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq_default(arrays[0]) : [];
  }
  var index4 = -1, result2 = Array(length);
  while (++index4 < length) {
    var array3 = arrays[index4], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index4) {
        result2[index4] = baseDifference_default(result2[index4] || array3, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip2 = baseRest_default(unzip_default);
var zip_default = zip2;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index4 = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index4 < length) {
    var value2 = index4 < valsLength ? values2[index4] : void 0;
    assignFunc(result2, props[index4], value2);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default2,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index4 = -1, length = transforms.length;
  while (++index4 < length) {
    var data = transforms[index4], size2 = data.size;
    switch (data.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size2);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array3 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array3), isRight = dir < 0, arrLength = isArr ? array3.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index4 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue_default(array3, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length-- && resIndex < takeCount) {
      index4 += dir;
      var iterIndex = -1, value2 = array3[index4];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value2);
        if (type == LAZY_MAP_FLAG) {
          value2 = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value2;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto29 = Object.prototype;
var hasOwnProperty25 = objectProto29.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ function(func) {
  return function(object2, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object2;
        object2 = this;
      }
    }
    return func(object2, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty25.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index4) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index4 ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index4) {
  var type = index4 + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index4) {
  var takeName = "take" + (index4 ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index4) {
  var dropName = "drop" + (index4 ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path3, args) {
  if (typeof path3 == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value2) {
    return baseInvoke_default(value2, path3, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value2);
    var interceptor = function(value3) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value3], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value2 = onlyLazy ? value2 : new LazyWrapper_default(this);
      var result2 = func.apply(value2, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value2 = this.value();
      return func.apply(isArray_default(value2) ? value2 : [], args);
    }
    return this[chainName](function(value3) {
      return func.apply(isArray_default(value3) ? value3 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key2 = lodashFunc.name + "";
    if (!hasOwnProperty25.call(realNames_default, key2)) {
      realNames_default[key2] = [];
    }
    realNames_default[key2].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/@layerstack/utils/dist/typeHelpers.js
function keys2(o) {
  return Object.keys(o);
}
function entries(o) {
  if (o instanceof Map)
    return Array.from(o.entries());
  return Object.entries(o);
}
function fromEntries(entries2) {
  return Object.fromEntries(entries2);
}

// node_modules/@layerstack/utils/dist/string.js
var uppercaseChars = "[A-ZÀ-ÜÙ-Ý]";
var capitalsRegEx = new RegExp(uppercaseChars, "g");
var allCapitalsRegEx = new RegExp(`^${uppercaseChars}+$`);

// node_modules/@layerstack/utils/dist/object.js
function isLiteralObject(obj) {
  return obj && typeof obj === "object" && obj.constructor === Object;
}
function propAccessor(prop2) {
  return typeof prop2 === "function" ? prop2 : typeof prop2 === "string" ? (d) => get_default(d, prop2) : (x4) => x4;
}
var objIdMap = /* @__PURE__ */ new WeakMap();
var objectCount = 0;
function objectId(object2) {
  if (!objIdMap.has(object2))
    objIdMap.set(object2, ++objectCount);
  return objIdMap.get(object2);
}
function omitNil(obj) {
  if (keys2.length === 0) {
    return obj;
  } else {
    return fromEntries(entries(obj).filter(([key2, value2]) => value2 != null));
  }
}

// node_modules/@layerstack/utils/dist/array.js
function unique2(values2) {
  return Array.from(new Set(values2));
}
function greatestAbs(array3) {
  return greatest(array3, (a5, b) => Math.abs(a5) - Math.abs(b));
}

// node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count4, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start, stop2, step) => {
    const range4 = [];
    start = interval2.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0)) return range4;
    let previous;
    do
      range4.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range4;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count4) {
    interval2.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count4(t0, t1));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k3) => {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0)) return null;
  if (!(k3 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k3) * k3);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k3);
  }, (start, end) => {
    return (end - start) / k3;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k3);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k3);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop2, count4) {
    const reverse4 = stop2 < start;
    if (reverse4) [start, stop2] = [stop2, start];
    const interval2 = count4 && typeof count4.range === "function" ? count4 : tickInterval(start, stop2, count4);
    const ticks3 = interval2 ? interval2.range(start, +stop2 + 1) : [];
    return reverse4 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop2, count4) {
    const target = Math.abs(stop2 - start) / count4;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop2 / durationYear, count4));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop2, count4), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y4, m3, d) {
  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c3, pad4, format3;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad4 = pads[c3 = specifier.charAt(++i)]) != null) c3 = specifier.charAt(++i);
          else pad4 = c3 === "e" ? " " : "0";
          if (format3 = formats2[c3]) c3 = format3(date2, pad4);
          string.push(c3);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m3 = string.length, c3, parse2;
    while (i < n) {
      if (j >= m3) return -1;
      c3 = specifier.charCodeAt(i++);
      if (c3 === 37) {
        c3 = specifier.charAt(i++);
        parse2 = parses[c3 in pads ? specifier.charAt(i++) : c3];
        if (!parse2 || (j = parse2(d, string, j)) < 0) return -1;
      } else if (c3 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value2, fill2, width) {
  var sign5 = value2 < 0 ? "-" : "", string = (sign5 ? -value2 : value2) + "", length = string.length;
  return sign5 + (length < width ? new Array(width - length + 1).join(fill2) + string : string);
}
function requote(s3) {
  return s3.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/@layerstack/utils/dist/typeGuards.js
function notNull(value2) {
  return value2 != null;
}
function isSVGElement(elem) {
  return !!elem && (elem instanceof SVGElement || "ownerSVGElement" in elem);
}
function isSVGSVGElement(elem) {
  return !!elem && "createSVGPoint" in elem;
}
function isSVGGraphicsElement(elem) {
  return !!elem && "getScreenCTM" in elem;
}
function isTouchEvent(event2) {
  return !!event2 && "changedTouches" in event2;
}

// node_modules/@layerstack/utils/dist/date_types.js
var PeriodType;
(function(PeriodType2) {
  PeriodType2[PeriodType2["Custom"] = 1] = "Custom";
  PeriodType2[PeriodType2["Day"] = 10] = "Day";
  PeriodType2[PeriodType2["DayTime"] = 11] = "DayTime";
  PeriodType2[PeriodType2["TimeOnly"] = 15] = "TimeOnly";
  PeriodType2[PeriodType2["Week"] = 20] = "Week";
  PeriodType2[PeriodType2["WeekSun"] = 21] = "WeekSun";
  PeriodType2[PeriodType2["WeekMon"] = 22] = "WeekMon";
  PeriodType2[PeriodType2["WeekTue"] = 23] = "WeekTue";
  PeriodType2[PeriodType2["WeekWed"] = 24] = "WeekWed";
  PeriodType2[PeriodType2["WeekThu"] = 25] = "WeekThu";
  PeriodType2[PeriodType2["WeekFri"] = 26] = "WeekFri";
  PeriodType2[PeriodType2["WeekSat"] = 27] = "WeekSat";
  PeriodType2[PeriodType2["Month"] = 30] = "Month";
  PeriodType2[PeriodType2["MonthYear"] = 31] = "MonthYear";
  PeriodType2[PeriodType2["Quarter"] = 40] = "Quarter";
  PeriodType2[PeriodType2["CalendarYear"] = 50] = "CalendarYear";
  PeriodType2[PeriodType2["FiscalYearOctober"] = 60] = "FiscalYearOctober";
  PeriodType2[PeriodType2["BiWeek1"] = 70] = "BiWeek1";
  PeriodType2[PeriodType2["BiWeek1Sun"] = 71] = "BiWeek1Sun";
  PeriodType2[PeriodType2["BiWeek1Mon"] = 72] = "BiWeek1Mon";
  PeriodType2[PeriodType2["BiWeek1Tue"] = 73] = "BiWeek1Tue";
  PeriodType2[PeriodType2["BiWeek1Wed"] = 74] = "BiWeek1Wed";
  PeriodType2[PeriodType2["BiWeek1Thu"] = 75] = "BiWeek1Thu";
  PeriodType2[PeriodType2["BiWeek1Fri"] = 76] = "BiWeek1Fri";
  PeriodType2[PeriodType2["BiWeek1Sat"] = 77] = "BiWeek1Sat";
  PeriodType2[PeriodType2["BiWeek2"] = 80] = "BiWeek2";
  PeriodType2[PeriodType2["BiWeek2Sun"] = 81] = "BiWeek2Sun";
  PeriodType2[PeriodType2["BiWeek2Mon"] = 82] = "BiWeek2Mon";
  PeriodType2[PeriodType2["BiWeek2Tue"] = 83] = "BiWeek2Tue";
  PeriodType2[PeriodType2["BiWeek2Wed"] = 84] = "BiWeek2Wed";
  PeriodType2[PeriodType2["BiWeek2Thu"] = 85] = "BiWeek2Thu";
  PeriodType2[PeriodType2["BiWeek2Fri"] = 86] = "BiWeek2Fri";
  PeriodType2[PeriodType2["BiWeek2Sat"] = 87] = "BiWeek2Sat";
})(PeriodType || (PeriodType = {}));
var periodTypeMappings = {
  [PeriodType.Custom]: "custom",
  [PeriodType.Day]: "day",
  [PeriodType.DayTime]: "daytime",
  [PeriodType.TimeOnly]: "time",
  [PeriodType.WeekSun]: "week-sun",
  [PeriodType.WeekMon]: "week-mon",
  [PeriodType.WeekTue]: "week-tue",
  [PeriodType.WeekWed]: "week-wed",
  [PeriodType.WeekThu]: "week-thu",
  [PeriodType.WeekFri]: "week-fri",
  [PeriodType.WeekSat]: "week-sat",
  [PeriodType.Week]: "week",
  [PeriodType.Month]: "month",
  [PeriodType.MonthYear]: "month-year",
  [PeriodType.Quarter]: "quarter",
  [PeriodType.CalendarYear]: "year",
  [PeriodType.FiscalYearOctober]: "fiscal-year-october",
  [PeriodType.BiWeek1Sun]: "biweek1-sun",
  [PeriodType.BiWeek1Mon]: "biweek1-mon",
  [PeriodType.BiWeek1Tue]: "biweek1-tue",
  [PeriodType.BiWeek1Wed]: "biweek1-wed",
  [PeriodType.BiWeek1Thu]: "biweek1-thu",
  [PeriodType.BiWeek1Fri]: "biweek1-fri",
  [PeriodType.BiWeek1Sat]: "biweek1-sat",
  [PeriodType.BiWeek1]: "biweek1",
  [PeriodType.BiWeek2Sun]: "biweek2-sun",
  [PeriodType.BiWeek2Mon]: "biweek2-mon",
  [PeriodType.BiWeek2Tue]: "biweek2-tue",
  [PeriodType.BiWeek2Wed]: "biweek2-wed",
  [PeriodType.BiWeek2Thu]: "biweek2-thu",
  [PeriodType.BiWeek2Fri]: "biweek2-fri",
  [PeriodType.BiWeek2Sat]: "biweek2-sat",
  [PeriodType.BiWeek2]: "biweek2"
};
var DayOfWeek;
(function(DayOfWeek2) {
  DayOfWeek2[DayOfWeek2["Sunday"] = 0] = "Sunday";
  DayOfWeek2[DayOfWeek2["Monday"] = 1] = "Monday";
  DayOfWeek2[DayOfWeek2["Tuesday"] = 2] = "Tuesday";
  DayOfWeek2[DayOfWeek2["Wednesday"] = 3] = "Wednesday";
  DayOfWeek2[DayOfWeek2["Thursday"] = 4] = "Thursday";
  DayOfWeek2[DayOfWeek2["Friday"] = 5] = "Friday";
  DayOfWeek2[DayOfWeek2["Saturday"] = 6] = "Saturday";
})(DayOfWeek || (DayOfWeek = {}));
var DateToken;
(function(DateToken2) {
  DateToken2["Year_numeric"] = "yyy";
  DateToken2["Year_2Digit"] = "yy";
  DateToken2["Month_long"] = "MMMM";
  DateToken2["Month_short"] = "MMM";
  DateToken2["Month_2Digit"] = "MM";
  DateToken2["Month_numeric"] = "M";
  DateToken2["Hour_numeric"] = "h";
  DateToken2["Hour_2Digit"] = "hh";
  DateToken2["Hour_wAMPM"] = "a";
  DateToken2["Hour_woAMPM"] = "aaaaaa";
  DateToken2["Minute_numeric"] = "m";
  DateToken2["Minute_2Digit"] = "mm";
  DateToken2["Second_numeric"] = "s";
  DateToken2["Second_2Digit"] = "ss";
  DateToken2["MiliSecond_3"] = "SSS";
  DateToken2["DayOfMonth_numeric"] = "d";
  DateToken2["DayOfMonth_2Digit"] = "dd";
  DateToken2["DayOfMonth_withOrdinal"] = "do";
  DateToken2["DayOfWeek_narrow"] = "eeeee";
  DateToken2["DayOfWeek_long"] = "eeee";
  DateToken2["DayOfWeek_short"] = "eee";
})(DateToken || (DateToken = {}));

// node_modules/@layerstack/utils/dist/dateInternal.js
function getWeekStartsOnFromIntl(locales) {
  if (!locales) {
    return DayOfWeek.Sunday;
  }
  const locale3 = new Intl.Locale(locales);
  const weekInfo = locale3.weekInfo ?? locale3.getWeekInfo?.();
  return (weekInfo?.firstDay ?? 0) % 7;
}
var unicodeToStrftime = {
  // ===== YEAR =====
  y: "%y",
  // 2-digit year (00-99)
  yy: "%y",
  // 2-digit year with leading zero
  yyyy: "%Y",
  // 4-digit year
  Y: "%Y",
  // 4-digit year (short form)
  // ===== MONTH =====
  M: "%m",
  // Month as number (1-12, but strftime uses 01-12)
  MM: "%m",
  // Month as 2-digit number (01-12)
  MMM: "%b",
  // Abbreviated month name (Jan, Feb, etc.)
  MMMM: "%B",
  // Full month name (January, February, etc.)
  L: "%m",
  // Standalone month number (same as M in most cases)
  LL: "%m",
  // Standalone month number, 2-digit
  LLL: "%b",
  // Standalone abbreviated month name
  LLLL: "%B",
  // Standalone full month name
  // ===== WEEK =====
  w: null,
  // ❌ Week of year (1-53) - no direct strftime equivalent
  ww: null,
  // ❌ Week of year, 2-digit - no direct strftime equivalent
  W: "%W",
  // Week of year (Monday as first day) - close match
  // ===== DAY =====
  d: "%d",
  // Day of month (1-31, but strftime uses 01-31)
  dd: "%d",
  // Day of month, 2-digit (01-31)
  D: "%j",
  // Day of year (1-366, but strftime uses 001-366)
  DD: "%j",
  // Day of year, 2-digit - strftime always uses 3 digits
  DDD: "%j",
  // Day of year, 3-digit (001-366)
  // ===== WEEKDAY =====
  E: "%a",
  // Abbreviated weekday name (Mon, Tue, etc.)
  EE: "%a",
  // Abbreviated weekday name
  EEE: "%a",
  // Abbreviated weekday name
  EEEE: "%A",
  // Full weekday name (Monday, Tuesday, etc.)
  EEEEE: null,
  // ❌ Narrow weekday name (M, T, W) - no strftime equivalent
  EEEEEE: null,
  // ❌ Short weekday name - no strftime equivalent
  e: "%u",
  // Local weekday number (1-7, Monday=1) - close match
  ee: "%u",
  // Local weekday number, 2-digit
  eee: "%a",
  // Local abbreviated weekday name
  eeee: "%A",
  // Local full weekday name
  c: "%u",
  // Standalone weekday number
  cc: "%u",
  // Standalone weekday number, 2-digit
  ccc: "%a",
  // Standalone abbreviated weekday name
  cccc: "%A",
  // Standalone full weekday name
  // ===== PERIOD (AM/PM) =====
  a: "%p",
  // AM/PM
  aa: "%p",
  // AM/PM
  aaa: "%p",
  // AM/PM
  aaaa: "%p",
  // AM/PM (long form, but strftime only has short)
  aaaaa: null,
  // ❌ Narrow AM/PM (A/P) - no strftime equivalent
  // ===== HOUR =====
  h: "%I",
  // Hour in 12-hour format (1-12)
  hh: "%I",
  // Hour in 12-hour format, 2-digit (01-12)
  H: "%H",
  // Hour in 24-hour format (0-23)
  HH: "%H",
  // Hour in 24-hour format, 2-digit (00-23)
  K: null,
  // ❌ Hour in 12-hour format (0-11) - no direct strftime equivalent
  KK: null,
  // ❌ Hour in 12-hour format, 2-digit (00-11) - no strftime equivalent
  k: null,
  // ❌ Hour in 24-hour format (1-24) - no direct strftime equivalent
  kk: null,
  // ❌ Hour in 24-hour format, 2-digit (01-24) - no strftime equivalent
  // ===== MINUTE =====
  m: "%M",
  // Minutes (0-59)
  mm: "%M",
  // Minutes, 2-digit (00-59)
  // ===== SECOND =====
  s: "%S",
  // Seconds (0-59)
  ss: "%S",
  // Seconds, 2-digit (00-59)
  S: null,
  // ❌ Fractional seconds (1 digit) - no direct strftime equivalent
  SS: null,
  // ❌ Fractional seconds (2 digits) - no direct strftime equivalent
  SSS: null,
  // ❌ Fractional seconds (3 digits) - no direct strftime equivalent
  A: null,
  // ❌ Milliseconds in day - no strftime equivalent
  // ===== TIMEZONE =====
  z: "%Z",
  // Timezone name (EST, PST, etc.)
  zz: "%Z",
  // Timezone name
  zzz: "%Z",
  // Timezone name
  zzzz: "%Z",
  // Full timezone name
  Z: "%z",
  // Timezone offset (+0000, -0500, etc.)
  ZZ: "%z",
  // Timezone offset
  ZZZ: "%z",
  // Timezone offset
  ZZZZ: null,
  // ❌ GMT-relative timezone - partial strftime support
  ZZZZZ: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  O: null,
  // ❌ Localized GMT offset - no strftime equivalent
  OOOO: null,
  // ❌ Full localized GMT offset - no strftime equivalent
  v: null,
  // ❌ Generic timezone - no strftime equivalent
  vvvv: null,
  // ❌ Generic timezone full - no strftime equivalent
  V: null,
  // ❌ Timezone ID - no strftime equivalent
  VV: null,
  // ❌ Timezone ID - no strftime equivalent
  VVV: null,
  // ❌ Timezone exemplar city - no strftime equivalent
  VVVV: null,
  // ❌ Generic location format - no strftime equivalent
  X: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  XX: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  XXX: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  XXXX: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  XXXXX: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  x: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  xx: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  xxx: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  xxxx: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  xxxxx: null,
  // ❌ ISO 8601 timezone - no direct strftime equivalent
  // ===== QUARTER =====
  Q: null,
  // ❌ Quarter (1-4) - no strftime equivalent
  QQ: null,
  // ❌ Quarter, 2-digit (01-04) - no strftime equivalent
  QQQ: null,
  // ❌ Abbreviated quarter (Q1, Q2, etc.) - no strftime equivalent
  QQQQ: null,
  // ❌ Full quarter (1st quarter, etc.) - no strftime equivalent
  QQQQQ: null,
  // ❌ Narrow quarter - no strftime equivalent
  q: null,
  // ❌ Standalone quarter - no strftime equivalent
  qq: null,
  // ❌ Standalone quarter, 2-digit - no strftime equivalent
  qqq: null,
  // ❌ Standalone abbreviated quarter - no strftime equivalent
  qqqq: null,
  // ❌ Standalone full quarter - no strftime equivalent
  qqqqq: null,
  // ❌ Standalone narrow quarter - no strftime equivalent
  // ===== ERA =====
  G: null,
  // ❌ Era designator (AD, BC) - no strftime equivalent
  GG: null,
  // ❌ Era designator - no strftime equivalent
  GGG: null,
  // ❌ Era designator - no strftime equivalent
  GGGG: null,
  // ❌ Era designator full - no strftime equivalent
  GGGGG: null
  // ❌ Era designator narrow - no strftime equivalent
};
function convertUnicodeToStrftime(unicodeFormat) {
  let result2 = "";
  let i = 0;
  let unsupportedPatterns = [];
  while (i < unicodeFormat.length) {
    let matched = false;
    for (let len = Math.min(5, unicodeFormat.length - i); len >= 1; len--) {
      const pattern = unicodeFormat.substring(i, i + len);
      if (pattern in unicodeToStrftime) {
        const strftimeEquivalent = unicodeToStrftime[pattern];
        if (strftimeEquivalent === null) {
          unsupportedPatterns.push(pattern);
          result2 += pattern;
        } else {
          result2 += strftimeEquivalent;
        }
        i += len;
        matched = true;
        break;
      }
    }
    if (!matched) {
      result2 += unicodeFormat[i];
      i++;
    }
  }
  if (unsupportedPatterns.length > 0) {
    console.warn("Unsupported patterns:", [...new Set(unsupportedPatterns)]);
  }
  return result2;
}

// node_modules/@layerstack/utils/dist/locale.js
var defaultLocaleSettings = {
  locale: "en",
  dictionary: {
    Ok: "Ok",
    Cancel: "Cancel",
    Date: {
      Start: "Start",
      End: "End",
      Empty: "Empty",
      Day: "Day",
      DayTime: "Day Time",
      Time: "Time",
      Week: "Week",
      BiWeek: "Bi-Week",
      Month: "Month",
      Quarter: "Quarter",
      CalendarYear: "Calendar Year",
      FiscalYearOct: "Fiscal Year (Oct)",
      PeriodDay: {
        Current: "Today",
        Last: "Yesterday",
        LastX: "Last {0} days"
      },
      PeriodWeek: {
        Current: "This week",
        Last: "Last week",
        LastX: "Last {0} weeks"
      },
      PeriodBiWeek: {
        Current: "This bi-week",
        Last: "Last bi-week",
        LastX: "Last {0} bi-weeks"
      },
      PeriodMonth: {
        Current: "This month",
        Last: "Last month",
        LastX: "Last {0} months"
      },
      PeriodQuarter: {
        Current: "This quarter",
        Last: "Last quarter",
        LastX: "Last {0} quarters"
      },
      PeriodQuarterSameLastyear: "Same quarter last year",
      PeriodYear: {
        Current: "This year",
        Last: "Last year",
        LastX: "Last {0} years"
      },
      PeriodFiscalYear: {
        Current: "This fiscal year",
        Last: "Last fiscal year",
        LastX: "Last {0} fiscal years"
      }
    }
  },
  formats: {
    numbers: {
      defaults: {
        currency: "USD",
        fractionDigits: 2,
        currencyDisplay: "symbol"
      }
    },
    dates: {
      baseParsing: "MM/dd/yyyy",
      weekStartsOn: DayOfWeek.Sunday,
      ordinalSuffixes: {
        one: "st",
        two: "nd",
        few: "rd",
        other: "th"
      },
      presets: {
        day: {
          short: [DateToken.DayOfMonth_numeric, DateToken.Month_numeric],
          default: [DateToken.DayOfMonth_numeric, DateToken.Month_numeric, DateToken.Year_numeric],
          long: [DateToken.DayOfMonth_numeric, DateToken.Month_short, DateToken.Year_numeric]
        },
        dayTime: {
          short: [
            DateToken.DayOfMonth_numeric,
            DateToken.Month_numeric,
            DateToken.Year_numeric,
            DateToken.Hour_numeric,
            DateToken.Minute_numeric
          ],
          default: [
            DateToken.DayOfMonth_numeric,
            DateToken.Month_numeric,
            DateToken.Year_numeric,
            DateToken.Hour_2Digit,
            DateToken.Minute_2Digit
          ],
          long: [
            DateToken.DayOfMonth_numeric,
            DateToken.Month_numeric,
            DateToken.Year_numeric,
            DateToken.Hour_2Digit,
            DateToken.Minute_2Digit,
            DateToken.Second_2Digit
          ]
        },
        timeOnly: {
          short: [DateToken.Hour_numeric, DateToken.Minute_numeric],
          default: [DateToken.Hour_2Digit, DateToken.Minute_2Digit, DateToken.Second_2Digit],
          long: [
            DateToken.Hour_2Digit,
            DateToken.Minute_2Digit,
            DateToken.Second_2Digit,
            DateToken.MiliSecond_3
          ]
        },
        week: {
          short: [DateToken.DayOfMonth_numeric, DateToken.Month_numeric],
          default: [DateToken.DayOfMonth_numeric, DateToken.Month_numeric, DateToken.Year_numeric],
          long: [DateToken.DayOfMonth_numeric, DateToken.Month_numeric, DateToken.Year_numeric]
        },
        month: {
          short: DateToken.Month_short,
          default: DateToken.Month_long,
          long: [DateToken.Month_long, DateToken.Year_numeric]
        },
        monthsYear: {
          short: [DateToken.Month_short, DateToken.Year_2Digit],
          default: [DateToken.Month_long, DateToken.Year_numeric],
          long: [DateToken.Month_long, DateToken.Year_numeric]
        },
        year: {
          short: DateToken.Year_2Digit,
          default: DateToken.Year_numeric,
          long: DateToken.Year_numeric
        }
      }
    }
  }
};
function createLocaleSettings(localeSettings, base = defaultLocaleSettings) {
  if (localeSettings.formats?.dates?.ordinalSuffixes) {
    localeSettings.formats.dates.ordinalSuffixes = {
      one: "",
      two: "",
      few: "",
      other: "",
      zero: "",
      many: "",
      ...localeSettings.formats.dates.ordinalSuffixes
    };
  }
  if (localeSettings.formats?.dates?.weekStartsOn === void 0) {
    localeSettings = defaultsDeep_default(localeSettings, {
      formats: { dates: { weekStartsOn: getWeekStartsOnFromIntl(localeSettings.locale) } }
    });
  }
  return defaultsDeep_default(localeSettings, base);
}
var defaultLocale2 = createLocaleSettings({ locale: "en" });

// node_modules/@layerstack/utils/dist/date.js
function getPeriodTypeByCode(code) {
  const element = entries(periodTypeMappings).find((c3) => c3[1] === code);
  return parseInt(String(element?.[0] ?? "0"));
}
function getFiscalYear(date2 = /* @__PURE__ */ new Date(), options) {
  if (date2 === null) {
    return NaN;
  }
  const startMonth = options && options.startMonth || 10;
  return date2.getMonth() >= startMonth - 1 ? date2.getFullYear() + 1 : date2.getFullYear();
}
var biweekBaseDates = [/* @__PURE__ */ new Date("1799-12-22T00:00"), /* @__PURE__ */ new Date("1799-12-15T00:00")];
function startOfBiWeek(date2, week, startOfWeek2) {
  var weekBaseDate = biweekBaseDates[week - 1];
  var baseDate = intervalOffset("day", weekBaseDate, startOfWeek2);
  var periodsSince = Math.floor(intervalDifference("day", baseDate, date2) / 14);
  return intervalOffset("day", baseDate, periodsSince * 14);
}
function endOfBiWeek(date2, week, startOfWeek2) {
  return intervalOffset("day", startOfBiWeek(date2, week, startOfWeek2), 13);
}
function startOfWeek(date2, weekStartsOn) {
  switch (weekStartsOn) {
    case DayOfWeek.Sunday:
      return startOfInterval(timeSunday, date2);
    case DayOfWeek.Monday:
      return startOfInterval(timeMonday, date2);
    case DayOfWeek.Tuesday:
      return startOfInterval(timeTuesday, date2);
    case DayOfWeek.Wednesday:
      return startOfInterval(timeWednesday, date2);
    case DayOfWeek.Thursday:
      return startOfInterval(timeThursday, date2);
    case DayOfWeek.Friday:
      return startOfInterval(timeFriday, date2);
    case DayOfWeek.Saturday:
      return startOfInterval(timeSaturday, date2);
  }
}
function endOfWeek(date2, weekStartsOn) {
  switch (weekStartsOn) {
    case DayOfWeek.Sunday:
      return endOfInterval(timeSunday, date2);
    case DayOfWeek.Monday:
      return endOfInterval(timeMonday, date2);
    case DayOfWeek.Tuesday:
      return endOfInterval(timeTuesday, date2);
    case DayOfWeek.Wednesday:
      return endOfInterval(timeWednesday, date2);
    case DayOfWeek.Thursday:
      return endOfInterval(timeThursday, date2);
    case DayOfWeek.Friday:
      return endOfInterval(timeFriday, date2);
    case DayOfWeek.Saturday:
      return endOfInterval(timeSaturday, date2);
  }
}
function formatIntl(settings, dt, tokens_or_intlOptions) {
  const { locale: locale3, formats: { dates: { ordinalSuffixes: suffixes } } } = settings;
  function formatIntlOrdinal(formatter2, with_ordinal = false) {
    if (with_ordinal) {
      const rules = new Intl.PluralRules(locale3, { type: "ordinal" });
      const splited = formatter2.formatToParts(dt);
      return splited.map((c3) => {
        if (c3.type === "day") {
          const ordinal2 = rules.select(parseInt(c3.value, 10));
          const suffix = suffixes[ordinal2];
          return `${c3.value}${suffix}`;
        }
        return c3.value;
      }).join("");
    }
    return formatter2.format(dt);
  }
  if (typeof tokens_or_intlOptions !== "string" && !Array.isArray(tokens_or_intlOptions)) {
    return formatIntlOrdinal(new Intl.DateTimeFormat(locale3, tokens_or_intlOptions), tokens_or_intlOptions.withOrdinal);
  }
  const tokens = Array.isArray(tokens_or_intlOptions) ? tokens_or_intlOptions.join("") : tokens_or_intlOptions;
  const formatter = new Intl.DateTimeFormat(locale3, {
    year: tokens.includes(DateToken.Year_numeric) ? "numeric" : tokens.includes(DateToken.Year_2Digit) ? "2-digit" : void 0,
    month: tokens.includes(DateToken.Month_long) ? "long" : tokens.includes(DateToken.Month_short) ? "short" : tokens.includes(DateToken.Month_2Digit) ? "2-digit" : tokens.includes(DateToken.Month_numeric) ? "numeric" : void 0,
    day: tokens.includes(DateToken.DayOfMonth_2Digit) ? "2-digit" : tokens.includes(DateToken.DayOfMonth_numeric) ? "numeric" : void 0,
    hour: tokens.includes(DateToken.Hour_2Digit) ? "2-digit" : tokens.includes(DateToken.Hour_numeric) ? "numeric" : void 0,
    hour12: tokens.includes(DateToken.Hour_woAMPM) ? false : tokens.includes(DateToken.Hour_wAMPM) ? true : void 0,
    minute: tokens.includes(DateToken.Minute_2Digit) ? "2-digit" : tokens.includes(DateToken.Minute_numeric) ? "numeric" : void 0,
    second: tokens.includes(DateToken.Second_2Digit) ? "2-digit" : tokens.includes(DateToken.Second_numeric) ? "numeric" : void 0,
    fractionalSecondDigits: tokens.includes(DateToken.MiliSecond_3) ? 3 : void 0,
    weekday: tokens.includes(DateToken.DayOfWeek_narrow) ? "narrow" : tokens.includes(DateToken.DayOfWeek_long) ? "long" : tokens.includes(DateToken.DayOfWeek_short) ? "short" : void 0
  });
  return formatIntlOrdinal(formatter, tokens.includes(DateToken.DayOfMonth_withOrdinal));
}
function range3(settings, date2, weekStartsOn, formatToUse, biWeek = void 0) {
  const start = biWeek === void 0 ? startOfWeek(date2, weekStartsOn) : startOfBiWeek(date2, biWeek, weekStartsOn);
  const end = biWeek === void 0 ? endOfWeek(date2, weekStartsOn) : endOfBiWeek(date2, biWeek, weekStartsOn);
  return formatIntl(settings, start, formatToUse) + " - " + formatIntl(settings, end, formatToUse);
}
function updatePeriodTypeWithWeekStartsOn(weekStartsOn, periodType) {
  if (periodType === PeriodType.Week) {
    periodType = [
      PeriodType.WeekSun,
      PeriodType.WeekMon,
      PeriodType.WeekTue,
      PeriodType.WeekWed,
      PeriodType.WeekThu,
      PeriodType.WeekFri,
      PeriodType.WeekSat
    ][weekStartsOn];
  } else if (periodType === PeriodType.BiWeek1) {
    periodType = [
      PeriodType.BiWeek1Sun,
      PeriodType.BiWeek1Mon,
      PeriodType.BiWeek1Tue,
      PeriodType.BiWeek1Wed,
      PeriodType.BiWeek1Thu,
      PeriodType.BiWeek1Fri,
      PeriodType.BiWeek1Sat
    ][weekStartsOn];
  } else if (periodType === PeriodType.BiWeek2) {
    periodType = [
      PeriodType.BiWeek2Sun,
      PeriodType.BiWeek2Mon,
      PeriodType.BiWeek2Tue,
      PeriodType.BiWeek2Wed,
      PeriodType.BiWeek2Thu,
      PeriodType.BiWeek2Fri,
      PeriodType.BiWeek2Sat
    ][weekStartsOn];
  }
  return periodType;
}
function formatDateWithLocale(settings, date2, periodType, options = {}) {
  if (typeof date2 === "string") {
    date2 = parseDate(date2);
  }
  if (date2 == null || isNaN(date2)) {
    return "";
  }
  const weekStartsOn = options.weekStartsOn ?? settings.formats.dates.weekStartsOn;
  const { day, dayTime, timeOnly, week, month, monthsYear, year } = settings.formats.dates.presets;
  periodType = typeof periodType === "string" ? getPeriodTypeByCode(periodType) : periodType ?? PeriodType.Day;
  periodType = updatePeriodTypeWithWeekStartsOn(weekStartsOn, periodType) ?? periodType;
  function rv(preset) {
    if (options.variant === "custom") {
      return options.custom ?? preset.default;
    } else if (options.custom && !options.variant) {
      return options.custom;
    }
    return preset[options.variant ?? "default"];
  }
  switch (periodType) {
    case PeriodType.Custom:
      return formatIntl(settings, date2, options.custom);
    case PeriodType.Day:
      return formatIntl(settings, date2, rv(day));
    case PeriodType.DayTime:
      return formatIntl(settings, date2, rv(dayTime));
    case PeriodType.TimeOnly:
      return formatIntl(settings, date2, rv(timeOnly));
    case PeriodType.Week:
    //Should never happen, but to make types happy
    case PeriodType.WeekSun:
      return range3(settings, date2, 0, rv(week));
    case PeriodType.WeekMon:
      return range3(settings, date2, 1, rv(week));
    case PeriodType.WeekTue:
      return range3(settings, date2, 2, rv(week));
    case PeriodType.WeekWed:
      return range3(settings, date2, 3, rv(week));
    case PeriodType.WeekThu:
      return range3(settings, date2, 4, rv(week));
    case PeriodType.WeekFri:
      return range3(settings, date2, 5, rv(week));
    case PeriodType.WeekSat:
      return range3(settings, date2, 6, rv(week));
    case PeriodType.Month:
      return formatIntl(settings, date2, rv(month));
    case PeriodType.MonthYear:
      return formatIntl(settings, date2, rv(monthsYear));
    case PeriodType.Quarter:
      return [
        formatIntl(settings, startOfInterval("quarter", date2), rv(month)),
        formatIntl(settings, endOfInterval("quarter", date2), rv(monthsYear))
      ].join(" - ");
    case PeriodType.CalendarYear:
      return formatIntl(settings, date2, rv(year));
    case PeriodType.FiscalYearOctober:
      const fDate = new Date(getFiscalYear(date2), 0, 1);
      return formatIntl(settings, fDate, rv(year));
    case PeriodType.BiWeek1:
    //Should never happen, but to make types happy
    case PeriodType.BiWeek1Sun:
      return range3(settings, date2, 0, rv(week), 1);
    case PeriodType.BiWeek1Mon:
      return range3(settings, date2, 1, rv(week), 1);
    case PeriodType.BiWeek1Tue:
      return range3(settings, date2, 2, rv(week), 1);
    case PeriodType.BiWeek1Wed:
      return range3(settings, date2, 3, rv(week), 1);
    case PeriodType.BiWeek1Thu:
      return range3(settings, date2, 4, rv(week), 1);
    case PeriodType.BiWeek1Fri:
      return range3(settings, date2, 5, rv(week), 1);
    case PeriodType.BiWeek1Sat:
      return range3(settings, date2, 6, rv(week), 1);
    case PeriodType.BiWeek2:
    //Should never happen, but to make types happy
    case PeriodType.BiWeek2Sun:
      return range3(settings, date2, 0, rv(week), 2);
    case PeriodType.BiWeek2Mon:
      return range3(settings, date2, 1, rv(week), 2);
    case PeriodType.BiWeek2Tue:
      return range3(settings, date2, 2, rv(week), 2);
    case PeriodType.BiWeek2Wed:
      return range3(settings, date2, 3, rv(week), 2);
    case PeriodType.BiWeek2Thu:
      return range3(settings, date2, 4, rv(week), 2);
    case PeriodType.BiWeek2Fri:
      return range3(settings, date2, 5, rv(week), 2);
    case PeriodType.BiWeek2Sat:
      return range3(settings, date2, 6, rv(week), 2);
    default:
      return date2.toISOString();
  }
}
var DATE_FORMAT = /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2}(\.\d+|)?(Z|(-|\+)\d{2}:\d{2}?)?)?)?$/;
function isStringDate(value2) {
  return DATE_FORMAT.test(value2);
}
function isStringDateWithTime(value2) {
  return isStringDate(value2) && value2.includes("T");
}
function parseDate(dateStr, format3) {
  if (format3) {
    let strftimeFormat = format3;
    if (!format3.includes("%")) {
      strftimeFormat = convertUnicodeToStrftime(format3);
    }
    return timeParse(strftimeFormat)(dateStr) ?? /* @__PURE__ */ new Date("Invalid Date");
  }
  if (!isStringDate(dateStr))
    return /* @__PURE__ */ new Date("Invalid Date");
  if (isStringDateWithTime(dateStr)) {
    return new Date(dateStr);
  }
  const [date2, time2] = dateStr.split("T");
  const [year, month, day] = date2.split("-").map(Number);
  if (time2) {
    const [hour, minute, second2] = time2.split(":").map(Number);
    return new Date(year, month - 1, day, hour, minute, second2);
  } else {
    return new Date(year, month - 1, day);
  }
}
var timeQuarter = timeInterval(
  // floor
  (date2) => {
    date2.setMonth(date2.getMonth() - date2.getMonth() % 3, 1);
    date2.setHours(0, 0, 0, 0);
  },
  // offset
  (date2, step) => date2.setMonth(date2.getMonth() + step * 3, 1),
  // count
  (start, end) => (end.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24 * 30 * 3),
  // field
  (date2) => date2.getMonth()
  // TODO: what should this be?
);
function timeInterval2(name) {
  switch (name) {
    case "millisecond":
      return millisecond;
    case "second":
      return second;
    case "minute":
      return timeMinute;
    case "hour":
      return timeHour;
    case "day":
      return timeDay;
    case "week":
      return timeSunday;
    case "month":
      return timeMonth;
    case "quarter":
      return timeQuarter;
    case "year":
      return timeYear;
  }
}
function startOfInterval(interval2, date2) {
  interval2 = typeof interval2 === "string" ? timeInterval2(interval2) : interval2;
  if (date2 === void 0) {
    return (date3) => new Date(interval2.floor(date3));
  }
  return new Date(interval2.floor(date2));
}
function endOfInterval(interval2, date2) {
  interval2 = typeof interval2 === "string" ? timeInterval2(interval2) : interval2;
  if (date2 === void 0) {
    return (date3) => new Date(interval2.offset(interval2.floor(date3), 1).getTime() - 1);
  }
  return new Date(interval2.offset(interval2.floor(date2), 1).getTime() - 1);
}
function intervalOffset(interval2, date2, offset) {
  interval2 = typeof interval2 === "string" ? timeInterval2(interval2) : interval2;
  return interval2.offset(date2, offset);
}
function intervalDifference(interval2, date1, date2) {
  interval2 = typeof interval2 === "string" ? timeInterval2(interval2) : interval2;
  if (date1 === void 0 || date2 === void 0) {
    return (date12, date22) => interval2.count(date12, date22);
  }
  return interval2.count(date1, date2);
}

// node_modules/@layerstack/utils/dist/dom.js
function localPoint(event2, node) {
  if (!node) {
    node = event2.currentTarget ?? event2.target;
  }
  if (!node || !event2)
    return { x: 0, y: 0 };
  const coords = getPointFromEvent(event2);
  const svg = isSVGElement(node) ? node.ownerSVGElement : node;
  const screenCTM = isSVGGraphicsElement(svg) ? svg.getScreenCTM() : null;
  if (isSVGSVGElement(svg) && screenCTM) {
    let point10 = svg.createSVGPoint();
    point10.x = coords.x;
    point10.y = coords.y;
    point10 = point10.matrixTransform(screenCTM.inverse());
    return {
      x: point10.x,
      y: point10.y
    };
  }
  const rect = node.getBoundingClientRect();
  return {
    x: coords.x - rect.left - node.clientLeft,
    y: coords.y - rect.top - node.clientTop
  };
}
function getPointFromEvent(event2) {
  if (!event2)
    return { x: 0, y: 0 };
  if (isTouchEvent(event2)) {
    return event2.changedTouches.length > 0 ? {
      x: event2.changedTouches[0].clientX,
      y: event2.changedTouches[0].clientY
    } : { x: 0, y: 0 };
  }
  return {
    x: event2.clientX,
    y: event2.clientY
  };
}

// node_modules/@layerstack/utils/dist/duration.js
var DurationUnits;
(function(DurationUnits2) {
  DurationUnits2[DurationUnits2["Year"] = 0] = "Year";
  DurationUnits2[DurationUnits2["Day"] = 1] = "Day";
  DurationUnits2[DurationUnits2["Hour"] = 2] = "Hour";
  DurationUnits2[DurationUnits2["Minute"] = 3] = "Minute";
  DurationUnits2[DurationUnits2["Second"] = 4] = "Second";
  DurationUnits2[DurationUnits2["Millisecond"] = 5] = "Millisecond";
})(DurationUnits || (DurationUnits = {}));
var Duration = class {
  #milliseconds = 0;
  #seconds = 0;
  #minutes = 0;
  #hours = 0;
  #days = 0;
  #years = 0;
  constructor(options = {}) {
    const startDate = typeof options.start === "string" ? parseDate(options.start) : options.start;
    const endDate = typeof options.end === "string" ? parseDate(options.end) : options.end;
    const differenceInMs = startDate ? Math.abs(Number(endDate || /* @__PURE__ */ new Date()) - Number(startDate)) : void 0;
    if (!Number.isFinite(differenceInMs) && options.duration == null) {
      return;
    }
    this.#milliseconds = options.duration?.milliseconds ?? differenceInMs ?? 0;
    this.#seconds = options.duration?.seconds ?? 0;
    this.#minutes = options.duration?.minutes ?? 0;
    this.#hours = options.duration?.hours ?? 0;
    this.#days = options.duration?.days ?? 0;
    this.#years = options.duration?.years ?? 0;
    if (this.#milliseconds >= 1e3) {
      const carrySeconds = (this.#milliseconds - this.#milliseconds % 1e3) / 1e3;
      this.#seconds += carrySeconds;
      this.#milliseconds = this.#milliseconds - carrySeconds * 1e3;
    }
    if (this.#seconds >= 60) {
      const carryMinutes = (this.#seconds - this.#seconds % 60) / 60;
      this.#minutes += carryMinutes;
      this.#seconds = this.#seconds - carryMinutes * 60;
    }
    if (this.#minutes >= 60) {
      const carryHours = (this.#minutes - this.#minutes % 60) / 60;
      this.#hours += carryHours;
      this.#minutes = this.#minutes - carryHours * 60;
    }
    if (this.#hours >= 24) {
      const carryDays = (this.#hours - this.#hours % 24) / 24;
      this.#days += carryDays;
      this.#hours = this.#hours - carryDays * 24;
    }
    if (this.#days >= 365) {
      const carryYears = (this.#days - this.#days % 365) / 365;
      this.#years += carryYears;
      this.#days = this.#days - carryYears * 365;
    }
  }
  get years() {
    return this.#years;
  }
  get days() {
    return this.#days;
  }
  get hours() {
    return this.#hours;
  }
  get minutes() {
    return this.#minutes;
  }
  get seconds() {
    return this.#seconds;
  }
  get milliseconds() {
    return this.#milliseconds;
  }
  valueOf() {
    return this.#milliseconds + this.#seconds * 1e3 + this.#minutes * 60 * 1e3 + this.#hours * 60 * 60 * 1e3 + this.#days * 24 * 60 * 60 * 1e3 + this.#years * 365 * 24 * 60 * 60 * 1e3;
  }
  toJSON() {
    return {
      years: this.#years,
      days: this.#days,
      hours: this.#hours,
      minutes: this.#minutes,
      seconds: this.#seconds,
      milliseconds: this.#milliseconds
    };
  }
  format(options = {}) {
    const { minUnits, totalUnits = 99, variant = "short" } = options;
    var sentenceArr = [];
    var unitNames = variant === "short" ? ["y", "d", "h", "m", "s", "ms"] : ["years", "days", "hours", "minutes", "seconds", "milliseconds"];
    var unitNums = [
      this.years,
      this.days,
      this.hours,
      this.minutes,
      this.seconds,
      this.milliseconds
    ].filter((x4, i2) => i2 <= (minUnits ?? 99));
    for (var i in unitNums) {
      if (sentenceArr.length >= totalUnits) {
        break;
      }
      const unitNum = unitNums[i];
      let unitName = unitNames[i];
      if (unitNum !== 0 || sentenceArr.length === 0 && Number(i) === unitNums.length - 1) {
        switch (variant) {
          case "short":
            sentenceArr.push(unitNum + unitName);
            break;
          case "long":
            if (unitNum === 1) {
              unitName = unitName.slice(0, -1);
            }
            sentenceArr.push(unitNum + " " + unitName);
            break;
        }
      }
    }
    const sentence = sentenceArr.join(variant === "long" ? " and " : " ");
    return sentence;
  }
  toString() {
    return this.format();
  }
};

// node_modules/@layerstack/utils/dist/number.js
function getFormatNumber(settings, style) {
  const { numbers: numbers3 } = settings.formats;
  const styleSettings = style && style != "none" ? numbers3[style] : {};
  return {
    ...numbers3.defaults,
    ...styleSettings
  };
}
function formatNumberWithLocale(settings, number4, style, options = {}) {
  if (number4 == null) {
    return "";
  }
  if (style === "none") {
    return `${number4}`;
  }
  if (style == null) {
    style = Number.isInteger(number4) ? "integer" : "decimal";
  }
  const defaults2 = getFormatNumber(settings, style);
  const formatter = Intl.NumberFormat(settings.locale, {
    // Let's always starts with all defaults
    ...defaults2,
    ...style !== "default" && {
      style
    },
    // Let's shorten min / max with fractionDigits
    ...{
      minimumFractionDigits: options.fractionDigits ?? defaults2.fractionDigits,
      maximumFractionDigits: options.fractionDigits ?? defaults2.fractionDigits
    },
    // now we bring in user specified options
    ...omitNil(options),
    ...style === "currencyRound" && {
      style: "currency",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    },
    // Let's overwrite for style=percentRound
    ...style === "percentRound" && {
      style: "percent",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    },
    // Let's overwrite for style=metric
    ...style === "metric" && {
      style: "decimal",
      notation: "compact",
      minimumFractionDigits: 0
    },
    // Let's overwrite for style=integer
    ...style === "integer" && {
      style: "decimal",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }
  });
  const value2 = formatter.format(number4);
  let suffix = options.suffix ?? "";
  if (suffix && Math.abs(number4) >= 2 && options.suffixExtraIfMany !== "") {
    suffix += options.suffixExtraIfMany ?? "s";
  }
  return `${value2}${suffix}`;
}
function clamp2(value2, min7, max7) {
  return value2 < min7 ? min7 : value2 > max7 ? max7 : value2;
}

// node_modules/@layerstack/utils/dist/format.js
function format(value2, formatOrConfig, options) {
  if (formatOrConfig && typeof formatOrConfig === "object" && "type" in formatOrConfig) {
    return formatWithLocale(defaultLocale2, value2, formatOrConfig.type, formatOrConfig.options);
  }
  return formatWithLocale(defaultLocale2, value2, formatOrConfig, options);
}
function formatWithLocale(settings, value2, formatOrConfig, options) {
  const format3 = formatOrConfig && typeof formatOrConfig === "object" && "type" in formatOrConfig ? formatOrConfig.type : formatOrConfig;
  const formatOptions = formatOrConfig && typeof formatOrConfig === "object" && "type" in formatOrConfig && "options" in formatOrConfig ? formatOrConfig.options : options;
  if (typeof format3 === "function") {
    return format3(value2);
  } else if (value2 instanceof Date || isStringDate(value2) || format3 && (format3 in PeriodType || Object.values(periodTypeMappings).includes(format3))) {
    return formatDateWithLocale(settings, value2, format3, formatOptions);
  } else if (typeof value2 === "number") {
    return formatNumberWithLocale(settings, value2, format3, formatOptions);
  } else if (typeof value2 === "string") {
    return value2;
  } else if (value2 == null) {
    return "";
  } else {
    return `${value2}`;
  }
}

// node_modules/@layerstack/utils/dist/env.js
var browser = typeof window !== "undefined";

// node_modules/@layerstack/utils/dist/logger.js
var logLevels = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR"];
var Logger = class {
  name;
  constructor(name) {
    this.name = name;
  }
  trace(...message) {
    this.log("TRACE", ...message);
  }
  debug(...message) {
    this.log("DEBUG", ...message);
  }
  info(...message) {
    this.log("INFO", ...message);
  }
  warn(...message) {
    this.log("WARN", ...message);
  }
  error(...message) {
    this.log("ERROR", ...message);
  }
  log(level, ...message) {
    const enabledLoggers = browser ? localStorage.getItem("logger")?.split(",").map((x4) => x4.split(":")) ?? [] : [];
    const enabledLogger = enabledLoggers.find((x4) => x4[0] === this.name);
    const shouldLog = enabledLogger != null && logLevels.indexOf(level) >= logLevels.indexOf(enabledLogger[1] ?? "DEBUG");
    if (shouldLog) {
      switch (level) {
        case "TRACE":
          console.trace(`%c${this.name} %c${level}`, "color: hsl(200deg, 10%, 50%)", "color: hsl(200deg, 40%, 50%)", ...message);
          break;
        case "DEBUG":
          console.log(`%c${this.name} %c${level}`, "color: hsl(200deg, 10%, 50%)", "color: hsl(200deg, 40%, 50%)", ...message);
          break;
        case "INFO":
          console.log(`%c${this.name} %c${level}`, "color: hsl(200deg, 10%, 50%)", "color: hsl(60deg, 100%, 50%)", ...message);
          break;
        case "WARN":
          console.warn(`%c${this.name} %c${level}`, "color: hsl(200deg, 10%, 50%)", "color: hsl(30deg, 100%, 50%)", ...message);
          break;
        case "ERROR":
          console.warn(`%c${this.name} %c${level}`, "color: hsl(200deg, 10%, 50%)", "color: hsl(0deg, 100%, 50%)", ...message);
          break;
      }
    }
  }
};

// node_modules/@layerstack/utils/dist/sort.js
function sortFunc(value2, direction = "asc") {
  const sortDirection = direction === "asc" ? 1 : -1;
  return (a5, b) => {
    const valueFn = propAccessor(value2);
    const aValue = valueFn(a5);
    const bValue = valueFn(b);
    if (aValue == null || bValue == null) {
      if (aValue == null && bValue != null) {
        return -sortDirection;
      } else if (aValue != null && bValue == null) {
        return sortDirection;
      } else {
        return 0;
      }
    }
    return aValue < bValue ? -sortDirection : aValue > bValue ? sortDirection : 0;
  };
}

// node_modules/@layerstack/tailwind/dist/theme.js
var semanticColors = ["primary", "secondary", "accent", "neutral"];
var stateColors = ["info", "success", "warning", "danger"];
var colors = [...semanticColors, ...stateColors];
var shades = [50, ...range(100, 1e3, 100)];

// node_modules/@layerstack/tailwind/dist/utils.js
var twMerge = extendTailwindMerge({
  extend: {
    classGroups: {
      shadow: [
        "shadow-border-l",
        "shadow-border-r",
        "shadow-border-t",
        "shadow-border-b",
        "elevation-none",
        ...range(1, 25).map((x4) => `elevation-${x4}`)
      ]
    }
  }
});
var cls = (...inputs) => twMerge(clsx_default(...inputs));

// node_modules/@layerstack/svelte-state/dist/mediaQueryPresets.svelte.js
var MediaQueryPresets = class {
  width(width) {
    return new MediaQuery(`(min-width: ${width}px)`);
  }
  height(height) {
    return new MediaQuery(`(min-height: ${height}px)`);
  }
  // Matches tailwind defaults (https://tailwindcss.com/docs/responsive-design)
  smScreen = this.width(640);
  mdScreen = this.width(768);
  lgScreen = this.width(1024);
  xlScreen = this.width(1280);
  xxlScreen = this.width(1536);
  screen = new MediaQuery("screen and (min-width: 0)");
  // workaround for https://github.com/sveltejs/svelte/issues/15930
  print = new MediaQuery("print and (min-width: 0)");
  // workaround for https://github.com/sveltejs/svelte/issues/15930
  dark = new MediaQuery("(prefers-color-scheme: dark)");
  light = new MediaQuery("(prefers-color-scheme: light)");
  motion = new MediaQuery("(prefers-reduced-motion: no-preference)");
  motionReduce = new MediaQuery("(prefers-reduced-motion: reduce)");
  landscape = new MediaQuery("(orientation: landscape)");
  portrait = new MediaQuery("(orientation: portrait)");
};

// node_modules/@layerstack/svelte-state/dist/uniqueState.svelte.js
var UniqueState = class {
  #initial;
  current;
  constructor(initial2) {
    this.#initial = initial2 ?? [];
    this.current = new SvelteSet(initial2 ?? []);
  }
  /** Clear all values */
  clear() {
    this.current.clear();
  }
  /** Reset to initial values */
  reset() {
    this.clear();
    this.addEach(this.#initial);
  }
  /** Add a value */
  add(value2) {
    this.current.add(value2);
  }
  /** Add multiple values */
  addEach(values2) {
    for (const value2 of values2) {
      this.current.add(value2);
    }
  }
  /** Remove a value */
  delete(value2) {
    this.current.delete(value2);
  }
  /** Toggle a value */
  toggle(value2) {
    if (this.current.has(value2)) {
      this.current.delete(value2);
    } else {
      this.current.add(value2);
    }
  }
};

// node_modules/@layerstack/svelte-state/dist/selectionState.svelte.js
var SelectionState = class {
  #initial;
  #selected;
  all;
  single;
  max;
  constructor(options = {}) {
    this.#initial = options.initial ?? [];
    this.#selected = new UniqueState(this.#initial);
    this.all = options.all ?? [];
    this.single = options.single ?? false;
    this.max = options.max;
  }
  get current() {
    return this.single ? Array.from(this.#selected.current)[0] ?? null : Array.from(this.#selected.current);
  }
  set current(values2) {
    if (Array.isArray(values2)) {
      if (equals(this.max, null) || values2.length < this.max) {
        this.#selected.clear();
        this.#selected.addEach(values2);
      } else {
        throw new Error(`Too many values selected.  Current: ${values2.length}, max: ${this.max}`);
      }
    } else if (equals(values2, null, false)) {
      this.#selected.clear();
      this.#selected.add(values2);
    } else {
      this.#selected.clear();
    }
  }
  /** Check if a value is selected */
  isSelected(value2) {
    return this.#selected.current.has(value2);
  }
  /** Check if the selection is empty */
  isEmpty() {
    return strict_equals(this.#selected.current.size, 0);
  }
  /** Check if all values in `all` are selected */
  isAllSelected() {
    return this.all.every((v2) => this.#selected.current.has(v2));
  }
  /** Check if any values in `all` are selected */
  isAnySelected() {
    return this.all.some((v2) => this.#selected.current.has(v2));
  }
  /** Check if the selection is at the maximum */
  isMaxSelected() {
    return equals(this.max, null, false) ? this.#selected.current.size >= this.max : false;
  }
  /** Check if a value is disabled (max reached) */
  isDisabled(value2) {
    return !this.isSelected(value2) && this.isMaxSelected();
  }
  /** Clear all selected values */
  clear() {
    this.#selected.clear();
  }
  /** Reset to initial values */
  reset() {
    this.#selected.reset();
  }
  /** Toggle a value */
  toggle(value2) {
    if (this.#selected.current.has(value2)) {
      const prevSelected = [...this.#selected.current];
      this.#selected.clear();
      this.#selected.addEach(prevSelected.filter((v2) => equals(v2, value2, false)));
    } else if (this.single) {
      this.#selected.clear();
      this.#selected.add(value2);
    } else {
      if (equals(this.max, null) || this.#selected.current.size < this.max) {
        return this.#selected.add(value2);
      }
    }
  }
  /** Toggle all values */
  toggleAll() {
    let values2;
    if (this.isAllSelected()) {
      values2 = [...this.#selected.current].filter((v2) => !this.all.includes(v2));
    } else {
      values2 = [...this.#selected.current, ...this.all];
    }
    this.#selected.clear();
    this.#selected.addEach(values2);
  }
};

// node_modules/layerchart/dist/utils/motion.svelte.js
var MotionSpring = class extends Spring {
  type = "spring";
  constructor(value2, options) {
    super(value2, options);
  }
};
var MotionTween = class extends Tween {
  type = "tween";
  constructor(value2, options) {
    super(value2, options);
  }
};
var MotionNone = class {
  type = "none";
  #current = tag(state(null), "MotionNone.#current");
  #target = tag(state(null), "MotionNone.#target");
  constructor(value2, _options = {}) {
    set(this.#current, value2, true);
    set(this.#target, value2, true);
  }
  /**
   * Updates the value immediately and returns a resolved promise
   * to maintain API compatibility with animated motion classes
   */
  set(value2, _options = {}) {
    set(this.#current, value2, true);
    set(this.#target, value2, true);
    return Promise.resolve();
  }
  get current() {
    return get(this.#current);
  }
  get target() {
    return get(this.#target);
  }
  set target(v2) {
    this.set(v2);
  }
};
function setupTracking(motion, getValue2, options) {
  if (options.controlled) return;
  user_effect(() => {
    motion.set(getValue2());
  });
}
function createMotion(initialValue, getValue2, motionProp, options = {}) {
  const motion = parseMotionProp(motionProp);
  const motionState = strict_equals(motion.type, "spring") ? new MotionSpring(initialValue, motion.options) : strict_equals(motion.type, "tween") ? new MotionTween(initialValue, motion.options) : new MotionNone(initialValue);
  setupTracking(motionState, getValue2, options);
  return motionState;
}
function createControlledMotion(initialValue, motionProp) {
  return createMotion(initialValue, () => initialValue, motionProp, { controlled: true });
}
function createMotionTracker() {
  let latestIndex = 0;
  let current = tag(state(false), "current");
  function handle(promise) {
    latestIndex += 1;
    if (!promise) {
      set(current, false);
      return;
    }
    let currIndex = latestIndex;
    set(current, true);
    promise.then(() => {
      if (strict_equals(currIndex, latestIndex)) {
        set(current, false);
      }
    }).catch(() => {
    });
  }
  return {
    handle,
    get current() {
      return get(current);
    }
  };
}
function extractTweenConfig(prop2) {
  const resolved = parseMotionProp(prop2);
  if (strict_equals(resolved.type, "tween")) return resolved;
}
function parseMotionProp(config, accessor2) {
  if (strict_equals(typeof config, "object") && "type" in config && "options" in config) {
    if (strict_equals(typeof config.options, "object")) return config;
    return { type: config.type, options: {} };
  }
  if (strict_equals(config, void 0)) return { type: "none", options: {} };
  if (strict_equals(typeof config, "string")) {
    if (strict_equals(config, "spring")) {
      return { type: "spring", options: {} };
    } else if (strict_equals(config, "tween")) {
      return { type: "tween", options: {} };
    }
    return { type: "none", options: {} };
  }
  if (strict_equals(typeof config, "object") && "type" in config) {
    if (strict_equals(config.type, "spring")) {
      const { type, ...options } = config;
      return { type: "spring", options };
    } else if (strict_equals(config.type, "tween")) {
      const { type, ...options } = config;
      return { type: "tween", options };
    } else {
      return { type: "none", options: {} };
    }
  }
  if (accessor2) {
    const propConfig = config[accessor2];
    if (strict_equals(propConfig, void 0, false)) {
      return parseMotionProp(propConfig);
    }
  }
  return { type: "none", options: {} };
}

// node_modules/layerchart/dist/utils/common.js
function accessor(prop2) {
  if (Array.isArray(prop2)) {
    return (d) => prop2.map((p) => accessor(p)(d));
  } else if (typeof prop2 === "function") {
    return prop2;
  } else if (typeof prop2 === "string" || typeof prop2 === "number") {
    return (d) => get_default(d, prop2);
  } else {
    return (d) => d;
  }
}
function chartDataArray(data) {
  if (data == null) {
    return [];
  } else if (Array.isArray(data)) {
    return data;
  } else if ("nodes" in data) {
    return data.nodes;
  } else if ("descendants" in data) {
    return data.descendants();
  }
  return [];
}
function defaultChartPadding(axis = true, legend = false) {
  if (axis === false) {
    return void 0;
  } else {
    return {
      top: axis === true || axis === "y" ? 4 : 0,
      left: axis === true || axis === "y" ? 20 : 0,
      bottom: (axis === true || axis === "x" ? 20 : 0) + (legend === true ? 32 : 0),
      right: axis === true || axis === "x" ? 4 : 0
    };
  }
}
function findRelatedData(data, original, accessor2) {
  return data.find((d) => {
    return accessor2(d)?.valueOf() === accessor2(original)?.valueOf();
  });
}

// node_modules/d3-shape/src/constant.js
function constant_default2(x4) {
  return function constant5() {
    return x4;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max3 = Math.max;
var min3 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi : Math.acos(x4);
}
function asin(x4) {
  return x4 >= 1 ? halfPi : x4 <= -1 ? -halfPi : Math.asin(x4);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append2(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append2;
  const k3 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append2 : appendRound(digits);
  }
  moveTo(x4, y4) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x4, y4) {
    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y12, x4, y4) {
    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x4, y4) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arcTo(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x06},${y06}`;
    } else if (Math.abs(this._x1 - x06) > epsilon2 || Math.abs(this._y1 - y06) > epsilon2) {
      this._append`L${x06},${y06}`;
    }
    if (!r) return;
    if (da2 < 0) da2 = da2 % tau2 + tau2;
    if (da2 > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
    } else if (da2 > epsilon2) {
      this._append`A${r},${r},0,${+(da2 >= pi2)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;
    }
  }
  rect(x4, y4, w, h) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon) return;
  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
  return [x06 + t * x10, y06 + t * y10];
}
function cornerTangents(x06, y06, x12, y12, r1, rc, cw) {
  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max3(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path3 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da2 = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path3();
    if (r1 < r0) r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da2 > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min3(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da2 < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min3(rc, (r0 - lc) / (kc - 1));
            rc1 = min3(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc) context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc) context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a5 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a5) * r, sin(a5) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default2(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice3 = Array.prototype.slice;
function array_default(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x4, y4) {
  var defined = constant_default2(true), context = null, curve = linear_default, output = null, path3 = withPath(line);
  x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x : constant_default2(x4);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y : constant_default2(y4);
  function line(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x4(d, i, data), +y4(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default2(+_), line) : x4;
  };
  line.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default2(+_), line) : y4;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default(x06, y06, y12) {
  var x12 = null, defined = constant_default2(true), context = null, curve = linear_default, output = null, path3 = withPath(area);
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x : constant_default2(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default2(0) : constant_default2(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default2(+y12);
  function area(data) {
    var i, j, k3, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k3 = i - 1; k3 >= j; --k3) {
            output.point(x0z[k3], y0z[k3]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);
        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default2(+_), x12 = null, area) : x06;
  };
  area.x0 = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default2(+_), area) : x06;
  };
  area.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : x12;
  };
  area.y = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default2(+_), y12 = null, area) : y06;
  };
  area.y0 = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default2(+_), area) : y06;
  };
  area.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : y12;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a5, b) {
  return b < a5 ? -1 : b > a5 ? 1 : b >= a5 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default2(d) {
  return d;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value2 = identity_default2, sortValues = descending_default, sort3 = null, startAngle = constant_default2(0), endAngle = constant_default2(tau), padAngle = constant_default2(0);
  function pie(data) {
    var i, n = (data = array_default(data)).length, j, k3, sum7 = 0, index4 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;
    for (i = 0; i < n; ++i) {
      if ((v2 = arcs[index4[i] = i] = +value2(data[i], i, data)) > 0) {
        sum7 += v2;
      }
    }
    if (sortValues != null) index4.sort(function(i2, j2) {
      return sortValues(arcs[i2], arcs[j2]);
    });
    else if (sort3 != null) index4.sort(function(i2, j2) {
      return sort3(data[i2], data[j2]);
    });
    for (i = 0, k3 = sum7 ? (da2 - n * pa) / sum7 : 0; i < n; ++i, a0 = a1) {
      j = index4[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k3 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v2,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant_default2(+_), pie) : value2;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort3 = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort3 = _, sortValues = null, pie) : sort3;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default2(+_), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a5, r) {
    this._curve.point(r * Math.sin(a5), r * -Math.cos(a5));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c3 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c3(curveRadial(_)) : c3()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a5 = area_default().curve(curveRadialLinear), c3 = a5.curve, x06 = a5.lineX0, x12 = a5.lineX1, y06 = a5.lineY0, y12 = a5.lineY1;
  a5.angle = a5.x, delete a5.x;
  a5.startAngle = a5.x0, delete a5.x0;
  a5.endAngle = a5.x1, delete a5.x1;
  a5.radius = a5.y, delete a5.y;
  a5.innerRadius = a5.y0, delete a5.y0;
  a5.outerRadius = a5.y1, delete a5.y1;
  a5.lineStartAngle = function() {
    return lineRadial(x06());
  }, delete a5.lineX0;
  a5.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a5.lineX1;
  a5.lineInnerRadius = function() {
    return lineRadial(y06());
  }, delete a5.lineY0;
  a5.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a5.lineY1;
  a5.curve = function(_) {
    return arguments.length ? c3(curveRadial(_)) : c3()._curve;
  };
  return a5;
}

// node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x4, y4) {
  return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];
}

// node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x4) {
    this._context = context;
    this._x = x4;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x4, y4);
        else this._context.moveTo(x4, y4);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);
        break;
      }
    }
    this._x0 = x4, this._y0 = y4;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x4, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x4, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x4, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j = x4.length - 1;
    if (j > 0) {
      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x4),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x4, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a5 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a5 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a5 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point3(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point3(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point3(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) this._context.lineTo(x4, y4);
    else this._point = 1, this._context.moveTo(x4, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    var t13 = NaN;
    x4 = +x4, y4 = +y4;
    if (x4 === this._x1 && y4 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t13 = slope3(this, x4, y4)), t13);
        break;
      default:
        point4(this, this._t0, t13 = slope3(this, x4, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
  MonotoneX.prototype.point.call(this, y4, x4);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x4, y4) {
    this._context.moveTo(y4, x4);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x4, y4) {
    this._context.lineTo(y4, x4);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);
  }
};

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, n = x4.length;
    if (n) {
      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
      if (n === 2) {
        this._context.lineTo(x4[1], y4[1]);
      } else {
        var px = controlPoints(x4), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
function controlPoints(x4) {
  var i, n = x4.length - 1, m3, a5 = new Array(n), b = new Array(n), r = new Array(n);
  a5[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];
  for (i = 1; i < n - 1; ++i) a5[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
  a5[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
  for (i = 1; i < n; ++i) m3 = a5[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
  a5[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a5[i] = (r[i] - a5[i + 1]) / b[i];
  b[n - 1] = (x4[n] + a5[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x4[i + 1] - a5[i + 1];
  return [a5, b];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x4, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x4 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x4, this._y = y4;
  }
};

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m3; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key2) {
  return d[key2];
}
function stackSeries(key2) {
  const series = [];
  series.key = key2;
  return series;
}
function stack_default() {
  var keys3 = constant_default2([]), order = none_default2, offset = none_default, value2 = stackValue;
  function stack(data) {
    var sz = Array.from(keys3.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value2(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys3 = typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : keys3;
  };
  stack.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant_default2(+_), stack) : value2;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {
    for (y4 = i = 0; i < n; ++i) y4 += series[i][j][1] || 0;
    if (y4) for (i = 0; i < n; ++i) series[i][j][1] /= y4;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

// node_modules/d3-interpolate-path/build/d3-interpolate-path.mjs
function ownKeys(object2, enumerableOnly) {
  var keys3 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols2);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function decasteljau(points, t) {
  var left2 = [];
  var right2 = [];
  function decasteljauRecurse(points2, t4) {
    if (points2.length === 1) {
      left2.push(points2[0]);
      right2.push(points2[0]);
    } else {
      var newPoints = Array(points2.length - 1);
      for (var i = 0; i < newPoints.length; i++) {
        if (i === 0) {
          left2.push(points2[0]);
        }
        if (i === newPoints.length - 1) {
          right2.push(points2[i + 1]);
        }
        newPoints[i] = [(1 - t4) * points2[i][0] + t4 * points2[i + 1][0], (1 - t4) * points2[i][1] + t4 * points2[i + 1][1]];
      }
      decasteljauRecurse(newPoints, t4);
    }
  }
  if (points.length) {
    decasteljauRecurse(points, t);
  }
  return {
    left: left2,
    right: right2.reverse()
  };
}
function pointsToCommand(points) {
  var command = {};
  if (points.length === 4) {
    command.x2 = points[2][0];
    command.y2 = points[2][1];
  }
  if (points.length >= 3) {
    command.x1 = points[1][0];
    command.y1 = points[1][1];
  }
  command.x = points[points.length - 1][0];
  command.y = points[points.length - 1][1];
  if (points.length === 4) {
    command.type = "C";
  } else if (points.length === 3) {
    command.type = "Q";
  } else {
    command.type = "L";
  }
  return command;
}
function splitCurveAsPoints(points, segmentCount) {
  segmentCount = segmentCount || 2;
  var segments = [];
  var remainingCurve = points;
  var tIncrement = 1 / segmentCount;
  for (var i = 0; i < segmentCount - 1; i++) {
    var tRelative = tIncrement / (1 - tIncrement * i);
    var split2 = decasteljau(remainingCurve, tRelative);
    segments.push(split2.left);
    remainingCurve = split2.right;
  }
  segments.push(remainingCurve);
  return segments;
}
function splitCurve(commandStart, commandEnd, segmentCount) {
  var points = [[commandStart.x, commandStart.y]];
  if (commandEnd.x1 != null) {
    points.push([commandEnd.x1, commandEnd.y1]);
  }
  if (commandEnd.x2 != null) {
    points.push([commandEnd.x2, commandEnd.y2]);
  }
  points.push([commandEnd.x, commandEnd.y]);
  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);
}
var commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\d.e+-]+/g;
var typeMap = {
  M: ["x", "y"],
  L: ["x", "y"],
  H: ["x"],
  V: ["y"],
  C: ["x1", "y1", "x2", "y2", "x", "y"],
  S: ["x2", "y2", "x", "y"],
  Q: ["x1", "y1", "x", "y"],
  T: ["x", "y"],
  A: ["rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "x", "y"],
  Z: []
};
Object.keys(typeMap).forEach(function(key2) {
  typeMap[key2.toLowerCase()] = typeMap[key2];
});
function arrayOfLength(length, value2) {
  var array3 = Array(length);
  for (var i = 0; i < length; i++) {
    array3[i] = value2;
  }
  return array3;
}
function commandToString(command) {
  return "".concat(command.type).concat(typeMap[command.type].map(function(p) {
    return command[p];
  }).join(","));
}
function convertToSameType(aCommand, bCommand) {
  var conversionMap = {
    x1: "x",
    y1: "y",
    x2: "x",
    y2: "y"
  };
  var readFromBKeys = ["xAxisRotation", "largeArcFlag", "sweepFlag"];
  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== "M") {
    var aConverted = {};
    Object.keys(bCommand).forEach(function(bKey) {
      var bValue = bCommand[bKey];
      var aValue = aCommand[bKey];
      if (aValue === void 0) {
        if (readFromBKeys.includes(bKey)) {
          aValue = bValue;
        } else {
          if (aValue === void 0 && conversionMap[bKey]) {
            aValue = aCommand[conversionMap[bKey]];
          }
          if (aValue === void 0) {
            aValue = 0;
          }
        }
      }
      aConverted[bKey] = aValue;
    });
    aConverted.type = bCommand.type;
    aCommand = aConverted;
  }
  return aCommand;
}
function splitSegment(commandStart, commandEnd, segmentCount) {
  var segments = [];
  if (commandEnd.type === "L" || commandEnd.type === "Q" || commandEnd.type === "C") {
    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount));
  } else {
    var copyCommand = _extends({}, commandStart);
    if (copyCommand.type === "M") {
      copyCommand.type = "L";
    }
    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function() {
      return copyCommand;
    }));
    segments.push(commandEnd);
  }
  return segments;
}
function extend(commandsToExtend, referenceCommands, excludeSegment) {
  var numSegmentsToExtend = commandsToExtend.length - 1;
  var numReferenceSegments = referenceCommands.length - 1;
  var segmentRatio = numSegmentsToExtend / numReferenceSegments;
  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function(accum, d, i) {
    var insertIndex = Math.floor(segmentRatio * i);
    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {
      var addToPriorSegment = segmentRatio * i % 1 < 0.5;
      if (accum[insertIndex]) {
        if (addToPriorSegment) {
          if (insertIndex > 0) {
            insertIndex -= 1;
          } else if (insertIndex < commandsToExtend.length - 1) {
            insertIndex += 1;
          }
        } else if (insertIndex < commandsToExtend.length - 1) {
          insertIndex += 1;
        } else if (insertIndex > 0) {
          insertIndex -= 1;
        }
      }
    }
    accum[insertIndex] = (accum[insertIndex] || 0) + 1;
    return accum;
  }, []);
  var extended = countPointsPerSegment.reduce(function(extended2, segmentCount, i) {
    if (i === commandsToExtend.length - 1) {
      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1]));
      if (lastCommandCopies[0].type === "M") {
        lastCommandCopies.forEach(function(d) {
          d.type = "L";
        });
      }
      return extended2.concat(lastCommandCopies);
    }
    return extended2.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));
  }, []);
  extended.unshift(commandsToExtend[0]);
  return extended;
}
function pathCommandsFromString(d) {
  var tokens = (d || "").match(commandTokenRegex) || [];
  var commands = [];
  var commandArgs;
  var command;
  for (var i = 0; i < tokens.length; ++i) {
    commandArgs = typeMap[tokens[i]];
    if (commandArgs) {
      command = {
        type: tokens[i]
      };
      for (var a5 = 0; a5 < commandArgs.length; ++a5) {
        command[commandArgs[a5]] = +tokens[i + a5 + 1];
      }
      i += commandArgs.length;
      commands.push(command);
    }
  }
  return commands;
}
function interpolatePathCommands(aCommandsInput, bCommandsInput, interpolateOptions) {
  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();
  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();
  var _ref = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref.excludeSegment, snapEndsToInput = _ref.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return [];
    };
  }
  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === "Z") && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === "Z");
  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === "Z") {
    aCommands.pop();
  }
  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === "Z") {
    bCommands.pop();
  }
  if (!aCommands.length) {
    aCommands.push(bCommands[0]);
  } else if (!bCommands.length) {
    bCommands.push(aCommands[0]);
  }
  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);
  if (numPointsToExtend !== 0) {
    if (bCommands.length > aCommands.length) {
      aCommands = extend(aCommands, bCommands, excludeSegment);
    } else if (bCommands.length < aCommands.length) {
      bCommands = extend(bCommands, aCommands, excludeSegment);
    }
  }
  aCommands = aCommands.map(function(aCommand, i) {
    return convertToSameType(aCommand, bCommands[i]);
  });
  var interpolatedCommands = aCommands.map(function(aCommand) {
    return _objectSpread2({}, aCommand);
  });
  if (addZ) {
    interpolatedCommands.push({
      type: "Z"
    });
    aCommands.push({
      type: "Z"
    });
  }
  return function pathCommandInterpolator(t) {
    if (t === 1 && snapEndsToInput) {
      return bCommandsInput == null ? [] : bCommandsInput;
    }
    if (t === 0) {
      return aCommands;
    }
    for (var i = 0; i < interpolatedCommands.length; ++i) {
      var aCommand = aCommands[i];
      var bCommand = bCommands[i];
      var interpolatedCommand = interpolatedCommands[i];
      var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var arg = _step.value;
          interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg];
          if (arg === "largeArcFlag" || arg === "sweepFlag") {
            interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return interpolatedCommands;
  };
}
function interpolatePath(a5, b, interpolateOptions) {
  var aCommands = pathCommandsFromString(a5);
  var bCommands = pathCommandsFromString(b);
  var _ref2 = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref2.excludeSegment, snapEndsToInput = _ref2.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return "";
    };
  }
  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, {
    excludeSegment,
    snapEndsToInput
  });
  return function pathStringInterpolator(t) {
    if (t === 1 && snapEndsToInput) {
      return b == null ? "" : b;
    }
    var interpolatedCommands = commandInterpolator(t);
    var interpolatedString = "";
    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var interpolatedCommand = _step2.value;
        interpolatedString += commandToString(interpolatedCommand);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return interpolatedString;
  };
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index4 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale2(d) {
    let i = index4.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index4.set(d, i = domain.push(d) - 1);
    }
    return range4[i % range4.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index4 = new InternMap();
    for (const value2 of _) {
      if (index4.has(value2)) continue;
      index4.set(value2, domain.push(value2) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), scale2) : range4.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round3 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse4 = r1 < r0, start = reverse4 ? r1 : r0, stop2 = reverse4 ? r0 : r1;
    step = (stop2 - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round3) step = Math.floor(step);
    start += (stop2 - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round3) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values2 = range(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse4 ? values2.reverse() : values2);
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round3 = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    return arguments.length ? (round3 = !!_, rescale()) : round3;
  };
  scale2.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale2.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a5) {
  if (a5 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a5);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend2(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a5 = clampa(this.opacity);
  return `${a5 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a5 === 1 ? ")" : `, ${a5})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s3, l, a5) {
  if (a5 <= 0) h = s3 = l = NaN;
  else if (l <= 0 || l >= 1) h = s3 = NaN;
  else if (s3 <= 0) h = NaN;
  return new Hsl(h, s3, l, a5);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min7 = Math.min(r, g, b), max7 = Math.max(r, g, b), h = NaN, s3 = max7 - min7, l = (max7 + min7) / 2;
  if (s3) {
    if (r === max7) h = (g - b) / s3 + (g < b) * 6;
    else if (g === max7) h = (b - r) / s3 + 2;
    else h = (r - g) / s3 + 4;
    s3 /= l < 0.5 ? max7 + min7 : 2 - max7 - min7;
    h *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s3, l, o.opacity);
}
function hsl(h, s3, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s3, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s3, l, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend2(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m22;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
      hsl2rgb(h, m1, m22),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a5 = clampa(this.opacity);
    return `${a5 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a5 === 1 ? ")" : `, ${a5})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m22) {
  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t02 = 4 / 29;
var t12 = 6 / 29;
var t2 = 3 * t12 * t12;
var t3 = t12 * t12 * t12;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x4, z;
  if (r === g && g === b) x4 = z = y4;
  else {
    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);
}
function lab(l, a5, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a5, b, opacity == null ? 1 : opacity);
}
function Lab(l, a5, b, opacity) {
  this.l = +l;
  this.a = +a5;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend2(Color, {
  brighter(k3) {
    return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  darker(k3) {
    return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x4 = Xn * lab2xyz(x4);
    y4 = Yn * lab2xyz(y4);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t02;
}
function lab2xyz(t) {
  return t > t12 ? t * t * t : t2 * (t - t02);
}
function lrgb2rgb(x4) {
  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x4) {
  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c3, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c3, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c3, l, opacity) {
  this.h = +h;
  this.c = +c3;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend2(Color, {
  brighter(k3) {
    return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
  },
  darker(k3) {
    return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k3 = (E * (g - l) - C * bl) / D, s3 = Math.sqrt(k3 * k3 + bl * bl) / (E * l * (1 - l)), h = s3 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s3, l, o.opacity);
}
function cubehelix(h, s3, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s3, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s3, l, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend2(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a5 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a5 * (A * cosh2 + B * sinh2)),
      255 * (l + a5 * (C * cosh2 + D * sinh2)),
      255 * (l + a5 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x4) => () => x4;

// node_modules/d3-interpolate/src/color.js
function linear(a5, d) {
  return function(t) {
    return a5 + t * d;
  };
}
function exponential(a5, b, y4) {
  return a5 = Math.pow(a5, y4), b = Math.pow(b, y4) - a5, y4 = 1 / y4, function(t) {
    return Math.pow(a5 + t * b, y4);
  };
}
function hue(a5, b) {
  var d = b - a5;
  return d ? linear(a5, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a5) ? b : a5);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a5, b) {
    return b - a5 ? exponential(a5, b, y4) : constant_default3(isNaN(a5) ? b : a5);
  };
}
function nogamma(a5, b) {
  var d = b - a5;
  return d ? linear(a5, d) : constant_default3(isNaN(a5) ? b : a5);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color2 = gamma(y4);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors2[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a5, b) {
  if (!b) b = [];
  var n = a5 ? Math.min(b.length, a5.length) : 0, c3 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c3[i] = a5[i] * (1 - t) + b[i] * t;
    return c3;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a5, b) {
  var nb = b ? b.length : 0, na = a5 ? Math.min(nb, a5.length) : 0, x4 = new Array(na), c3 = new Array(nb), i;
  for (i = 0; i < na; ++i) x4[i] = value_default(a5[i], b[i]);
  for (; i < nb; ++i) c3[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c3[i] = x4[i](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a5, b) {
  var d = /* @__PURE__ */ new Date();
  return a5 = +a5, b = +b, function(t) {
    return d.setTime(a5 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a5, b) {
  return a5 = +a5, b = +b, function(t) {
    return a5 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a5, b) {
  var i = {}, c3 = {}, k3;
  if (a5 === null || typeof a5 !== "object") a5 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k3 in b) {
    if (k3 in a5) {
      i[k3] = value_default(a5[k3], b[k3]);
    } else {
      c3[k3] = b[k3];
    }
  }
  return function(t) {
    for (k3 in i) c3[k3] = i[k3](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a5, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s3 = [], q = [];
  a5 = a5 + "", b = b + "";
  while ((am = reA.exec(a5)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s3[i]) s3[i] += bs;
      else s3[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i]) s3[i] += bm;
      else s3[++i] = bm;
    } else {
      s3[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s3[i]) s3[i] += bs;
    else s3[++i] = bs;
  }
  return s3.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s3[(o = q[i2]).i] = o.x(t);
    return s3.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a5, b) {
  var t = typeof b, c3;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c3 = color(b)) ? (b = c3, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a5, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default2(a5, b) {
  return a5 = +a5, b = +b, function(t) {
    return Math.round(a5 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a5, b, c3, d, e, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a5 * a5 + b * b)) a5 /= scaleX, b /= scaleX;
  if (skewX = a5 * c3 + b * d) c3 -= a5 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d * d)) c3 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a5 * d < b * c3) a5 = -a5, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f2,
    rotate: Math.atan2(b, a5) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m3.isIdentity ? identity3 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity3;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity3;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop2(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a5, b, s3, q) {
    if (a5 !== b) {
      if (a5 - b > 180) b += 360;
      else if (b - a5 > 180) a5 += 360;
      q.push({ i: s3.push(pop2(s3) + "rotate(", null, degParen) - 2, x: number_default(a5, b) });
    } else if (b) {
      s3.push(pop2(s3) + "rotate(" + b + degParen);
    }
  }
  function skewX(a5, b, s3, q) {
    if (a5 !== b) {
      q.push({ i: s3.push(pop2(s3) + "skewX(", null, degParen) - 2, x: number_default(a5, b) });
    } else if (b) {
      s3.push(pop2(s3) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push(pop2(s3) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop2(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a5, b) {
    var s3 = [], q = [];
    a5 = parse2(a5), b = parse2(b);
    translate(a5.translateX, a5.translateY, b.translateX, b.translateY, s3, q);
    rotate(a5.rotate, b.rotate, s3, q);
    skewX(a5.skewX, b.skewX, s3, q);
    scale2(a5.scaleX, a5.scaleY, b.scaleX, b.scaleY, s3, q);
    a5 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s3[(o = q[i]).i] = o.x(t);
      return s3.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon22 = 1e-12;
function cosh(x4) {
  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
}
function sinh(x4) {
  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
}
function tanh(x4) {
  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s3 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
        return [
          ux0 + u4 * dx,
          uy0 + u4 * dy,
          w0 * coshr0 / cosh(rho * s3 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s3(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c3 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c3(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s3(t);
        start.l = l(Math.pow(t, y4));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x4) {
  return +x4;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity4(x4) {
  return x4;
}
function normalize(a5, b) {
  return (b -= a5 = +a5) ? function(x4) {
    return (x4 - a5) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a5, b) {
  var t;
  if (a5 > b) t = a5, a5 = b, b = t;
  return function(x4) {
    return Math.max(a5, Math.min(b, x4));
  };
}
function bimap(domain, range4, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range4, interpolate) {
  var j = Math.min(domain.length, range4.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range4[i], range4[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j) - 1;
    return r[i2](d[i2](x4));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range4 = unit, interpolate = value_default, transform2, untransform, unknown, clamp3 = identity4, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range4.length);
    if (clamp3 !== identity4) clamp3 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range4, interpolate)))(transform2(clamp3(x4)));
  }
  scale2.invert = function(y4) {
    return clamp3(untransform((input || (input = piecewise2(range4, domain.map(transform2), number_default)))(y4)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range4 = Array.from(_), rescale()) : range4.slice();
  };
  scale2.rangeRound = function(_) {
    return range4 = Array.from(_), interpolate = round_default2, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp3 = _ ? true : identity4, rescale()) : clamp3 !== identity4;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t, u4) {
    transform2 = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity4, identity4);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p) {
  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x4.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x4.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value2.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out: for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s3[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s3[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p) => (x4 * 100).toFixed(p),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p) => x4.toExponential(p),
  "f": (x4, p) => x4.toFixed(p),
  "g": (x4, p) => x4.toPrecision(p),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p) => formatRounded_default(x4 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x4) {
  return x4;
}

// node_modules/d3-format/src/locale.js
var map4 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default3 : formatGroup_default(map4.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default3 : formatNumerals_default(map4.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "−" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign5 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero3 || fill2 === "0" && align === "=") zero3 = true, fill2 = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c3;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim2) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign5 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c3 = value2.charCodeAt(i), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value2 = group3(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill2) : "";
      if (comma && zero3) value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value2) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k3 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f2(k3 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale2;
var format2;
var formatPrefix;
defaultLocale3({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale3(definition) {
  locale2 = locale_default(definition);
  format2 = locale2.format;
  formatPrefix = locale2.formatPrefix;
  return locale2;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max7) {
  step = Math.abs(step), max7 = Math.abs(max7) - step;
  return Math.max(0, exponent_default(max7) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop2, count4, specifier) {
  var step = tickStep(start, stop2, count4), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop2))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format2(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count4) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count4 == null ? 10 : count4);
  };
  scale2.tickFormat = function(count4, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count4 == null ? 10 : count4, specifier);
  };
  scale2.nice = function(count4) {
    if (count4 == null) count4 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop2, count4);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear2() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear2());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x06);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x4) {
    return x4 < 0 ? -Math.pow(-x4, exponent) : Math.pow(x4, exponent);
  };
}
function transformSqrt(x4) {
  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);
}
function transformSquare(x4) {
  return x4 < 0 ? -x4 * x4 : x4 * x4;
}
function powish(transform2) {
  var scale2 = transform2(identity4, identity4), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity4, identity4) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale2);
}
function pow() {
  var scale2 = powish(transformer());
  scale2.copy = function() {
    return copy(scale2, pow()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt2() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format3) {
  var scale2 = continuous(), invert2 = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale2.invert = function(y4) {
    return new Date(invert2(y4));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number3)) : domain().map(date);
  };
  scale2.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count4, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale2.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format3));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/mimic-function/index.js
var copyProperty = (to, from, property2, ignoreNonConfigurable) => {
  if (property2 === "length" || property2 === "prototype") {
    return;
  }
  if (property2 === "arguments" || property2 === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property2);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property2);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property2, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  const { writable: writable2, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, "toString", { value: newToString, writable: writable2, enumerable, configurable });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property2 of Reflect.ownKeys(from)) {
    copyProperty(to, from, property2, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/memoize/distribution/index.js
var cacheStore = /* @__PURE__ */ new WeakMap();
var cacheTimerStore = /* @__PURE__ */ new WeakMap();
function memoize2(function_, { cacheKey, cache = /* @__PURE__ */ new Map(), maxAge } = {}) {
  if (maxAge === 0) {
    return function_;
  }
  if (typeof maxAge === "number") {
    const maxSetIntervalValue = 2147483647;
    if (maxAge > maxSetIntervalValue) {
      throw new TypeError(`The \`maxAge\` option cannot exceed ${maxSetIntervalValue}.`);
    }
    if (maxAge < 0) {
      throw new TypeError("The `maxAge` option should not be a negative number.");
    }
  }
  const memoized = function(...arguments_) {
    const key2 = cacheKey ? cacheKey(arguments_) : arguments_[0];
    const cacheItem = cache.get(key2);
    if (cacheItem) {
      return cacheItem.data;
    }
    const result2 = function_.apply(this, arguments_);
    const computedMaxAge = typeof maxAge === "function" ? maxAge(...arguments_) : maxAge;
    cache.set(key2, {
      data: result2,
      maxAge: computedMaxAge ? Date.now() + computedMaxAge : Number.POSITIVE_INFINITY
    });
    if (computedMaxAge && computedMaxAge > 0 && computedMaxAge !== Number.POSITIVE_INFINITY) {
      const timer2 = setTimeout(() => {
        cache.delete(key2);
      }, computedMaxAge);
      timer2.unref?.();
      const timers = cacheTimerStore.get(function_) ?? /* @__PURE__ */ new Set();
      timers.add(timer2);
      cacheTimerStore.set(function_, timers);
    }
    return result2;
  };
  mimicFunction(memoized, function_, {
    ignoreNonConfigurable: true
  });
  cacheStore.set(memoized, cache);
  return memoized;
}

// node_modules/layerchart/dist/utils/string.js
var MEASUREMENT_ELEMENT_ID = "__text_measurement_id";
function _getStringWidth(str, style) {
  try {
    let textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);
    if (!textEl) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.position = "absolute";
      svg.style.top = "-100%";
      svg.style.left = "-100%";
      textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.setAttribute("id", MEASUREMENT_ELEMENT_ID);
      svg.appendChild(textEl);
      document.body.appendChild(svg);
    }
    Object.assign(textEl.style, style);
    textEl.textContent = str;
    return textEl.getComputedTextLength();
  } catch (e) {
    return null;
  }
}
var getStringWidth = memoize2(_getStringWidth, {
  cacheKey: ([str, style]) => `${str}_${JSON.stringify(style)}`
});
function toTitleCase(str) {
  return str.replace(/^\w/, (d) => d.toUpperCase());
}
var DEFAULT_ELLIPSIS = "…";
function truncateText(text2, { position = "end", ellipsis = DEFAULT_ELLIPSIS, maxWidth, style, maxChars }) {
  if (!text2)
    return "";
  if (maxWidth === void 0 && maxChars === void 0)
    return text2;
  let workingText = text2;
  if (maxChars !== void 0 && text2.length > maxChars) {
    if (position === "start") {
      workingText = ellipsis + text2.slice(-maxChars);
    } else if (position === "middle") {
      const half = Math.floor(maxChars / 2);
      workingText = text2.slice(0, half) + ellipsis + text2.slice(-half);
    } else {
      workingText = text2.slice(0, maxChars) + ellipsis;
    }
  }
  if (maxWidth !== void 0) {
    const fullWidth = getStringWidth(workingText, style);
    if (fullWidth === null || fullWidth <= maxWidth)
      return workingText;
    const ellipsisWidth = getStringWidth(ellipsis, style) ?? 0;
    let availableWidth = maxWidth - ellipsisWidth;
    if (position === "start") {
      let truncated = workingText.slice(ellipsis.length);
      let truncatedWidth = getStringWidth(truncated, style);
      while (truncatedWidth !== null && truncatedWidth > availableWidth && truncated.length > 0) {
        truncated = truncated.slice(1);
        truncatedWidth = getStringWidth(truncated, style);
      }
      return ellipsis + truncated;
    } else if (position === "middle") {
      const halfWidth = availableWidth / 2;
      let left2 = "";
      let right2 = "";
      let bestLeft = "";
      let bestRight = "";
      for (let i = 0, j = workingText.length - 1; i < workingText.length && j >= 0; i++, j--) {
        const leftTest = workingText.slice(0, i + 1);
        const rightTest = workingText.slice(j);
        const leftWidth = getStringWidth(leftTest, style);
        const rightWidth = getStringWidth(rightTest, style);
        if (leftWidth !== null && leftWidth <= halfWidth)
          left2 = leftTest;
        if (rightWidth !== null && rightWidth <= halfWidth)
          right2 = rightTest;
        const combinedWidth = getStringWidth(left2 + ellipsis + right2, style);
        if (combinedWidth !== null && combinedWidth <= maxWidth) {
          bestLeft = left2;
          bestRight = right2;
        } else {
          break;
        }
      }
      return bestLeft + ellipsis + bestRight;
    } else {
      let truncated = workingText.slice(0, -ellipsis.length);
      let truncatedWidth = getStringWidth(truncated + ellipsis, style);
      while (truncatedWidth !== null && truncatedWidth > maxWidth && truncated.length > 0) {
        truncated = truncated.slice(0, -1);
        truncatedWidth = getStringWidth(truncated + ellipsis, style);
      }
      return truncated + ellipsis;
    }
  }
  return workingText;
}

// node_modules/layerchart/dist/utils/array.js
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((k3) => {
    return arr2.includes(k3);
  });
}
function applyLanes(data, options = {
  start: "start",
  end: "end"
}) {
  const result2 = [];
  let stack = [];
  const startAccessor = accessor(options.start);
  const endAccessor = accessor(options.end);
  for (const d of data) {
    let lane = stack.findIndex((s3) => endAccessor(s3) <= startAccessor(d) && startAccessor(s3) < startAccessor(d));
    if (lane === -1) {
      lane = stack.length;
    }
    result2.push({ ...d, lane });
    stack[lane] = d;
  }
  return result2;
}

// node_modules/layerchart/dist/utils/chart.js
function calcDomain(s3, extents, domain) {
  return extents ? partialDomain(extents[s3], domain) : domain;
}
function partialDomain(domain = [], directive) {
  if (Array.isArray(directive) === true) {
    return directive.map((d, i) => {
      if (d === null) {
        return domain[i];
      }
      return d;
    });
  }
  return domain;
}
function createChartScale(axis, { domain, scale: scale2, padding, nice: nice4, reverse: reverse4, width, height, range: range4, percentRange }) {
  const defaultRange = getDefaultRange(axis, width, height, reverse4, range4, percentRange);
  const trueScale = scale2.copy();
  trueScale.domain(domain);
  if (!trueScale.interpolator || typeof trueScale.interpolator === "function" && trueScale.interpolator().name.startsWith("identity")) {
    trueScale.range(defaultRange);
  }
  if (padding) {
    trueScale.domain(padScale(trueScale, padding));
  }
  if (nice4 === true || typeof nice4 === "number") {
    if (typeof trueScale.nice === "function") {
      trueScale.nice(typeof nice4 === "number" ? nice4 : void 0);
    } else {
      console.error(`[Layer Chart] You set \`${axis}Nice: true\` but the ${axis}Scale does not have a \`.nice\` method. Ignoring...`);
    }
  }
  return trueScale;
}
var unpaddable = ["scaleThreshold", "scaleQuantile", "scaleQuantize", "scaleSequentialQuantile"];
function padScale(scale2, padding) {
  if (typeof scale2.range !== "function") {
    throw new Error("Scale method `range` must be a function");
  }
  if (typeof scale2.domain !== "function") {
    throw new Error("Scale method `domain` must be a function");
  }
  if (!Array.isArray(padding) || unpaddable.includes(findScaleName(scale2))) {
    return scale2.domain();
  }
  if (isOrdinalDomain(scale2) === true)
    return scale2.domain();
  const { lift, ground } = getPadFunctions(scale2);
  const d0 = scale2.domain()[0];
  const isTime = Object.prototype.toString.call(d0) === "[object Date]";
  const [d1, d2] = scale2.domain().map((d) => {
    return isTime ? lift(d.getTime()) : lift(d);
  });
  const [r1, r2] = scale2.range();
  const paddingLeft = padding[0] || 0;
  const paddingRight = padding[1] || 0;
  const step = (d2 - d1) / (Math.abs(r2 - r1) - paddingLeft - paddingRight);
  return [d1 - paddingLeft * step, paddingRight * step + d2].map((d) => {
    return isTime ? ground(new Date(d).getTime()) : ground(d);
  });
}
function f(name, modifier = "") {
  return `scale${toTitleCase(modifier)}${toTitleCase(name)}`;
}
function findScaleName(scale2) {
  if (typeof scale2.bandwidth === "function") {
    if (typeof scale2.paddingInner === "function") {
      return f("band");
    }
    return f("point");
  }
  if (arraysEqual(Object.keys(scale2), ["domain", "range", "unknown", "copy"])) {
    return f("ordinal");
  }
  let modifier = "";
  if (scale2.interpolator) {
    if (scale2.domain().length === 3) {
      modifier = "diverging";
    } else {
      modifier = "sequential";
    }
  }
  if (scale2.quantiles) {
    return f("quantile", modifier);
  }
  if (scale2.thresholds) {
    return f("quantize", modifier);
  }
  if (scale2.constant) {
    return f("symlog", modifier);
  }
  if (scale2.base) {
    return f("log", modifier);
  }
  if (scale2.exponent) {
    if (scale2.exponent() === 0.5) {
      return f("sqrt", modifier);
    }
    return f("pow", modifier);
  }
  if (arraysEqual(Object.keys(scale2), ["domain", "range", "invertExtent", "unknown", "copy"])) {
    return f("threshold");
  }
  if (arraysEqual(Object.keys(scale2), [
    "invert",
    "range",
    "domain",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("identity");
  }
  if (arraysEqual(Object.keys(scale2), [
    "invert",
    "domain",
    "range",
    "rangeRound",
    "round",
    "clamp",
    "unknown",
    "copy",
    "ticks",
    "tickFormat",
    "nice"
  ])) {
    return f("radial");
  }
  if (modifier) {
    return f(modifier);
  }
  if (scale2.domain()[0] instanceof Date) {
    const d = /* @__PURE__ */ new Date();
    let s3 = "";
    d.getDay = () => s3 = "time";
    d.getUTCDay = () => s3 = "utc";
    scale2.tickFormat(0, "%a")(d);
    return f(s3);
  }
  return f("linear");
}
function isOrdinalDomain(scale2) {
  if (typeof scale2.bandwidth === "function")
    return true;
  if (arraysEqual(Object.keys(scale2), ["domain", "range", "unknown", "copy"])) {
    return true;
  }
  return false;
}
function calcScaleExtents(flatData, getters, activeScales) {
  const scaleGroups = Object.entries(activeScales).reduce((groups3, [key2, scaleInfo]) => {
    const domainType = isOrdinalDomain(scaleInfo.scale) === true ? "ordinal" : "other";
    if (!groups3[domainType]) {
      groups3[domainType] = {};
    }
    groups3[domainType][key2] = getters[key2];
    return groups3;
  }, { ordinal: false, other: false });
  let extents = {};
  if (scaleGroups.ordinal) {
    const sortOptions = Object.fromEntries(Object.entries(activeScales).map(([key2, scaleInfo]) => [key2, scaleInfo.sort]));
    extents = calcUniques(flatData, scaleGroups.ordinal, sortOptions);
  }
  if (scaleGroups.other) {
    const otherExtents = calcExtents(flatData, scaleGroups.other);
    extents = { ...extents, ...otherExtents };
  }
  return extents;
}
function calcUniques(data, fields, sortOptions = {}) {
  if (!Array.isArray(data)) {
    throw new TypeError(`The first argument of calcUniques() must be an array. You passed in a ${typeof data}. If you got this error using the <Chart> component, consider passing a flat array to the \`flatData\` prop`);
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError("The second argument of calcUniques() must be an object with field names as keys and accessor functions as values.");
  }
  const uniques = {};
  const keys3 = Object.keys(fields);
  for (const key2 of keys3) {
    const set5 = new InternSet();
    const accessor2 = fields[key2];
    if (!accessor2)
      continue;
    for (const item of data) {
      const value2 = accessor2(item);
      if (Array.isArray(value2)) {
        for (const val of value2) {
          set5.add(val);
        }
      } else {
        set5.add(value2);
      }
    }
    const results = Array.from(set5);
    if (sortOptions.sort === true || sortOptions[key2] === true) {
      results.sort((a5, b) => {
        if (typeof a5 === "number" && typeof b === "number") {
          return a5 - b;
        }
        return String(a5).localeCompare(String(b));
      });
    }
    uniques[key2] = results;
  }
  return uniques;
}
function calcBaseRange(s3, width, height, reverse4, percentRange) {
  let min7;
  let max7;
  if (percentRange === true) {
    min7 = 0;
    max7 = 100;
  } else {
    min7 = s3 === "r" ? 1 : 0;
    max7 = s3 === "y" ? height : s3 === "r" ? 25 : width;
  }
  return reverse4 === true ? [max7, min7] : [min7, max7];
}
function getDefaultRange(s3, width, height, reverse4, range4, percentRange = false) {
  return !range4 ? calcBaseRange(s3, width, height, reverse4, percentRange) : typeof range4 === "function" ? range4({ width, height }) : range4;
}
function identity6(d) {
  return d;
}
function findScaleType(scale2) {
  if (scale2.constant) {
    return "symlog";
  }
  if (scale2.base) {
    return "log";
  }
  if (typeof scale2.exponent === "function") {
    const expValue = scale2.exponent();
    if (expValue === 0.5) {
      return "sqrt";
    }
    return "pow";
  }
  return "other";
}
function log2(sign5) {
  return (x4) => Math.log(sign5 * x4);
}
function exp(sign5) {
  return (x4) => sign5 * Math.exp(x4);
}
function symlog2(c3) {
  return (x4) => Math.sign(x4) * Math.log1p(Math.abs(x4 / c3));
}
function symexp(c3) {
  return (x4) => Math.sign(x4) * Math.expm1(Math.abs(x4)) * c3;
}
function pow2(exponent) {
  return function powFn(x4) {
    return x4 < 0 ? -Math.pow(-x4, exponent) : Math.pow(x4, exponent);
  };
}
function getPadFunctions(scale2) {
  const scaleType = findScaleType(scale2);
  switch (scaleType) {
    case "log": {
      const domain = scale2.domain();
      const sign5 = Math.sign(domain[0]);
      return { lift: log2(sign5), ground: exp(sign5), scaleType };
    }
    case "pow": {
      const exponent = 1;
      return {
        lift: pow2(exponent),
        ground: pow2(1 / exponent),
        scaleType
      };
    }
    case "sqrt": {
      const exponent = 0.5;
      return {
        lift: pow2(exponent),
        ground: pow2(1 / exponent),
        scaleType
      };
    }
    case "symlog": {
      const constant5 = 1;
      return {
        lift: symlog2(constant5),
        ground: symexp(constant5),
        scaleType
      };
    }
    default:
      return {
        lift: identity6,
        ground: identity6,
        scaleType
      };
  }
}
function createGetter(accessor2, scale2) {
  return (d) => {
    const val = accessor2(d);
    if (!scale2)
      return void 0;
    if (Array.isArray(val)) {
      return val.map((v2) => scale2(v2));
    }
    return scale2(val);
  };
}
function calcExtents(data, fields) {
  if (!Array.isArray(data)) {
    throw new TypeError(`The first argument of calcExtents() must be an array. You passed in a ${typeof data}. If you got this error using the <Chart> component, consider passing a flat array to the \`flatData\` prop.`);
  }
  if (Array.isArray(fields) || fields === void 0 || fields === null) {
    throw new TypeError("The second argument of calcExtents() must be an object with field names as keys as accessor functions as values.");
  }
  const extents = {};
  const keys3 = Object.keys(fields);
  const kl = keys3.length;
  let i;
  let j;
  let k3;
  let s3;
  let min7;
  let max7;
  let acc;
  let val;
  const dl = data.length;
  for (i = 0; i < kl; i += 1) {
    s3 = keys3[i];
    acc = fields[s3];
    min7 = null;
    max7 = null;
    if (!acc)
      continue;
    for (j = 0; j < dl; j += 1) {
      val = acc(data[j]);
      if (Array.isArray(val)) {
        const vl = val.length;
        for (k3 = 0; k3 < vl; k3 += 1) {
          if (val[k3] !== void 0 && val[k3] !== null && (typeof val[k3] === "string" || Number.isNaN(val[k3]) === false)) {
            if (min7 === null || val[k3] < min7) {
              min7 = val[k3];
            }
            if (max7 === null || val[k3] > max7) {
              max7 = val[k3];
            }
          }
        }
      } else if (val !== void 0 && val !== null && (typeof val === "string" || Number.isNaN(val) === false)) {
        if (min7 === null || val < min7) {
          min7 = val;
        }
        if (max7 === null || val > max7) {
          max7 = val;
        }
      }
    }
    extents[s3] = [min7, max7];
  }
  return extents;
}
function raise(node) {
  if (node.nextSibling) {
    node.parentNode?.appendChild(node);
  }
}

// node_modules/layerchart/dist/utils/debug.js
var indent = "    ";
function printObject(obj) {
  Object.entries(obj).forEach(([key2, value2]) => {
    console.log(`${indent}${key2}:`, value2);
  });
}
function getRgb(clr) {
  const { r, g, b, opacity: o } = rgb(clr);
  if (![r, g, b].every((c3) => c3 >= 0 && c3 <= 255)) {
    return false;
  }
  return { r, g, b, o };
}
function printValues(scale2, method2, extraSpace = "") {
  const values2 = scale2[method2]();
  const colorValues = colorizeArray(values2);
  if (colorValues) {
    printColorArray(colorValues, method2, values2);
  } else {
    console.log(`${indent}${indent}${toTitleCase(method2)}:${extraSpace}`, values2);
  }
}
function printColorArray(colorValues, method2, values2) {
  console.log(`${indent}${indent}${toTitleCase(method2)}:    %cArray%c(${values2.length}) ` + colorValues[0] + "%c ]", "color: #1377e4", "color: #737373", "color: #1478e4", ...colorValues[1], "color: #1478e4");
}
function colorizeArray(arr) {
  const colors2 = [];
  const a5 = arr.map((d, i) => {
    const rgbo = getRgb(d);
    if (rgbo !== false) {
      colors2.push(rgbo);
      const space = i === arr.length - 1 ? " " : "";
      return `%c ${d}${space}`;
    }
    return d;
  });
  if (colors2.length) {
    return [
      `%c[ ${a5.join(", ")}`,
      colors2.map((d) => `background-color: rgba(${d.r}, ${d.g}, ${d.b}, ${d.o}); color:${contrast(d)};`)
    ];
  }
  return null;
}
function printScale(s3, scale2, acc) {
  const scaleName = findScaleName(scale2);
  console.log(`${indent}${s3}:`);
  console.log(`${indent}${indent}Accessor: "${acc.toString()}"`);
  console.log(`${indent}${indent}Type: ${scaleName}`);
  printValues(scale2, "domain");
  printValues(scale2, "range", " ");
}
function contrast({ r, g, b }) {
  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
  return luminance > 0.6 ? "black" : "white";
}
function printDebug(obj) {
  console.log("/********* LayerChart Debug ************/");
  console.log("Bounding box:");
  printObject(obj.boundingBox);
  console.log("Data:");
  console.log(indent, obj.data);
  if (obj.flatData) {
    console.log("flatData:");
    console.log(indent, obj.flatData);
  }
  console.log("Scales:");
  Object.keys(obj.activeGetters).forEach((g) => {
    printScale(g, obj[`${g}Scale`], obj[g]);
  });
  console.log("/************ End LayerChart Debug ***************/\n");
}

// node_modules/layerchart/dist/utils/filterObject.js
function filterObject(obj, comparisonObj = {}) {
  return Object.fromEntries(Object.entries(obj).filter(([key2, value2]) => {
    return value2 !== void 0 && comparisonObj[key2] === void 0;
  }));
}

// node_modules/layerchart/dist/utils/scales.svelte.js
function isAnyScale(scale2) {
  return strict_equals(typeof scale2, "function") && strict_equals(typeof scale2.range, "function");
}
function isScaleBand(scale2) {
  return strict_equals(typeof scale2.bandwidth, "function");
}
function isScaleTime(scale2) {
  const domain = scale2.domain();
  return domain[0] instanceof Date || domain[1] instanceof Date;
}
function getRange(scale2) {
  if (isAnyScale(scale2)) {
    return scale2.range();
  }
  console.error("[LayerChart] Your scale doesn't have a `.range` method?");
  return [];
}
function createMotionScale(scale2, motion, options) {
  const domain = createControlledMotion(options.defaultDomain, motion);
  const range4 = createControlledMotion(options.defaultRange, motion);
  const motionScale = tag(
    user_derived(() => {
      const scaleInstance = scale2.domain ? scale2 : scale2();
      if (domain.current) {
        scaleInstance.domain(domain.current);
      }
      if (range4.current) {
        scaleInstance.range(range4.current);
      }
      return scaleInstance;
    }),
    "motionScale"
  );
  return {
    get current() {
      return get(motionScale);
    },
    domain: (values2) => domain.set(values2),
    range: (values2) => range4.set(values2)
  };
}
function scaleBandInvert(scale2) {
  const domain = scale2.domain();
  const eachBand = scale2.step();
  const paddingOuter = eachBand * (scale2.paddingOuter?.() ?? scale2.padding());
  return function(value2) {
    const index4 = Math.floor((value2 - paddingOuter / 2) / eachBand);
    return domain[Math.max(0, Math.min(index4, domain.length - 1))];
  };
}
function scaleInvert(scale2, value2) {
  if (isScaleBand(scale2)) {
    return scaleBandInvert(scale2)(value2);
  } else {
    return scale2.invert?.(value2);
  }
}
function createScale(scale2, domain, range4, context) {
  const scaleCopy = scale2.copy();
  if (domain) {
    scaleCopy.domain(domain);
  }
  if (strict_equals(typeof range4, "function")) {
    scaleCopy.range(range4(context));
  } else {
    scaleCopy.range(range4);
  }
  return scaleCopy;
}
function canBeZero(val) {
  if (strict_equals(val, 0)) return true;
  return val;
}
function makeAccessor(acc) {
  if (!canBeZero(acc)) return null;
  if (Array.isArray(acc)) {
    return (d) => acc.map((k3) => {
      return strict_equals(typeof k3, "function", false) ? d[k3] : k3(d);
    });
  } else if (strict_equals(typeof acc, "function", false)) {
    return (d) => d[acc];
  }
  return acc;
}

// node_modules/layerchart/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/layerchart/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2?.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/layerchart/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update2) => {
      const cleanupFocusIn = on(window2, "focusin", update2);
      const cleanupFocusOut = on(window2, "focusout", update2);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/layerchart/node_modules/runed/dist/internal/utils/is.js
function isFunction2(value2) {
  return typeof value2 === "function";
}

// node_modules/layerchart/node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value2, defaultValue) {
  if (isFunction2(value2)) {
    const getter = value2;
    const gotten = getter();
    if (strict_equals(gotten, void 0)) return defaultValue;
    return gotten;
  }
  if (strict_equals(value2, void 0)) return defaultValue;
  return value2;
}

// node_modules/layerchart/node_modules/runed/dist/utilities/context/context.js
var Context = class {
  #name;
  #key;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    this.#name = name;
    this.#key = Symbol(name);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#key;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(this.#key);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(this.#key);
    if (context === void 0) {
      throw new Error(`Context "${this.#name}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(this.#key);
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(this.#key, context);
  }
};

// node_modules/layerchart/node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait) {
  let context = tag(state(null), "context");
  const wait$ = tag(user_derived(() => extract(wait, 250)), "wait$");
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject2;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject2 = rej;
      });
      set(context, { timeout: null, runner: null, promise, resolve, reject: reject2 }, true);
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve((await track_reactivity_loss(callback.apply(this, args)))());
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, get(wait$));
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    if (!get(context) || !get(context).timeout) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    (await track_reactivity_loss(get(context).runner?.()))();
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      return !!get(context)?.timeout;
    }
  });
  return debounced;
}

// node_modules/layerchart/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values2 = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values2;
      return;
    }
    const cleanup = untrack(() => effect(values2, previousValues));
    previousValues = values2;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop2 = false;
    runWatcher(
      sources,
      flush,
      (values2, previousValues) => {
        if (stop2) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values2, previousValues);
        stop2 = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/layerchart/node_modules/runed/dist/utilities/use-mutation-observer/use-mutation-observer.svelte.js
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow } = options;
  let observer;
  const targets = tag(
    user_derived(() => {
      const value2 = extract(target);
      return new Set(value2 ? Array.isArray(value2) ? value2 : [value2] : []);
    }),
    "targets"
  );
  const stop2 = effect_root(() => {
    user_effect(() => {
      if (!get(targets).size || !window2) return;
      observer = new window2.MutationObserver(callback);
      for (const el of get(targets)) observer.observe(el, options);
      return () => {
        observer?.disconnect();
        observer = void 0;
      };
    });
  });
  user_effect(() => {
    return stop2;
  });
  return {
    stop: stop2,
    takeRecords() {
      return observer?.takeRecords();
    }
  };
}

// node_modules/layerchart/node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce2(fn, delay2) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result2 = (await track_reactivity_loss(fn(...args)))();
          if (lastResolve) {
            lastResolve(result2);
            lastResolve = null;
          }
        },
        delay2
      );
    });
  };
}
function throttle2(fn, delay2) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now3 = Date.now();
    if (lastRun && now3 - lastRun < delay2) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now3;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once: once2 = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value2, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup(() => controller.abort());
      const result2 = (await track_reactivity_loss(fetcher(value2, previousValue, {
        data: get(current),
        refetching,
        onCleanup,
        signal: controller.signal
      })))();
      set(current, result2, true);
      return result2;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce2(baseFetcher, debounceTime) : throttleTime ? throttle2(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values2, previousValues) => {
      if (once2 && prevValues) {
        return;
      }
      prevValues = values2;
      runFetcher(Array.isArray(source) ? values2 : values2[0], Array.isArray(source) ? previousValues : previousValues?.[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value2) => {
      set(current, value2, true);
    },
    refetch: (info) => {
      const values2 = sources.map((s3) => s3());
      return runFetcher(Array.isArray(source) ? values2 : values2[0], Array.isArray(source) ? values2 : values2[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s3) => s3());
    watch(
      getters,
      (values2, previousValues) => {
        fn(values2, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s3) => s3());
    watch.pre(
      getter,
      (values2, previousValues) => {
        fn(values2, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/layerchart/dist/utils/attributes.js
function layerClass(layerName) {
  return `lc-${layerName}`;
}
function isObjectWithClass(val) {
  return typeof val === "object" && val !== null && typeof val !== "function";
}
function extractLayerProps(props, layerName, extraClasses) {
  const className = layerClass(layerName);
  if (isObjectWithClass(props)) {
    return {
      ...props,
      class: cls(className, props.class ?? "", extraClasses)
    };
  }
  return {
    class: cls(className, extraClasses)
  };
}

// node_modules/layerchart/dist/components/TransformContext.svelte
TransformContext[FILENAME] = "node_modules/layerchart/dist/components/TransformContext.svelte";
var DEFAULT_TRANSLATE = { x: 0, y: 0 };
var DEFAULT_SCALE = 1;
var _TransformContext = new Context("TransformContext");
function createDefaultTransformContext() {
  let defaultTranslate2 = tag(state(proxy(DEFAULT_TRANSLATE)), "defaultTranslate");
  let defaultScale2 = tag(state(DEFAULT_SCALE), "defaultScale");
  const defaultContext2 = {
    mode: "none",
    get scale() {
      return get(defaultScale2);
    },
    setScale: (value2) => {
      set(defaultScale2, value2, true);
    },
    get translate() {
      return get(defaultTranslate2);
    },
    setTranslate: (value2) => {
      set(defaultTranslate2, value2, true);
    },
    moving: false,
    dragging: false,
    scrollMode: "none",
    setScrollMode: () => {
    },
    reset: () => {
    },
    zoomIn: () => {
    },
    zoomOut: () => {
    },
    translateCenter: () => {
    },
    zoomTo: () => {
    }
  };
  return defaultContext2;
}
function getTransformContext() {
  return _TransformContext.getOr(createDefaultTransformContext());
}
function setTransformContext(transform2) {
  return _TransformContext.set(transform2);
}
var root2 = add_locations(from_html(`<div><!></div>`), TransformContext[FILENAME], [[506, 0]]);
function TransformContext($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TransformContext);
  let mode2 = prop($$props, "mode", 3, "none"), processTranslate = prop($$props, "processTranslate", 3, (x4, y4, deltaX, deltaY) => ({ x: x4 + deltaX, y: y4 + deltaY })), disablePointer = prop($$props, "disablePointer", 3, false), initialScrollMode = prop($$props, "initialScrollMode", 3, "none"), clickDistance = prop($$props, "clickDistance", 3, 10), ondragend = prop($$props, "ondragend", 3, () => {
  }), ondragstart = prop($$props, "ondragstart", 3, () => {
  }), onTransform = prop($$props, "onTransform", 3, () => {
  }), onwheel = prop($$props, "onwheel", 3, () => {
  }), onpointerdown = prop($$props, "onpointerdown", 3, () => {
  }), onpointermove = prop($$props, "onpointermove", 3, () => {
  }), ontouchmove = prop($$props, "ontouchmove", 3, () => {
  }), onpointerup = prop($$props, "onpointerup", 3, () => {
  }), ondblclick = prop($$props, "ondblclick", 3, () => {
  }), onclickcapture = prop($$props, "onclickcapture", 3, () => {
  }), refProp = prop($$props, "ref", 15), transformContext = prop($$props, "transformContext", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "mode",
      "motion",
      "processTranslate",
      "disablePointer",
      "initialScrollMode",
      "clickDistance",
      "ondragend",
      "ondragstart",
      "onTransform",
      "initialTranslate",
      "initialScale",
      "onwheel",
      "onpointerdown",
      "onpointermove",
      "ontouchmove",
      "onpointerup",
      "ondblclick",
      "onclickcapture",
      "ref",
      "children",
      "class",
      "transformContext"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  transformContext({
    get mode() {
      return mode2();
    },
    get scale() {
      return scale2.current;
    },
    setScale,
    get translate() {
      return translate.current;
    },
    setTranslate,
    get dragging() {
      return get(dragging);
    },
    get moving() {
      return get(moving);
    },
    reset: reset2,
    zoomIn,
    zoomOut,
    translateCenter,
    zoomTo,
    get scrollMode() {
      return get(scrollMode);
    },
    setScrollMode
  });
  const ctx = getChartContext();
  let pointerDown = false;
  let dragging = tag(state(false), "dragging");
  let scrollMode = tag(state(proxy(initialScrollMode())), "scrollMode");
  const resolvedMotion = parseMotionProp($$props.motion);
  const translate = createControlledMotion($$props.initialTranslate ?? DEFAULT_TRANSLATE, resolvedMotion);
  const scale2 = createControlledMotion($$props.initialScale ?? DEFAULT_SCALE, resolvedMotion);
  let startPoint = { x: 0, y: 0 };
  let startTranslate = { x: 0, y: 0 };
  function setScrollMode(mode3) {
    set(scrollMode, mode3, true);
  }
  function reset2() {
    translate.target = $$props.initialTranslate ?? DEFAULT_TRANSLATE;
    scale2.target = $$props.initialScale ?? DEFAULT_SCALE;
  }
  function zoomIn() {
    scaleTo(1.25, {
      x: (ctx.width + ctx.padding.left) / 2,
      y: (ctx.height + ctx.padding.top) / 2
    });
  }
  function zoomOut() {
    scaleTo(0.8, {
      x: (ctx.width + ctx.padding.left) / 2,
      y: (ctx.height + ctx.padding.top) / 2
    });
  }
  function translateCenter() {
    translate.target = { x: 0, y: 0 };
  }
  function zoomTo(center2, rect) {
    const newScale = rect ? ctx.width < ctx.height ? ctx.width / rect.width : ctx.height / rect.height : 1;
    translate.target = {
      x: ctx.width / 2 - center2.x * newScale,
      y: ctx.height / 2 - center2.y * newScale
    };
    if (rect) {
      scale2.target = newScale;
    }
  }
  function onPointerDown(e) {
    onpointerdown()?.(e);
    if (strict_equals(mode2(), "none") || disablePointer()) return;
    e.preventDefault();
    pointerDown = true;
    set(dragging, false);
    startPoint = localPoint(e);
    startTranslate = translate.current;
    ondragstart()?.();
  }
  function onPointerMove2(e) {
    onpointermove()?.(e);
    if (!pointerDown) return;
    e.preventDefault();
    const endPoint = localPoint(e);
    const deltaX = endPoint.x - startPoint.x;
    const deltaY = endPoint.y - startPoint.y;
    if (!get(dragging)) {
      set(dragging, deltaX * deltaX + deltaY * deltaY > clickDistance());
    }
    if (get(dragging)) {
      e.stopPropagation();
      e.currentTarget?.setPointerCapture(e.pointerId);
      setTranslate(processTranslate()(startTranslate.x, startTranslate.y, deltaX, deltaY), strict_equals(translate.type, "spring") ? { instant: true } : strict_equals(translate.type, "tween") ? { duration: 0 } : void 0);
    }
  }
  function onPointerUp(e) {
    onpointerup()?.(e);
    pointerDown = false;
    set(dragging, false);
    ondragend()?.();
  }
  function onClick(e) {
    onclickcapture()?.(e);
    if (get(dragging)) {
      e.stopPropagation();
    }
  }
  function onDoubleClick(e) {
    ondblclick()?.(e);
    if (strict_equals(mode2(), "none") || disablePointer()) return;
    const point10 = localPoint(e);
    scaleTo(e.shiftKey ? 0.5 : 2, point10);
  }
  function onWheel(e) {
    onwheel()?.(e);
    if (strict_equals(mode2(), "none") || disablePointer() || strict_equals(get(scrollMode), "none")) return;
    e.preventDefault();
    const point10 = startPoint = localPoint(e);
    const pinchToZoom = e.ctrlKey;
    if (strict_equals(get(scrollMode), "scale") || pinchToZoom) {
      const scaleBy = -e.deltaY * (strict_equals(e.deltaMode, 1) ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
      scaleTo(Math.pow(2, scaleBy), point10, strict_equals(scale2.type, "spring") ? { instant: true } : strict_equals(scale2.type, "tween") ? { duration: 0 } : void 0);
    } else if (strict_equals(get(scrollMode), "translate")) {
      const startTranslate2 = translate.current;
      translate.set(processTranslate()(startTranslate2.x, startTranslate2.y, -e.deltaX, -e.deltaY), strict_equals(translate.type, "spring") ? { instant: true } : strict_equals(translate.type, "tween") ? { duration: 0 } : void 0).then(() => {
      }).catch(() => {
      });
    }
  }
  function scaleTo(value2, point10, options = void 0) {
    const currentScale = scale2.current;
    const newScale = scale2.current * value2;
    setScale(newScale, options);
    const invertTransformPoint = {
      x: (point10.x - ctx.padding.left - translate.current.x) / currentScale,
      y: (point10.y - ctx.padding.top - translate.current.y) / currentScale
    };
    const newTranslate = {
      x: point10.x - ctx.padding.left - invertTransformPoint.x * newScale,
      y: point10.y - ctx.padding.top - invertTransformPoint.y * newScale
    };
    setTranslate(newTranslate, options);
  }
  const translating = createMotionTracker();
  const scaling = createMotionTracker();
  const moving = tag(user_derived(() => get(dragging) || translating.current || scaling.current), "moving");
  function setTranslate(point10, options) {
    translating.handle(translate.set(point10, options));
  }
  function setScale(value2, options) {
    scaling.handle(scale2.set(value2, options));
  }
  watch([() => scale2.current, () => translate.current], () => {
    onTransform()({ scale: scale2.current, translate: translate.current });
  });
  setTransformContext(transformContext());
  var div = root2();
  var event_handler = (e) => {
    ontouchmove()?.(e);
    if (strict_equals(mode2(), "none", false) && !disablePointer()) {
      e.preventDefault();
    }
  };
  attribute_effect(
    div,
    ($0) => ({
      onwheel: onWheel,
      onpointerdown: onPointerDown,
      onpointermove: onPointerMove2,
      ontouchmove: event_handler,
      onpointerup: onPointerUp,
      ondblclick: onDoubleClick,
      onclickcapture: onClick,
      class: $0,
      ...restProps
    }),
    [
      () => cls(layerClass("transform-context"), "h-full", $$props.class)
    ]
  );
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ transformContext: transformContext() })), "render", TransformContext, 526, 2);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({
    get setScrollMode() {
      return setScrollMode;
    },
    get reset() {
      return reset2;
    },
    get zoomIn() {
      return zoomIn;
    },
    get zoomOut() {
      return zoomOut;
    },
    get translateCenter() {
      return translateCenter;
    },
    get zoomTo() {
      return zoomTo;
    },
    get setTranslate() {
      return setTranslate;
    },
    get setScale() {
      return setScale;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  TransformContext = hmr(TransformContext, () => TransformContext[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TransformContext[HMR].source;
    set(TransformContext[HMR].source, module2.default[HMR].original);
  });
}
var TransformContext_default = TransformContext;

// node_modules/layerchart/dist/components/GeoContext.svelte
GeoContext[FILENAME] = "node_modules/layerchart/dist/components/GeoContext.svelte";
var _GeoContext = new Context("GeoContext");
function getGeoContext() {
  return _GeoContext.getOr({ projection: void 0 });
}
function setGeoContext(geo) {
  return _GeoContext.set(geo);
}
function GeoContext($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoContext);
  let applyTransform = prop($$props, "applyTransform", 19, () => []), geoContextProp = prop($$props, "geoContext", 15);
  const ctx = getChartContext();
  const transformCtx = getTransformContext();
  let projection2 = tag(state(void 0), "projection");
  const geoContext = {
    get projection() {
      return get(projection2);
    },
    set projection(v2) {
      set(projection2, v2, true);
    }
  };
  geoContextProp(geoContext);
  setGeoContext(geoContext);
  const fitSizeRange = tag(
    user_derived(() => $$props.fixedAspectRatio ? [100, 100 / $$props.fixedAspectRatio] : [ctx.width, ctx.height]),
    "fitSizeRange"
  );
  user_pre_effect(() => {
    if (!$$props.projection) return;
    const _projection = $$props.projection();
    if ($$props.fitGeojson && "fitSize" in _projection) {
      _projection.fitSize(get(fitSizeRange), $$props.fitGeojson);
    }
    if ("scale" in _projection) {
      if ($$props.scale) {
        _projection.scale($$props.scale);
      }
      if (applyTransform().includes("scale")) {
        _projection.scale(transformCtx.scale);
      }
    }
    if ("rotate" in _projection) {
      if ($$props.rotate) {
        _projection.rotate([
          $$props.rotate.yaw,
          $$props.rotate.pitch,
          $$props.rotate.roll
        ]);
      }
      if (applyTransform().includes("rotate")) {
        _projection.rotate([
          transformCtx.translate.x,
          // yaw
          transformCtx.translate.y
          // pitch
          // TODO: `roll` from `transformContext`?
        ]);
      }
    }
    if ("translate" in _projection) {
      if ($$props.translate) {
        _projection.translate($$props.translate);
      }
      if (applyTransform().includes("translate")) {
        _projection.translate([transformCtx.translate.x, transformCtx.translate.y]);
      }
    }
    if ($$props.center && "center" in _projection) {
      _projection.center($$props.center);
    }
    if ($$props.reflectX) {
      _projection.reflectX($$props.reflectX);
    }
    if ($$props.reflectY) {
      _projection.reflectY($$props.reflectY);
    }
    if ($$props.clipAngle && "clipAngle" in _projection) {
      _projection.clipAngle($$props.clipAngle);
    }
    if ($$props.clipExtent && "clipExtent" in _projection) {
      _projection.clipExtent($$props.clipExtent);
    }
    geoContext.projection = _projection;
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children, () => ({ geoContext })), "render", GeoContext, 174, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoContext = hmr(GeoContext, () => GeoContext[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoContext[HMR].source;
    set(GeoContext[HMR].source, module2.default[HMR].original);
  });
}
var GeoContext_default = GeoContext;

// node_modules/d3-quadtree/src/add.js
function add_default2(d) {
  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);
  return add2(this.cover(x4, y4), x4, y4, d);
}
function add2(tree, x4, y4, d) {
  if (isNaN(x4) || isNaN(y4)) return tree;
  var parent2, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (parent2 = node, !(node = node[i = bottom << 1 | right2])) return parent2[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp) return leaf.next = node, parent2 ? parent2[i] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i] = new Array(4) : tree._root = new Array(4);
    if (right2 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
  } while ((i = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent2[j] = node, parent2[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d))) continue;
    xz[i] = x4;
    yz[i] = y4;
    if (x4 < x06) x06 = x4;
    if (x4 > x12) x12 = x4;
    if (y4 < y06) y06 = y4;
    if (y4 > y12) y12 = y4;
  }
  if (x06 > x12 || y06 > y12) return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add2(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4)) return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x4)) + 1;
    y12 = (y06 = Math.floor(y4)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent2, i;
    while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {
      i = (y4 < y06) << 1 | x4 < x06;
      parent2 = new Array(4), parent2[i] = node, node = parent2, z *= 2;
      switch (i) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default2(x4, y4, radius) {
  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node) quads.push(new quad_default(node, x06, y06, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x06 = x4 - radius, y06 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06) continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y4 >= ym) << 1 | x4 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x06 = x4 - d, y06 = y4 - d;
        x32 = x4 + d, y32 = y4 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d) {
  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d))) return this;
  var parent2, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x4, y4, xm, ym, right2, bottom, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right2 = x4 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (!(parent2 = node, node = node[i = bottom << 1 | right2])) return this;
    if (!node.length) break;
    if (parent2[i + 1 & 3] || parent2[i + 2 & 3] || parent2[i + 3 & 3]) retainer = parent2, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent2) return this._root = next, this;
  next ? parent2[i] = next : delete parent2[i];
  if ((node = parent2[0] || parent2[1] || parent2[2] || parent2[3]) && node === (parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child2, x06, y06, x12, y12;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
      if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
      if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
      if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child2, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
      if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
      if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
      if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x06, y06, x12, y12) {
  this._x = x4;
  this._y = y4;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child2;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child2 = node.source[i]) {
        if (child2.length) nodes.push({ source: child2, target: node.target[i] = new Array(4) });
        else node.target[i] = leaf_copy(child2);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default2;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default2;
treeProto.remove = remove_default2;
treeProto.removeAll = removeAll;
treeProto.root = root_default2;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/layerchart/dist/components/layout/Svg.svelte
Svg[FILENAME] = "node_modules/layerchart/dist/components/layout/Svg.svelte";
var root_3 = add_locations(from_svg(`<title> </title>`), Svg[FILENAME], [[129, 4]]);
var root_4 = add_locations(from_svg(`<g><!></g>`), Svg[FILENAME], [[142, 6]]);
var root3 = add_locations(from_svg(`<svg><!><defs><!></defs><g><!></g></svg>`), Svg[FILENAME], [[111, 0, [[132, 2], [136, 2]]]]);
function Svg($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Svg);
  let refProp = prop($$props, "ref", 15), innerRefProp = prop($$props, "innerRef", 15), zIndex = prop($$props, "zIndex", 3, 0), ignoreTransform = prop($$props, "ignoreTransform", 3, false), center2 = prop($$props, "center", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "innerRef",
      "zIndex",
      "pointerEvents",
      "viewBox",
      "ignoreTransform",
      "center",
      "class",
      "title",
      "defs",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  let innerRef = tag(state(void 0), "innerRef");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    innerRefProp(get(innerRef));
  });
  const ctx = getChartContext();
  const transformCtx = getTransformContext();
  const transform2 = tag(
    user_derived(() => {
      if (strict_equals(transformCtx.mode, "canvas") && !ignoreTransform()) {
        return `translate(${transformCtx.translate.x},${transformCtx.translate.y}) scale(${transformCtx.scale})`;
      } else if (center2()) {
        return `translate(${strict_equals(center2(), "x") || strict_equals(center2(), true) ? ctx.width / 2 : 0}, ${strict_equals(center2(), "y") || strict_equals(center2(), true) ? ctx.height / 2 : 0})`;
      }
    }),
    "transform"
  );
  setRenderContext("svg");
  var svg = root3();
  attribute_effect(
    svg,
    ($0, $1) => ({
      viewBox: $$props.viewBox,
      width: ctx.containerWidth,
      height: ctx.containerHeight,
      class: $0,
      role: "figure",
      ...restProps,
      [STYLE]: $1
    }),
    [
      () => cls(layerClass("layout-svg"), "absolute top-0 left-0 overflow-visible", strict_equals($$props.pointerEvents, false) && "pointer-events-none", $$props.class),
      () => ({ "z-index": zIndex() })
    ]
  );
  var node = child(svg);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      add_svelte_meta(() => snippet(node_1, () => $$props.title), "render", Svg, 127, 4);
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var title_1 = root_3();
          var text2 = child(title_1, true);
          reset(title_1);
          template_effect(
            ($0) => {
              set_class(title_1, 0, $0);
              set_text(text2, $$props.title);
            },
            [() => clsx(layerClass("layout-svg-title"))]
          );
          append($$anchor3, title_1);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if ($$props.title) $$render(consequent_1);
            },
            true
          ),
          "if",
          Svg,
          128,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(typeof $$props.title, "function")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Svg,
      126,
      2
    );
  }
  var defs_1 = sibling(node);
  var node_3 = child(defs_1);
  add_svelte_meta(() => snippet(node_3, () => $$props.defs ?? noop), "render", Svg, 133, 4);
  reset(defs_1);
  var g = sibling(defs_1);
  var node_4 = child(g);
  {
    var consequent_2 = ($$anchor2) => {
      var g_1 = root_4();
      var node_5 = child(g_1);
      add_svelte_meta(() => snippet(node_5, () => $$props.children ?? noop, () => ({ ref: get(ref) })), "render", Svg, 143, 8);
      reset(g_1);
      template_effect(
        ($0) => {
          set_attribute(g_1, "transform", get(transform2));
          set_class(g_1, 0, $0);
        },
        [() => clsx(layerClass("layout-svg-g-transform"))]
      );
      append($$anchor2, g_1);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_6 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_6, () => $$props.children ?? noop, () => ({ ref: get(ref) })), "render", Svg, 146, 6);
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_4, ($$render) => {
        if (get(transform2)) $$render(consequent_2);
        else $$render(alternate_1, false);
      }),
      "if",
      Svg,
      141,
      4
    );
  }
  reset(g);
  bind_this(g, ($$value) => set(innerRef, $$value), () => get(innerRef));
  reset(svg);
  bind_this(svg, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(
    ($0) => {
      set_class(g, 0, $0);
      set_attribute(g, "transform", `translate(${ctx.padding.left ?? ""}, ${ctx.padding.top ?? ""})`);
    },
    [() => clsx(layerClass("layout-svg-g"))]
  );
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Svg = hmr(Svg, () => Svg[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Svg[HMR].source;
    set(Svg[HMR].source, module2.default[HMR].original);
  });
}
var Svg_default = Svg;

// node_modules/layerchart/dist/utils/canvas.js
var DEFAULT_FILL = "rgb(0, 0, 0)";
var CANVAS_STYLES_ELEMENT_ID = "__layerchart_canvas_styles_id";
var supportedStyles = [
  "fill",
  "fillOpacity",
  "stroke",
  "strokeWidth",
  "opacity",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "textAnchor",
  "textAlign",
  "paintOrder"
];
function _getComputedStyles(canvas, { styles, classes } = {}) {
  try {
    let svg = document.getElementById(CANVAS_STYLES_ELEMENT_ID);
    if (!svg) {
      svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("id", CANVAS_STYLES_ELEMENT_ID);
      svg.style.display = "none";
      canvas.after(svg);
    }
    svg = svg;
    svg.removeAttribute("style");
    svg.removeAttribute("class");
    if (styles) {
      Object.assign(svg.style, styles);
    }
    svg.style.display = "none";
    if (classes) {
      svg.setAttribute("class", cls(classes).split(" ").filter((s3) => !s3.startsWith("transition-")).join(" "));
    }
    const computedStyles = supportedStyles.reduce((acc, style) => {
      acc[style] = window.getComputedStyle(svg)[style];
      return acc;
    }, {});
    return computedStyles;
  } catch (e) {
    console.error("Unable to get computed styles", e);
    return {};
  }
}
function getComputedStylesKey(canvas, { styles, classes } = {}) {
  return JSON.stringify({ canvasId: canvas.id, styles, classes });
}
var getComputedStyles = memoize2(_getComputedStyles, {
  cacheKey: ([canvas, styleOptions]) => {
    return getComputedStylesKey(canvas, styleOptions);
  }
});
function render(ctx, render2, styleOptions = {}, { applyText } = {}) {
  let resolvedStyles;
  if (styleOptions.classes == null && !Object.values(styleOptions.styles ?? {}).some((v2) => typeof v2 === "string" && v2.includes("var("))) {
    resolvedStyles = styleOptions.styles ?? {};
  } else {
    const { constantStyles, variableStyles } = Object.entries(styleOptions.styles ?? {}).reduce((acc, [key2, value2]) => {
      if (typeof value2 === "number" || typeof value2 === "string" && !value2.includes("var(")) {
        acc.constantStyles[key2] = value2;
      } else if (typeof value2 === "string" && value2.includes("var(")) {
        acc.variableStyles[key2] = value2;
      }
      return acc;
    }, { constantStyles: {}, variableStyles: {} });
    const computedStyles = getComputedStyles(ctx.canvas, {
      styles: variableStyles,
      classes: styleOptions.classes
    });
    resolvedStyles = { ...computedStyles, ...constantStyles };
  }
  const paintOrder = resolvedStyles?.paintOrder === "stroke" ? ["stroke", "fill"] : ["fill", "stroke"];
  if (resolvedStyles?.opacity) {
    ctx.globalAlpha = Number(resolvedStyles?.opacity);
  }
  if (applyText) {
    ctx.font = `${resolvedStyles.fontWeight} ${resolvedStyles.fontSize} ${resolvedStyles.fontFamily}`;
    if (resolvedStyles.textAnchor === "middle") {
      ctx.textAlign = "center";
    } else if (resolvedStyles.textAnchor === "end") {
      ctx.textAlign = "right";
    } else {
      ctx.textAlign = resolvedStyles.textAlign;
    }
  }
  if (resolvedStyles.strokeDasharray?.includes(",")) {
    const dashArray = resolvedStyles.strokeDasharray.split(",").map((s3) => Number(s3.replace("px", "")));
    ctx.setLineDash(dashArray);
  }
  for (const attr of paintOrder) {
    if (attr === "fill") {
      const fill2 = styleOptions.styles?.fill && (styleOptions.styles?.fill instanceof CanvasGradient || styleOptions.styles?.fill instanceof CanvasPattern || !styleOptions.styles?.fill?.includes("var")) ? styleOptions.styles.fill : resolvedStyles?.fill;
      if (fill2 && !["none", DEFAULT_FILL].includes(fill2)) {
        const currentGlobalAlpha = ctx.globalAlpha;
        const fillOpacity = Number(resolvedStyles?.fillOpacity);
        const opacity = Number(resolvedStyles?.opacity);
        ctx.globalAlpha = fillOpacity * opacity;
        ctx.fillStyle = fill2;
        render2.fill(ctx);
        ctx.globalAlpha = currentGlobalAlpha;
      }
    } else if (attr === "stroke") {
      const stroke = styleOptions.styles?.stroke && (styleOptions.styles?.stroke instanceof CanvasGradient || !styleOptions.styles?.stroke?.includes("var")) ? styleOptions.styles?.stroke : resolvedStyles?.stroke;
      if (stroke && !["none"].includes(stroke)) {
        ctx.lineWidth = typeof resolvedStyles?.strokeWidth === "string" ? Number(resolvedStyles?.strokeWidth?.replace("px", "")) : resolvedStyles?.strokeWidth ?? 1;
        ctx.strokeStyle = stroke;
        render2.stroke(ctx);
      }
    }
  }
}
function renderPathData(ctx, pathData, styleOptions = {}) {
  const path3 = new Path2D(pathData ?? "");
  render(ctx, {
    fill: (ctx2) => ctx2.fill(path3),
    stroke: (ctx2) => ctx2.stroke(path3)
  }, styleOptions);
}
function renderText(ctx, text2, coords, styleOptions = {}) {
  if (text2) {
    render(ctx, {
      fill: (ctx2) => ctx2.fillText(text2.toString(), coords.x, coords.y),
      stroke: (ctx2) => ctx2.strokeText(text2.toString(), coords.x, coords.y)
    }, styleOptions, { applyText: true });
  }
}
function renderRect(ctx, coords, styleOptions = {}) {
  render(ctx, {
    fill: (ctx2) => ctx2.fillRect(coords.x, coords.y, coords.width, coords.height),
    stroke: (ctx2) => ctx2.strokeRect(coords.x, coords.y, coords.width, coords.height)
  }, styleOptions);
}
function renderCircle(ctx, coords, styleOptions = {}) {
  ctx.beginPath();
  ctx.arc(coords.cx, coords.cy, coords.r, 0, 2 * Math.PI);
  render(ctx, {
    fill: (ctx2) => {
      ctx2.fill();
    },
    stroke: (ctx2) => {
      ctx2.stroke();
    }
  }, styleOptions);
  ctx.closePath();
}
function renderEllipse(ctx, coords, styleOptions = {}) {
  ctx.beginPath();
  ctx.ellipse(coords.cx, coords.cy, coords.rx, coords.ry, 0, 0, 2 * Math.PI);
  render(ctx, {
    fill: (ctx2) => {
      ctx2.fill();
    },
    stroke: (ctx2) => {
      ctx2.stroke();
    }
  }, styleOptions);
  ctx.closePath();
}
function clearCanvasContext(ctx, options) {
  ctx.clearRect(-options.padding.left, -options.padding.top, options.containerWidth, options.containerHeight);
}
function scaleCanvas(ctx, width, height) {
  const devicePixelRatio = window.devicePixelRatio || 1;
  ctx.canvas.width = width * devicePixelRatio;
  ctx.canvas.height = height * devicePixelRatio;
  ctx.canvas.style.width = `${width}px`;
  ctx.canvas.style.height = `${height}px`;
  ctx.scale(devicePixelRatio, devicePixelRatio);
  return { width: ctx.canvas.width, height: ctx.canvas.height };
}
function getPixelColor(ctx, x4, y4) {
  const dpr = window.devicePixelRatio ?? 1;
  const imageData = ctx.getImageData(x4 * dpr, y4 * dpr, 1, 1);
  const [r, g, b, a5] = imageData.data;
  return { r, g, b, a: a5 };
}
function _createLinearGradient(ctx, x06, y06, x12, y12, stops) {
  const gradient = ctx.createLinearGradient(x06, y06, x12, y12);
  for (const { offset, color: color2 } of stops) {
    gradient.addColorStop(offset, color2);
  }
  return gradient;
}
var createLinearGradient = memoize2(_createLinearGradient, {
  cacheKey: (args) => JSON.stringify(args.slice(1))
  // Ignore `ctx` argument
});
function _createPattern(ctx, width, height, shapes, background) {
  const patternCanvas = document.createElement("canvas");
  const patternCtx = patternCanvas.getContext("2d");
  ctx.canvas.after(patternCanvas);
  patternCanvas.width = width;
  patternCanvas.height = height;
  if (background) {
    patternCtx.fillStyle = background;
    patternCtx.fillRect(0, 0, width, height);
  }
  for (const shape of shapes) {
    patternCtx.save();
    if (shape.type === "circle") {
      renderCircle(patternCtx, { cx: shape.cx, cy: shape.cy, r: shape.r }, { styles: { fill: shape.fill, opacity: shape.opacity } });
    } else if (shape.type === "line") {
      renderPathData(patternCtx, shape.path, {
        styles: { stroke: shape.stroke, strokeWidth: shape.strokeWidth, opacity: shape.opacity }
      });
    }
    patternCtx.restore();
  }
  const pattern = ctx.createPattern(patternCanvas, "repeat");
  ctx.canvas.parentElement?.removeChild(patternCanvas);
  return pattern;
}
var createPattern = memoize2(_createPattern, {
  cacheKey: (args) => JSON.stringify(args.slice(1))
  // Ignore `ctx` argument
});

// node_modules/layerchart/dist/utils/color.js
function* rgbColorGenerator(step = 500) {
  let nextColor = 0;
  while (nextColor < 16777216) {
    const r = nextColor & 255;
    const g = (nextColor & 65280) >> 8;
    const b = (nextColor & 16711680) >> 16;
    nextColor += step;
    yield { r, g, b, a: 255 };
  }
  return { r: 0, g: 0, b: 0, a: 255 };
}
function getColorStr(color2) {
  if (color2.a !== void 0) {
    return `rgba(${color2.r},${color2.g},${color2.b},${color2.a})`;
  } else {
    return `rgb(${color2.r},${color2.g},${color2.b})`;
  }
}
function getColorIfDefined(data) {
  if (!data || typeof data !== "object" || Array.isArray(data))
    return;
  if ("color" in data)
    return data.color;
  if ("fill" in data)
    return data.fill;
}

// node_modules/layerchart/dist/components/layout/Canvas.svelte
Canvas[FILENAME] = "node_modules/layerchart/dist/components/layout/Canvas.svelte";
var CanvasContext = new Context("CanvasContext");
var defaultCanvasContext = {
  register: (_) => {
    return () => {
    };
  },
  invalidate: () => {
  }
};
function getCanvasContext() {
  return CanvasContext.getOr(defaultCanvasContext);
}
function setCanvasContext(context) {
  return CanvasContext.set(context);
}
function registerCanvasComponent(component2) {
  const canvasContext = getCanvasContext();
  user_pre_effect(() => {
    return untrack(() => canvasContext.register(component2));
  });
}
var root4 = add_locations(from_html(`<canvas><!></canvas> <canvas></canvas> <!>`, 1), Canvas[FILENAME], [[453, 0], [510, 0]]);
function Canvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Canvas);
  let refProp = prop($$props, "ref", 15), canvasContextProp = prop($$props, "canvasContext", 15), willReadFrequently = prop($$props, "willReadFrequently", 3, false), debug = prop($$props, "debug", 3, false), zIndex = prop($$props, "zIndex", 3, 0), pointerEvents = prop($$props, "pointerEvents", 3, true), center2 = prop($$props, "center", 3, false), ignoreTransform = prop($$props, "ignoreTransform", 3, false), disableHitCanvas = prop($$props, "disableHitCanvas", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "canvasContext",
      "willReadFrequently",
      "debug",
      "zIndex",
      "pointerEvents",
      "fallback",
      "center",
      "ignoreTransform",
      "disableHitCanvas",
      "class",
      "children",
      "onclick",
      "ondblclick",
      "onpointerenter",
      "onpointermove",
      "onpointerleave",
      "onpointerdown",
      "ontouchmove"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  let context = tag(state(void 0), "context");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    canvasContextProp(get(context));
  });
  const ctx = getChartContext();
  const transformCtx = getTransformContext();
  const logger = new Logger("Canvas");
  let components = /* @__PURE__ */ new Map();
  let pendingInvalidation = false;
  let frameId;
  let hitCanvasElement = tag(state(void 0), "hitCanvasElement");
  let hitCanvasContext = tag(state(void 0), "hitCanvasContext");
  let colorGenerator = rgbColorGenerator();
  let activeCanvas = tag(state(false), "activeCanvas");
  let lastActiveComponent = null;
  const componentByColor = /* @__PURE__ */ new Map();
  function getPointerComponent(e) {
    const { x: x4, y: y4 } = localPoint(e);
    const color2 = getPixelColor(get(hitCanvasContext), x4, y4);
    const colorKey = getColorStr(color2);
    const component2 = componentByColor.get(colorKey);
    logger.debug({ colorKey, component: component2, componentByColor });
    return component2;
  }
  const onPointerMove2 = (e) => {
    set(activeCanvas, true);
    const component2 = getPointerComponent(e);
    if (equals(component2, lastActiveComponent, false)) {
      if (lastActiveComponent) {
        lastActiveComponent.events?.pointerleave?.(e);
        lastActiveComponent.events?.pointerout?.(e);
      }
      component2?.events?.pointerenter?.(e);
      component2?.events?.pointerover?.(e);
    }
    component2?.events?.pointermove?.(e);
    lastActiveComponent = component2;
  };
  const onPointerLeave = (e) => {
    lastActiveComponent?.events?.pointerleave?.(e);
    lastActiveComponent?.events?.pointerout?.(e);
    lastActiveComponent = null;
    set(activeCanvas, false);
  };
  const { dark } = new MediaQueryPresets();
  watch(() => dark.current, () => {
    canvasContext.invalidate();
  });
  useMutationObserver(() => document.documentElement, () => canvasContext.invalidate(), { attributes: true, attributeFilter: ["class", "data-theme"] });
  onMount(() => {
    set(context, get(ref)?.getContext("2d", { willReadFrequently: willReadFrequently() }), true);
    set(
      hitCanvasContext,
      get(hitCanvasElement)?.getContext("2d", {
        willReadFrequently: false
        // Explicitly set to `false` to resolve pixel artifacts between fill and stroke with the same color (issue #372)
      }),
      true
    );
    return () => {
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  });
  function update2() {
    if (!get(context)) return;
    scaleCanvas(get(context), ctx.containerWidth, ctx.containerHeight);
    get(context).clearRect(0, 0, ctx.containerWidth, ctx.containerHeight);
    get(context).translate(ctx.padding.left ?? 0, ctx.padding.top ?? 0);
    let newTranslate;
    if (center2()) {
      newTranslate = {
        x: strict_equals(center2(), "x") || strict_equals(center2(), true) ? ctx.width / 2 : 0,
        y: strict_equals(center2(), "y") || strict_equals(center2(), true) ? ctx.height / 2 : 0
      };
      get(context).translate(newTranslate.x, newTranslate.y);
    } else if (strict_equals(transformCtx.mode, "canvas") && !ignoreTransform()) {
      get(context).translate(transformCtx.translate.x, transformCtx.translate.y);
      get(context).scale(transformCtx.scale, transformCtx.scale);
    }
    const retainStateComponents = [];
    const nonRetainStateComponents = [];
    for (const [_, c3] of components) {
      if (c3.retainState) {
        retainStateComponents.push(c3);
      } else {
        nonRetainStateComponents.push(c3);
      }
    }
    for (const c3 of retainStateComponents) {
      c3.render(get(context));
    }
    const mainTransformAfterRetain = get(context).getTransform();
    for (const c3 of nonRetainStateComponents) {
      get(context).save();
      c3.render(get(context));
      get(context).restore();
    }
    if (get(hitCanvasContext)) {
      const inactiveMoving = !get(activeCanvas) && transformCtx.moving;
      if (disableHitCanvas() || transformCtx.dragging || inactiveMoving) {
        get(hitCanvasContext).clearRect(0, 0, ctx.containerWidth, ctx.containerHeight);
      } else {
        scaleCanvas(get(hitCanvasContext), ctx.containerWidth, ctx.containerHeight);
        get(hitCanvasContext).clearRect(0, 0, ctx.containerWidth, ctx.containerHeight);
        get(hitCanvasContext).resetTransform();
        get(hitCanvasContext).setTransform(mainTransformAfterRetain);
        colorGenerator = rgbColorGenerator();
        for (const c3 of retainStateComponents) {
          const componentHasEvents = c3.events && Object.values(c3.events).filter((d) => d).length > 0;
          if (componentHasEvents) {
            continue;
          }
        }
        for (const c3 of nonRetainStateComponents) {
          const componentHasEvents = c3.events && Object.values(c3.events).filter((d) => d).length > 0;
          if (componentHasEvents) {
            const color2 = getColorStr(colorGenerator.next().value);
            const styleOverrides = { styles: { fill: color2, stroke: color2, _fillOpacity: 0.1 } };
            get(hitCanvasContext).save();
            c3.render(get(hitCanvasContext), styleOverrides);
            get(hitCanvasContext).restore();
            componentByColor.set(color2, c3);
          }
        }
      }
    }
    pendingInvalidation = false;
  }
  function createCanvasContext() {
    function register(component2) {
      const key2 = Symbol();
      components.set(key2, component2);
      invalidate();
      const cleanupRoot = effect_root(() => {
        if (component2.deps) {
          user_pre_effect(() => {
            component2.deps?.();
            invalidate();
          });
        }
      });
      user_pre_effect(() => {
        return cleanupRoot;
      });
      return () => {
        components.delete(key2);
        cleanupRoot();
        invalidate();
      };
    }
    function invalidate() {
      if (pendingInvalidation) return;
      pendingInvalidation = true;
      frameId = requestAnimationFrame(update2);
    }
    return { register, invalidate };
  }
  const canvasContext = createCanvasContext();
  user_pre_effect(() => {
    [
      ctx.height,
      ctx.width,
      ctx.containerHeight,
      ctx.containerWidth,
      transformCtx.dragging
    ];
    canvasContext.invalidate();
  });
  setCanvasContext(canvasContext);
  setRenderContext("canvas");
  var fragment = root4();
  var canvas = first_child(fragment);
  var event_handler = (e) => {
    const component2 = getPointerComponent(e);
    component2?.events?.click?.(e);
    $$props.onclick?.(e);
  };
  var event_handler_1 = (e) => {
    const component2 = getPointerComponent(e);
    component2?.events?.dblclick?.(e);
    $$props.ondblclick?.(e);
  };
  var event_handler_2 = (e) => {
    const component2 = getPointerComponent(e);
    component2?.events?.pointerdown?.(e);
    $$props.onpointerdown?.(e);
  };
  var event_handler_3 = (e) => {
    $$props.onpointerenter?.(e);
    onPointerMove2(e);
  };
  var event_handler_4 = (e) => {
    $$props.onpointermove?.(e);
    onPointerMove2(e);
  };
  var event_handler_5 = (e) => {
    $$props.onpointerleave?.(e);
    onPointerLeave(e);
  };
  var event_handler_6 = (e) => {
    if (lastActiveComponent) {
      e.preventDefault();
    }
    const component2 = getPointerComponent(e);
    component2?.events?.touchmove?.(e);
  };
  attribute_effect(
    canvas,
    ($0, $1) => ({
      class: $0,
      onclick: event_handler,
      ondblclick: event_handler_1,
      onpointerdown: event_handler_2,
      onpointerenter: event_handler_3,
      onpointermove: event_handler_4,
      onpointerleave: event_handler_5,
      ontouchmove: event_handler_6,
      ...restProps,
      [STYLE]: $1
    }),
    [
      () => cls(layerClass("layout-canvas"), "absolute top-0 left-0 w-full h-full", strict_equals(pointerEvents(), false) && "pointer-events-none", $$props.class),
      () => ({ "z-index": zIndex() })
    ]
  );
  var node = child(canvas);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.fallback), "render", Canvas, 502, 6);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $$props.fallback));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (strict_equals(typeof $$props.fallback, "function")) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Canvas,
          501,
          4
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.fallback) $$render(consequent_1);
      }),
      "if",
      Canvas,
      500,
      2
    );
  }
  reset(canvas);
  bind_this(canvas, ($$value) => set(ref, $$value), () => get(ref));
  var canvas_1 = sibling(canvas, 2);
  bind_this(canvas_1, ($$value) => set(hitCanvasElement, $$value), () => get(hitCanvasElement));
  var node_3 = sibling(canvas_1, 2);
  add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ ref: get(ref), canvasContext: get(context) })), "render", Canvas, 523, 0);
  template_effect(($0) => set_class(canvas_1, 1, $0), [
    () => clsx(cls(layerClass("hit-canvas"), "layerchart-hitcanvas", "absolute top-0 left-0 w-full h-full", "pointer-events-none", "border border-danger", !debug() && "opacity-0"))
  ]);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Canvas = hmr(Canvas, () => Canvas[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Canvas[HMR].source;
    set(Canvas[HMR].source, module2.default[HMR].original);
  });
}
var Canvas_default = Canvas;

// node_modules/layerchart/dist/utils/key.svelte.js
function createKey(getValue2) {
  const value2 = tag(user_derived(getValue2), "value");
  const key2 = tag(user_derived(() => get(value2) && strict_equals(typeof get(value2), "object") ? objectId(get(value2)) : get(value2)), "key");
  return {
    get current() {
      return get(key2);
    }
  };
}

// node_modules/layerchart/dist/components/Rect.svelte
Rect[FILENAME] = "node_modules/layerchart/dist/components/Rect.svelte";
var root_1 = add_locations(from_svg(`<rect></rect>`), Rect[FILENAME], [[148, 2]]);
function Rect($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Rect);
  let x4 = prop($$props, "x", 3, 0), y4 = prop($$props, "y", 3, 0), initialX = prop($$props, "initialX", 19, x4), initialY = prop($$props, "initialY", 19, y4), initialHeight = prop($$props, "initialHeight", 19, () => $$props.height), initialWidth = prop($$props, "initialWidth", 19, () => $$props.width), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "height",
      "width",
      "x",
      "y",
      "initialX",
      "initialY",
      "fill",
      "fillOpacity",
      "stroke",
      "initialHeight",
      "initialWidth",
      "strokeWidth",
      "opacity",
      "ref",
      "motion",
      "class",
      "onclick",
      "ondblclick",
      "onpointerenter",
      "onpointermove",
      "onpointerleave",
      "onpointerover",
      "onpointerout"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const motionX = createMotion(initialX(), () => x4(), parseMotionProp($$props.motion, "x"));
  const motionY = createMotion(initialY(), () => y4(), parseMotionProp($$props.motion, "y"));
  const motionWidth = createMotion(initialWidth(), () => $$props.width, parseMotionProp($$props.motion, "width"));
  const motionHeight = createMotion(initialHeight(), () => $$props.height, parseMotionProp($$props.motion, "height"));
  const renderCtx = getRenderContext();
  function render2(ctx, styleOverrides) {
    renderRect(
      ctx,
      {
        x: motionX.current,
        y: motionY.current,
        width: motionWidth.current,
        height: motionHeight.current
      },
      styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
        styles: {
          fill: $$props.fill,
          fillOpacity: $$props.fillOpacity,
          stroke: $$props.stroke,
          strokeWidth: $$props.strokeWidth,
          opacity: $$props.opacity
        },
        classes: $$props.class
      }
    );
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Rect",
      render: render2,
      events: {
        click: $$props.onclick,
        dblclick: $$props.ondblclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave,
        pointerover: $$props.onpointerover,
        pointerout: $$props.onpointerout
      },
      deps: () => [
        motionX.current,
        motionY.current,
        motionWidth.current,
        motionHeight.current,
        fillKey.current,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var rect = root_1();
      attribute_effect(
        rect,
        ($0) => ({
          x: motionX.current,
          y: motionY.current,
          width: motionWidth.current,
          height: motionHeight.current,
          fill: $$props.fill,
          "fill-opacity": $$props.fillOpacity,
          stroke: $$props.stroke,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          class: $0,
          ...restProps,
          onclick: $$props.onclick,
          ondblclick: $$props.ondblclick,
          onpointerenter: $$props.onpointerenter,
          onpointermove: $$props.onpointermove,
          onpointerleave: $$props.onpointerleave,
          onpointerover: $$props.onpointerover,
          onpointerout: $$props.onpointerout
        }),
        [
          () => cls(layerClass("rect"), equals($$props.fill, null) && "fill-surface-content", $$props.class)
        ]
      );
      bind_this(rect, ($$value) => set(ref, $$value), () => get(ref));
      append($$anchor2, rect);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent);
      }),
      "if",
      Rect,
      147,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rect = hmr(Rect, () => Rect[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Rect[HMR].source;
    set(Rect[HMR].source, module2.default[HMR].original);
  });
}
var Rect_default = Rect;

// node_modules/layerchart/dist/utils/createId.js
function createId(prefix, uid) {
  return `${prefix}-${uid}`;
}

// node_modules/layerchart/dist/components/ClipPath.svelte
ClipPath[FILENAME] = "node_modules/layerchart/dist/components/ClipPath.svelte";
var root_2 = add_locations(from_svg(`<use></use>`), ClipPath[FILENAME], [[69, 8]]);
var root_12 = add_locations(from_svg(`<defs><clipPath><!><!></clipPath></defs>`), ClipPath[FILENAME], [[64, 2, [[65, 4]]]]);
var root_5 = add_locations(from_svg(`<g><!></g>`), ClipPath[FILENAME], [[79, 4]]);
var root5 = add_locations(from_svg(`<!><!>`, 1), ClipPath[FILENAME], []);
function ClipPath($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, ClipPath);
  let id = prop($$props, "id", 19, () => createId("clipPath-", uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "useId",
      "disabled",
      "children",
      "clip"
    ],
    "restProps"
  );
  const url = tag(user_derived(() => `url(#${id()})`), "url");
  const renderContext = getRenderContext();
  var fragment = root5();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var defs = root_12();
      var clipPath = child(defs);
      attribute_effect(clipPath, () => ({ id: id(), ...restProps }));
      var node_1 = child(clipPath);
      add_svelte_meta(() => snippet(node_1, () => $$props.clip ?? noop, () => ({ id: id() })), "render", ClipPath, 66, 6);
      var node_2 = sibling(node_1);
      {
        var consequent = ($$anchor3) => {
          var use = root_2();
          template_effect(() => set_attribute(use, "href", `#${$$props.useId ?? ""}`));
          append($$anchor3, use);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.useId) $$render(consequent);
          }),
          "if",
          ClipPath,
          68,
          6
        );
      }
      reset(clipPath);
      reset(defs);
      append($$anchor2, defs);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderContext, "svg")) $$render(consequent_1);
      }),
      "if",
      ClipPath,
      63,
      0
    );
  }
  var node_3 = sibling(node);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_4 = first_child(fragment_1);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_5 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_5, () => $$props.children, () => ({ id: id(), url: get(url), useId: $$props.useId })), "render", ClipPath, 77, 4);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var g = root_5();
          let styles;
          var node_6 = child(g);
          add_svelte_meta(() => snippet(node_6, () => $$props.children, () => ({ id: id(), url: get(url), useId: $$props.useId })), "render", ClipPath, 80, 6);
          reset(g);
          template_effect(
            ($0, $1) => {
              set_class(g, 0, $0);
              styles = set_style(g, "", styles, $1);
            },
            [
              () => clsx(layerClass("clip-path-g")),
              () => ({ "clip-path": get(url) })
            ]
          );
          append($$anchor3, g);
        };
        add_svelte_meta(
          () => if_block(node_4, ($$render) => {
            if (disabled() || strict_equals(renderContext, "svg", false)) $$render(consequent_2);
            else $$render(alternate, false);
          }),
          "if",
          ClipPath,
          76,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_3, ($$render) => {
        if ($$props.children) $$render(consequent_3);
      }),
      "if",
      ClipPath,
      75,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipPath = hmr(ClipPath, () => ClipPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ClipPath[HMR].source;
    set(ClipPath[HMR].source, module2.default[HMR].original);
  });
}
var ClipPath_default = ClipPath;

// node_modules/layerchart/dist/components/RectClipPath.svelte
RectClipPath[FILENAME] = "node_modules/layerchart/dist/components/RectClipPath.svelte";
function RectClipPath($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, RectClipPath);
  let id = prop($$props, "id", 19, () => createId("clipPath-", uid)), x4 = prop($$props, "x", 3, 0), y4 = prop($$props, "y", 3, 0), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "x",
      "y",
      "disabled",
      "children"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const clip = wrap_snippet(RectClipPath, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => extractLayerProps(restProps, "clip-path-rect"));
        add_svelte_meta(
          () => Rect_default(node_1, spread_props(
            {
              get x() {
                return x4();
              },
              get y() {
                return y4();
              }
            },
            () => get($0)
          )),
          "component",
          RectClipPath,
          84,
          4,
          { componentTag: "Rect" }
        );
      }
      append($$anchor2, fragment_1);
    });
    const children = wrap_snippet(RectClipPath, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let url = () => $$arg0?.().url;
      url();
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ id: id(), url: url() })), "render", RectClipPath, 87, 4);
      append($$anchor2, fragment_2);
    });
    add_svelte_meta(
      () => ClipPath_default(node, {
        get id() {
          return id();
        },
        get disabled() {
          return disabled();
        },
        clip,
        children,
        $$slots: { clip: true, default: true }
      }),
      "component",
      RectClipPath,
      82,
      0,
      { componentTag: "ClipPath" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RectClipPath = hmr(RectClipPath, () => RectClipPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = RectClipPath[HMR].source;
    set(RectClipPath[HMR].source, module2.default[HMR].original);
  });
}
var RectClipPath_default = RectClipPath;

// node_modules/layerchart/dist/components/ChartClipPath.svelte
ChartClipPath[FILENAME] = "node_modules/layerchart/dist/components/ChartClipPath.svelte";
function ChartClipPath($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ChartClipPath);
  let full = prop($$props, "full", 3, false), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "full", "disabled"], "restProps");
  const ctx = getChartContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => full() && ctx.padding.left ? -ctx.padding.left : 0);
    let $1 = user_derived(() => full() && ctx.padding.top ? -ctx.padding.top : 0);
    let $2 = user_derived(() => ctx.height + (full() ? (ctx.padding?.top ?? 0) + (ctx.padding?.bottom ?? 0) : 0));
    let $3 = user_derived(() => ctx.width + (full() ? (ctx.padding?.left ?? 0) + (ctx.padding?.right ?? 0) : 0));
    let $4 = user_derived(() => extractLayerProps(restProps, "chart-clip-path"));
    add_svelte_meta(
      () => RectClipPath_default(node, spread_props(
        {
          get x() {
            return get($0);
          },
          get y() {
            return get($1);
          },
          get disabled() {
            return disabled();
          },
          get height() {
            return get($2);
          },
          get width() {
            return get($3);
          }
        },
        () => get($4)
      )),
      "component",
      ChartClipPath,
      38,
      0,
      { componentTag: "RectClipPath" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartClipPath = hmr(ChartClipPath, () => ChartClipPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ChartClipPath[HMR].source;
    set(ChartClipPath[HMR].source, module2.default[HMR].original);
  });
}
var ChartClipPath_default = ChartClipPath;

// node_modules/robust-predicates/esm/util.js
var epsilon3 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon3) * epsilon3;
function sum4(elen, e, flen, f2, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f2[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f2[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f2[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f2[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f2[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon3) * epsilon3;
var ccwerrboundB = (2 + 12 * epsilon3) * epsilon3;
var ccwerrboundC = (9 + 64 * epsilon3) * epsilon3 * epsilon3;
var B2 = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D2 = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c3, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum4(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum4(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum4(C2len, C2, 4, u, D2);
  return D2[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon3) * epsilon3;
var o3derrboundB = (3 + 28 * epsilon3) * epsilon3;
var o3derrboundC = (26 + 288 * epsilon3) * epsilon3 * epsilon3;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon3) * epsilon3;
var iccerrboundB = (4 + 48 * epsilon3) * epsilon3;
var iccerrboundC = (44 + 576 * epsilon3) * epsilon3 * epsilon3;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon3) * epsilon3;
var isperrboundB = (5 + 72 * epsilon3) * epsilon3;
var isperrboundC = (71 + 1408 * epsilon3) * epsilon3 * epsilon3;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < n; i++) {
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (x4 < minX) minX = x4;
      if (y4 < minY) minY = y4;
      if (x4 > maxX) maxX = x4;
      if (y4 > maxY) maxY = y4;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];
        const d = this._dists[id];
        if (d > d0) {
          hull[j++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x4 = i1x;
      const y4 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x4;
      i2y = y4;
    }
    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center2.x;
    this._cy = center2.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
      const i = this._ids[k3];
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (k3 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON) continue;
      xp = x4;
      yp = y4;
      if (i === i0 || i === i1 || i === i2) continue;
      let start = 0;
      for (let j = 0, key2 = this._hashKey(x4, y4); j < this._hashSize; j++) {
        start = hullHash[(key2 + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x4, y4)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x4, y4) {
    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a5) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a5];
      const a0 = a5 - a5 % 3;
      ar = a0 + (a5 + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a5 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b - b % 3;
      const al = a0 + (a5 + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a5];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a5] = p1;
        triangles[b] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a5;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a5, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a5 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a5, b) {
    this._halfedges[a5] = b;
    if (b !== -1) this._halfedges[b] = a5;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a5, b, c3) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a5);
    this._link(t + 1, b);
    this._link(t + 2, c3);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = (ey * bl - dy * cl) * d;
  const y4 = (dx * cl - ex * bl) * d;
  return x4 * x4 + y4 * y4;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = ax + (ey * bl - dy * cl) * d;
  const y4 = ay + (dx * cl - ex * bl) * d;
  return { x: x4, y: y4 };
}
function quicksort(ids, dists, left2, right2) {
  if (right2 - left2 <= 20) {
    for (let i = left2 + 1; i <= right2; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left2 && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median2 = left2 + right2 >> 1;
    let i = left2 + 1;
    let j = right2;
    swap2(ids, median2, i);
    if (dists[ids[left2]] > dists[ids[right2]]) swap2(ids, left2, right2);
    if (dists[ids[i]] > dists[ids[right2]]) swap2(ids, i, right2);
    if (dists[ids[left2]] > dists[ids[i]]) swap2(ids, left2, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap2(ids, i, j);
    }
    ids[left2 + 1] = ids[j];
    ids[j] = temp;
    if (right2 - i + 1 >= j - left2) {
      quicksort(ids, dists, i, right2);
      quicksort(ids, dists, left2, j - 1);
    } else {
      quicksort(ids, dists, left2, j - 1);
      quicksort(ids, dists, i, right2);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon4 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x4, y4) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x4, y4) {
    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arc(x4, y4, r) {
    x4 = +x4, y4 = +y4, r = +r;
    const x06 = x4 + r;
    const y06 = y4;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x06},${y06}`;
    else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) this._ += "L" + x06 + "," + y06;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
  }
  rect(x4, y4, w, h) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x4, y4) {
    this._.push([x4, y4]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x4, y4) {
    this._.push([x4, y4]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x13 = points[t13];
      const y13 = points[t13 + 1];
      const x22 = points[t22];
      const y22 = points[t22 + 1];
      const x32 = points[t32];
      const y32 = points[t32 + 1];
      const dx = x22 - x13;
      const dy = y22 - y13;
      const ex = x32 - x13;
      const ey = y32 - y13;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull) bx += points[i2 * 2], by += points[i2 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a5 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
        x4 = (x13 + x32) / 2 - a5 * ey;
        y4 = (y13 + y32) / 2 + a5 * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x4 = x13 + (ey * bl - dy * cl) * d;
        y4 = y13 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x4;
      circumcenters[j + 1] = y4;
    }
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x06, x12 = points[2 * h];
    let y06, y12 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x06 = x12, y06 = y12;
      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y06 - y12;
      vectors[p0 + 3] = vectors[p1 + 1] = x12 - x06;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x4 = circumcenters[t];
      const y4 = circumcenters[t + 1];
      const v2 = h0 * 4;
      const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);
      if (p) this._renderSegment(x4, y4, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
        context.lineTo(points[i2], points[i2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon2 = new Polygon();
    this.renderCell(i, polygon2);
    return polygon2.value();
  }
  _renderSegment(x06, y06, x12, y12, context) {
    let S;
    const c0 = this._regioncode(x06, y06);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x06, y06);
      context.lineTo(x12, y12);
    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x4, y4) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4)) return false;
    return this.delaunay._step(i, x4, y4) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const { vectors: V } = this;
    const v2 = i * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points));
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x06, y06, x12 = points[n - 2], y12 = points[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x12, y12);
        else P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x06, y06, x12, y12, c0, c1) {
    const flip2 = c0 < c1;
    if (flip2) [x06, y06, x12, y12, c0, c1] = [x12, y12, x06, y06, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip2 ? [x12, y12, x06, y06] : [x06, y06, x12, y12];
      if (c0 & c1) return null;
      let x4, y4, c3 = c0 || c1;
      if (c3 & 8) x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;
      else if (c3 & 4) x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;
      else if (c3 & 2) y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;
      else y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;
      if (c0) x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);
      else x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x4, y4;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        // top-left
        case 4:
          e0 = 6, x4 = this.xmax, y4 = this.ymin;
          break;
        // top
        case 6:
          e0 = 2;
          continue;
        // top-right
        case 2:
          e0 = 10, x4 = this.xmax, y4 = this.ymax;
          break;
        // right
        case 10:
          e0 = 8;
          continue;
        // bottom-right
        case 8:
          e0 = 9, x4 = this.xmin, y4 = this.ymax;
          break;
        // bottom
        case 9:
          e0 = 1;
          continue;
        // bottom-left
        case 1:
          e0 = 5, x4 = this.xmin, y4 = this.ymin;
          break;
      }
      if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {
        P.splice(j, 0, x4, y4), j += 2;
      }
    }
    return j;
  }
  _project(x06, y06, vx, vy) {
    let t = Infinity, c3, x4, y4;
    if (vy < 0) {
      if (y06 <= this.ymin) return null;
      if ((c3 = (this.ymin - y06) / vy) < t) y4 = this.ymin, x4 = x06 + (t = c3) * vx;
    } else if (vy > 0) {
      if (y06 >= this.ymax) return null;
      if ((c3 = (this.ymax - y06) / vy) < t) y4 = this.ymax, x4 = x06 + (t = c3) * vx;
    }
    if (vx > 0) {
      if (x06 >= this.xmax) return null;
      if ((c3 = (this.xmax - x06) / vx) < t) x4 = this.xmax, y4 = y06 + (t = c3) * vy;
    } else if (vx < 0) {
      if (x06 <= this.xmin) return null;
      if ((c3 = (this.xmin - x06) / vx) < t) x4 = this.xmin, y4 = y06 + (t = c3) * vy;
    }
    return [x4, y4];
  }
  _edgecode(x4, y4) {
    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);
  }
  _regioncode(x4, y4) {
    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);
  }
  _simplify(P) {
    if (P && P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length, k3 = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k3] || P[i + 1] === P[j + 1] && P[j + 1] === P[k3 + 1]) {
          P.splice(j, 2), i -= 2;
        }
      }
      if (!P.length) P = null;
    }
    return P;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau3 = 2 * Math.PI;
var pow3 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a5 = 2 * triangles[i], b = 2 * triangles[i + 1], c3 = 2 * triangles[i + 2], cross3 = (coords[c3] - coords[a5]) * (coords[b + 1] - coords[a5 + 1]) - (coords[b] - coords[a5]) * (coords[c3 + 1] - coords[a5 + 1]);
    if (cross3 > 1e-10) return false;
  }
  return true;
}
function jitter(x4, y4, r) {
  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
      const e = this.collinear[0], f2 = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f2], points[2 * f2 + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l = collinear2.indexOf(i);
      if (l > 0) yield collinear2[l - 1];
      if (l < collinear2.length - 1) yield collinear2[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x4, y4, i = 0) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4)) return -1;
    const i0 = i;
    let c3;
    while ((c3 = this._step(i, x4, y4)) >= 0 && c3 !== i && c3 !== i0) i = c3;
    return c3;
  }
  _step(i, x4, y4) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c3 = i;
    let dc = pow3(x4 - points[i * 2], 2) + pow3(y4 - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow3(x4 - points[t * 2], 2) + pow3(y4 - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c3 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow3(x4 - points[e * 2], 2) + pow3(y4 - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c3;
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r) {
    if (r === void 0 && (!context || typeof context.moveTo !== "function")) r = context, context = null;
    r = r == void 0 ? 2 : +r;
    const buffer = context == null ? context = new Path2() : void 0;
    const { points } = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x4 = points[i], y4 = points[i + 1];
      context.moveTo(x4 + r, y4);
      context.arc(x4, y4, r, 0, tau3);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h2 = 2 * hull[i];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon2 = new Polygon();
    this.renderHull(polygon2);
    return polygon2.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, triangles } = this;
    const t03 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context.moveTo(points[t03], points[t03 + 1]);
    context.lineTo(points[t13], points[t13 + 1]);
    context.lineTo(points[t22], points[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon2 = new Polygon();
    this.renderTriangle(i, polygon2);
    return polygon2.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array3 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array3[i * 2] = fx.call(that, p, i, points);
    array3[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array3;
}
function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}

// node_modules/d3-geo/src/math.js
var epsilon5 = 1e-6;
var epsilon23 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau4 = pi3 * 2;
var degrees3 = 180 / pi3;
var radians2 = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil2 = Math.ceil;
var exp2 = Math.exp;
var hypot = Math.hypot;
var log3 = Math.log;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x4) {
  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
};
var sqrt4 = Math.sqrt;
var tan = Math.tan;
function acos2(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi3 : Math.acos(x4);
}
function asin2(x4) {
  return x4 > 1 ? halfPi2 : x4 < -1 ? -halfPi2 : Math.asin(x4);
}
function haversin(x4) {
  return (x4 = sin2(x4 / 2)) * x4;
}

// node_modules/d3-geo/src/noop.js
function noop4() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamLine(coordinates2[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamPolygon(coordinates2[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates2, stream, closed) {
  var i = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates2[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian(spherical3) {
  var lambda = spherical3[0], phi2 = spherical3[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1] + a5[2] * b[2];
}
function cartesianCross(a5, b) {
  return [a5[1] * b[2] - a5[2] * b[1], a5[2] * b[0] - a5[0] * b[2], a5[0] * b[1] - a5[1] * b[0]];
}
function cartesianAddInPlace(a5, b) {
  a5[0] += b[0], a5[1] += b[1], a5[2] += b[2];
}
function cartesianScale(vector, k3) {
  return [vector[0] * k3, vector[1] * k3, vector[2] * k3];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt4(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00;
var phi00;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop4,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x4, y4, z) {
  ++W0;
  X0 += (x4 - X0) / W0;
  Y0 += (y4 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan22(sqrt4((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x4 - x0 * z, cz = x0 * y4 - y0 * x4, m3 = hypot(cx, cy, cz), w = asin2(m3), v2 = m3 && -w / m3;
  X2.add(v2 * cx);
  Y2.add(v2 * cy);
  Z2.add(v2 * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x4 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x4, y4, z);
  if (m3 < epsilon23) {
    x4 = X1, y4 = Y1, z = Z1;
    if (W1 < epsilon5) x4 = X0, y4 = Y0, z = Z0;
    m3 = hypot(x4, y4, z);
    if (m3 < epsilon23) return [NaN, NaN];
  }
  return [atan22(y4, x4) * degrees3, asin2(z / m3) * degrees3];
}

// node_modules/d3-geo/src/constant.js
function constant_default4(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-geo/src/compose.js
function compose_default(a5, b) {
  function compose(x4, y4) {
    return x4 = a5(x4, y4), b(x4[0], x4[1]);
  }
  if (a5.invert && b.invert) compose.invert = function(x4, y4) {
    return x4 = b.invert(x4, y4), x4 && a5.invert(x4[0], x4[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau4) * tau4;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau4) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau4) * tau4;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k3 = z * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan22(y4 * cosDeltaGamma - k3 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k3 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k3 = z * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan22(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k3 * sinDeltaPhi),
      asin2(k3 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau4;
    t13 = radius - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau4;
  }
  for (var point10, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
    point10 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point10[0], point10[1]);
  }
}
function circleRadius(cosRadius, point10) {
  point10 = cartesian(point10), point10[0] -= cosRadius;
  cartesianNormalizeInPlace(point10);
  var radius = acos2(-point10[1]);
  return ((-point10[2] < 0 ? -radius : radius) + tau4 - epsilon5) % tau4;
}
function circle_default2() {
  var center2 = constant_default4([0, 0]), radius = constant_default4(90), precision = constant_default4(2), ring, rotate, stream = { point: point10 };
  function point10(x4, y4) {
    ring.push(x4 = rotate(x4, y4));
    x4[0] *= degrees3, x4[1] *= degrees3;
  }
  function circle() {
    var c3 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;
    ring = [];
    rotate = rotateRadians(-c3[0] * radians2, -c3[1] * radians2, 0).invert;
    circleStream(stream, r, p, 1);
    c3 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c3;
  }
  circle.center = function(_) {
    return arguments.length ? (center2 = typeof _ === "function" ? _ : constant_default4([+_[0], +_[1]]), circle) : center2;
  };
  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default4(+_), circle) : radius;
  };
  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant_default4(+_), circle) : precision;
  };
  return circle;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x4, y4, m3) {
      line.push([x4, y4, m3]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop4,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result2 = lines;
      lines = [];
      line = null;
      return result2;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a5, b) {
  return abs2(a5[0] - b[0]) < epsilon5 && abs2(a5[1] - b[1]) < epsilon5;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point10, points, other, entry) {
  this.x = point10;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p0 = segment[0], p1 = segment[n2], x4;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon5;
    }
    subject.push(x4 = new Intersection(p0, segment, null, true));
    clip.push(x4.o = new Intersection(p0, null, x4, false));
    subject.push(x4 = new Intersection(p1, segment, null, false));
    clip.push(x4.o = new Intersection(p1, null, x4, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point10;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point10 = points[i])[0], point10[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point10 = points[i])[0], point10[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array3) {
  if (!(n = array3.length)) return;
  var n, i = 0, a5 = array3[0], b;
  while (++i < n) {
    a5.n = b = array3[i];
    b.p = a5;
    a5 = b;
  }
  a5.n = b = array3[0];
  b.p = a5;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point10) {
  return abs2(point10[0]) <= pi3 ? point10[0] : sign2(point10[0]) * ((abs2(point10[0]) + pi3) % tau4 - pi3);
}
function polygonContains_default(polygon2, point10) {
  var lambda = longitude(point10), phi2 = point10[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle = 0, winding = 0;
  var sum7 = new Adder();
  if (sinPhi === 1) phi2 = halfPi2 + epsilon5;
  else if (sinPhi === -1) phi2 = -halfPi2 - epsilon5;
  for (var i = 0, n = polygon2.length; i < n; ++i) {
    if (!(m3 = (ring = polygon2[i]).length)) continue;
    var ring, m3, point0 = ring[m3 - 1], lambda02 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi02 = sin2(phi0), cosPhi02 = cos2(phi0);
    for (var j = 0; j < m3; ++j, lambda02 = lambda1, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda02, sign5 = delta >= 0 ? 1 : -1, absDelta = sign5 * delta, antimeridian = absDelta > pi3, k3 = sinPhi02 * sinPhi1;
      sum7.add(atan22(k3 * sign5 * sin2(absDelta), cosPhi02 * cosPhi1 + k3 * cos2(absDelta)));
      angle += antimeridian ? delta + sign5 * tau4 : delta;
      if (antimeridian ^ lambda02 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection4 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection4);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection4[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon5 || angle < epsilon5 && sum7 < -epsilon23) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
    var clip = {
      point: point10,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon2 = [];
      },
      polygonEnd: function() {
        clip.point = point10;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon2, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon2 = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point10(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point10;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point11;
      ring.pop();
      polygon2.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m3; ++i) sink.point((point11 = segment[i])[0], point11[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a5, b) {
  return ((a5 = a5.x)[0] < 0 ? a5[1] - halfPi2 - epsilon5 : halfPi2 - a5[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon5 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda02 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda02);
      if (abs2(delta - pi3) < epsilon5) {
        stream.point(lambda02, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda02 - sign0) < epsilon5) lambda02 -= sign0 * epsilon5;
        if (abs2(lambda1 - sign1) < epsilon5) lambda1 -= sign1 * epsilon5;
        phi0 = clipAntimeridianIntersect(lambda02, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda02 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda02 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda02, phi0, lambda1, phi1) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin2(lambda02 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon5 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi02 = cos2(phi0)) * sin2(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon5) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default3(radius) {
  var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon5;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c3 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect2(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect2(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect2(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t;
          if (!(c3 & c0) && (t = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c3;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a5, b, two) {
    var pa = cartesian(a5), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a5;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B3);
    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t = sqrt4(t22), q = cartesianScale(u4, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda02 = a5[0], lambda1 = b[0], phi0 = a5[1], phi1 = b[1], z;
    if (lambda1 < lambda02) z = lambda02, lambda02 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda02, polar = abs2(delta2 - pi3) < epsilon5, meridian = polar || delta2 < epsilon5;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda02) < epsilon5 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda02 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u4, (-w + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi2 < -r) code2 |= 4;
    else if (phi2 > r) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a5, b, x06, y06, x12, y12) {
  var ax = a5[0], ay = a5[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x06 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dx > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dx > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  r = y06 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dy > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dy > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  if (t03 > 0) a5[0] = ax + t03 * dx, a5[1] = ay + t03 * dy;
  if (t13 < 1) b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x4, y4) {
    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a5 = 0, a1 = 0;
    if (from == null || (a5 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a5 === 0 || a5 === 3 ? x06 : x12, a5 > 1 ? y12 : y06);
      while ((a5 = (a5 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x06) < epsilon5 ? direction > 0 ? 0 : 3 : abs2(p[0] - x12) < epsilon5 ? direction > 0 ? 2 : 1 : abs2(p[1] - y06) < epsilon5 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a5, b) {
    return comparePoint(a5.x, b.x);
  }
  function comparePoint(a5, b) {
    var ca3 = corner(a5, 1), cb = corner(b, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a5[1] : ca3 === 1 ? a5[0] - b[0] : ca3 === 2 ? a5[1] - b[1] : b[0] - a5[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point10,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point10(x4, y4) {
      if (visible(x4, y4)) activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon2.length; i < n; ++i) {
        for (var ring2 = polygon2[i], j = 1, m3 = ring2.length, point11 = ring2[0], a0, a1, b0 = point11[0], b1 = point11[1]; j < m3; ++j) {
          a0 = b0, a1 = b1, point11 = ring2[j], b0 = point11[0], b1 = point11[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon2 = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon2 = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon2) polygon2.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point10;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x4, y4) {
      var v2 = visible(x4, y4);
      if (polygon2) ring.push([x4, y4]);
      if (first) {
        x__ = x4, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v2 && v_) activeStream.point(x4, y4);
        else {
          var a5 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default2(a5, b, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a5[0], a5[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/length.js
var lengthSum;
var lambda0;
var sinPhi0;
var cosPhi0;
var lengthStream = {
  sphere: noop4,
  point: noop4,
  lineStart: lengthLineStart,
  lineEnd: noop4,
  polygonStart: noop4,
  polygonEnd: noop4
};
function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop4;
}
function lengthPointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, sinPhi0 = sin2(phi2), cosPhi0 = cos2(phi2);
  lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs2(lambda - lambda0), cosDelta = cos2(delta), sinDelta = sin2(delta), x4 = cosPhi * sinDelta, y4 = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta, z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(atan22(sqrt4(x4 * x4 + y4 * y4), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}
function length_default(object2) {
  lengthSum = new Adder();
  stream_default(object2, lengthStream);
  return +lengthSum;
}

// node_modules/d3-geo/src/distance.js
var coordinates = [null, null];
var object = { type: "LineString", coordinates };
function distance_default(a5, b) {
  coordinates[0] = a5;
  coordinates[1] = b;
  return length_default(object);
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y4 = range(y06, y12 - epsilon5, dy).concat(y12);
  return function(x4) {
    return y4.map(function(y5) {
      return [x4, y5];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x4 = range(x06, x12 - epsilon5, dx).concat(x12);
  return function(y4) {
    return x4.map(function(x5) {
      return [x5, y4];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil2(X03 / DX) * DX, X13, DX).map(X).concat(range(ceil2(Y03 / DY) * DY, Y13, DY).map(Y)).concat(range(ceil2(x06 / dx) * dx, x12, dx).filter(function(x5) {
      return abs2(x5 % DX) > epsilon5;
    }).map(x4)).concat(range(ceil2(y06 / dy) * dy, y12, dy).filter(function(y5) {
      return abs2(y5 % DY) > epsilon5;
    }).map(y4));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X03).concat(
          Y(Y13).slice(1),
          X(X13).reverse().slice(1),
          Y(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13) _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13) _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x06, y06], [x12, y12]];
    x06 = +_[0][0], x12 = +_[1][0];
    y06 = +_[0][1], y12 = +_[1][1];
    if (x06 > x12) _ = x06, x06 = x12, x12 = _;
    if (y06 > y12) _ = y06, y06 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x4 = graticuleX(y06, y12, 90);
    y4 = graticuleY(x06, x12, precision);
    X = graticuleX(Y03, Y13, 90);
    Y = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon5], [180, 90 - epsilon5]]).extentMinor([[-180, -80 - epsilon5], [180, 80 + epsilon5]]);
}

// node_modules/d3-geo/src/interpolate.js
function interpolate_default(a5, b) {
  var x06 = a5[0] * radians2, y06 = a5[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin2(sqrt4(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k3 = sin2(d);
  var interpolate = d ? function(t) {
    var B3 = sin2(t *= d) / k3, A5 = sin2(d - t) / k3, x4 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;
    return [
      atan22(y4, x4) * degrees3,
      atan22(z, sqrt4(x4 * x4 + y4 * y4)) * degrees3
    ];
  } : function() {
    return [x06 * degrees3, y06 * degrees3];
  };
  interpolate.distance = d;
  return interpolate;
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x4) => x4;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop4,
  lineStart: noop4,
  lineEnd: noop4,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop4;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area = areaSum2 / 2;
    areaSum2 = new Adder();
    return area;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x4, y4) {
  areaStream2.point = areaPoint;
  x00 = x02 = x4, y00 = y02 = y4;
}
function areaPoint(x4, y4) {
  areaRingSum2.add(y02 * x4 - x02 * y4);
  x02 = x4, y02 = y4;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop4,
  lineEnd: noop4,
  polygonStart: noop4,
  polygonEnd: noop4,
  result: function() {
    var bounds = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds;
  }
};
function boundsPoint(x4, y4) {
  if (x4 < x03) x03 = x4;
  if (x4 > x1) x1 = x4;
  if (y4 < y03) y03 = y4;
  if (y4 > y1) y1 = y4;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x4, y4) {
  X02 += x4;
  Y02 += y4;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x4, y4) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidPointLine(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x4) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x4, y4) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);
}
function centroidPointRing(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x4) / 2;
  Y12 += z * (y04 + y4) / 2;
  Z12 += z;
  z = y04 * x4 - x04 * y4;
  X22 += z * (x04 + x4);
  Y22 += z * (y04 + y4);
  Z22 += z * 3;
  centroidPoint2(x04 = x4, y04 = y4);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x4, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x4, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x4, y4);
        break;
      }
      default: {
        this._context.moveTo(x4 + this._radius, y4);
        this._context.arc(x4, y4, this._radius, 0, tau4);
        break;
      }
    }
  },
  result: noop4
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum2 = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream2 = {
  point: noop4,
  lineStart: function() {
    lengthStream2.point = lengthPointFirst2;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint2(x003, y003);
    lengthStream2.point = noop4;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum2;
    lengthSum2 = new Adder();
    return length;
  }
};
function lengthPointFirst2(x4, y4) {
  lengthStream2.point = lengthPoint2;
  x003 = x05 = x4, y003 = y05 = y4;
}
function lengthPoint2(x4, y4) {
  x05 -= x4, y05 -= y4;
  lengthSum2.add(sqrt4(x05 * x05 + y05 * y05));
  x05 = x4, y05 = y4;
}
var measure_default = lengthStream2;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append3 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x4, y4) {
    switch (this._point) {
      case 0: {
        this._append`M${x4},${y4}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x4},${y4}`;
        break;
      }
      default: {
        this._append`M${x4},${y4}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s3 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s3;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result2 = this._;
    this._ = "";
    return result2.length ? result2 : null;
  }
};
function append3(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append3;
  if (d !== cacheDigits) {
    const k3 = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append4(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path3(object2) {
    if (object2) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object2) {
    stream_default(object2, projectionStream(area_default2));
    return area_default2.result();
  };
  path3.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path3.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path3.projection = function(_) {
    if (!arguments.length) return projection2;
    projectionStream = _ == null ? (projection2 = null, identity_default4) : (projection2 = _).stream;
    return path3;
  };
  path3.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path3;
  };
  path3.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context === null) contextStream = new PathString(digits);
    return path3;
  };
  return path3.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transform_default2(methods) {
  return {
    stream: transformer2(methods)
  };
}
function transformer2(methods) {
  return function(stream) {
    var s3 = new TransformStream();
    for (var key2 in methods) s3[key2] = methods[key2];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x4, y4) {
    this.stream.point(x4, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object2) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k3 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x4 = +extent2[0][0] + (w - k3 * (b[1][0] + b[0][0])) / 2, y4 = +extent2[0][1] + (h - k3 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k3).translate([x4, y4]);
  }, object2);
}
function fitSize(projection2, size2, object2) {
  return fitExtent(projection2, [[0, 0], size2], object2);
}
function fitWidth(projection2, width, object2) {
  return fit(projection2, function(b) {
    var w = +width, k3 = w / (b[1][0] - b[0][0]), x4 = (w - k3 * (b[1][0] + b[0][0])) / 2, y4 = -k3 * b[0][1];
    projection2.scale(150 * k3).translate([x4, y4]);
  }, object2);
}
function fitHeight(projection2, height, object2) {
  return fit(projection2, function(b) {
    var h = +height, k3 = h / (b[1][1] - b[0][1]), x4 = -k3 * b[0][0], y4 = (h - k3 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k3).translate([x4, y4]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer2({
    point: function(x4, y4) {
      x4 = project(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x06, y06, lambda02, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a5 = a0 + a1, b = b0 + b1, c3 = c0 + c1, m3 = sqrt4(a5 * a5 + b * b + c3 * c3), phi2 = asin2(c3 /= m3), lambda2 = abs2(abs2(c3) - 1) < epsilon5 || abs2(lambda02 - lambda1) < epsilon5 ? (lambda02 + lambda1) / 2 : atan22(b, a5), p = project(lambda2, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda02, a0, b0, c0, x22, y22, lambda2, a5 /= m3, b /= m3, c3, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a5, b, c3, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda002, x004, y004, a00, b00, c00, lambda02, x06, y06, a0, b0, c0;
    var resampleStream = {
      point: point10,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point10(x4, y4) {
      x4 = project(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c3 = cartesian([lambda, phi2]), p = project(lambda, phi2);
      resampleLineTo(x06, y06, lambda02, a0, b0, c0, x06 = p[0], y06 = p[1], lambda02 = lambda, a0 = c3[0], b0 = c3[1], c0 = c3[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point10;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda002 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda02, a0, b0, c0, x004, y004, lambda002, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer2({
  point: function(x4, y4) {
    this.stream.point(x4 * radians2, y4 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer2({
    point: function(x4, y4) {
      var r = rotate(x4, y4);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k3, dx, dy, sx, sy) {
  function transform2(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [dx + k3 * x4, dy - k3 * y4];
  }
  transform2.invert = function(x4, y4) {
    return [(x4 - dx) / k3 * sx, (dy - y4) / k3 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k3, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a5 = cosAlpha * k3, b = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
  function transform2(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [a5 * x4 - b * y4 + dx, dy - b * x4 - a5 * y4];
  }
  transform2.invert = function(x4, y4) {
    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k3 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point10) {
    return projectRotateTransform(point10[0] * radians2, point10[1] * radians2);
  }
  function invert2(point10) {
    point10 = projectRotateTransform.invert(point10[0], point10[1]);
    return point10 && [point10[0] * degrees3, point10[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset2()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default3(theta = _ * radians2) : (theta = null, antimeridian_default), reset2()) : theta * degrees3;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default4) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k3 = +_, recenter()) : k3;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x4 = +_[0], y4 = +_[1], recenter()) : [x4, y4];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset2()) : sqrt4(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size2, object2) {
    return fitSize(projection2, size2, object2);
  };
  projection2.fitWidth = function(width, object2) {
    return fitWidth(projection2, width, object2);
  };
  projection2.fitHeight = function(height, object2) {
    return fitHeight(projection2, height, object2);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k3, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset2();
  }
  function reset2() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x4, y4) {
    var cx = cos2(x4), cy = cos2(y4), k3 = scale2(cx * cy);
    if (k3 === Infinity) return [2, 0];
    return [
      k3 * cy * sin2(x4),
      k3 * sin2(y4)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x4, y4) {
    var z = sqrt4(x4 * x4 + y4 * y4), c3 = angle(z), sc = sin2(c3), cc2 = cos2(c3);
    return [
      atan22(x4 * sc, z * cc2),
      asin2(z && y4 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt4(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c3) {
  return (c3 = acos2(c3)) && c3 / sin2(c3);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log3(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x4, y4) {
  return [x4, 2 * atan(exp2(y4)) - halfPi2];
};

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt4(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x4, y4) {
  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon23) break;
  }
  return [
    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x4, y4) {
  var cy = cos2(y4), k3 = cos2(x4) * cy;
  return [cy * sin2(x4) / k3, sin2(y4) / k3];
}
gnomonicRaw.invert = azimuthalInvert(atan);

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x4, y4) {
  var phi2 = y4, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon5 && --i > 0);
  return [
    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x4, y4) {
  return [cos2(y4) * sin2(x4), sin2(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon5);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x4, y4) {
  var cy = cos2(y4), k3 = 1 + cos2(x4) * cy;
  return [cy * sin2(x4) / k3, sin2(y4) / k3];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log3(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x4, y4) {
  return [-y4, 2 * atan(exp2(x4)) - halfPi2];
};

// node_modules/d3-geo-voronoi/src/math.js
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi2 = pi4 / 4;
var tau5 = pi4 * 2;
var degrees4 = 180 / pi4;
var radians3 = pi4 / 180;
var atan23 = Math.atan2;
var cos3 = Math.cos;
var max4 = Math.max;
var min4 = Math.min;
var sin3 = Math.sin;
var sign3 = Math.sign || function(x4) {
  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
};
var sqrt5 = Math.sqrt;
function asin3(x4) {
  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);
}

// node_modules/d3-geo-voronoi/src/cartesian.js
function cartesianDot2(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1] + a5[2] * b[2];
}
function cartesianCross2(a5, b) {
  return [
    a5[1] * b[2] - a5[2] * b[1],
    a5[2] * b[0] - a5[0] * b[2],
    a5[0] * b[1] - a5[1] * b[0]
  ];
}
function cartesianAdd(a5, b) {
  return [a5[0] + b[0], a5[1] + b[1], a5[2] + b[2]];
}
function cartesianNormalize(d) {
  var l = sqrt5(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  return [d[0] / l, d[1] / l, d[2] / l];
}

// node_modules/d3-geo-voronoi/src/delaunay.js
function spherical2(cartesian3) {
  return [
    atan23(cartesian3[1], cartesian3[0]) * degrees4,
    asin3(max4(-1, min4(1, cartesian3[2]))) * degrees4
  ];
}
function cartesian2(coordinates2) {
  const lambda = coordinates2[0] * radians3, phi2 = coordinates2[1] * radians3, cosphi = cos3(phi2);
  return [cosphi * cos3(lambda), cosphi * sin3(lambda), sin3(phi2)];
}
function excess(triangle) {
  triangle = triangle.map((p) => cartesian2(p));
  return cartesianDot2(triangle[0], cartesianCross2(triangle[2], triangle[1]));
}
function geoDelaunay(points) {
  const delaunay = geo_delaunay_from(points), triangles = geo_triangles(delaunay), edges = geo_edges(triangles, points), neighbors = geo_neighbors(triangles, points.length), find3 = geo_find(neighbors, points), circumcenters = geo_circumcenters(triangles, points), { polygons, centers } = geo_polygons(circumcenters, triangles, points), mesh = geo_mesh(polygons), hull = geo_hull(triangles, points), urquhart = geo_urquhart(edges, triangles);
  return {
    delaunay,
    edges,
    triangles,
    centers,
    neighbors,
    polygons,
    mesh,
    hull,
    urquhart,
    find: find3
  };
}
function geo_find(neighbors, points) {
  function distance2(a5, b) {
    let x4 = a5[0] - b[0], y4 = a5[1] - b[1], z = a5[2] - b[2];
    return x4 * x4 + y4 * y4 + z * z;
  }
  return function find3(x4, y4, next) {
    if (next === void 0) next = 0;
    let cell, dist2, found = next;
    const xyz = cartesian2([x4, y4]);
    do {
      cell = next;
      next = null;
      dist2 = distance2(xyz, cartesian2(points[cell]));
      neighbors[cell].forEach((i) => {
        let ndist = distance2(xyz, cartesian2(points[i]));
        if (ndist < dist2) {
          dist2 = ndist;
          next = i;
          found = i;
          return;
        }
      });
    } while (next !== null);
    return found;
  };
}
function geo_delaunay_from(points) {
  if (points.length < 2) return {};
  let pivot = 0;
  while (isNaN(points[pivot][0] + points[pivot][1]) && pivot++ < points.length) ;
  const r = rotation_default(points[pivot]), projection2 = stereographic_default().translate([0, 0]).scale(1).rotate(r.invert([180, 0]));
  points = points.map(projection2);
  const zeros = [];
  let max22 = 1;
  for (let i = 0, n = points.length; i < n; i++) {
    let m3 = points[i][0] ** 2 + points[i][1] ** 2;
    if (!isFinite(m3) || m3 > 1e32) zeros.push(i);
    else if (m3 > max22) max22 = m3;
  }
  const FAR = 1e6 * sqrt5(max22);
  zeros.forEach((i) => points[i] = [FAR, 0]);
  points.push([0, FAR]);
  points.push([-FAR, 0]);
  points.push([0, -FAR]);
  const delaunay = Delaunay.from(points);
  delaunay.projection = projection2;
  const { triangles, halfedges, inedges } = delaunay;
  const degenerate = [];
  for (let i = 0, l = halfedges.length; i < l; i++) {
    if (halfedges[i] < 0) {
      const j = i % 3 == 2 ? i - 2 : i + 1;
      const k3 = i % 3 == 0 ? i + 2 : i - 1;
      const a5 = halfedges[j];
      const b = halfedges[k3];
      halfedges[a5] = b;
      halfedges[b] = a5;
      halfedges[j] = halfedges[k3] = -1;
      triangles[i] = triangles[j] = triangles[k3] = pivot;
      inedges[triangles[a5]] = a5 % 3 == 0 ? a5 + 2 : a5 - 1;
      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;
      degenerate.push(Math.min(i, j, k3));
      i += 2 - i % 3;
    } else if (triangles[i] > points.length - 3 - 1) {
      triangles[i] = pivot;
    }
  }
  return delaunay;
}
function geo_edges(triangles, points) {
  const _index = /* @__PURE__ */ new Set();
  if (points.length === 2) return [[0, 1]];
  triangles.forEach((tri) => {
    if (tri[0] === tri[1]) return;
    if (excess(tri.map((i) => points[i])) < 0) return;
    for (let i = 0, j; i < 3; i++) {
      j = (i + 1) % 3;
      _index.add(extent([tri[i], tri[j]]).join("-"));
    }
  });
  return Array.from(_index, (d) => d.split("-").map(Number));
}
function geo_triangles(delaunay) {
  const { triangles } = delaunay;
  if (!triangles) return [];
  const geo_triangles2 = [];
  for (let i = 0, n = triangles.length / 3; i < n; i++) {
    const a5 = triangles[3 * i], b = triangles[3 * i + 1], c3 = triangles[3 * i + 2];
    if (a5 !== b && b !== c3) {
      geo_triangles2.push([a5, c3, b]);
    }
  }
  return geo_triangles2;
}
function geo_circumcenters(triangles, points) {
  return triangles.map((tri) => {
    const c3 = tri.map((i) => points[i]).map(cartesian2), V = cartesianAdd(
      cartesianAdd(cartesianCross2(c3[1], c3[0]), cartesianCross2(c3[2], c3[1])),
      cartesianCross2(c3[0], c3[2])
    );
    return spherical2(cartesianNormalize(V));
  });
}
function geo_neighbors(triangles, npoints) {
  const neighbors = [];
  triangles.forEach((tri) => {
    for (let j = 0; j < 3; j++) {
      const a5 = tri[j], b = tri[(j + 1) % 3];
      neighbors[a5] = neighbors[a5] || [];
      neighbors[a5].push(b);
    }
  });
  if (triangles.length === 0) {
    if (npoints === 2) neighbors[0] = [1], neighbors[1] = [0];
    else if (npoints === 1) neighbors[0] = [];
  }
  return neighbors;
}
function geo_polygons(circumcenters, triangles, points) {
  const polygons = [];
  const centers = circumcenters.slice();
  if (triangles.length === 0) {
    if (points.length < 2) return { polygons, centers };
    if (points.length === 2) {
      const a5 = cartesian2(points[0]), b = cartesian2(points[1]), m3 = cartesianNormalize(cartesianAdd(a5, b)), d = cartesianNormalize(cartesianCross2(a5, b)), c3 = cartesianCross2(m3, d);
      const poly = [
        m3,
        cartesianCross2(m3, c3),
        cartesianCross2(cartesianCross2(m3, c3), c3),
        cartesianCross2(cartesianCross2(cartesianCross2(m3, c3), c3), c3)
      ].map(spherical2).map(supplement);
      return polygons.push(poly), polygons.push(poly.slice().reverse()), { polygons, centers };
    }
  }
  triangles.forEach((tri, t) => {
    for (let j = 0; j < 3; j++) {
      const a5 = tri[j], b = tri[(j + 1) % 3], c3 = tri[(j + 2) % 3];
      polygons[a5] = polygons[a5] || [];
      polygons[a5].push([b, c3, t, [a5, b, c3]]);
    }
  });
  const reordered = polygons.map((poly) => {
    const p = [poly[0][2]];
    let k3 = poly[0][1];
    for (let i = 1; i < poly.length; i++) {
      for (let j = 0; j < poly.length; j++) {
        if (poly[j][0] == k3) {
          k3 = poly[j][1];
          p.push(poly[j][2]);
          break;
        }
      }
    }
    if (p.length > 2) {
      return p;
    } else if (p.length == 2) {
      const R0 = o_midpoint(
        points[poly[0][3][0]],
        points[poly[0][3][1]],
        centers[p[0]]
      ), R1 = o_midpoint(
        points[poly[0][3][2]],
        points[poly[0][3][0]],
        centers[p[0]]
      );
      const i0 = supplement(R0), i1 = supplement(R1);
      return [p[0], i1, p[1], i0];
    }
  });
  function supplement(point10) {
    let f2 = -1;
    centers.slice(triangles.length, Infinity).forEach((p, i) => {
      if (p[0] === point10[0] && p[1] === point10[1]) f2 = i + triangles.length;
    });
    if (f2 < 0) f2 = centers.length, centers.push(point10);
    return f2;
  }
  return { polygons: reordered, centers };
}
function o_midpoint(a5, b, c3) {
  a5 = cartesian2(a5);
  b = cartesian2(b);
  c3 = cartesian2(c3);
  const s3 = sign3(cartesianDot2(cartesianCross2(b, a5), c3));
  return spherical2(cartesianNormalize(cartesianAdd(a5, b)).map((d) => s3 * d));
}
function geo_mesh(polygons) {
  const mesh = [];
  polygons.forEach((poly) => {
    if (!poly) return;
    let p = poly[poly.length - 1];
    for (let q of poly) {
      if (q > p) mesh.push([p, q]);
      p = q;
    }
  });
  return mesh;
}
function geo_urquhart(edges, triangles) {
  return function(distances) {
    const _lengths = /* @__PURE__ */ new Map(), _urquhart = /* @__PURE__ */ new Map();
    edges.forEach((edge, i) => {
      const u4 = edge.join("-");
      _lengths.set(u4, distances[i]);
      _urquhart.set(u4, true);
    });
    triangles.forEach((tri) => {
      let l = 0, remove2 = -1;
      for (let j = 0; j < 3; j++) {
        let u4 = extent([tri[j], tri[(j + 1) % 3]]).join("-");
        if (_lengths.get(u4) > l) {
          l = _lengths.get(u4);
          remove2 = u4;
        }
      }
      _urquhart.set(remove2, false);
    });
    return edges.map((edge) => _urquhart.get(edge.join("-")));
  };
}
function geo_hull(triangles, points) {
  const _hull = /* @__PURE__ */ new Set(), hull = [];
  triangles.map((tri) => {
    if (excess(tri.map((i) => points[i > points.length ? 0 : i])) > 1e-12)
      return;
    for (let i = 0; i < 3; i++) {
      let e = [tri[i], tri[(i + 1) % 3]], code = `${e[0]}-${e[1]}`;
      if (_hull.has(code)) _hull.delete(code);
      else _hull.add(`${e[1]}-${e[0]}`);
    }
  });
  const _index = /* @__PURE__ */ new Map();
  let start;
  _hull.forEach((e) => {
    e = e.split("-").map(Number);
    _index.set(e[0], e[1]);
    start = e[0];
  });
  if (start === void 0) return hull;
  let next = start;
  do {
    hull.push(next);
    let n = _index.get(next);
    _index.set(next, -1);
    next = n;
  } while (next > -1 && next !== start);
  return hull;
}

// node_modules/d3-geo-voronoi/src/voronoi.js
function geoVoronoi(data) {
  const v2 = function(data2) {
    v2.delaunay = null;
    v2._data = data2;
    if (typeof v2._data === "object" && v2._data.type === "FeatureCollection") {
      v2._data = v2._data.features;
    }
    if (typeof v2._data === "object") {
      const temp = v2._data.map((d) => [v2._vx(d), v2._vy(d), d]).filter((d) => isFinite(d[0] + d[1]));
      v2.points = temp.map((d) => [d[0], d[1]]);
      v2.valid = temp.map((d) => d[2]);
      v2.delaunay = geoDelaunay(v2.points);
    }
    return v2;
  };
  v2._vx = function(d) {
    if (typeof d == "object" && "type" in d) {
      return centroid_default(d)[0];
    }
    if (0 in d) return d[0];
  };
  v2._vy = function(d) {
    if (typeof d == "object" && "type" in d) {
      return centroid_default(d)[1];
    }
    if (1 in d) return d[1];
  };
  v2.x = function(f2) {
    if (!f2) return v2._vx;
    v2._vx = f2;
    return v2;
  };
  v2.y = function(f2) {
    if (!f2) return v2._vy;
    v2._vy = f2;
    return v2;
  };
  v2.polygons = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const coll = {
      type: "FeatureCollection",
      features: []
    };
    if (v2.valid.length === 0) return coll;
    v2.delaunay.polygons.forEach(
      (poly, i) => coll.features.push({
        type: "Feature",
        geometry: !poly ? null : {
          type: "Polygon",
          coordinates: [
            [...poly, poly[0]].map((i2) => v2.delaunay.centers[i2])
          ]
        },
        properties: {
          site: v2.valid[i],
          sitecoordinates: v2.points[i],
          neighbours: v2.delaunay.neighbors[i]
          // not part of the public API
        }
      })
    );
    if (v2.valid.length === 1)
      coll.features.push({
        type: "Feature",
        geometry: { type: "Sphere" },
        properties: {
          site: v2.valid[0],
          sitecoordinates: v2.points[0],
          neighbours: []
        }
      });
    return coll;
  };
  v2.triangles = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    return {
      type: "FeatureCollection",
      features: v2.delaunay.triangles.map((tri, index4) => {
        tri = tri.map((i) => v2.points[i]);
        tri.center = v2.delaunay.centers[index4];
        return tri;
      }).filter((tri) => excess(tri) > 0).map((tri) => ({
        type: "Feature",
        properties: {
          circumcenter: tri.center
        },
        geometry: {
          type: "Polygon",
          coordinates: [[...tri, tri[0]]]
        }
      }))
    };
  };
  v2.links = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const _distances = v2.delaunay.edges.map(
      (e) => distance_default(v2.points[e[0]], v2.points[e[1]])
    ), _urquart = v2.delaunay.urquhart(_distances);
    return {
      type: "FeatureCollection",
      features: v2.delaunay.edges.map((e, i) => ({
        type: "Feature",
        properties: {
          source: v2.valid[e[0]],
          target: v2.valid[e[1]],
          length: _distances[i],
          urquhart: !!_urquart[i]
        },
        geometry: {
          type: "LineString",
          coordinates: [v2.points[e[0]], v2.points[e[1]]]
        }
      }))
    };
  };
  v2.mesh = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    return {
      type: "MultiLineString",
      coordinates: v2.delaunay.edges.map((e) => [
        v2.points[e[0]],
        v2.points[e[1]]
      ])
    };
  };
  v2.cellMesh = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const { centers, polygons } = v2.delaunay;
    const coordinates2 = [];
    for (const p of polygons) {
      if (!p) continue;
      for (let n = p.length, p0 = p[n - 1], p1 = p[0], i = 0; i < n; p0 = p1, p1 = p[++i]) {
        if (p1 > p0) {
          coordinates2.push([centers[p0], centers[p1]]);
        }
      }
    }
    return {
      type: "MultiLineString",
      coordinates: coordinates2
    };
  };
  v2._found = void 0;
  v2.find = function(x4, y4, radius) {
    v2._found = v2.delaunay.find(x4, y4, v2._found);
    if (!radius || distance_default([x4, y4], v2.points[v2._found]) < radius)
      return v2._found;
  };
  v2.hull = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    const hull = v2.delaunay.hull, points = v2.points;
    return hull.length === 0 ? null : {
      type: "Polygon",
      coordinates: [[...hull.map((i) => points[i]), points[hull[0]]]]
    };
  };
  return data ? v2(data) : v2;
}

// node_modules/layerchart/dist/utils/geo.js
function geoCurvePath(projection2, curve, context) {
  const pathContext = context === void 0 ? path() : context;
  const geoPath = path_default(projection2, curveContext(curve(pathContext)));
  const fn = (object2) => {
    geoPath(object2);
    return context === void 0 ? pathContext + "" : void 0;
  };
  Object.setPrototypeOf(fn, geoPath);
  return fn;
}
function curveContext(curve) {
  return {
    beginPath() {
    },
    moveTo(x4, y4) {
      curve.lineStart();
      curve.point(x4, y4);
    },
    arc(x4, y4, radius, startAngle, endAngle, anticlockwise) {
    },
    lineTo(x4, y4) {
      curve.point(x4, y4);
    },
    closePath() {
      curve.lineEnd();
    }
  };
}
function antipode([longitude2, latitude]) {
  return [longitude2 + 180, -latitude];
}
function isVisible(projection2) {
  let visible;
  const stream = projection2.stream({
    point() {
      visible = true;
    }
  });
  return ([x4, y4]) => (visible = false, stream.point(x4, y4), visible);
}
function geoFitObjectTransform(projection2, size2, object2) {
  const newProjection = projection2.fitSize(size2, object2);
  const translate = newProjection.translate();
  return { translate: { x: translate[0], y: translate[1] }, scale: newProjection.scale() };
}

// node_modules/layerchart/dist/components/GeoPath.svelte
GeoPath[FILENAME] = "node_modules/layerchart/dist/components/GeoPath.svelte";
var root_32 = add_locations(from_svg(`<path></path>`), GeoPath[FILENAME], [[190, 2]]);
function GeoPath($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoPath);
  let curve = prop($$props, "curve", 3, linearClosed_default), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "fill",
      "stroke",
      "strokeWidth",
      "opacity",
      "geoTransform",
      "geojson",
      "tooltipContext",
      "curve",
      "onclick",
      "class",
      "ref",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const geo = getGeoContext();
  const projection2 = tag(
    user_derived(() => $$props.geoTransform && geo.projection ? transform_default2($$props.geoTransform(geo.projection)) : geo.projection),
    "projection"
  );
  const geoPath = tag(
    user_derived(() => {
      $$props.geojson;
      if (!get(projection2)) return;
      if (strict_equals(curve(), linearClosed_default)) {
        return path_default(get(projection2));
      }
      return geoCurvePath(get(projection2), curve());
    }),
    "geoPath"
  );
  const renderCtx = getRenderContext();
  function render2(ctx, styleOverrides) {
    if (!$$props.geojson) return;
    const pathData = get(geoPath)?.($$props.geojson);
    renderPathData(ctx, pathData, styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        stroke: $$props.stroke,
        strokeWidth: $$props.strokeWidth,
        opacity: $$props.opacity
      },
      classes: $$props.class
    });
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  function _onClick(e) {
    $$props.onclick?.(e, get(geoPath));
  }
  const _onPointerEnter = (e) => {
    $$props.onpointerenter?.(e);
    $$props.tooltipContext?.show(e, $$props.geojson);
  };
  const _onPointerMove = (e) => {
    $$props.onpointermove?.(e);
    $$props.tooltipContext?.show(e, $$props.geojson);
  };
  const _onPointerLeave = (e) => {
    $$props.onpointerleave?.(e);
    $$props.tooltipContext?.hide();
  };
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "GeoPath",
      render: render2,
      events: {
        // Only register events if they are defined (so they are not registered with hit canvas unnecessarily)
        click: $$props.onclick ? _onClick : void 0,
        pointerenter: $$props.onpointerenter || $$props.tooltipContext ? _onPointerEnter : void 0,
        pointermove: $$props.onpointermove || $$props.tooltipContext ? _onPointerMove : void 0,
        pointerleave: $$props.onpointerleave || $$props.tooltipContext ? _onPointerLeave : void 0,
        pointerdown: $$props.onpointerdown,
        touchmove: $$props.ontouchmove
      },
      deps: () => [
        get(projection2),
        $$props.geojson,
        curve(),
        fillKey.current,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children, () => ({ geoPath: get(geoPath) })), "render", GeoPath, 188, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var path3 = root_32();
          attribute_effect(
            path3,
            ($0, $1) => ({
              ...restProps,
              d: $0,
              fill: $$props.fill,
              stroke: $$props.stroke,
              "stroke-width": $$props.strokeWidth,
              opacity: $$props.opacity,
              onclick: _onClick,
              onpointerenter: _onPointerEnter,
              onpointermove: _onPointerMove,
              onpointerleave: _onPointerLeave,
              class: $1
            }),
            [
              () => $$props.geojson ? get(geoPath)?.($$props.geojson) : "",
              () => cls(layerClass("geo-path"), equals($$props.fill, null) && "fill-transparent", $$props.class)
            ]
          );
          bind_this(path3, ($$value) => set(ref, $$value), () => get(ref));
          append($$anchor3, path3);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(renderCtx, "svg")) $$render(consequent_1);
            },
            true
          ),
          "if",
          GeoPath,
          189,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      GeoPath,
      187,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoPath = hmr(GeoPath, () => GeoPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoPath[HMR].source;
    set(GeoPath[HMR].source, module2.default[HMR].original);
  });
}
var GeoPath_default = GeoPath;

// node_modules/layerchart/dist/components/Circle.svelte
Circle[FILENAME] = "node_modules/layerchart/dist/components/Circle.svelte";
var root_13 = add_locations(from_svg(`<circle></circle>`), Circle[FILENAME], [[154, 2]]);
function Circle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Circle);
  let cx = prop($$props, "cx", 3, 0), cy = prop($$props, "cy", 3, 0), r = prop($$props, "r", 3, 1), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cx",
      "initialCx",
      "cy",
      "initialCy",
      "r",
      "initialR",
      "motion",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "class",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const initialCx = $$props.initialCx ?? cx();
  const initialCy = $$props.initialCy ?? cy();
  const initialR = $$props.initialR ?? r();
  const renderCtx = getRenderContext();
  const motionCx = createMotion(initialCx, () => cx(), $$props.motion);
  const motionCy = createMotion(initialCy, () => cy(), $$props.motion);
  const motionR = createMotion(initialR, () => r(), $$props.motion);
  function render2(ctx, styleOverrides) {
    renderCircle(
      ctx,
      {
        cx: motionCx.current,
        cy: motionCy.current,
        r: motionR.current
      },
      styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
        styles: {
          fill: $$props.fill,
          fillOpacity: $$props.fillOpacity,
          stroke: $$props.stroke,
          strokeWidth: $$props.strokeWidth,
          opacity: $$props.opacity
        },
        classes: $$props.class
      }
    );
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Circle",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerdown: $$props.onpointerdown,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave
      },
      deps: () => [
        motionCx.current,
        motionCy.current,
        motionR.current,
        fillKey.current,
        $$props.fillOpacity,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var circle = root_13();
      attribute_effect(
        circle,
        ($0) => ({
          cx: motionCx.current,
          cy: motionCy.current,
          r: motionR.current,
          fill: $$props.fill,
          "fill-opacity": $$props.fillOpacity,
          stroke: $$props.stroke,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          class: $0,
          ...restProps
        }),
        [
          () => cls(layerClass("circle"), equals($$props.fill, null) && "fill-surface-content", $$props.class)
        ]
      );
      bind_this(circle, ($$value) => set(ref, $$value), () => get(ref));
      append($$anchor2, circle);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent);
      }),
      "if",
      Circle,
      153,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Circle = hmr(Circle, () => Circle[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Circle[HMR].source;
    set(Circle[HMR].source, module2.default[HMR].original);
  });
}
var Circle_default = Circle;

// node_modules/layerchart/dist/components/CircleClipPath.svelte
CircleClipPath[FILENAME] = "node_modules/layerchart/dist/components/CircleClipPath.svelte";
function CircleClipPath($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, CircleClipPath);
  let id = prop($$props, "id", 19, () => createId("clipPath-", uid)), cx = prop($$props, "cx", 3, 0), cy = prop($$props, "cy", 3, 0), disabled = prop($$props, "disabled", 3, false), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "cx",
      "cy",
      "r",
      "motion",
      "disabled",
      "ref",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const clip = wrap_snippet(CircleClipPath, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => extractLayerProps(restProps, "clip-path-circle"));
        add_svelte_meta(
          () => Circle_default(node_1, spread_props(
            {
              get cx() {
                return cx();
              },
              get cy() {
                return cy();
              },
              get r() {
                return $$props.r;
              },
              get motion() {
                return $$props.motion;
              }
            },
            () => get($0),
            {
              get ref() {
                return get(ref);
              },
              set ref($$value) {
                set(ref, $$value, true);
              }
            }
          )),
          "component",
          CircleClipPath,
          83,
          4,
          { componentTag: "Circle" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => ClipPath_default(node, {
        get id() {
          return id();
        },
        get disabled() {
          return disabled();
        },
        get children() {
          return $$props.children;
        },
        clip,
        $$slots: { clip: true }
      }),
      "component",
      CircleClipPath,
      81,
      0,
      { componentTag: "ClipPath" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CircleClipPath = hmr(CircleClipPath, () => CircleClipPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = CircleClipPath[HMR].source;
    set(CircleClipPath[HMR].source, module2.default[HMR].original);
  });
}
var CircleClipPath_default = CircleClipPath;

// node_modules/layerchart/dist/components/Voronoi.svelte
Voronoi2[FILENAME] = "node_modules/layerchart/dist/components/Voronoi.svelte";
function Voronoi2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Voronoi2);
  let classes = prop($$props, "classes", 19, () => ({})), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "r",
      "classes",
      "onclick",
      "onpointerenter",
      "onpointerdown",
      "onpointermove",
      "class"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const geo = getGeoContext();
  const points = tag(
    user_derived(() => ($$props.data ?? ctx.flatData).map((d) => {
      const xValue = geo.projection ? ctx.x(d) : ctx.xGet(d);
      const yValue = geo.projection ? ctx.y(d) : ctx.yGet(d);
      const x4 = Array.isArray(xValue) ? min(xValue) : xValue;
      const y4 = Array.isArray(yValue) ? min(yValue) : yValue;
      let point10;
      if (ctx.radial) {
        const radialPoint = pointRadial_default(x4, y4);
        point10 = [
          radialPoint[0] + ctx.width / 2,
          radialPoint[1] + ctx.height / 2
        ];
      } else {
        point10 = [x4, y4];
      }
      point10.data = d;
      return point10;
    })),
    "points"
  );
  const boundWidth = tag(user_derived(() => Math.max(ctx.width, 0)), "boundWidth");
  const boundHeight = tag(user_derived(() => Math.max(ctx.height, 0)), "boundHeight");
  const disableClip = tag(user_derived(() => strict_equals($$props.r, 0) || equals($$props.r, null) || strict_equals($$props.r, Infinity)), "disableClip");
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls(layerClass("voronoi-g"), classes().root, $$props.class));
    add_svelte_meta(
      () => Group_default(node, spread_props(() => restProps, {
        get class() {
          return get($0);
        },
        children: wrap_snippet(Voronoi2, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              const polygons = tag(user_derived(() => geoVoronoi().polygons(get(points))), "polygons");
              get(polygons);
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => each(node_2, 17, () => get(polygons).features, index, ($$anchor4, feature) => {
                  var fragment_3 = comment();
                  const point10 = tag(
                    user_derived(() => $$props.r ? geo.projection?.(get(feature).properties.sitecoordinates) : null),
                    "point"
                  );
                  get(point10);
                  var node_3 = first_child(fragment_3);
                  {
                    let $02 = user_derived(() => get(point10)?.[0]);
                    let $1 = user_derived(() => get(point10)?.[1]);
                    let $2 = user_derived(() => $$props.r ?? 0);
                    let $3 = user_derived(() => equals(get(point10), null) || get(disableClip));
                    add_svelte_meta(
                      () => CircleClipPath_default(node_3, {
                        get cx() {
                          return get($02);
                        },
                        get cy() {
                          return get($1);
                        },
                        get r() {
                          return get($2);
                        },
                        get disabled() {
                          return get($3);
                        },
                        children: wrap_snippet(Voronoi2, ($$anchor5, $$slotProps2) => {
                          var fragment_4 = comment();
                          var node_4 = first_child(fragment_4);
                          {
                            let $03 = user_derived(() => cls(layerClass("voronoi-geo-path"), "fill-transparent stroke-transparent", classes().path));
                            add_svelte_meta(
                              () => GeoPath_default(node_4, {
                                get geojson() {
                                  return get(feature);
                                },
                                get class() {
                                  return get($03);
                                },
                                onclick: (e) => $$props.onclick?.(e, {
                                  data: get(feature).properties.site.data,
                                  feature: get(feature)
                                }),
                                onpointerenter: (e) => $$props.onpointerenter?.(e, {
                                  data: get(feature).properties.site.data,
                                  feature: get(feature)
                                }),
                                onpointermove: (e) => $$props.onpointermove?.(e, {
                                  data: get(feature).properties.site.data,
                                  feature: get(feature)
                                }),
                                onpointerdown: (e) => $$props.onpointerdown?.(e, {
                                  data: get(feature).properties.site.data,
                                  feature: get(feature)
                                }),
                                onpointerleave,
                                ontouchmove: (e) => {
                                  e.preventDefault();
                                }
                              }),
                              "component",
                              Voronoi2,
                              132,
                              8,
                              { componentTag: "GeoPath" }
                            );
                          }
                          append($$anchor5, fragment_4);
                        }),
                        $$slots: { default: true }
                      }),
                      "component",
                      Voronoi2,
                      126,
                      6,
                      { componentTag: "CircleClipPath" }
                    );
                  }
                  append($$anchor4, fragment_3);
                }),
                "each",
                Voronoi2,
                124,
                4
              );
              append($$anchor3, fragment_2);
            };
            var alternate = ($$anchor3) => {
              var fragment_5 = comment();
              const voronoi = tag(user_derived(() => Delaunay.from(get(points)).voronoi([0, 0, get(boundWidth), get(boundHeight)])), "voronoi");
              get(voronoi);
              var node_5 = first_child(fragment_5);
              add_svelte_meta(
                () => each(node_5, 17, () => get(points), index, ($$anchor4, point10, i) => {
                  var fragment_6 = comment();
                  const pathData = tag(user_derived(() => get(voronoi).renderCell(i)), "pathData");
                  get(pathData);
                  var node_6 = first_child(fragment_6);
                  {
                    var consequent_1 = ($$anchor5) => {
                      var fragment_7 = comment();
                      var node_7 = first_child(fragment_7);
                      {
                        let $02 = user_derived(() => $$props.r ?? 0);
                        add_svelte_meta(
                          () => CircleClipPath_default(node_7, {
                            get cx() {
                              return get(point10)[0];
                            },
                            get cy() {
                              return get(point10)[1];
                            },
                            get r() {
                              return get($02);
                            },
                            get disabled() {
                              return get(disableClip);
                            },
                            children: wrap_snippet(Voronoi2, ($$anchor6, $$slotProps2) => {
                              var fragment_8 = comment();
                              var node_8 = first_child(fragment_8);
                              {
                                let $03 = user_derived(() => cls(layerClass("voronoi-path"), "fill-transparent stroke-transparent", classes().path));
                                add_svelte_meta(
                                  () => Spline_default(node_8, {
                                    get pathData() {
                                      return get(pathData);
                                    },
                                    get class() {
                                      return get($03);
                                    },
                                    onclick: (e) => $$props.onclick?.(e, { data: get(point10).data, point: get(point10) }),
                                    onpointerenter: (e) => $$props.onpointerenter?.(e, { data: get(point10).data, point: get(point10) }),
                                    onpointermove: (e) => $$props.onpointermove?.(e, { data: get(point10).data, point: get(point10) }),
                                    onpointerleave,
                                    onpointerdown: (e) => $$props.onpointerdown?.(e, { data: get(point10).data, point: get(point10) }),
                                    ontouchmove: (e) => {
                                      e.preventDefault();
                                    }
                                  }),
                                  "component",
                                  Voronoi2,
                                  159,
                                  10,
                                  { componentTag: "Spline" }
                                );
                              }
                              append($$anchor6, fragment_8);
                            }),
                            $$slots: { default: true }
                          }),
                          "component",
                          Voronoi2,
                          158,
                          8,
                          { componentTag: "CircleClipPath" }
                        );
                      }
                      append($$anchor5, fragment_7);
                    };
                    add_svelte_meta(
                      () => if_block(node_6, ($$render) => {
                        if (get(pathData)) $$render(consequent_1);
                      }),
                      "if",
                      Voronoi2,
                      157,
                      6
                    );
                  }
                  append($$anchor4, fragment_6);
                }),
                "each",
                Voronoi2,
                154,
                4
              );
              append($$anchor3, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (geo.projection) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Voronoi2,
              122,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      })),
      "component",
      Voronoi2,
      121,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Voronoi2 = hmr(Voronoi2, () => Voronoi2[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Voronoi2[HMR].source;
    set(Voronoi2[HMR].source, module2.default[HMR].original);
  });
}
var Voronoi_default = Voronoi2;

// node_modules/layerchart/dist/utils/math.js
function degreesToRadians(degrees5) {
  return degrees5 * Math.PI / 180;
}
function radiansToDegrees(radians4) {
  return radians4 * (180 / Math.PI);
}
function polarToCartesian(angle, radius) {
  return {
    x: Math.cos(angle) * radius,
    y: Math.sin(angle) * radius
  };
}
function cartesianToPolar(x4, y4) {
  let radians4 = Math.atan2(y4, x4);
  radians4 += Math.PI / 2;
  if (radians4 < 0) {
    radians4 += 2 * Math.PI;
  }
  return {
    radius: Math.sqrt(x4 ** 2 + y4 ** 2),
    radians: radians4
  };
}
function celsiusToFahrenheit(temperature) {
  return temperature * (9 / 5) + 32;
}
function fahrenheitToCelsius(temperature) {
  return (temperature - 32) * (5 / 9);
}
function parsePercent(percent) {
  if (typeof percent === "number") {
    return percent;
  } else {
    return Number(percent.replace("%", "")) / 100;
  }
}
function add3(value1, value2) {
  if (value1 instanceof Date) {
    return new Date(value1.getTime() + value2);
  } else {
    return value1 + value2;
  }
}

// node_modules/layerchart/dist/utils/quadtree.js
function quadtreeRects(quadtree2, showLeaves = true) {
  const rects = [];
  quadtree2.visit((node, x06, y06, x12, y12) => {
    if (showLeaves || Array.isArray(node)) {
      rects.push({ x: x06, y: y06, width: x12 - x06, height: y12 - y06 });
    }
  });
  return rects;
}

// node_modules/layerchart/dist/utils/types.js
function asAny(x4) {
  return x4;
}

// node_modules/layerchart/dist/components/tooltip/tooltipMetaContext.js
function handleBarTooltipPayload({ ctx, data, metaCtx }) {
  const seriesItems = metaCtx.stackSeries ? [...metaCtx.visibleSeries].reverse() : metaCtx.visibleSeries;
  const payload = seriesItems.map((s3) => {
    const seriesTooltipData = s3.data ? findRelatedData(s3.data, data, ctx.x) : data;
    const valueAccessor = accessor(s3.value ?? (s3.data ? ctx.y : s3.key));
    const label = metaCtx.orientation === "vertical" ? ctx.x(data) : ctx.y(data);
    const name = s3.label ?? (s3.key !== "default" ? s3.key : "value");
    const value2 = seriesTooltipData ? valueAccessor(seriesTooltipData) : void 0;
    const color2 = s3.color ?? ctx.cScale?.(ctx.c(data));
    return {
      ...s3.data,
      chartType: "bar",
      color: color2,
      label,
      name,
      value: value2,
      valueAccessor,
      key: s3.key,
      payload: data,
      rawSeriesData: s3,
      formatter: format
    };
  });
  return payload;
}
function handleAreaTooltipPayload({ ctx, data, metaCtx }) {
  const seriesItems = metaCtx.stackSeries ? [...metaCtx.visibleSeries].reverse() : metaCtx.visibleSeries;
  const payload = seriesItems.map((s3) => {
    const seriesTooltipData = s3.data ? findRelatedData(s3.data, data, ctx.x) : data;
    const valueAccessor = accessor(s3.value ?? (s3.data ? asAny(ctx.y) : s3.key));
    const label = ctx.x(data);
    const name = s3.label ?? (s3.key !== "default" ? s3.key : "value");
    const value2 = seriesTooltipData ? valueAccessor(seriesTooltipData) : void 0;
    const color2 = s3.color ?? ctx.cScale?.(ctx.c(data));
    return {
      ...s3.data,
      chartType: "area",
      color: color2,
      label,
      name,
      value: value2,
      valueAccessor,
      key: s3.key,
      payload: data,
      rawSeriesData: s3,
      formatter: format
    };
  });
  return payload;
}
function handleLineTooltipPayload({ ctx, data, metaCtx }) {
  return metaCtx.visibleSeries.map((s3) => {
    const seriesTooltipData = s3.data ? findRelatedData(s3.data, data, ctx.x) : data;
    const label = ctx.x(data);
    const valueAccessor = accessor(s3.value ?? (s3.data ? asAny(ctx.y) : s3.key));
    const name = s3.label ?? (s3.key !== "default" ? s3.key : "value");
    const value2 = seriesTooltipData ? valueAccessor(seriesTooltipData) : void 0;
    const color2 = s3.color ?? ctx.cScale?.(ctx.c(data));
    return {
      ...s3.data,
      chartType: "line",
      color: color2,
      label,
      name,
      value: value2,
      valueAccessor,
      key: s3.key,
      payload: data,
      rawSeriesData: s3,
      formatter: format
    };
  });
}
function handlePieOrArcTooltipPayload({ ctx, data, metaCtx }) {
  const keyAccessor = accessor(metaCtx.key);
  const labelAccessor = accessor(metaCtx.label);
  const valueAccessor = accessor(metaCtx.value);
  const colorAccessor = accessor(metaCtx.color);
  return [
    {
      key: keyAccessor(data),
      label: labelAccessor(data) || keyAccessor(data),
      value: valueAccessor(data),
      color: colorAccessor(data) ?? ctx.cScale?.(ctx.c(data)),
      payload: data,
      chartType: "pie",
      labelAccessor,
      keyAccessor,
      valueAccessor,
      colorAccessor
    }
  ];
}
function handleScatterTooltipPayload({ ctx, data, metaCtx }) {
  return [{ payload: data, key: "" }];
}
var _TooltipMetaContext = new Context("TooltipMetaContext");
function getTooltipMetaContext() {
  return _TooltipMetaContext.getOr(null);
}
function setTooltipMetaContext(v2) {
  return _TooltipMetaContext.set(v2);
}
function getTooltipPayload({ ctx, tooltipData, metaCtx }) {
  if (!metaCtx)
    return [{ payload: tooltipData, key: "" }];
  switch (metaCtx.type) {
    case "bar":
      return handleBarTooltipPayload({ ctx, data: tooltipData, metaCtx });
    case "area":
      return handleAreaTooltipPayload({ ctx, data: tooltipData, metaCtx });
    case "line":
      return handleLineTooltipPayload({ ctx, data: tooltipData, metaCtx });
    case "pie":
    case "arc":
      return handlePieOrArcTooltipPayload({ ctx, data: tooltipData, metaCtx });
    case "scatter":
      return handleScatterTooltipPayload({ ctx, data: tooltipData, metaCtx });
  }
}

// node_modules/layerchart/dist/components/tooltip/TooltipContext.svelte
TooltipContext[FILENAME] = "node_modules/layerchart/dist/components/tooltip/TooltipContext.svelte";
var _TooltipContext = new Context("TooltipContext");
function getTooltipContext() {
  return _TooltipContext.get();
}
function setTooltipContext(tooltip) {
  return _TooltipContext.set(tooltip);
}
function onPointerMove(e, triggerPointerEvents, showTooltip) {
  if (get(triggerPointerEvents)) {
    showTooltip(e);
  }
}
var on_click = (e, triggerPointerEvents, tooltipContext, onclick) => {
  if (get(triggerPointerEvents) && equals(tooltipContext.data, null, false)) {
    onclick()(e, { data: tooltipContext.data });
  }
};
var on_keydown = () => {
};
var on_pointermove = (
  // @ts-expect-error
  // @ts-expect-error
  (e, showTooltip, rect) => showTooltip(e, get(rect)?.data)
);
var on_pointerdown = (e) => {
  const target = e.target;
  if (target?.hasPointerCapture(e.pointerId)) {
    target.releasePointerCapture(e.pointerId);
  }
};
var on_click_1 = (e, onclick, rect) => {
  onclick()(e, { data: get(rect)?.data });
};
var root_8 = add_locations(from_svg(`<rect></rect>`), TooltipContext[FILENAME], [[638, 14]]);
var root_52 = add_locations(from_svg(`<g></g>`), TooltipContext[FILENAME], [[611, 8]]);
var root_14 = add_locations(from_svg(`<rect></rect>`), TooltipContext[FILENAME], [[670, 16]]);
var root_122 = add_locations(from_svg(`<g><!></g>`), TooltipContext[FILENAME], [[667, 10]]);
var root6 = add_locations(from_html(`<div><div><!> <!></div></div>`), TooltipContext[FILENAME], [[550, 0, [[576, 2]]]]);
function TooltipContext($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TooltipContext);
  const ctx = getChartContext();
  const geoCtx = getGeoContext();
  let refProp = prop($$props, "ref", 15), debug = prop($$props, "debug", 3, false), findTooltipData = prop($$props, "findTooltipData", 3, "closest"), hideDelay = prop($$props, "hideDelay", 3, 0), locked = prop($$props, "locked", 3, false), mode2 = prop($$props, "mode", 3, "manual"), onclick = prop($$props, "onclick", 3, () => {
  }), radius = prop($$props, "radius", 3, Infinity), raiseTarget = prop($$props, "raiseTarget", 3, false), tooltipContextProp = prop($$props, "tooltipContext", 15);
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  let x4 = tag(state(0), "x");
  let y4 = tag(state(0), "y");
  let data = tag(state(null), "data");
  let payload = tag(state(proxy([])), "payload");
  let isHoveringTooltipArea = tag(state(false), "isHoveringTooltipArea");
  let isHoveringTooltipContent = tag(state(false), "isHoveringTooltipContent");
  const metaCtx = getTooltipMetaContext();
  const tooltipContext = {
    get x() {
      return get(x4);
    },
    get y() {
      return get(y4);
    },
    get data() {
      return get(data);
    },
    get payload() {
      return get(payload);
    },
    show: showTooltip,
    hide: hideTooltip,
    get mode() {
      return mode2();
    },
    get isHoveringTooltipArea() {
      return get(isHoveringTooltipArea);
    },
    get isHoveringTooltipContent() {
      return get(isHoveringTooltipContent);
    },
    set isHoveringTooltipContent(value2) {
      set(isHoveringTooltipContent, value2, true);
    }
  };
  tooltipContextProp(tooltipContext);
  setTooltipContext(tooltipContext);
  let hideTimeoutId;
  const bisectX = bisector((d) => {
    const value2 = ctx.x(d);
    if (Array.isArray(value2)) {
      return value2[0];
    } else {
      return value2;
    }
  }).left;
  const bisectY = bisector((d) => {
    const value2 = ctx.y(d);
    if (Array.isArray(value2)) {
      return value2[0];
    } else {
      return value2;
    }
  }).left;
  function findData(previousValue, currentValue, valueAtPoint, accessor2) {
    switch (findTooltipData()) {
      case "closest":
        if (strict_equals(currentValue, void 0)) {
          return previousValue;
        } else if (strict_equals(previousValue, void 0)) {
          return currentValue;
        } else {
          return Number(valueAtPoint) - Number(accessor2(previousValue)) > Number(accessor2(currentValue)) - Number(valueAtPoint) ? currentValue : previousValue;
        }
      case "left":
        return previousValue;
      case "right":
      default:
        return currentValue;
    }
  }
  function showTooltip(e, tooltipData) {
    if (hideTimeoutId) {
      clearTimeout(hideTimeoutId);
    }
    if (locked()) {
      return;
    }
    const containerNode = e.target.closest(".lc-root-container");
    const point10 = localPoint(e, containerNode);
    if (strict_equals(get(ref), void 0, false) && equals(
      tooltipData,
      null
      // mode !== 'manual' but support annotations
    ) && (point10.x < get(ref).offsetLeft || point10.x > get(ref).offsetLeft + get(ref).offsetWidth || point10.y < get(ref).offsetTop || point10.y > get(ref).offsetTop + get(ref).offsetHeight)) {
      hideTooltip();
      return;
    }
    if (equals(tooltipData, null)) {
      switch (mode2()) {
        case "bisect-x": {
          let xValueAtPoint;
          if (ctx.radial) {
            const { radians: radians4 } = cartesianToPolar(point10.x - ctx.width / 2, point10.y - ctx.height / 2);
            xValueAtPoint = scaleInvert(ctx.xScale, radians4);
          } else {
            xValueAtPoint = scaleInvert(ctx.xScale, point10.x - ctx.padding.left);
          }
          const index4 = bisectX(ctx.flatData, xValueAtPoint, 1);
          const previousValue = ctx.flatData[index4 - 1];
          const currentValue = ctx.flatData[index4];
          tooltipData = findData(previousValue, currentValue, xValueAtPoint, ctx.x);
          break;
        }
        case "bisect-y": {
          const yValueAtPoint = scaleInvert(ctx.yScale, point10.y - ctx.padding.top);
          const index4 = bisectY(ctx.flatData, yValueAtPoint, 1);
          const previousValue = ctx.flatData[index4 - 1];
          const currentValue = ctx.flatData[index4];
          tooltipData = findData(previousValue, currentValue, yValueAtPoint, ctx.y);
          break;
        }
        case "bisect-band": {
          const xValueAtPoint = scaleInvert(ctx.xScale, point10.x);
          const yValueAtPoint = scaleInvert(ctx.yScale, point10.y);
          if (isScaleBand(ctx.xScale)) {
            const bandData = ctx.flatData.filter((d) => strict_equals(ctx.x(d), xValueAtPoint)).sort(sortFunc(ctx.y));
            const index4 = bisectY(bandData, yValueAtPoint, 1);
            const previousValue = bandData[index4 - 1];
            const currentValue = bandData[index4];
            tooltipData = findData(previousValue, currentValue, yValueAtPoint, ctx.y);
          } else if (isScaleBand(ctx.yScale)) {
            const bandData = ctx.flatData.filter((d) => strict_equals(ctx.y(d), yValueAtPoint)).sort(sortFunc(ctx.x));
            const index4 = bisectX(bandData, xValueAtPoint, 1);
            const previousValue = bandData[index4 - 1];
            const currentValue = bandData[index4];
            tooltipData = findData(previousValue, currentValue, xValueAtPoint, ctx.x);
          } else {
          }
          break;
        }
        case "quadtree-x":
        case "quadtree-y":
        case "quadtree": {
          tooltipData = get(quadtree2)?.find(point10.x - ctx.padding.left, point10.y - ctx.padding.top, radius());
          break;
        }
      }
    }
    if (tooltipData) {
      if (raiseTarget()) {
        raise(e.target);
      }
      const payloadData = getTooltipPayload({ ctx, tooltipData, metaCtx });
      set(x4, point10.x, true);
      set(y4, point10.y, true);
      set(data, tooltipData, true);
      set(payload, payloadData, true);
    } else {
      hideTooltip();
    }
  }
  function hideTooltip() {
    if (locked()) {
      return;
    }
    set(isHoveringTooltipArea, false);
    hideTimeoutId = setTimeout(
      () => {
        if (!get(isHoveringTooltipArea) && !get(isHoveringTooltipContent)) {
          set(data, null);
          set(payload, [], true);
        }
      },
      hideDelay()
    );
  }
  const quadtree2 = tag(
    user_derived(() => {
      if (["quadtree", "quadtree-x", "quadtree-y"].includes(mode2())) {
        return quadtree().x((d) => {
          if (strict_equals(mode2(), "quadtree-y")) {
            return 0;
          }
          if (geoCtx.projection) {
            const lat = ctx.x(d);
            const long = ctx.y(d);
            const geoValue = geoCtx.projection([lat, long]) ?? [0, 0];
            return geoValue[0];
          }
          const value2 = ctx.xGet(d);
          if (Array.isArray(value2)) {
            return min(value2);
          } else {
            return value2;
          }
        }).y((d) => {
          if (strict_equals(mode2(), "quadtree-x")) {
            return 0;
          }
          if (geoCtx.projection) {
            const lat = ctx.x(d);
            const long = ctx.y(d);
            const geoValue = geoCtx.projection([lat, long]) ?? [0, 0];
            return geoValue[1];
          }
          const value2 = ctx.yGet(d);
          if (Array.isArray(value2)) {
            return min(value2);
          } else {
            return value2;
          }
        }).addAll(ctx.flatData);
      }
    }),
    "quadtree"
  );
  const rects = tag(
    user_derived(() => {
      if (strict_equals(mode2(), "bounds") || strict_equals(mode2(), "band")) {
        return ctx.flatData.map((d) => {
          const xValue = ctx.xGet(d);
          const yValue = ctx.yGet(d);
          const x5 = Array.isArray(xValue) ? xValue[0] : xValue;
          const y5 = Array.isArray(yValue) ? yValue[0] : yValue;
          const xOffset = isScaleBand(ctx.xScale) ? ctx.xScale.padding() * ctx.xScale.step() / 2 : 0;
          const yOffset = isScaleBand(ctx.yScale) ? ctx.yScale.padding() * ctx.yScale.step() / 2 : 0;
          const fullWidth = max(ctx.xRange) - min(ctx.xRange);
          const fullHeight = max(ctx.yRange) - min(ctx.yRange);
          if (strict_equals(mode2(), "band")) {
            return {
              x: isScaleBand(ctx.xScale) ? x5 - xOffset : min(ctx.xRange),
              y: isScaleBand(ctx.yScale) ? y5 - yOffset : min(ctx.yRange),
              width: isScaleBand(ctx.xScale) ? ctx.xScale.step() : fullWidth,
              height: isScaleBand(ctx.yScale) ? ctx.yScale.step() : fullHeight,
              data: d
            };
          } else if (strict_equals(mode2(), "bounds")) {
            return {
              x: isScaleBand(ctx.xScale) || Array.isArray(xValue) ? x5 - xOffset : min(ctx.xRange),
              // y: isScaleBand($yScale) || Array.isArray(yValue) ? y - yOffset : min($yRange),
              y: y5 - yOffset,
              width: Array.isArray(xValue) ? xValue[1] - xValue[0] : isScaleBand(ctx.xScale) ? ctx.xScale.step() : min(ctx.xRange) + x5,
              height: Array.isArray(yValue) ? yValue[1] - yValue[0] : isScaleBand(ctx.yScale) ? ctx.yScale.step() : max(ctx.yRange) - y5,
              data: d
            };
          }
        }).filter((x5) => strict_equals(x5, void 0, false)).sort(sortFunc("x"));
      }
      return [];
    }),
    "rects"
  );
  const triggerPointerEvents = tag(
    user_derived(() => [
      "bisect-x",
      "bisect-y",
      "bisect-band",
      "quadtree",
      "quadtree-x",
      "quadtree-y"
    ].includes(mode2())),
    "triggerPointerEvents"
  );
  function onPointerEnter(e) {
    set(isHoveringTooltipArea, true);
    if (get(triggerPointerEvents)) {
      showTooltip(e);
    }
  }
  function onPointerLeave(e) {
    set(isHoveringTooltipArea, false);
    hideTooltip();
  }
  var div = root6();
  div.__touchstart = onPointerEnter;
  div.__mousemove = [onPointerMove, triggerPointerEvents, showTooltip];
  div.__touchmove = [onPointerMove, triggerPointerEvents, showTooltip];
  div.__touchend = onPointerLeave;
  div.__click = [on_click, triggerPointerEvents, tooltipContext, onclick];
  div.__keydown = [on_keydown];
  let styles;
  var div_1 = child(div);
  let styles_1;
  var node = child(div_1);
  add_svelte_meta(
    () => snippet(node, () => $$props.children ?? noop, () => ({ tooltipContext })),
    "render",
    TooltipContext,
    583,
    4
  );
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      add_svelte_meta(
        () => Svg_default(node_2, {
          children: wrap_snippet(TooltipContext, ($$anchor3, $$slotProps) => {
            var fragment_1 = comment();
            var node_3 = first_child(fragment_1);
            {
              let $0 = user_derived(() => ({ path: cls(debug() && "fill-danger/10 stroke-danger") }));
              add_svelte_meta(
                () => Voronoi_default(node_3, {
                  get r() {
                    return radius();
                  },
                  onpointerenter: (e, { data: data2 }) => {
                    showTooltip(e, data2);
                  },
                  onpointermove: (e, { data: data2 }) => {
                    showTooltip(e, data2);
                  },
                  onpointerleave: () => hideTooltip(),
                  onpointerdown: (e) => {
                    if (e.target?.hasPointerCapture(e.pointerId)) {
                      e.target.releasePointerCapture(e.pointerId);
                    }
                  },
                  onclick: (e, { data: data2 }) => {
                    onclick()(e, { data: data2 });
                  },
                  get classes() {
                    return get($0);
                  }
                }),
                "component",
                TooltipContext,
                587,
                8,
                { componentTag: "Voronoi" }
              );
            }
            append($$anchor3, fragment_1);
          }),
          $$slots: { default: true }
        }),
        "component",
        TooltipContext,
        586,
        6,
        { componentTag: "Svg" }
      );
      append($$anchor2, fragment);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_4 = first_child(fragment_2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_5 = first_child(fragment_3);
          add_svelte_meta(
            () => Svg_default(node_5, {
              get center() {
                return ctx.radial;
              },
              children: wrap_snippet(TooltipContext, ($$anchor4, $$slotProps) => {
                var g = root_52();
                add_svelte_meta(
                  () => each(g, 21, () => get(rects), index, ($$anchor5, rect) => {
                    var fragment_4 = comment();
                    var node_6 = first_child(fragment_4);
                    {
                      var consequent_1 = ($$anchor6) => {
                        var fragment_5 = comment();
                        var node_7 = first_child(fragment_5);
                        {
                          let $0 = user_derived(() => get(rect).y + get(rect).height);
                          let $1 = user_derived(() => get(rect).x + get(rect).width);
                          let $2 = user_derived(() => cls(layerClass("tooltip-rect"), debug() ? "fill-danger/10 stroke-danger" : "fill-transparent"));
                          add_svelte_meta(
                            () => Arc_default(node_7, {
                              get innerRadius() {
                                return get(rect).y;
                              },
                              get outerRadius() {
                                return get($0);
                              },
                              get startAngle() {
                                return get(rect).x;
                              },
                              get endAngle() {
                                return get($1);
                              },
                              get class() {
                                return get($2);
                              },
                              onpointerenter: (e) => showTooltip(e, get(rect)?.data),
                              onpointermove: (e) => showTooltip(e, get(rect)?.data),
                              onpointerleave: () => hideTooltip(),
                              onpointerdown: (e) => {
                                const target = e.target;
                                if (target?.hasPointerCapture(e.pointerId)) {
                                  target.releasePointerCapture(e.pointerId);
                                }
                              },
                              onclick: (e) => {
                                onclick()(e, { data: get(rect)?.data });
                              }
                            }),
                            "component",
                            TooltipContext,
                            615,
                            14,
                            { componentTag: "Arc" }
                          );
                        }
                        append($$anchor6, fragment_5);
                      };
                      var alternate = ($$anchor6) => {
                        var rect_1 = root_8();
                        rect_1.__pointermove = [on_pointermove, showTooltip, rect];
                        rect_1.__pointerdown = [on_pointerdown];
                        rect_1.__click = [on_click_1, onclick, rect];
                        template_effect(
                          ($0) => {
                            set_attribute(rect_1, "x", get(rect)?.x);
                            set_attribute(rect_1, "y", get(rect)?.y);
                            set_attribute(rect_1, "width", get(rect)?.width);
                            set_attribute(rect_1, "height", get(rect)?.height);
                            set_class(rect_1, 0, $0);
                          },
                          [
                            () => clsx(cls(layerClass("tooltip-rect"), debug() ? "fill-danger/10 stroke-danger" : "fill-transparent"))
                          ]
                        );
                        event("pointerenter", rect_1, (e) => showTooltip(e, get(rect)?.data));
                        event("pointerleave", rect_1, () => hideTooltip());
                        append($$anchor6, rect_1);
                      };
                      add_svelte_meta(
                        () => if_block(node_6, ($$render) => {
                          if (ctx.radial) $$render(consequent_1);
                          else $$render(alternate, false);
                        }),
                        "if",
                        TooltipContext,
                        614,
                        12
                      );
                    }
                    append($$anchor5, fragment_4);
                  }),
                  "each",
                  TooltipContext,
                  612,
                  10
                );
                reset(g);
                template_effect(($0) => set_class(g, 0, $0), [() => clsx(layerClass("tooltip-rects-g"))]);
                append($$anchor4, g);
              }),
              $$slots: { default: true }
            }),
            "component",
            TooltipContext,
            610,
            6,
            { componentTag: "Svg" }
          );
          append($$anchor3, fragment_3);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_6 = comment();
          var node_8 = first_child(fragment_6);
          {
            var consequent_4 = ($$anchor4) => {
              var fragment_7 = comment();
              var node_9 = first_child(fragment_7);
              add_svelte_meta(
                () => Svg_default(node_9, {
                  pointerEvents: false,
                  children: wrap_snippet(TooltipContext, ($$anchor5, $$slotProps) => {
                    var fragment_8 = comment();
                    var node_10 = first_child(fragment_8);
                    add_svelte_meta(
                      () => ChartClipPath_default(node_10, {
                        children: wrap_snippet(TooltipContext, ($$anchor6, $$slotProps2) => {
                          var g_1 = root_122();
                          var node_11 = child(g_1);
                          {
                            var consequent_3 = ($$anchor7) => {
                              var fragment_9 = comment();
                              var node_12 = first_child(fragment_9);
                              add_svelte_meta(
                                () => each(node_12, 17, () => quadtreeRects(get(quadtree2), false), index, ($$anchor8, rect) => {
                                  var rect_2 = root_14();
                                  template_effect(
                                    ($0) => {
                                      set_attribute(rect_2, "x", get(rect).x);
                                      set_attribute(rect_2, "y", get(rect).y);
                                      set_attribute(rect_2, "width", get(rect).width);
                                      set_attribute(rect_2, "height", get(rect).height);
                                      set_class(rect_2, 0, $0);
                                    },
                                    [
                                      () => clsx(cls(layerClass("tooltip-quadtree-rect"), debug() ? "fill-danger/10 stroke-danger" : "fill-transparent"))
                                    ]
                                  );
                                  append($$anchor8, rect_2);
                                }),
                                "each",
                                TooltipContext,
                                669,
                                14
                              );
                              append($$anchor7, fragment_9);
                            };
                            add_svelte_meta(
                              () => if_block(node_11, ($$render) => {
                                if (get(quadtree2)) $$render(consequent_3);
                              }),
                              "if",
                              TooltipContext,
                              668,
                              12
                            );
                          }
                          reset(g_1);
                          template_effect(($0) => set_class(g_1, 0, $0), [() => clsx(layerClass("tooltip-quadtree-g"))]);
                          append($$anchor6, g_1);
                        }),
                        $$slots: { default: true }
                      }),
                      "component",
                      TooltipContext,
                      666,
                      8,
                      { componentTag: "ChartClipPath" }
                    );
                    append($$anchor5, fragment_8);
                  }),
                  $$slots: { default: true }
                }),
                "component",
                TooltipContext,
                665,
                6,
                { componentTag: "Svg" }
              );
              append($$anchor4, fragment_7);
            };
            add_svelte_meta(
              () => if_block(
                node_8,
                ($$render) => {
                  if (["quadtree", "quadtree-x", "quadtree-y"].includes(mode2()) && debug()) $$render(consequent_4);
                },
                true
              ),
              "if",
              TooltipContext,
              664,
              4
            );
          }
          append($$anchor3, fragment_6);
        };
        add_svelte_meta(
          () => if_block(
            node_4,
            ($$render) => {
              if (strict_equals(mode2(), "bounds") || strict_equals(mode2(), "band")) $$render(consequent_2);
              else $$render(alternate_1, false);
            },
            true
          ),
          "if",
          TooltipContext,
          609,
          4
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (strict_equals(mode2(), "voronoi")) $$render(consequent);
        else $$render(alternate_2, false);
      }),
      "if",
      TooltipContext,
      585,
      4
    );
  }
  reset(div_1);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(
    ($0, $1, $2, $3) => {
      set_class(div, 1, $0);
      styles = set_style(div, "", styles, $1);
      set_class(div_1, 1, $2);
      styles_1 = set_style(div_1, "", styles_1, $3);
    },
    [
      () => clsx(cls(layerClass("tooltip-context"), "absolute", debug() && get(triggerPointerEvents) && "bg-danger/10 outline outline-danger")),
      () => ({
        top: `${ctx.padding.top ?? ""}px`,
        left: `${ctx.padding.left ?? ""}px`,
        width: `${ctx.width ?? ""}px`,
        height: `${ctx.height ?? ""}px`
      }),
      () => clsx(cls(layerClass("tooltip-context-container"), "absolute")),
      () => ({
        top: `-${ctx.padding.top ?? 0 ?? ""}px`,
        left: `-${ctx.padding.left ?? 0 ?? ""}px`,
        width: `${ctx.containerWidth ?? ""}px`,
        height: `${ctx.containerHeight ?? ""}px`
      })
    ]
  );
  event("mouseenter", div, onPointerEnter);
  event("mouseleave", div, onPointerLeave);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipContext = hmr(TooltipContext, () => TooltipContext[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TooltipContext[HMR].source;
    set(TooltipContext[HMR].source, module2.default[HMR].original);
  });
}
var TooltipContext_default = TooltipContext;
delegate([
  "touchstart",
  "mousemove",
  "touchmove",
  "touchend",
  "click",
  "keydown",
  "pointermove",
  "pointerdown"
]);

// node_modules/layerchart/dist/components/BrushContext.svelte
BrushContext[FILENAME] = "node_modules/layerchart/dist/components/BrushContext.svelte";
var _BrushContext = new Context("BrushContext");
var defaultContext = {
  xDomain: null,
  yDomain: null,
  isActive: false,
  range: { x: 0, y: 0, width: 0, height: 0 },
  handleSize: 0
};
function getBrushContext() {
  const defaults2 = tag_proxy(proxy(defaultContext), "defaults");
  return _BrushContext.getOr(defaults2);
}
function setBrushContext(brush) {
  return _BrushContext.set(brush);
}
var on_dblclick = (
  /**
  * The axis to apply brushing
  *
  * @default 'x'
  */
  /**
   * The axis to apply brushing
   *
   * @default 'x'
   */
  /**
   * Size of the draggable handles (width/height)
   *
   * @default 5
   */
  /**
   * Only show range while actively brushing.
   * Useful with `brushEnd` event
   *
   * @default false
   */
  /**
   * Ignore click to reset.
   * Useful to add click handlers to marks.  Requires external resetting (button, another chart, etc)
   *
   * @default false
   */
  /**
   * Mode of operation
   *  - `integrated`: use with single chart
   *  - `separated`: use with separate (typically smaller) chart and state can be managed
   * externally (sync with other charts, etc).  Show active selection when domain does not equal
   * original
   *
   * @default 'integrated'
   */
  /**
   * Disable brush
   *
   * @default false
   */
  /**
   * Attributes passed to the range <div> element
   */
  /**
   * Attributes passed to the handle <div> elements
   */
  /**
   * Classes to apply to the various elements rendered
   *
   * @default {}
   */
  /**
   * A reference to this brush's context for use in parent
   * components.
   *
   * @bindable
   */
  // size of pointer delta to ignore
  // Is click on frame (i.e. not on the `.range` or `.handle`)
  // Clicked on frame, or pointer delta was less than threshold (default: 1px)
  // Still hide brush, but do not reset domain
  // @ts-expect-error
  // @ts-expect-error
  // xDomain = [start.value.x, value.x];
  // @ts-expect-error
  // @ts-expect-error
  // Set reactively to handle cases where xDomain/yDomain are set externally (ex. `bind:xDomain`)
  (_, selectAll) => selectAll()
);
var root_42 = add_locations(from_html(`<div></div> <div></div>`, 1), BrushContext[FILENAME], [[507, 8], [532, 8]]);
var root_53 = add_locations(from_html(`<div></div> <div></div>`, 1), BrushContext[FILENAME], [[560, 8], [585, 8]]);
var root_33 = add_locations(from_html(`<div></div> <!> <!>`, 1), BrushContext[FILENAME], [[489, 6]]);
var root_22 = add_locations(from_html(`<div><div><!></div> <!></div>`), BrushContext[FILENAME], [[468, 2, [[478, 4]]]]);
function BrushContext($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BrushContext);
  var $$ownership_validator = create_ownership_validator($$props);
  const ctx = getChartContext();
  let brushContextProp = prop($$props, "brushContext", 15), axis = prop($$props, "axis", 3, "x"), handleSize = prop($$props, "handleSize", 3, 5), resetOnEnd = prop($$props, "resetOnEnd", 3, false), ignoreResetClick = prop($$props, "ignoreResetClick", 3, false), xDomain = prop($$props, "xDomain", 7), yDomain = prop($$props, "yDomain", 7), mode2 = prop($$props, "mode", 3, "integrated"), disabled = prop($$props, "disabled", 3, false), range4 = prop($$props, "range", 19, () => ({})), handle = prop($$props, "handle", 19, () => ({})), classes = prop($$props, "classes", 19, () => ({})), onBrushEnd = prop($$props, "onBrushEnd", 3, () => {
  }), onBrushStart = prop($$props, "onBrushStart", 3, () => {
  }), onChange = prop($$props, "onChange", 3, () => {
  }), onReset = prop($$props, "onReset", 3, () => {
  });
  let rootEl = tag(state(void 0), "rootEl");
  if (strict_equals(xDomain(), void 0)) {
    xDomain(ctx.xScale.domain());
  }
  if (strict_equals(yDomain(), void 0)) {
    yDomain(ctx.yScale.domain());
  }
  user_pre_effect(() => {
    if (strict_equals(xDomain(), void 0, false)) return;
    xDomain(ctx.xScale.domain());
  });
  user_pre_effect(() => {
    if (strict_equals(yDomain(), void 0, false)) return;
    yDomain(ctx.yScale.domain());
  });
  const ogXDomain = xDomain();
  const ogYDomain = yDomain();
  const originalXDomain = ctx.config.xDomain;
  const originalYDomain = ctx.config.yDomain;
  const xDomainMinMax = tag(user_derived(() => extent(ctx.xScale.domain())), "xDomainMinMax");
  const xDomainMin = tag(user_derived(() => get(xDomainMinMax)[0]), "xDomainMin");
  const xDomainMax = tag(user_derived(() => get(xDomainMinMax)[1]), "xDomainMax");
  const yDomainMinMax = tag(user_derived(() => extent(ctx.yScale.domain())), "yDomainMinMax");
  const yDomainMin = tag(user_derived(() => get(yDomainMinMax)[0]), "yDomainMin");
  const yDomainMax = tag(user_derived(() => get(yDomainMinMax)[1]), "yDomainMax");
  const top = tag(user_derived(() => ctx.yScale(yDomain()?.[1])), "top");
  const bottom = tag(user_derived(() => ctx.yScale(yDomain()?.[0])), "bottom");
  const left2 = tag(user_derived(() => ctx.xScale(xDomain()?.[0])), "left");
  const right2 = tag(user_derived(() => ctx.xScale(xDomain()?.[1])), "right");
  const _range = tag(
    user_derived(() => ({
      x: strict_equals(axis(), "both") || strict_equals(axis(), "x") ? get(left2) : 0,
      y: strict_equals(axis(), "both") || strict_equals(axis(), "y") ? get(top) : 0,
      width: strict_equals(axis(), "both") || strict_equals(axis(), "x") ? get(right2) - get(left2) : ctx.width,
      height: strict_equals(axis(), "both") || strict_equals(axis(), "y") ? get(bottom) - get(top) : ctx.height
    })),
    "_range"
  );
  let isActive = tag(state(false), "isActive");
  const brushContext = {
    get xDomain() {
      return xDomain();
    },
    set xDomain(v2) {
      xDomain(v2);
    },
    get yDomain() {
      return yDomain();
    },
    set yDomain(v2) {
      yDomain(v2);
    },
    get isActive() {
      return get(isActive);
    },
    set isActive(v2) {
      set(isActive, v2, true);
    },
    get range() {
      return get(_range);
    },
    get handleSize() {
      return handleSize();
    }
  };
  brushContextProp(brushContext);
  setBrushContext(brushContext);
  const logger = new Logger("BrushContext");
  const RESET_THRESHOLD = 1;
  function handler(fn) {
    return (e) => {
      logger.debug("drag start");
      e.stopPropagation();
      const startPoint = localPoint(e, get(rootEl));
      if (startPoint && (startPoint.x < 0 || startPoint.x > ctx.width || startPoint.y < 0 || startPoint.y > ctx.height)) {
        logger.debug("ignoring click as outside of chart bounds", { startPoint, width: ctx.width, height: ctx.height });
        return;
      }
      const start = {
        xDomain: [
          xDomain()?.[0] ?? get(xDomainMin),
          xDomain()?.[1] ?? get(xDomainMax)
        ],
        yDomain: [
          yDomain()?.[0] ?? get(yDomainMin),
          yDomain()?.[1] ?? get(yDomainMax)
        ],
        value: {
          x: scaleInvert(ctx.xScale, startPoint?.x ?? 0),
          y: scaleInvert(ctx.yScale, startPoint?.y ?? 0)
        }
      };
      onBrushStart()({ xDomain: xDomain(), yDomain: yDomain() });
      const onPointerMove2 = (e3) => {
        const currentPoint = localPoint(e3, get(rootEl));
        fn(start, {
          x: scaleInvert(ctx.xScale, currentPoint?.x ?? 0),
          y: scaleInvert(ctx.yScale, currentPoint?.y ?? 0)
        });
        onChange()({ xDomain: xDomain(), yDomain: yDomain() });
      };
      const onPointerUp = (e3) => {
        const currentPoint = localPoint(e3, get(rootEl));
        const xPointDelta = Math.abs((startPoint?.x ?? 0) - (currentPoint?.x ?? 0));
        const yPointDelta = Math.abs((startPoint?.y ?? 0) - (currentPoint?.y ?? 0));
        const isClickOutside = !Array.from(e3.target.classList).some((cls2) => ["range", "handle"].includes(cls2));
        if (isClickOutside && xPointDelta < RESET_THRESHOLD && yPointDelta < RESET_THRESHOLD || get(_range).width < RESET_THRESHOLD || get(_range).height < RESET_THRESHOLD) {
          if (ignoreResetClick()) {
            logger.debug("ignoring frame click reset");
          } else {
            logger.debug("resetting due to frame click");
            reset2();
            onChange()({ xDomain: xDomain(), yDomain: yDomain() });
          }
        } else {
          logger.debug("drag end", {
            target: e3.target,
            xPointDelta,
            yPointDelta,
            rangeWidth: get(_range).width,
            rangeHeight: get(_range).height
          });
        }
        onBrushEnd()({ xDomain: xDomain(), yDomain: yDomain() });
        if (resetOnEnd()) {
          if (ignoreResetClick()) {
            brushContext.isActive = false;
          } else {
            reset2();
          }
        }
        window.removeEventListener("pointermove", onPointerMove2);
        window.removeEventListener("pointerup", onPointerUp);
      };
      window.addEventListener("pointermove", onPointerMove2);
      window.addEventListener("pointerup", onPointerUp);
    };
  }
  const createRange2 = handler((start, value2) => {
    logger.debug("createRange");
    brushContext.isActive = true;
    xDomain([
      // @ts-expect-error
      clamp2(min([start.value.x, value2.x]), get(xDomainMin), get(xDomainMax)),
      // @ts-expect-error
      clamp2(max([start.value.x, value2.x]), get(xDomainMin), get(xDomainMax))
    ]);
    yDomain([
      // @ts-expect-error
      clamp2(min([start.value.y, value2.y]), get(yDomainMin), get(yDomainMax)),
      // @ts-expect-error
      clamp2(max([start.value.y, value2.y]), get(yDomainMin), get(yDomainMax))
    ]);
  });
  const adjustRange = handler((start, value2) => {
    logger.debug("adjustRange");
    const dx = clamp2(value2.x - start.value.x, get(xDomainMin) - start.xDomain[0], get(xDomainMax) - start.xDomain[1]);
    xDomain([add3(start.xDomain[0], dx), add3(start.xDomain[1], dx)]);
    const dy = clamp2(value2.y - start.value.y, get(yDomainMin) - start.yDomain[0], get(yDomainMax) - start.yDomain[1]);
    yDomain([add3(start.yDomain[0], dy), add3(start.yDomain[1], dy)]);
  });
  const adjustTop = handler((start, value2) => {
    logger.debug("adjustTop");
    yDomain([
      clamp2(value2.y < start.yDomain[0] ? value2.y : start.yDomain[0], get(yDomainMin), get(yDomainMax)),
      clamp2(value2.y < start.yDomain[0] ? start.yDomain[0] : value2.y, get(yDomainMin), get(yDomainMax))
    ]);
  });
  const adjustBottom = handler((start, value2) => {
    logger.debug("adjustBottom");
    yDomain([
      clamp2(value2.y > start.yDomain[1] ? start.yDomain[1] : value2.y, get(yDomainMin), get(yDomainMax)),
      clamp2(value2.y > start.yDomain[1] ? value2.y : start.yDomain[1], get(yDomainMin), get(yDomainMax))
    ]);
  });
  const adjustLeft = handler((start, value2) => {
    logger.debug("adjustLeft");
    xDomain([
      clamp2(value2.x > start.xDomain[1] ? start.xDomain[1] : value2.x, get(xDomainMin), get(xDomainMax)),
      clamp2(value2.x > start.xDomain[1] ? value2.x : start.xDomain[1], get(xDomainMin), get(xDomainMax))
    ]);
  });
  const adjustRight = handler((start, value2) => {
    logger.debug("adjustRight");
    xDomain([
      clamp2(value2.x < start.xDomain[0] ? value2.x : start.xDomain[0], get(xDomainMin), get(xDomainMax)),
      clamp2(value2.x < start.xDomain[0] ? start.xDomain[0] : value2.x, get(xDomainMin), get(xDomainMax))
    ]);
  });
  function reset2() {
    logger.debug("reset");
    brushContext.isActive = false;
    onReset()({ xDomain: xDomain(), yDomain: yDomain() });
    xDomain(ogXDomain);
    yDomain(ogYDomain);
  }
  function selectAll() {
    logger.debug("selectedAll");
    xDomain([get(xDomainMin), get(xDomainMax)]);
    yDomain([get(yDomainMin), get(yDomainMax)]);
  }
  user_pre_effect(() => {
    if (strict_equals(mode2(), "separated")) {
      const isXAxisActive = strict_equals(xDomain()?.[0]?.valueOf(), originalXDomain?.[0]?.valueOf(), false) || strict_equals(xDomain()?.[1]?.valueOf(), originalXDomain?.[1]?.valueOf(), false);
      const isYAxisActive = strict_equals(yDomain()?.[0]?.valueOf(), originalYDomain?.[0]?.valueOf(), false) || strict_equals(yDomain()?.[1]?.valueOf(), originalYDomain?.[1]?.valueOf(), false);
      const result2 = strict_equals(axis(), "x") ? isXAxisActive : equals(axis(), "y") ? isYAxisActive : isXAxisActive || isYAxisActive;
      brushContext.isActive = result2;
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ brushContext })), "render", BrushContext, 464, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      const handleClass = tag(user_derived(() => layerClass("brush-handle")), "handleClass");
      get(handleClass);
      div.__pointerdown = function(...$$args) {
        apply(() => createRange2, this, $$args, BrushContext, [475, 19]);
      };
      div.__dblclick = [on_dblclick, selectAll];
      let styles;
      var div_1 = child(div);
      let styles_1;
      var node_2 = child(div_1);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ brushContext })), "render", BrushContext, 485, 6);
      reset(div_1);
      var node_3 = sibling(div_1, 2);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_2 = root_33();
          var div_2 = first_child(fragment_2);
          var event_handler = () => reset2();
          attribute_effect(
            div_2,
            ($0, $1) => ({
              ...range4(),
              class: $0,
              onpointerdown: adjustRange,
              ondblclick: event_handler,
              [STYLE]: $1
            }),
            [
              () => cls(layerClass("brush-range"), "absolute bg-surface-content/10 cursor-move select-none", "z-10", classes().range, range4()?.class),
              () => ({
                left: `${get(_range).x ?? ""}px`,
                top: `${get(_range).y ?? ""}px`,
                width: `${get(_range).width ?? ""}px`,
                height: `${get(_range).height ?? ""}px`
              })
            ]
          );
          var node_4 = sibling(div_2, 2);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_3 = root_42();
              var div_3 = first_child(fragment_3);
              var event_handler_1 = (e) => {
                e.stopPropagation();
                if (yDomain()) {
                  $$ownership_validator.mutation("yDomain", ["yDomain", 0], yDomain()[0] = get(yDomainMin), 526, 14);
                  onChange()({ xDomain: xDomain(), yDomain: yDomain() });
                }
              };
              attribute_effect(
                div_3,
                ($0, $1) => ({
                  ...handle(),
                  "data-position": "top",
                  class: $0,
                  onpointerdown: adjustTop,
                  ondblclick: event_handler_1,
                  [STYLE]: $1
                }),
                [
                  () => cls(get(handleClass), "cursor-ns-resize select-none", "range absolute", "z-10", classes().handle, handle()?.class),
                  () => ({
                    left: `${get(_range).x ?? ""}px`,
                    top: `${get(_range).y ?? ""}px`,
                    width: `${get(_range).width ?? ""}px`,
                    height: `${handleSize() ?? ""}px`
                  })
                ]
              );
              var div_4 = sibling(div_3, 2);
              var event_handler_2 = (e) => {
                e.stopPropagation();
                if (yDomain()) {
                  $$ownership_validator.mutation("yDomain", ["yDomain", 1], yDomain()[1] = get(yDomainMax), 552, 14);
                  onChange()({ xDomain: xDomain(), yDomain: yDomain() });
                }
              };
              attribute_effect(
                div_4,
                ($0, $1) => ({
                  ...handle(),
                  "data-position": "bottom",
                  class: $0,
                  onpointerdown: adjustBottom,
                  ondblclick: event_handler_2,
                  [STYLE]: $1
                }),
                [
                  () => cls(get(handleClass), "handle bottom", "cursor-ns-resize select-none", "range absolute", "z-10", classes().handle, handle()?.class),
                  () => ({
                    left: `${get(_range).x ?? ""}px`,
                    top: `${get(bottom) - handleSize()}px`,
                    width: `${get(_range).width ?? ""}px`,
                    height: `${handleSize() ?? ""}px`
                  })
                ]
              );
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_4, ($$render) => {
                if (strict_equals(axis(), "both") || strict_equals(axis(), "y")) $$render(consequent_1);
              }),
              "if",
              BrushContext,
              506,
              6
            );
          }
          var node_5 = sibling(node_4, 2);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_4 = root_53();
              var div_5 = first_child(fragment_4);
              var event_handler_3 = (e) => {
                e.stopPropagation();
                if (xDomain()) {
                  $$ownership_validator.mutation("xDomain", ["xDomain", 0], xDomain()[0] = get(xDomainMin), 579, 14);
                  onChange()({ xDomain: xDomain(), yDomain: yDomain() });
                }
              };
              attribute_effect(
                div_5,
                ($0, $1) => ({
                  ...handle(),
                  "data-position": "left",
                  class: $0,
                  onpointerdown: adjustLeft,
                  ondblclick: event_handler_3,
                  [STYLE]: $1
                }),
                [
                  () => cls(get(handleClass), "cursor-ew-resize select-none", "range absolute", "z-10", classes().handle, handle()?.class),
                  () => ({
                    left: `${get(_range).x ?? ""}px`,
                    top: `${get(_range).y ?? ""}px`,
                    width: `${handleSize() ?? ""}px`,
                    height: `${get(_range).height ?? ""}px`
                  })
                ]
              );
              var div_6 = sibling(div_5, 2);
              var event_handler_4 = (e) => {
                e.stopPropagation();
                if (xDomain()) {
                  $$ownership_validator.mutation("xDomain", ["xDomain", 1], xDomain()[1] = get(xDomainMax), 604, 14);
                  onChange()({ xDomain: xDomain(), yDomain: yDomain() });
                }
              };
              attribute_effect(
                div_6,
                ($0, $1) => ({
                  ...handle(),
                  "data-position": "right",
                  class: $0,
                  onpointerdown: adjustRight,
                  ondblclick: event_handler_4,
                  [STYLE]: $1
                }),
                [
                  () => cls(get(handleClass), "cursor-ew-resize select-none", "range absolute", "z-10", classes().handle, handle()?.class),
                  () => ({
                    left: `${get(right2) - handleSize() + 1}px`,
                    top: `${get(_range).y ?? ""}px`,
                    width: `${handleSize() ?? ""}px`,
                    height: `${get(_range).height ?? ""}px`
                  })
                ]
              );
              append($$anchor4, fragment_4);
            };
            add_svelte_meta(
              () => if_block(node_5, ($$render) => {
                if (strict_equals(axis(), "both") || strict_equals(axis(), "x")) $$render(consequent_2);
              }),
              "if",
              BrushContext,
              559,
              6
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if (brushContext.isActive) $$render(consequent_3);
          }),
          "if",
          BrushContext,
          488,
          4
        );
      }
      reset(div);
      bind_this(div, ($$value) => set(rootEl, $$value), () => get(rootEl));
      template_effect(
        ($0, $1, $2, $3) => {
          set_class(div, 1, $0);
          styles = set_style(div, "", styles, $1);
          set_class(div_1, 1, $2);
          styles_1 = set_style(div_1, "", styles_1, $3);
        },
        [
          () => clsx(cls(layerClass("brush-context"), "absolute touch-none")),
          () => ({
            top: `${ctx.padding.top ?? ""}px`,
            left: `${ctx.padding.left ?? ""}px`,
            width: `${ctx.width ?? ""}px`,
            height: `${ctx.height ?? ""}px`
          }),
          () => clsx(cls(layerClass("brush-container"), "absolute")),
          () => ({
            top: `-${ctx.padding.top ?? 0 ?? ""}px`,
            left: `-${ctx.padding.left ?? 0 ?? ""}px`,
            width: `${ctx.containerWidth ?? ""}px`,
            height: `${ctx.containerHeight ?? ""}px`
          })
        ]
      );
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (disabled()) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      BrushContext,
      463,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BrushContext = hmr(BrushContext, () => BrushContext[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = BrushContext[HMR].source;
    set(BrushContext[HMR].source, module2.default[HMR].original);
  });
}
var BrushContext_default = BrushContext;
delegate(["pointerdown", "dblclick"]);

// node_modules/layerchart/dist/components/Chart.svelte
Chart[FILENAME] = "node_modules/layerchart/dist/components/Chart.svelte";
var defaultPadding = { top: 0, right: 0, bottom: 0, left: 0 };
var _ChartContext = new Context("ChartContext");
function getChartContext() {
  return _ChartContext.getOr({});
}
function setChartContext(context) {
  return _ChartContext.set(context);
}
var _RenderContext = new Context("RenderContext");
function getRenderContext() {
  return _RenderContext.get();
}
function setRenderContext(context) {
  return _RenderContext.set(context);
}
var root_15 = add_locations(from_html(`<div><!></div>`), Chart[FILENAME], [[1337, 2]]);
var $$css = {
  hash: "s-uDAH2GcCSDkP",
  code: "\n  .lc-root-container.s-uDAH2GcCSDkP,\n  .lc-root-container.s-uDAH2GcCSDkP * {\n    box-sizing: border-box;\n  }\n  .lc-root-container.s-uDAH2GcCSDkP {\n    width: 100%;\n    height: 100%;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhcnQuc3ZlbHRlIiwic291cmNlcyI6WyJDaGFydC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPVwidHNcIiBtb2R1bGU+XG4gIGltcG9ydCB7IHNjYWxlTGluZWFyLCBzY2FsZU9yZGluYWwsIHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJztcbiAgaW1wb3J0IHsgdHlwZSBBY2Nlc3NvciwgYWNjZXNzb3IsIGNoYXJ0RGF0YUFycmF5IH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uLmpzJztcbiAgaW1wb3J0IHsgcHJpbnREZWJ1ZyB9IGZyb20gJy4uL3V0aWxzL2RlYnVnLmpzJztcbiAgaW1wb3J0IHsgZmlsdGVyT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMvZmlsdGVyT2JqZWN0LmpzJztcbiAgaW1wb3J0IHtcbiAgICBjcmVhdGVTY2FsZSxcbiAgICBnZXRSYW5nZSxcbiAgICBpc1NjYWxlQmFuZCxcbiAgICBtYWtlQWNjZXNzb3IsXG4gICAgdHlwZSBBbnlTY2FsZSxcbiAgICB0eXBlIERvbWFpblR5cGUsXG4gIH0gZnJvbSAnLi4vdXRpbHMvc2NhbGVzLnN2ZWx0ZS5qcyc7XG4gIGltcG9ydCB7IENvbnRleHQsIHVzZURlYm91bmNlIH0gZnJvbSAncnVuZWQnO1xuICBpbXBvcnQgdHlwZSB7XG4gICAgQXhpc0tleSxcbiAgICBCYXNlUmFuZ2UsXG4gICAgRGF0YVR5cGUsXG4gICAgRXh0ZW50cyxcbiAgICBOaWNlLFxuICAgIFBhZGRpbmcsXG4gICAgUGFkZGluZ0FycmF5LFxuICAgIFhSYW5nZVdpdGhTY2FsZSxcbiAgICBZUmFuZ2VXaXRoU2NhbGUsXG4gIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMuanMnO1xuICBpbXBvcnQge1xuICAgIGNhbGNEb21haW4sXG4gICAgY2FsY1NjYWxlRXh0ZW50cyxcbiAgICBjcmVhdGVHZXR0ZXIsXG4gICAgY3JlYXRlQ2hhcnRTY2FsZSxcbiAgfSBmcm9tICcuLi91dGlscy9jaGFydC5qcyc7XG4gIGltcG9ydCB7IG9uTW91bnQsIHR5cGUgQ29tcG9uZW50UHJvcHMsIHR5cGUgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBHZW9Db250ZXh0LCB7IHR5cGUgR2VvQ29udGV4dFZhbHVlIH0gZnJvbSAnLi9HZW9Db250ZXh0LnN2ZWx0ZSc7XG4gIGltcG9ydCBUb29sdGlwQ29udGV4dCwgeyB0eXBlIFRvb2x0aXBDb250ZXh0VmFsdWUgfSBmcm9tICcuL3Rvb2x0aXAvVG9vbHRpcENvbnRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgZXh0ZW50LCBtYXgsIG1pbiB9IGZyb20gJ2QzLWFycmF5JztcbiAgaW1wb3J0IHR5cGUgeyBIaWVyYXJjaHlOb2RlIH0gZnJvbSAnZDMtaGllcmFyY2h5JztcbiAgaW1wb3J0IHR5cGUgeyBTYW5rZXlHcmFwaCB9IGZyb20gJ2QzLXNhbmtleSc7XG4gIGltcG9ydCB7IHVuaXF1ZSB9IGZyb20gJ0BsYXllcnN0YWNrL3V0aWxzJztcbiAgaW1wb3J0IHsgZ2VvRml0T2JqZWN0VHJhbnNmb3JtIH0gZnJvbSAnLi4vdXRpbHMvZ2VvLmpzJztcbiAgaW1wb3J0IFRyYW5zZm9ybUNvbnRleHQsIHsgdHlwZSBUcmFuc2Zvcm1Db250ZXh0VmFsdWUgfSBmcm9tICcuL1RyYW5zZm9ybUNvbnRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IEJydXNoQ29udGV4dCwgeyB0eXBlIEJydXNoQ29udGV4dFZhbHVlIH0gZnJvbSAnLi9CcnVzaENvbnRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgbGF5ZXJDbGFzcyB9IGZyb20gJy4uL3V0aWxzL2F0dHJpYnV0ZXMuanMnO1xuXG4gIGNvbnN0IGRlZmF1bHRQYWRkaW5nID0geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfTtcblxuICBleHBvcnQgdHlwZSBDaGFydFJlc2l6ZURldGFpbCA9IHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xuICAgIGNvbnRhaW5lcldpZHRoOiBudW1iZXI7XG4gICAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgUHJlc2VydmVkQ2hhcnRDb25maWc8XG4gICAgVCxcbiAgICBYU2NhbGUgZXh0ZW5kcyBBbnlTY2FsZSA9IEFueVNjYWxlLFxuICAgIFlTY2FsZSBleHRlbmRzIEFueVNjYWxlID0gQW55U2NhbGUsXG4gID4gPSBQaWNrPFxuICAgIENoYXJ0UHJvcHNXaXRob3V0SFRNTDxULCBYU2NhbGUsIFlTY2FsZT4sXG4gICAgfCAneCdcbiAgICB8ICd5J1xuICAgIHwgJ3onXG4gICAgfCAncidcbiAgICB8ICdjJ1xuICAgIHwgJ3gxJ1xuICAgIHwgJ3kxJ1xuICAgIHwgJ3hSYW5nZSdcbiAgICB8ICd5UmFuZ2UnXG4gICAgfCAnY0RvbWFpbidcbiAgICB8ICd6RG9tYWluJ1xuICAgIHwgJ3hEb21haW4nXG4gICAgfCAneURvbWFpbidcbiAgICB8ICdyRG9tYWluJ1xuICAgIHwgJ3gxRG9tYWluJ1xuICAgIHwgJ3kxRG9tYWluJ1xuICAgIHwgJ3pSYW5nZSdcbiAgICB8ICdyUmFuZ2UnXG4gICAgfCAnY1JhbmdlJ1xuICAgIHwgJ3gxUmFuZ2UnXG4gICAgfCAneTFSYW5nZSdcbiAgPjtcblxuICBleHBvcnQgdHlwZSBDaGFydENvbnRleHRWYWx1ZTxcbiAgICBUID0gYW55LFxuICAgIFhTY2FsZSBleHRlbmRzIEFueVNjYWxlID0gQW55U2NhbGUsXG4gICAgWVNjYWxlIGV4dGVuZHMgQW55U2NhbGUgPSBBbnlTY2FsZSxcbiAgPiA9IHtcbiAgICBhY3RpdmVHZXR0ZXJzOiBSZWNvcmQ8QXhpc0tleSwgKGQ6IFQpID0+IGFueT47XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBwZXJjZW50UmFuZ2U6IGJvb2xlYW47XG4gICAgYXNwZWN0UmF0aW86IG51bWJlcjtcbiAgICBjb250YWluZXJSZWY6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGNvbnRhaW5lcldpZHRoOiBudW1iZXI7XG4gICAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG4gICAgY29uZmlnOiBQcmVzZXJ2ZWRDaGFydENvbmZpZzxULCBYU2NhbGUsIFlTY2FsZT47XG4gICAgeDogKGQ6IFQpID0+IGFueTtcbiAgICB5OiAoZDogVCkgPT4gYW55O1xuICAgIHo6IChkOiBUKSA9PiBhbnk7XG4gICAgcjogKGQ6IFQpID0+IGFueTtcbiAgICB4MTogKGQ6IFQpID0+IGFueTtcbiAgICB5MTogKGQ6IFQpID0+IGFueTtcbiAgICBjOiAoZDogVCkgPT4gYW55O1xuICAgIGRhdGE6IERhdGFUeXBlPFQ+O1xuICAgIHhOaWNlOiBOaWNlO1xuICAgIHlOaWNlOiBOaWNlO1xuICAgIHpOaWNlOiBOaWNlO1xuICAgIHJOaWNlOiBOaWNlO1xuICAgIHhEb21haW5Tb3J0OiBib29sZWFuO1xuICAgIHlEb21haW5Tb3J0OiBib29sZWFuO1xuICAgIHpEb21haW5Tb3J0OiBib29sZWFuO1xuICAgIHJEb21haW5Tb3J0OiBib29sZWFuO1xuICAgIHhSZXZlcnNlOiBib29sZWFuO1xuICAgIHlSZXZlcnNlOiBib29sZWFuO1xuICAgIHpSZXZlcnNlOiBib29sZWFuO1xuICAgIHJSZXZlcnNlOiBib29sZWFuO1xuICAgIHhQYWRkaW5nOiBQYWRkaW5nQXJyYXk7XG4gICAgeVBhZGRpbmc6IFBhZGRpbmdBcnJheTtcbiAgICB6UGFkZGluZzogUGFkZGluZ0FycmF5O1xuICAgIHJQYWRkaW5nOiBQYWRkaW5nQXJyYXk7XG4gICAgcGFkZGluZzogUGFkZGluZztcbiAgICBmbGF0RGF0YTogVFtdO1xuICAgIGV4dGVudHM6IEV4dGVudHM7XG4gICAgeERvbWFpbjogbnVtYmVyW107XG4gICAgeURvbWFpbjogbnVtYmVyW107XG4gICAgekRvbWFpbjogRG9tYWluVHlwZTtcbiAgICByRG9tYWluOiBEb21haW5UeXBlO1xuICAgIGNEb21haW46IERvbWFpblR5cGU7XG4gICAgeDFEb21haW46IERvbWFpblR5cGU7XG4gICAgeTFEb21haW46IERvbWFpblR5cGU7XG4gICAgeFJhbmdlOiBhbnlbXTtcbiAgICB5UmFuZ2U6IGFueVtdO1xuICAgIHpSYW5nZTogYW55W107XG4gICAgclJhbmdlOiBhbnlbXTtcbiAgICBjUmFuZ2U6IHJlYWRvbmx5IHN0cmluZ1tdIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgeDFSYW5nZTogWFJhbmdlV2l0aFNjYWxlPFhTY2FsZT4gfCB1bmRlZmluZWQ7XG4gICAgeTFSYW5nZTogWVJhbmdlV2l0aFNjYWxlPFlTY2FsZT4gfCB1bmRlZmluZWQ7XG4gICAgbWV0YTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB4U2NhbGU6IEFueVNjYWxlO1xuICAgIHlTY2FsZTogQW55U2NhbGU7XG4gICAgelNjYWxlOiBBbnlTY2FsZTtcbiAgICByU2NhbGU6IEFueVNjYWxlO1xuICAgIGNTY2FsZTogQW55U2NhbGUgfCBudWxsO1xuICAgIHgxU2NhbGU6IEFueVNjYWxlIHwgbnVsbDtcbiAgICB5MVNjYWxlOiBBbnlTY2FsZSB8IG51bGw7XG4gICAgeUdldDogKGQ6IFQpID0+IGFueTtcbiAgICB4R2V0OiAoZDogVCkgPT4gYW55O1xuICAgIHpHZXQ6IChkOiBUKSA9PiBhbnk7XG4gICAgckdldDogKGQ6IFQpID0+IGFueTtcbiAgICBjR2V0OiAoZDogVCkgPT4gYW55O1xuICAgIHgxR2V0OiAoZDogVCkgPT4gYW55O1xuICAgIHkxR2V0OiAoZDogVCkgPT4gYW55O1xuICAgIHJhZGlhbDogYm9vbGVhbjtcbiAgICB0b29sdGlwOiBUb29sdGlwQ29udGV4dFZhbHVlPFQ+O1xuICAgIGdlbzogR2VvQ29udGV4dFZhbHVlO1xuICAgIGJydXNoOiBCcnVzaENvbnRleHRWYWx1ZTtcbiAgICB0cmFuc2Zvcm06IFRyYW5zZm9ybUNvbnRleHRWYWx1ZTtcbiAgfTtcblxuICBleHBvcnQgdHlwZSBMYXllckNoYXJ0SW50ZXJuYWxNZXRhID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGNoYXJ0IHR5cGUuXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYCdkZWZhdWx0J2Agd2hpY2ggaXMgYW55IGNoYXJ0IGJlaW5nIGNvbXBvc2VkXG4gICAgICogdGhhdCBpc24ndCBhIFwic2ltcGxpZmllZCBjaGFydFwiLlxuICAgICAqL1xuICAgIHR5cGU6XG4gICAgICB8ICdkZWZhdWx0J1xuICAgICAgfCAnc2ltcGxpZmllZC1hcmVhJ1xuICAgICAgfCAnc2ltcGxpZmllZC1iYXInXG4gICAgICB8ICdzaW1wbGlmaWVkLWxpbmUnXG4gICAgICB8ICdzaW1wbGlmaWVkLXBpZSdcbiAgICAgIHwgJ3NpbXBsaWZpZWQtc2NhdHRlcic7XG4gIH07XG5cbiAgY29uc3QgX0NoYXJ0Q29udGV4dCA9IG5ldyBDb250ZXh0PENoYXJ0Q29udGV4dFZhbHVlPGFueSwgQW55U2NhbGUsIEFueVNjYWxlPj4oJ0NoYXJ0Q29udGV4dCcpO1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRDaGFydENvbnRleHQ8XG4gICAgVCxcbiAgICBYU2NhbGUgZXh0ZW5kcyBBbnlTY2FsZSA9IEFueVNjYWxlLFxuICAgIFlTY2FsZSBleHRlbmRzIEFueVNjYWxlID0gQW55U2NhbGUsXG4gID4oKTogQ2hhcnRDb250ZXh0VmFsdWU8VCwgWFNjYWxlLCBZU2NhbGU+IHtcbiAgICByZXR1cm4gX0NoYXJ0Q29udGV4dC5nZXRPcih7fSBhcyBDaGFydENvbnRleHRWYWx1ZTxULCBYU2NhbGUsIFlTY2FsZT4pO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldENoYXJ0Q29udGV4dDxcbiAgICBULFxuICAgIFhTY2FsZSBleHRlbmRzIEFueVNjYWxlID0gQW55U2NhbGUsXG4gICAgWVNjYWxlIGV4dGVuZHMgQW55U2NhbGUgPSBBbnlTY2FsZSxcbiAgPihjb250ZXh0OiBDaGFydENvbnRleHRWYWx1ZTxULCBYU2NhbGUsIFlTY2FsZT4pOiBDaGFydENvbnRleHRWYWx1ZTxULCBYU2NhbGUsIFlTY2FsZT4ge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBzaGhcbiAgICByZXR1cm4gX0NoYXJ0Q29udGV4dC5zZXQoY29udGV4dCk7XG4gIH1cblxuICBleHBvcnQgdHlwZSBSZW5kZXJDb250ZXh0ID0gJ3N2ZycgfCAnY2FudmFzJyB8ICdodG1sJztcblxuICBjb25zdCBfUmVuZGVyQ29udGV4dCA9IG5ldyBDb250ZXh0PFJlbmRlckNvbnRleHQ+KCdSZW5kZXJDb250ZXh0Jyk7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlckNvbnRleHQoKTogUmVuZGVyQ29udGV4dCB7XG4gICAgcmV0dXJuIF9SZW5kZXJDb250ZXh0LmdldCgpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldFJlbmRlckNvbnRleHQoY29udGV4dDogUmVuZGVyQ29udGV4dCk6IFJlbmRlckNvbnRleHQge1xuICAgIHJldHVybiBfUmVuZGVyQ29udGV4dC5zZXQoY29udGV4dCk7XG4gIH1cblxuICBleHBvcnQgdHlwZSBDaGFydFByb3BzV2l0aG91dEhUTUw8XG4gICAgVCxcbiAgICBYU2NhbGUgZXh0ZW5kcyBBbnlTY2FsZSA9IEFueVNjYWxlLFxuICAgIFlTY2FsZSBleHRlbmRzIEFueVNjYWxlID0gQW55U2NhbGUsXG4gID4gPSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNoYXJ0IHNob3VsZCBiZSByZW5kZXJlZCBzZXJ2ZXIgc2lkZVxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzc3I/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBwb2ludGVyIGV2ZW50cyB2aWEgQ1NTLlxuICAgICAqIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZTtgIG9uIGFsbCBjb21wb25lbnRzLCBkaXNhYmxpbmdcbiAgICAgKiBhbGwgbW91c2UgaW50ZXJhY3Rpb25zLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHBvaW50ZXJFdmVudHM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgd3JhcHBlciBkaXYuXG4gICAgICogU2V0IHRoaXMgdG8gYCdhYnNvbHV0ZSdgIHdoZW4geW91IHdhbnQgdG8gc3RhY2sgbGF5ZXJzLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJ3JlbGF0aXZlJ1xuICAgICAqL1xuICAgIHBvc2l0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBzZXQgYWxsIHNjYWxlIHJhbmdlcyB0byBgWzAsIDEwMF1gLlxuICAgICAqIFJhbmdlcyByZXZlcnNlZCB2aWEgYHhSZXZlcnNlYCwgYHlSZXZlcnNlYCwgb3IgYHJSZXZlcnNlYCBwcm9wcyB3aWxsXG4gICAgICogY29udGludWUgdG8gYmUgcmV2ZXJzZWQgYXMgdXN1YWwuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBwZXJjZW50UmFuZ2U/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSBiaW5kYWJsZSByZWZlcmVuY2UgdG8gdGhlIHJvb3QgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICovXG4gICAgcmVmPzogSFRNTEVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiBgZGF0YWAgaXMgbm90IGEgZmxhdCBhcnJheSBvZiBvYmplY3RzIGFuZCB5b3Ugd2FudCB0byB1c2UgYW55IG9mIHRoZSBzY2FsZXMsIHNldCBhIGZsYXRcbiAgICAgKiB2ZXJzaW9uIG9mIHRoZSBkYXRhIHZpYSB0aGUgYGZsYXREYXRhYCBwcm9wLlxuICAgICAqL1xuICAgIGRhdGE/OiBUW10gfCByZWFkb25seSBUW10gfCBIaWVyYXJjaHlOb2RlPFQ+IHwgU2Fua2V5R3JhcGg8YW55LCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQSBmbGF0IHZlcnNpb24gb2YgZGF0YS5cbiAgICAgKi9cbiAgICBmbGF0RGF0YT86IFRbXSB8IHJlYWRvbmx5IFRbXSB8IEhpZXJhcmNoeU5vZGU8VD4gfCBTYW5rZXlHcmFwaDxhbnksIGFueT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgeCBhY2Nlc3Nvci4gVGhlIGtleSBpbiBlYWNoIHJvdyBvZiBkYXRhIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHgtZmllbGQuIFRoaXMgY2FuIGJlIGFcbiAgICAgKiBzdHJpbmcsIGFuIGFjY2Vzc29yIGZ1bmN0aW9uLCBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhbnkgY29tYmluYXRpb24gb2YgdGhvc2UgdHlwZXMuIFRoaXNcbiAgICAgKiBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHg/OiBBY2Nlc3NvcjxUPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB5IGFjY2Vzc29yLiBUaGUga2V5IGluIGVhY2ggcm93IG9mIGRhdGEgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgeS1maWVsZC4gVGhpcyBjYW4gYmUgYVxuICAgICAqIHN0cmluZywgYW4gYWNjZXNzb3IgZnVuY3Rpb24sIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGFueSBjb21iaW5hdGlvbiBvZiB0aG9zZSB0eXBlcy4gVGhpc1xuICAgICAqIHByb3BlcnR5IGdldHMgY29udmVydGVkIHRvIGEgZnVuY3Rpb24gd2hlbiB5b3UgYWNjZXNzIGl0IHRocm91Z2ggdGhlIGNvbnRleHQuXG4gICAgICovXG4gICAgeT86IEFjY2Vzc29yPFQ+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHogYWNjZXNzb3IuIFRoZSBrZXkgaW4gZWFjaCByb3cgb2YgZGF0YSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB6LWZpZWxkLiBUaGlzIGNhbiBiZSBhXG4gICAgICogc3RyaW5nLCBhbiBhY2Nlc3NvciBmdW5jdGlvbiwgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYW55IGNvbWJpbmF0aW9uIG9mIHRob3NlIHR5cGVzLiBUaGlzXG4gICAgICogcHJvcGVydHkgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBmdW5jdGlvbiB3aGVuIHlvdSBhY2Nlc3MgaXQgdGhyb3VnaCB0aGUgY29udGV4dC5cbiAgICAgKi9cbiAgICB6PzogQWNjZXNzb3I8VD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgciBhY2Nlc3Nvci4gVGhlIGtleSBpbiBlYWNoIHJvdyBvZiBkYXRhIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHItZmllbGQuIFRoaXMgY2FuIGJlIGFcbiAgICAgKiBzdHJpbmcsIGFuIGFjY2Vzc29yIGZ1bmN0aW9uLCBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhbnkgY29tYmluYXRpb24gb2YgdGhvc2UgdHlwZXMuIFRoaXNcbiAgICAgKiBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHI/OiBBY2Nlc3NvcjxUPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB4MSBhY2Nlc3Nvci4gVGhlIGtleSBpbiBlYWNoIHJvdyBvZiBkYXRhIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHgxLWZpZWxkLiBUaGlzIGNhbiBiZSBhXG4gICAgICogc3RyaW5nLCBhbiBhY2Nlc3NvciBmdW5jdGlvbiwgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYW55IGNvbWJpbmF0aW9uIG9mIHRob3NlIHR5cGVzLiBUaGlzXG4gICAgICogcHJvcGVydHkgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBmdW5jdGlvbiB3aGVuIHlvdSBhY2Nlc3MgaXQgdGhyb3VnaCB0aGUgY29udGV4dC5cbiAgICAgKi9cbiAgICB4MT86IEFjY2Vzc29yPFQ+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHkxIGFjY2Vzc29yLiBUaGUga2V5IGluIGVhY2ggcm93IG9mIGRhdGEgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgeTEtZmllbGQuIFRoaXMgY2FuIGJlXG4gICAgICogYSBzdHJpbmcsIGFuIGFjY2Vzc29yIGZ1bmN0aW9uLCBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhbnkgY29tYmluYXRpb24gb2YgdGhvc2UgdHlwZXMuIFRoaXNcbiAgICAgKiBwcm9wZXJ0eSBnZXRzIGNvbnZlcnRlZCB0byBhIGZ1bmN0aW9uIHdoZW4geW91IGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHkxPzogQWNjZXNzb3I8VD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYyAoY29sb3IpIGFjY2Vzc29yLiBUaGUga2V5IGluIGVhY2ggcm93IG9mIGRhdGEgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgY29sb3IuIFRoaXMgY2FuXG4gICAgICogYmUgYSBzdHJpbmcgb3IgYW4gYWNjZXNzb3IgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBmdW5jdGlvbiB3aGVuIHlvdVxuICAgICAqIGFjY2VzcyBpdCB0aHJvdWdoIHRoZSBjb250ZXh0LlxuICAgICAqL1xuICAgIGM/OiBBY2Nlc3NvcjxUPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIG1pbiBvciBtYXguIEZvciBsaW5lYXIgc2NhbGVzLCBpZiB5b3Ugd2FudCB0byBpbmhlcml0IHRoZSB2YWx1ZSBmcm9tIHRoZSBkYXRhJ3NcbiAgICAgKiBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyXG4gICAgICogc2NhbGVzIGFyZSBbcGllY2V3aXNlXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19kb21haW4pIG9yIGFyZSBhIGxpc3Qgb2ZcbiAgICAgKiBkaXNjcmV0ZSB2YWx1ZXMgc3VjaCBhcyBpbiBbb3JkaW5hbCBzY2FsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNvcmRpbmFsLXNjYWxlcyksXG4gICAgICogdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3VcbiAgICAgKiByZXR1cm4gYSBtb2RpZmllZCBkb21haW4sIHVzZWZ1bCBmb3Igc29ydGluZyB2YWx1ZXMuXG4gICAgICovXG4gICAgeERvbWFpbj86IERvbWFpblR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBtaW4gb3IgbWF4LiBGb3IgbGluZWFyIHNjYWxlcywgaWYgeW91IHdhbnQgdG8gaW5oZXJpdCB0aGUgdmFsdWUgZnJvbSB0aGUgZGF0YSdzXG4gICAgICogZXh0ZW50LCBzZXQgdGhhdCB2YWx1ZSB0byBgbnVsbGAuIFRoaXMgdmFsdWUgY2FuIGFsc28gYmUgYW4gYXJyYXkgYmVjYXVzZSBzb21ldGltZXMgeW91clxuICAgICAqIHNjYWxlcyBhcmUgW3BpZWNld2lzZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfZG9tYWluKSBvciBhcmUgYSBsaXN0IG9mXG4gICAgICogZGlzY3JldGUgdmFsdWVzIHN1Y2ggYXMgaW4gW29yZGluYWwgc2NhbGVzXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjb3JkaW5hbC1zY2FsZXMpLFxuICAgICAqIHVzZWZ1bCBmb3IgY29sb3Igc2VyaWVzLiBTZXQgaXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBjb21wdXRlZCBkb21haW4gYW5kIGxldHMgeW91XG4gICAgICogcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLlxuICAgICAqL1xuICAgIHlEb21haW4/OiBEb21haW5UeXBlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbWluIG9yIG1heC4gRm9yIGxpbmVhciBzY2FsZXMsIGlmIHlvdSB3YW50IHRvIGluaGVyaXQgdGhlIHZhbHVlIGZyb20gdGhlIGRhdGEnc1xuICAgICAqIGV4dGVudCwgc2V0IHRoYXQgdmFsdWUgdG8gYG51bGxgLiBUaGlzIHZhbHVlIGNhbiBhbHNvIGJlIGFuIGFycmF5IGJlY2F1c2Ugc29tZXRpbWVzIHlvdXJcbiAgICAgKiBzY2FsZXMgYXJlIFtwaWVjZXdpc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNjb250aW51b3VzX2RvbWFpbikgb3IgYXJlIGEgbGlzdCBvZlxuICAgICAqIGRpc2NyZXRlIHZhbHVlcyBzdWNoIGFzIGluIFtvcmRpbmFsIHNjYWxlc10oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI29yZGluYWwtc2NhbGVzKSxcbiAgICAgKiB1c2VmdWwgZm9yIGNvbG9yIHNlcmllcy4gU2V0IGl0IHRvIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgY29tcHV0ZWQgZG9tYWluIGFuZCBsZXRzIHlvdVxuICAgICAqIHJldHVybiBhIG1vZGlmaWVkIGRvbWFpbiwgdXNlZnVsIGZvciBzb3J0aW5nIHZhbHVlcy5cbiAgICAgKi9cbiAgICB6RG9tYWluPzogRG9tYWluVHlwZTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIG1pbiBvciBtYXguIEZvciBsaW5lYXIgc2NhbGVzLCBpZiB5b3Ugd2FudCB0byBpbmhlcml0IHRoZSB2YWx1ZSBmcm9tIHRoZSBkYXRhJ3NcbiAgICAgKiBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyXG4gICAgICogc2NhbGVzIGFyZSBbcGllY2V3aXNlXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19kb21haW4pIG9yIGFyZSBhIGxpc3Qgb2ZcbiAgICAgKiBkaXNjcmV0ZSB2YWx1ZXMgc3VjaCBhcyBpbiBbb3JkaW5hbCBzY2FsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNvcmRpbmFsLXNjYWxlcyksXG4gICAgICogdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3VcbiAgICAgKiByZXR1cm4gYSBtb2RpZmllZCBkb21haW4sIHVzZWZ1bCBmb3Igc29ydGluZyB2YWx1ZXMuXG4gICAgICovXG4gICAgckRvbWFpbj86IERvbWFpblR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBtaW4gb3IgbWF4LiBGb3IgbGluZWFyIHNjYWxlcywgaWYgeW91IHdhbnQgdG8gaW5oZXJpdCB0aGUgdmFsdWUgZnJvbSB0aGUgZGF0YSdzXG4gICAgICogZXh0ZW50LCBzZXQgdGhhdCB2YWx1ZSB0byBgbnVsbGAuIFRoaXMgdmFsdWUgY2FuIGFsc28gYmUgYW4gYXJyYXkgYmVjYXVzZSBzb21ldGltZXMgeW91clxuICAgICAqIHNjYWxlcyBhcmUgW3BpZWNld2lzZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfZG9tYWluKSBvciBhcmUgYSBsaXN0IG9mXG4gICAgICogZGlzY3JldGUgdmFsdWVzIHN1Y2ggYXMgaW4gW29yZGluYWwgc2NhbGVzXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjb3JkaW5hbC1zY2FsZXMpLFxuICAgICAqIHVzZWZ1bCBmb3IgY29sb3Igc2VyaWVzLiBTZXQgaXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBjb21wdXRlZCBkb21haW4gYW5kIGxldHMgeW91XG4gICAgICogcmV0dXJuIGEgbW9kaWZpZWQgZG9tYWluLCB1c2VmdWwgZm9yIHNvcnRpbmcgdmFsdWVzLlxuICAgICAqL1xuICAgIHgxRG9tYWluPzogRG9tYWluVHlwZTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIG1pbiBvciBtYXguIEZvciBsaW5lYXIgc2NhbGVzLCBpZiB5b3Ugd2FudCB0byBpbmhlcml0IHRoZSB2YWx1ZSBmcm9tIHRoZSBkYXRhJ3NcbiAgICAgKiBleHRlbnQsIHNldCB0aGF0IHZhbHVlIHRvIGBudWxsYC4gVGhpcyB2YWx1ZSBjYW4gYWxzbyBiZSBhbiBhcnJheSBiZWNhdXNlIHNvbWV0aW1lcyB5b3VyXG4gICAgICogc2NhbGVzIGFyZSBbcGllY2V3aXNlXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19kb21haW4pIG9yIGFyZSBhIGxpc3Qgb2ZcbiAgICAgKiBkaXNjcmV0ZSB2YWx1ZXMgc3VjaCBhcyBpbiBbb3JkaW5hbCBzY2FsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNvcmRpbmFsLXNjYWxlcyksXG4gICAgICogdXNlZnVsIGZvciBjb2xvciBzZXJpZXMuIFNldCBpdCB0byBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGNvbXB1dGVkIGRvbWFpbiBhbmQgbGV0cyB5b3VcbiAgICAgKiByZXR1cm4gYSBtb2RpZmllZCBkb21haW4sIHVzZWZ1bCBmb3Igc29ydGluZyB2YWx1ZXMuXG4gICAgICovXG4gICAgeTFEb21haW4/OiBEb21haW5UeXBlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaXN0IG9mIGNvbG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjRG9tYWluPzogRG9tYWluVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgRDMncyBbc2NhbGUubmljZSgpXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19uaWNlKSB0byB0aGUgeCBkb21haW4uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB4TmljZT86IE5pY2U7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIEQzJ3MgW3NjYWxlLm5pY2UoKV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI2NvbnRpbnVvdXNfbmljZSkgdG8gdGhlIHkgZG9tYWluLlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgeU5pY2U/OiBOaWNlO1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBEMydzIFtzY2FsZS5uaWNlKCldKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNjb250aW51b3VzX25pY2UpIHRvIHRoZSB6IGRvbWFpbi5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHpOaWNlPzogTmljZTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgRDMncyBbc2NhbGUubmljZSgpXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjY29udGludW91c19uaWNlKSB0byB0aGUgciBkb21haW4uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByTmljZT86IE5pY2U7XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSBwaXhlbCB2YWx1ZSB0byBhZGQgdG8gdGhlIG1pbiBvciBtYXggb2YgdGhlIHNjYWxlLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIHNjYWxlc1xuICAgICAqIGRvbWFpbiBieSB0aGUgc2NhbGUgdW5pdCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBwaXhlbHMuXG4gICAgICovXG4gICAgeFBhZGRpbmc/OiBQYWRkaW5nQXJyYXk7XG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgcGl4ZWwgdmFsdWUgdG8gYWRkIHRvIHRoZSBtaW4gb3IgbWF4IG9mIHRoZSBzY2FsZS4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBzY2FsZXNcbiAgICAgKiBkb21haW4gYnkgdGhlIHNjYWxlIHVuaXQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgcGl4ZWxzLlxuICAgICAqL1xuICAgIHlQYWRkaW5nPzogUGFkZGluZ0FycmF5O1xuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIHBpeGVsIHZhbHVlIHRvIGFkZCB0byB0aGUgbWluIG9yIG1heCBvZiB0aGUgc2NhbGUuIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgc2NhbGVzXG4gICAgICogZG9tYWluIGJ5IHRoZSBzY2FsZSB1bml0IGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIHBpeGVscy5cbiAgICAgKi9cbiAgICB6UGFkZGluZz86IFBhZGRpbmdBcnJheTtcbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSBwaXhlbCB2YWx1ZSB0byBhZGQgdG8gdGhlIG1pbiBvciBtYXggb2YgdGhlIHNjYWxlLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIHNjYWxlc1xuICAgICAqIGRvbWFpbiBieSB0aGUgc2NhbGUgdW5pdCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBwaXhlbHMuXG4gICAgICovXG4gICAgclBhZGRpbmc/OiBQYWRkaW5nQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHgtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZlxuICAgICAqIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuXG4gICAgICogQGRlZmF1bHQgc2NhbGVMaW5lYXJcbiAgICAgKi9cbiAgICB4U2NhbGU/OiBYU2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHgtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZlxuICAgICAqIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuXG4gICAgICogQGRlZmF1bHQgc2NhbGVMaW5lYXJcbiAgICAgKi9cbiAgICB5U2NhbGU/OiBZU2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHgtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZlxuICAgICAqIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuXG4gICAgICogQGRlZmF1bHQgc2NhbGVMaW5lYXJcbiAgICAgKi9cbiAgICB6U2NhbGU/OiBBbnlTY2FsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeC1kaW1lbnNpb24uIFBhc3MgaW4gYW4gaW5zdGFudGlhdGVkIEQzIHNjYWxlIGlmXG4gICAgICogeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3IgeW91IHdhbnQgdG8gZXh0cmEgb3B0aW9ucy5cbiAgICAgKiBAZGVmYXVsdCBzY2FsZVNxcnRcbiAgICAgKi9cbiAgICByU2NhbGU/OiBBbnlTY2FsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBEMyBzY2FsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgeDEtZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZSBpZlxuICAgICAqIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuXG4gICAgICogQGRlZmF1bHQgc2NhbGVMaW5lYXJcbiAgICAgKi9cbiAgICB4MVNjYWxlPzogQW55U2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRDMgc2NhbGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIHkxLWRpbWVuc2lvbi4gUGFzcyBpbiBhbiBpbnN0YW50aWF0ZWQgRDMgc2NhbGUgaWZcbiAgICAgKiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvciB5b3Ugd2FudCB0byBleHRyYSBvcHRpb25zLlxuICAgICAqIEBkZWZhdWx0IHNjYWxlTGluZWFyXG4gICAgICovXG4gICAgeTFTY2FsZT86IEFueVNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEQzIHNjYWxlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSAgY29sb3IgZGltZW5zaW9uLiBQYXNzIGluIGFuIGluc3RhbnRpYXRlZCBEMyBzY2FsZVxuICAgICAqIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yIHlvdSB3YW50IHRvIGV4dHJhIG9wdGlvbnMuXG4gICAgICogQGRlZmF1bHQgc2NhbGVPcmRpbmFsXG4gICAgICovXG4gICAgY1NjYWxlPzogQW55U2NhbGU7XG5cbiAgICAvKiogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgeCByYW5nZSBvZiBgWzAsIHdpZHRoXWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50XG4gICAgICogYCh7IHdpZHRoLCBoZWlnaHR9KWAgdGhhdCByZXR1cm5zIGFuIGFycmF5LiBTZXR0aW5nIHRoaXMgcHJvcCBvdmVycmlkZXMgYHhSZXZlcnNlYC4gVGhpcyBjYW5cbiAgICAgKiBhbHNvIGJlIGEgbGlzdCBvZiBudW1iZXJzIG9yIHN0cmluZ3MgZm9yIHNjYWxlcyB3aXRoIGRpc2NyZXRlIHJhbmdlcyBsaWtlXG4gICAgICogW3NjYWxlVGhyZXNob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3JcbiAgICAgKiBbc2NhbGVRdWFudGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlcykuXG4gICAgICovXG4gICAgeFJhbmdlPzogQmFzZVJhbmdlO1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgeSByYW5nZSBvZiBgWzAsIGhlaWdodF1gIGJ5IHNldHRpbmcgYW4gYXJyYXkgb3IgZnVuY3Rpb24gd2l0aCBhcmd1bWVudFxuICAgICAqIGAoeyB3aWR0aCwgaGVpZ2h0fSlgIHRoYXQgcmV0dXJucyBhbiBhcnJheS4gU2V0dGluZyB0aGlzIHByb3Agb3ZlcnJpZGVzIGB5UmV2ZXJzZWAuIFRoaXMgY2FuXG4gICAgICogYWxzbyBiZSBhIGxpc3Qgb2YgbnVtYmVycyBvciBzdHJpbmdzIGZvciBzY2FsZXMgd2l0aCBkaXNjcmV0ZSByYW5nZXMgbGlrZVxuICAgICAqIFtzY2FsZVRocmVzaG9sZF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXMpIG9yXG4gICAgICogW3NjYWxlUXVhbnRpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNxdWFudGl6ZS1zY2FsZXMpLlxuICAgICAqL1xuICAgIHlSYW5nZT86IEJhc2VSYW5nZTtcblxuICAgIC8qKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB6IHJhbmdlIG9mIGBbMCwgd2lkdGhdYCBieSBzZXR0aW5nIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRcbiAgICAgKiBgKHsgd2lkdGgsIGhlaWdodH0pYCB0aGF0IHJldHVybnMgYW4gYXJyYXkuIFNldHRpbmcgdGhpcyBwcm9wIG92ZXJyaWRlcyBgelJldmVyc2VgLiBUaGlzIGNhblxuICAgICAqIGFsc28gYmUgYSBsaXN0IG9mIG51bWJlcnMgb3Igc3RyaW5ncyBmb3Igc2NhbGVzIHdpdGggZGlzY3JldGUgcmFuZ2VzIGxpa2VcbiAgICAgKiBbc2NhbGVUaHJlc2hvbGRdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSN0aHJlc2hvbGQtc2NhbGVzKSBvclxuICAgICAqIFtzY2FsZVF1YW50aXplXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzKS5cbiAgICAgKi9cbiAgICB6UmFuZ2U/OiBCYXNlUmFuZ2U7XG5cbiAgICAvKiogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgciByYW5nZSBvZiBgWzEsIDI1XWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50XG4gICAgICogYCh7IHdpZHRoLCBoZWlnaHR9KWAgdGhhdCByZXR1cm5zIGFuIGFycmF5LiBTZXR0aW5nIHRoaXMgcHJvcCBvdmVycmlkZXMgYHJSZXZlcnNlYC4gVGhpcyBjYW5cbiAgICAgKiBhbHNvIGJlIGEgbGlzdCBvZiBudW1iZXJzIG9yIHN0cmluZ3MgZm9yIHNjYWxlcyB3aXRoIGRpc2NyZXRlIHJhbmdlcyBsaWtlXG4gICAgICogW3NjYWxlVGhyZXNob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3JcbiAgICAgKiBbc2NhbGVRdWFudGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlcykuXG4gICAgICovXG4gICAgclJhbmdlPzogQmFzZVJhbmdlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB4MSByYW5nZSBieSBzZXR0aW5nIGFuIGFycmF5IG9yIGZ1bmN0aW9uIHdpdGggYXJndW1lbnQgYCh7IHhTY2FsZSwgd2lkdGgsIGhlaWdodH0pYFxuICAgICAqIHRoYXQgcmV0dXJucyBhbiBhcnJheS4gVGhpcyBjYW4gYWxzbyBiZSBhIGxpc3Qgb2YgbnVtYmVycyBvciBzdHJpbmdzIGZvciBzY2FsZXMgd2l0aFxuICAgICAqIGRpc2NyZXRlIHJhbmdlcyBsaWtlIFtzY2FsZVRocmVzaG9sZF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXMpIG9yXG4gICAgICogW3NjYWxlUXVhbnRpemVdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSNxdWFudGl6ZS1zY2FsZXMpLlxuICAgICAqL1xuICAgIHgxUmFuZ2U/OiBYUmFuZ2VXaXRoU2NhbGU8WFNjYWxlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgeTEgcmFuZ2UgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50IGAoeyB5U2NhbGUsIHdpZHRoLCBoZWlnaHR9KWBcbiAgICAgKiB0aGF0IHJldHVybnMgYW4gYXJyYXkuIFRoaXMgY2FuIGFsc28gYmUgYSBsaXN0IG9mIG51bWJlcnMgb3Igc3RyaW5ncyBmb3Igc2NhbGVzIHdpdGhcbiAgICAgKiBkaXNjcmV0ZSByYW5nZXMgbGlrZSBbc2NhbGVUaHJlc2hvbGRdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZSN0aHJlc2hvbGQtc2NhbGVzKSBvclxuICAgICAqIFtzY2FsZVF1YW50aXplXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzKS5cbiAgICAgKi9cbiAgICB5MVJhbmdlPzogWVJhbmdlV2l0aFNjYWxlPFlTY2FsZT47XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB5MSByYW5nZSBvZiBgWzAsIHdpZHRoXWAgYnkgc2V0dGluZyBhbiBhcnJheSBvciBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50XG4gICAgICogYCh7IHlTY2FsZSwgd2lkdGgsIGhlaWdodH0pYCB0aGF0IHJldHVybnMgYW4gYXJyYXkuIFNldHRpbmcgdGhpcyBwcm9wIG92ZXJyaWRlcyBgeDFSZXZlcnNlYC5cbiAgICAgKiBUaGlzIGNhbiBhbHNvIGJlIGEgbGlzdCBvZiBudW1iZXJzIG9yIHN0cmluZ3MgZm9yIHNjYWxlcyB3aXRoIGRpc2NyZXRlIHJhbmdlcyBsaWtlXG4gICAgICogW3NjYWxlVGhyZXNob2xkXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlcykgb3JcbiAgICAgKiBbc2NhbGVRdWFudGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlcykuXG4gICAgICovXG4gICAgY1JhbmdlPzogc3RyaW5nW10gfCByZWFkb25seSBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgdGhlIGRlZmF1bHQgeCByYW5nZS4gQnkgZGVmYXVsdCB0aGlzIGlzIGBmYWxzZWAgYW5kIHRoZSByYW5nZSBpcyBgWzAsIHdpZHRoXWAuXG4gICAgICogSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSB4UmFuZ2UgcHJvcC5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHhSZXZlcnNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgdGhlIGRlZmF1bHQgeSByYW5nZS4gQnkgZGVmYXVsdCB0aGlzIGlzIGB0cnVlYCBhbmQgdGhlIHJhbmdlIGlzIGBbaGVpZ2h0LCAwXWAgdW5sZXNzXG4gICAgICogdXNpbmcgYW4gb3JkaW5hbCBzY2FsZSB3aXRoIGEgYC5iYW5kd2lkdGhgIG1ldGhvZCBmb3IgYHlTY2FsZWAuXG4gICAgICogSWdub3JlZCBpZiB5b3Ugc2V0IHRoZSBgeVJhbmdlYCBwcm9wLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB5UmV2ZXJzZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIHRoZSBkZWZhdWx0IHogcmFuZ2UuIEJ5IGRlZmF1bHQgdGhpcyBpcyBgZmFsc2VgIGFuZCB0aGUgcmFuZ2UgaXMgYFswLCB3aWR0aF1gLlxuICAgICAqIElnbm9yZWQgaWYgeW91IHNldCB0aGUgelJhbmdlIHByb3AuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB6UmV2ZXJzZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIHRoZSBkZWZhdWx0IHIgcmFuZ2UuIEJ5IGRlZmF1bHQgdGhpcyBpcyBgZmFsc2VgIGFuZCB0aGUgcmFuZ2UgaXMgYFsxLCAyNV1gLlxuICAgICAqIElnbm9yZWQgaWYgeW91IHNldCB0aGUgclJhbmdlIHByb3AuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByUmV2ZXJzZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAqKipPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLioqKlxuICAgICAqIFNldCB3aGV0aGVyIHRoZSBjYWxjdWxhdGVkIHVuaXF1ZSBpdGVtcyBjb21lIGJhY2sgc29ydGVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB4RG9tYWluU29ydD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAqKipPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLioqKlxuICAgICAqIFNldCB3aGV0aGVyIHRoZSBjYWxjdWxhdGVkIHVuaXF1ZSBpdGVtcyBjb21lIGJhY2sgc29ydGVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB5RG9tYWluU29ydD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAqKipPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLioqKlxuICAgICAqIFNldCB3aGV0aGVyIHRoZSBjYWxjdWxhdGVkIHVuaXF1ZSBpdGVtcyBjb21lIGJhY2sgc29ydGVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB6RG9tYWluU29ydD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAqKipPbmx5IHVzZWQgd2hlbiBzY2FsZSBpcyBvcmRpbmFsLioqKlxuICAgICAqIFNldCB3aGV0aGVyIHRoZSBjYWxjdWxhdGVkIHVuaXF1ZSBpdGVtcyBjb21lIGJhY2sgc29ydGVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByRG9tYWluU29ydD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gcHV0IGFyb3VuZCB5b3VyIGNoYXJ0LiBJdCBvcGVyYXRlcyBsaWtlIENTU1xuICAgICAqIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IHdoZXJlIHZhbHVlcyBhcmUgc3VidHJhY3RlZCBmcm9tIHRoZSBwYXJlbnQgY29udGFpbmVyJ3Mgd2lkdGhcbiAgICAgKiBhbmQgaGVpZ2h0LCB0aGUgc2FtZSBhcyBhIFtEMyBtYXJnaW4gY29udmVudGlvbl0oaHR0cHM6Ly9ibC5vY2tzLm9yZy9tYm9zdG9jay8zMDE5NTYzKS5cbiAgICAgKlxuICAgICAqIElmIGEgbnVtYmVyIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBzaWRlcy5cbiAgICAgKi9cbiAgICBwYWRkaW5nPzogeyB0b3A/OiBudW1iZXI7IHJpZ2h0PzogbnVtYmVyOyBib3R0b20/OiBudW1iZXI7IGxlZnQ/OiBudW1iZXIgfSB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHNldCB0aGUgZXh0ZW50cyBvZiB0aGUgeCwgeSBvciByIHNjYWxlIGFzIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IG9mIHRoZSBtaW4gYW5kXG4gICAgICogbWF4IHlvdSB3YW50LiBTZXR0aW5nIHZhbHVlcyBoZXJlIHdpbGwgc2tpcCBhbnkgZHluYW1pYyBleHRlbnQgY2FsY3VsYXRpb24gb2YgdGhlIGRhdGEgZm9yXG4gICAgICogdGhhdCBkaW1lbnNpb24uXG4gICAgICovXG4gICAgZXh0ZW50cz86IHtcbiAgICAgIHg/OiBbbWluOiBudW1iZXIsIG1heDogbnVtYmVyXTtcbiAgICAgIHk/OiBbbWluOiBudW1iZXIsIG1heDogbnVtYmVyXTtcbiAgICAgIHI/OiBbbWluOiBudW1iZXIsIG1heDogbnVtYmVyXTtcbiAgICAgIHo/OiBbbWluOiBudW1iZXIsIG1heDogbnVtYmVyXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW55IGV4dHJhIGNvbmZpZ3VyYXRpb24gdmFsdWVzIHlvdSB3YW50IGF2YWlsYWJsZSBvbiB0aGUgQ2hhcnQgY29udGV4dC5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIHVzZWZ1bCBmb3IgY29sb3IgbG9va3VwcyBvciBhZGRpdGlvbmFsIGNvbnN0YW50cy5cbiAgICAgKi9cbiAgICBtZXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBkZWJ1ZyBwcmludGluZyB0byB0aGUgY29uc29sZS5cbiAgICAgKiBVc2VmdWwgdG8gaW5zcGVjdCB5b3VyIHNjYWxlcyBhbmQgZGltZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZGVidWc/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2hvdyB3YXJuaW5ncyBpbiB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB2ZXJib3NlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgZ3VhcmFudGVlZCB0byBiZSB2aXNpYmxlIGluIHhEb21haW4uICBVc2VmdWwgd2l0aCBvcHRpb25hbCBuZWdhdGl2ZSB2YWx1ZXMgc2luY2VcbiAgICAgKiBgeERvbWFpbj17WzAsIG51bGxdfWAgd291bGQgaWdub3JlIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHhCYXNlbGluZT86IG51bWJlciB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIGd1YXJhbnRlZWQgdG8gYmUgdmlzaWJsZSBpbiB5RG9tYWluLiAgVXNlZnVsIHdpdGggb3B0aW9uYWwgbmVnYXRpdmUgdmFsdWVzIHNpbmNlXG4gICAgICogYHlEb21haW49e1swLCBudWxsXX1gIHdvdWxkIGlnbm9yZSBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB5QmFzZWxpbmU/OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyogUHJvcHMgcGFzc2VkIHRvIENoYXJ0Q29udGV4dCAqL1xuXG4gICAgLyoqXG4gICAgICogVXNlIHJhZGlhbCBpbnN0ZWFkIG9mIGNhcnRlc2lhbiBjb29yZGluYXRlcywgbWFwcGluZyBgeGAgdG8gYGFuZ2xlYCBhbmQgYHlgYCB0byByYWRpYWwuXG4gICAgICogUmFkaWFsIGxpbmVzIGFyZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4sIHVzZSB0cmFuc2Zvcm0gKGV4LiBgPEdyb3VwIGNlbnRlcj5gKVxuICAgICAqIHRvIGNoYW5nZSB0aGUgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHJhZGlhbD86IGJvb2xlYW47XG5cbiAgICBjaGlsZHJlbj86IFNuaXBwZXQ8W3sgY29udGV4dDogQ2hhcnRDb250ZXh0VmFsdWU8VCwgWFNjYWxlLCBZU2NhbGU+IH1dPjtcblxuICAgIC8qKlxuICAgICAqIEEgYmluZGFibGUgcmVmZXJlbmNlIHRvIHRoZSBjaGFydCBjb250ZXh0LlxuICAgICAqL1xuICAgIGNvbnRleHQ/OiBDaGFydENvbnRleHRWYWx1ZTxULCBYU2NhbGUsIFlTY2FsZT47XG5cbiAgICAvKipcbiAgICAgKiBQcm9wcyBwYXNzZWQgdG8gR2VvQ29udGV4dFxuICAgICAqL1xuICAgIGdlbz86IFBhcnRpYWw8Q29tcG9uZW50UHJvcHM8dHlwZW9mIEdlb0NvbnRleHQ+PjtcblxuICAgIC8qKlxuICAgICAqIFByb3BzIHBhc3NlZCB0byB0aGUgYFRvb2x0aXBDb250ZXh0YCBjb21wb25lbnQuXG4gICAgICovXG4gICAgdG9vbHRpcD86IFBhcnRpYWw8Q29tcG9uZW50UHJvcHM8dHlwZW9mIFRvb2x0aXBDb250ZXh0Pj4gfCBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUHJvcHMgcGFzc2VkIHRvIFRyYW5zZm9ybUNvbnRleHRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0/OiBQYXJ0aWFsPENvbXBvbmVudFByb3BzPHR5cGVvZiBUcmFuc2Zvcm1Db250ZXh0Pj47XG5cbiAgICAvKiogUHJvcHMgcGFzc2VkIHRvIEJydXNoQ29udGV4dCAqL1xuICAgIGJydXNoPzogUGFydGlhbDxDb21wb25lbnRQcm9wczx0eXBlb2YgQnJ1c2hDb250ZXh0Pj4gfCBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjaGFydCBpcyByZXNpemVkLlxuICAgICAqL1xuICAgIG9uUmVzaXplPzogKGU6IENoYXJ0UmVzaXplRGV0YWlsKSA9PiB2b2lkO1xuXG4gICAgLy8gVHJhbnNmb3JtQ29udGV4dCBjYWxsYmFjayBldmVudHNcbiAgICBvbmRyYWdzdGFydD86IENvbXBvbmVudFByb3BzPHR5cGVvZiBUcmFuc2Zvcm1Db250ZXh0Plsnb25kcmFnc3RhcnQnXTtcbiAgICBvbmRyYWdlbmQ/OiBDb21wb25lbnRQcm9wczx0eXBlb2YgVHJhbnNmb3JtQ29udGV4dD5bJ29uZHJhZ2VuZCddO1xuICAgIG9uVHJhbnNmb3JtPzogQ29tcG9uZW50UHJvcHM8dHlwZW9mIFRyYW5zZm9ybUNvbnRleHQ+WydvblRyYW5zZm9ybSddO1xuICB9O1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHRcbiAgbGFuZz1cInRzXCJcbiAgZ2VuZXJpY3M9XCJURGF0YSA9IGFueSwgWFNjYWxlIGV4dGVuZHMgQW55U2NhbGUgPSBBbnlTY2FsZSwgWVNjYWxlIGV4dGVuZHMgQW55U2NhbGUgPSBBbnlTY2FsZVwiXG4+XG4gIGxldCB7XG4gICAgc3NyID0gZmFsc2UsXG4gICAgcG9pbnRlckV2ZW50cyA9IHRydWUsXG4gICAgcG9zaXRpb24gPSAncmVsYXRpdmUnLFxuICAgIHBlcmNlbnRSYW5nZSA9IGZhbHNlLFxuICAgIHJlZjogcmVmUHJvcCA9ICRiaW5kYWJsZSgpLFxuICAgIHg6IHhQcm9wLFxuICAgIHk6IHlQcm9wLFxuICAgIHo6IHpQcm9wLFxuICAgIHI6IHJQcm9wLFxuICAgIGRhdGEgPSBbXSxcbiAgICB4RG9tYWluOiB4RG9tYWluUHJvcCxcbiAgICB5RG9tYWluOiB5RG9tYWluUHJvcCxcbiAgICB6RG9tYWluOiB6RG9tYWluUHJvcCxcbiAgICByRG9tYWluOiByRG9tYWluUHJvcCxcbiAgICB4TmljZSA9IGZhbHNlLFxuICAgIHlOaWNlID0gZmFsc2UsXG4gICAgek5pY2UgPSBmYWxzZSxcbiAgICByTmljZSA9IGZhbHNlLFxuICAgIHhQYWRkaW5nLFxuICAgIHlQYWRkaW5nLFxuICAgIHpQYWRkaW5nLFxuICAgIHJQYWRkaW5nLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2hoXG4gICAgeFNjYWxlOiB4U2NhbGVQcm9wID0gc2NhbGVMaW5lYXIoKSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNoaFxuICAgIHlTY2FsZTogeVNjYWxlUHJvcCA9IHNjYWxlTGluZWFyKCksXG4gICAgelNjYWxlOiB6U2NhbGVQcm9wID0gc2NhbGVMaW5lYXIoKSxcbiAgICByU2NhbGU6IHJTY2FsZVByb3AgPSBzY2FsZVNxcnQoKSxcbiAgICBmbGF0RGF0YTogZmxhdERhdGFQcm9wLFxuICAgIHBhZGRpbmc6IHBhZGRpbmdQcm9wID0ge30sXG4gICAgdmVyYm9zZSA9IHRydWUsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBleHRlbnRzOiBleHRlbnRzUHJvcCA9IHt9LFxuICAgIHhEb21haW5Tb3J0ID0gZmFsc2UsXG4gICAgeURvbWFpblNvcnQgPSBmYWxzZSxcbiAgICB6RG9tYWluU29ydCA9IGZhbHNlLFxuICAgIHJEb21haW5Tb3J0ID0gZmFsc2UsXG4gICAgeFJldmVyc2UgPSBmYWxzZSxcbiAgICB6UmV2ZXJzZSA9IGZhbHNlLFxuICAgIHJSZXZlcnNlID0gZmFsc2UsXG4gICAgeVJhbmdlOiBfeVJhbmdlUHJvcCxcbiAgICB6UmFuZ2U6IHpSYW5nZVByb3AsXG4gICAgclJhbmdlOiByUmFuZ2VQcm9wLFxuICAgIHhCYXNlbGluZSA9IG51bGwsXG4gICAgeUJhc2VsaW5lID0gbnVsbCxcbiAgICBtZXRhID0ge30sXG4gICAgY2hpbGRyZW46IF9jaGlsZHJlbixcbiAgICByYWRpYWwgPSBmYWxzZSxcbiAgICB4UmFuZ2U6IF94UmFuZ2VQcm9wLFxuICAgIHgxOiB4MVByb3AsXG4gICAgeDFEb21haW46IHgxRG9tYWluUHJvcCxcbiAgICB4MVJhbmdlOiB4MVJhbmdlUHJvcCxcbiAgICB4MVNjYWxlOiB4MVNjYWxlUHJvcCxcbiAgICB5MTogeTFQcm9wLFxuICAgIHkxRG9tYWluOiB5MURvbWFpblByb3AsXG4gICAgeTFSYW5nZTogeTFSYW5nZVByb3AsXG4gICAgeTFTY2FsZTogeTFTY2FsZVByb3AsXG4gICAgYzogY1Byb3AsXG4gICAgY1NjYWxlOiBjU2NhbGVQcm9wLFxuICAgIGNEb21haW46IGNEb21haW5Qcm9wLFxuICAgIGNSYW5nZTogY1JhbmdlUHJvcCxcbiAgICBvblJlc2l6ZSxcbiAgICBnZW8sXG4gICAgY29udGV4dDogY29udGV4dFByb3AgPSAkYmluZGFibGUoKSxcbiAgICB0b29sdGlwLFxuICAgIHRyYW5zZm9ybSxcbiAgICBvblRyYW5zZm9ybSxcbiAgICBvbmRyYWdlbmQsXG4gICAgb25kcmFnc3RhcnQsXG4gICAgYnJ1c2gsXG4gIH06IENoYXJ0UHJvcHNXaXRob3V0SFRNTDxURGF0YSwgWFNjYWxlLCBZU2NhbGU+ID0gJHByb3BzKCk7XG5cbiAgbGV0IHJlZiA9ICRzdGF0ZTxIVE1MRWxlbWVudD4oKTtcblxuICAkZWZmZWN0LnByZSgoKSA9PiB7XG4gICAgcmVmUHJvcCA9IHJlZjtcbiAgfSk7XG5cbiAgY29uc3QgeFJhbmdlUHJvcCA9ICRkZXJpdmVkKF94UmFuZ2VQcm9wID8gX3hSYW5nZVByb3AgOiByYWRpYWwgPyBbMCwgMiAqIE1hdGguUEldIDogdW5kZWZpbmVkKTtcblxuICBsZXQgY29udGFpbmVyV2lkdGggPSAkc3RhdGUoMTAwKTtcbiAgbGV0IGNvbnRhaW5lckhlaWdodCA9ICRzdGF0ZSgxMDApO1xuXG4gIGNvbnN0IGxvZ0RlYnVnID0gdXNlRGVib3VuY2UocHJpbnREZWJ1ZywgMjAwKTtcblxuICBjb25zdCBfeERvbWFpbjogRG9tYWluVHlwZSB8IHVuZGVmaW5lZCA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICBpZiAoeERvbWFpblByb3AgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHhEb21haW5Qcm9wO1xuICAgIGlmICh4QmFzZWxpbmUgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBjb25zdCB4VmFsdWVzID0gZGF0YS5mbGF0TWFwKGFjY2Vzc29yKHhQcm9wKSk7XG4gICAgICByZXR1cm4gW21pbihbeEJhc2VsaW5lLCAuLi54VmFsdWVzXSksIG1heChbeEJhc2VsaW5lLCAuLi54VmFsdWVzXSldO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgX3lEb21haW46IERvbWFpblR5cGUgfCB1bmRlZmluZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgaWYgKHlEb21haW5Qcm9wICE9PSB1bmRlZmluZWQpIHJldHVybiB5RG9tYWluUHJvcDtcbiAgICBpZiAoeUJhc2VsaW5lICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgY29uc3QgeVZhbHVlcyA9IGRhdGEuZmxhdE1hcChhY2Nlc3Nvcih5UHJvcCkpO1xuICAgICAgcmV0dXJuIFttaW4oW3lCYXNlbGluZSwgLi4ueVZhbHVlc10pLCBtYXgoW3lCYXNlbGluZSwgLi4ueVZhbHVlc10pXTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHlSYW5nZVByb3AgPSAkZGVyaXZlZChcbiAgICBfeVJhbmdlUHJvcCA/PyAocmFkaWFsID8gKHsgaGVpZ2h0IH06IHsgaGVpZ2h0OiBudW1iZXIgfSkgPT4gWzAsIGhlaWdodCAvIDJdIDogdW5kZWZpbmVkKVxuICApO1xuXG4gIGNvbnN0IHlSZXZlcnNlID0gJGRlcml2ZWQoeVNjYWxlUHJvcCA/ICFpc1NjYWxlQmFuZCh5U2NhbGVQcm9wKSA6IHRydWUpO1xuXG4gIGNvbnN0IHggPSAkZGVyaXZlZChtYWtlQWNjZXNzb3IoeFByb3ApKTtcbiAgY29uc3QgeSA9ICRkZXJpdmVkKG1ha2VBY2Nlc3Nvcih5UHJvcCkpO1xuICBjb25zdCB6ID0gJGRlcml2ZWQobWFrZUFjY2Vzc29yKHpQcm9wKSk7XG4gIGNvbnN0IHIgPSAkZGVyaXZlZChtYWtlQWNjZXNzb3IoclByb3ApKTtcbiAgY29uc3QgYyA9ICRkZXJpdmVkKGFjY2Vzc29yKGNQcm9wKSk7XG4gIGNvbnN0IHgxID0gJGRlcml2ZWQoYWNjZXNzb3IoeDFQcm9wKSk7XG4gIGNvbnN0IHkxID0gJGRlcml2ZWQoYWNjZXNzb3IoeTFQcm9wKSk7XG5cbiAgY29uc3QgZmxhdERhdGEgPSAkZGVyaXZlZChmbGF0RGF0YVByb3AgPz8gZGF0YSkgYXMgVERhdGFbXTtcblxuICBjb25zdCBmaWx0ZXJlZEV4dGVudHMgPSAkZGVyaXZlZChmaWx0ZXJPYmplY3QoJHN0YXRlLnNuYXBzaG90KGV4dGVudHNQcm9wKSkpO1xuXG4gIGNvbnN0IGFjdGl2ZUdldHRlcnMgPSAkZGVyaXZlZCh7XG4gICAgeCxcbiAgICB5LFxuICAgIHosXG4gICAgcixcbiAgfSk7XG5cbiAgY29uc3QgcGFkZGluZyA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhZGRpbmdQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdFBhZGRpbmcsXG4gICAgICAgIHRvcDogcGFkZGluZ1Byb3AsXG4gICAgICAgIHJpZ2h0OiBwYWRkaW5nUHJvcCxcbiAgICAgICAgYm90dG9tOiBwYWRkaW5nUHJvcCxcbiAgICAgICAgbGVmdDogcGFkZGluZ1Byb3AsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5kZWZhdWx0UGFkZGluZywgLi4ucGFkZGluZ1Byb3AgfTtcbiAgfSk7XG5cbiAgbGV0IGlzTW91bnRlZCA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgYm94ID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgIGNvbnN0IHRvcCA9IHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IHJpZ2h0ID0gY29udGFpbmVyV2lkdGggLSBwYWRkaW5nLnJpZ2h0O1xuICAgIGNvbnN0IGJvdHRvbSA9IGNvbnRhaW5lckhlaWdodCAtIHBhZGRpbmcuYm90dG9tO1xuICAgIGNvbnN0IGxlZnQgPSBwYWRkaW5nLmxlZnQ7XG4gICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgIGlmICh2ZXJib3NlID09PSB0cnVlKSB7XG4gICAgICBpZiAod2lkdGggPD0gMCAmJiBpc01vdW50ZWQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbTGF5ZXJDaGFydF0gVGFyZ2V0IGRpdiBoYXMgemVybyBvciBuZWdhdGl2ZSB3aWR0aCAoJHt3aWR0aH0pLiBEaWQgeW91IGZvcmdldCB0byBzZXQgYW4gZXhwbGljaXQgd2lkdGggaW4gQ1NTIG9uIHRoZSBjb250YWluZXI/YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA8PSAwICYmIGlzTW91bnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtMYXllckNoYXJ0XSBUYXJnZXQgZGl2IGhhcyB6ZXJvIG9yIG5lZ2F0aXZlIGhlaWdodCAoJHtoZWlnaHR9KS4gRGlkIHlvdSBmb3JnZXQgdG8gc2V0IGFuIGV4cGxpY2l0IGhlaWdodCBpbiBDU1Mgb24gdGhlIGNvbnRhaW5lcj9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IHdpZHRoID0gJGRlcml2ZWQoYm94LndpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gJGRlcml2ZWQoYm94LmhlaWdodCk7XG5cbiAgaW50ZXJmYWNlIFNjYWxlRW50cnkge1xuICAgIHNjYWxlOiBBbnlTY2FsZTtcbiAgICBzb3J0PzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENhbGN1bGF0ZSBleHRlbnRzIGJ5IHRha2luZyB0aGUgZXh0ZW50IG9mIHRoZSBkYXRhXG4gICAqIGFuZCBmaWxsaW5nIHRoYXQgaW4gd2l0aCBhbnl0aGluZyBzZXQgYnkgdGhlIHVzZXJcbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gYW4gXCJleHRlbnRcIiBwYXNzZWRcbiAgICogaW4gYXMgYSBkb21haW4sIHdoaWNoIGNhbiBiZSBhIHBhcnRpYWwgZG9tYWluXG4gICAqL1xuICBjb25zdCBleHRlbnRzOiBFeHRlbnRzID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgIGNvbnN0IHNjYWxlTG9va3VwOiBSZWNvcmQ8c3RyaW5nLCBTY2FsZUVudHJ5PiA9IHtcbiAgICAgIHg6IHsgc2NhbGU6IHhTY2FsZVByb3AsIHNvcnQ6IHhEb21haW5Tb3J0IH0sXG4gICAgICB5OiB7IHNjYWxlOiB5U2NhbGVQcm9wLCBzb3J0OiB5RG9tYWluU29ydCB9LFxuICAgICAgejogeyBzY2FsZTogelNjYWxlUHJvcCwgc29ydDogekRvbWFpblNvcnQgfSxcbiAgICAgIHI6IHsgc2NhbGU6IHJTY2FsZVByb3AsIHNvcnQ6IHJEb21haW5Tb3J0IH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGdldHRlcnMgPSBmaWx0ZXJPYmplY3QoYWN0aXZlR2V0dGVycywgZmlsdGVyZWRFeHRlbnRzKTtcbiAgICBjb25zdCBhY3RpdmVTY2FsZXM6IFJlY29yZDxzdHJpbmcsIFNjYWxlRW50cnk+ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmtleXMoZ2V0dGVycykubWFwKChrKSA9PiBbaywgc2NhbGVMb29rdXBba11dKVxuICAgICk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoZ2V0dGVycykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2FsY3VsYXRlZEV4dGVudHMgPSBjYWxjU2NhbGVFeHRlbnRzKGZsYXREYXRhLCBnZXR0ZXJzLCBhY3RpdmVTY2FsZXMpO1xuICAgICAgcmV0dXJuIHsgLi4uY2FsY3VsYXRlZEV4dGVudHMsIC4uLmZpbHRlcmVkRXh0ZW50cyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB4RG9tYWluID0gJGRlcml2ZWQoY2FsY0RvbWFpbigneCcsIGV4dGVudHMsIF94RG9tYWluKSk7XG4gIGNvbnN0IHlEb21haW4gPSAkZGVyaXZlZChjYWxjRG9tYWluKCd5JywgZXh0ZW50cywgX3lEb21haW4pKTtcbiAgY29uc3QgekRvbWFpbiA9ICRkZXJpdmVkKGNhbGNEb21haW4oJ3onLCBleHRlbnRzLCB6RG9tYWluUHJvcCkpO1xuICBjb25zdCByRG9tYWluID0gJGRlcml2ZWQoY2FsY0RvbWFpbigncicsIGV4dGVudHMsIHJEb21haW5Qcm9wKSk7XG5cbiAgY29uc3QgeDFEb21haW4gPSAkZGVyaXZlZCh4MURvbWFpblByb3AgPz8gZXh0ZW50KGNoYXJ0RGF0YUFycmF5KGRhdGEpLCB4MSkpO1xuICBjb25zdCB5MURvbWFpbiA9ICRkZXJpdmVkKHkxRG9tYWluUHJvcCA/PyBleHRlbnQoY2hhcnREYXRhQXJyYXkoZGF0YSksIHkxKSk7XG4gIGNvbnN0IGNEb21haW4gPSAkZGVyaXZlZChjRG9tYWluUHJvcCA/PyB1bmlxdWUoY2hhcnREYXRhQXJyYXkoZGF0YSkubWFwKGMpKSk7XG5cbiAgY29uc3Qgc25hcHBlZFBhZGRpbmcgPSAkZGVyaXZlZCgkc3RhdGUuc25hcHNob3QoeFBhZGRpbmcpKTtcbiAgY29uc3Qgc25hcHBlZEV4dGVudHMgPSAkZGVyaXZlZCgkc3RhdGUuc25hcHNob3QoZXh0ZW50cykpO1xuXG4gIGNvbnN0IHhTY2FsZSA9ICRkZXJpdmVkKFxuICAgIGNyZWF0ZUNoYXJ0U2NhbGUoJ3gnLCB7XG4gICAgICBzY2FsZTogeFNjYWxlUHJvcCxcbiAgICAgIGRvbWFpbjogeERvbWFpbixcbiAgICAgIHBhZGRpbmc6IHNuYXBwZWRQYWRkaW5nLFxuICAgICAgbmljZTogeE5pY2UsXG4gICAgICByZXZlcnNlOiB4UmV2ZXJzZSxcbiAgICAgIHBlcmNlbnRSYW5nZSxcbiAgICAgIHJhbmdlOiB4UmFuZ2VQcm9wLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICBleHRlbnRzOiBzbmFwcGVkRXh0ZW50cyxcbiAgICB9KVxuICApO1xuXG4gIGNvbnN0IHhHZXQgPSAkZGVyaXZlZChjcmVhdGVHZXR0ZXIoeCwgeFNjYWxlKSk7XG5cbiAgY29uc3QgeVNjYWxlID0gJGRlcml2ZWQoXG4gICAgY3JlYXRlQ2hhcnRTY2FsZSgneScsIHtcbiAgICAgIHNjYWxlOiB5U2NhbGVQcm9wLFxuICAgICAgZG9tYWluOiB5RG9tYWluLFxuICAgICAgcGFkZGluZzogeVBhZGRpbmcsXG4gICAgICBuaWNlOiB5TmljZSxcbiAgICAgIHJldmVyc2U6IHlSZXZlcnNlLFxuICAgICAgcGVyY2VudFJhbmdlLFxuICAgICAgcmFuZ2U6IHlSYW5nZVByb3AsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGV4dGVudHM6IGZpbHRlcmVkRXh0ZW50cyxcbiAgICB9KVxuICApO1xuXG4gIGNvbnN0IHlHZXQgPSAkZGVyaXZlZChjcmVhdGVHZXR0ZXIoeSwgeVNjYWxlKSk7XG5cbiAgY29uc3QgelNjYWxlID0gJGRlcml2ZWQoXG4gICAgY3JlYXRlQ2hhcnRTY2FsZSgneicsIHtcbiAgICAgIHNjYWxlOiB6U2NhbGVQcm9wLFxuICAgICAgZG9tYWluOiB6RG9tYWluLFxuICAgICAgcGFkZGluZzogelBhZGRpbmcsXG4gICAgICBuaWNlOiB6TmljZSxcbiAgICAgIHJldmVyc2U6IHpSZXZlcnNlLFxuICAgICAgcGVyY2VudFJhbmdlLFxuICAgICAgcmFuZ2U6IHpSYW5nZVByb3AsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGV4dGVudHM6IGZpbHRlcmVkRXh0ZW50cyxcbiAgICB9KVxuICApO1xuICBjb25zdCB6R2V0ID0gJGRlcml2ZWQoY3JlYXRlR2V0dGVyKHosIHpTY2FsZSkpO1xuXG4gIGNvbnN0IHJTY2FsZSA9ICRkZXJpdmVkKFxuICAgIGNyZWF0ZUNoYXJ0U2NhbGUoJ3InLCB7XG4gICAgICBzY2FsZTogclNjYWxlUHJvcCxcbiAgICAgIGRvbWFpbjogckRvbWFpbixcbiAgICAgIHBhZGRpbmc6IHJQYWRkaW5nLFxuICAgICAgbmljZTogck5pY2UsXG4gICAgICByZXZlcnNlOiByUmV2ZXJzZSxcbiAgICAgIHBlcmNlbnRSYW5nZSxcbiAgICAgIHJhbmdlOiByUmFuZ2VQcm9wLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICBleHRlbnRzOiBmaWx0ZXJlZEV4dGVudHMsXG4gICAgfSlcbiAgKTtcblxuICBjb25zdCByR2V0ID0gJGRlcml2ZWQoY3JlYXRlR2V0dGVyKHIsIHJTY2FsZSkpO1xuXG4gIGNvbnN0IHgxU2NhbGUgPSAkZGVyaXZlZChcbiAgICB4MVNjYWxlUHJvcCAmJiB4MVJhbmdlUHJvcFxuICAgICAgPyBjcmVhdGVTY2FsZSh4MVNjYWxlUHJvcCwgeDFEb21haW4sIHgxUmFuZ2VQcm9wLCB7XG4gICAgICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9KVxuICAgICAgOiBudWxsXG4gICk7XG5cbiAgY29uc3QgeDFHZXQgPSAkZGVyaXZlZChjcmVhdGVHZXR0ZXIoeDEsIHgxU2NhbGUpKTtcblxuICBjb25zdCB5MVNjYWxlID0gJGRlcml2ZWQoXG4gICAgeTFTY2FsZVByb3AgJiYgeTFSYW5nZVByb3BcbiAgICAgID8gY3JlYXRlU2NhbGUoeTFTY2FsZVByb3AsIHkxRG9tYWluLCB5MVJhbmdlUHJvcCwge1xuICAgICAgICAgIHlTY2FsZTogeVNjYWxlLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfSlcbiAgICAgIDogbnVsbFxuICApO1xuXG4gIGNvbnN0IHkxR2V0ID0gJGRlcml2ZWQoY3JlYXRlR2V0dGVyKHkxLCB5MVNjYWxlKSk7XG5cbiAgY29uc3QgY1NjYWxlID0gJGRlcml2ZWQoXG4gICAgY1JhbmdlUHJvcFxuICAgICAgPyBjcmVhdGVTY2FsZShjU2NhbGVQcm9wID8/IHNjYWxlT3JkaW5hbCgpLCBjRG9tYWluLCBjUmFuZ2VQcm9wLCB7IHdpZHRoLCBoZWlnaHQgfSlcbiAgICAgIDogbnVsbFxuICApO1xuXG4gIGNvbnN0IGNHZXQgPSAkZGVyaXZlZCgoZDogYW55KSA9PiBjU2NhbGU/LihjKGQpKSk7XG5cbiAgY29uc3QgeERvbWFpblBvc3NpYmx5TmljZSA9ICRkZXJpdmVkKHhTY2FsZS5kb21haW4oKSk7XG4gIGNvbnN0IHlEb21haW5Qb3NzaWJseU5pY2UgPSAkZGVyaXZlZCh5U2NhbGUuZG9tYWluKCkpO1xuICBjb25zdCB6RG9tYWluUG9zc2libHlOaWNlID0gJGRlcml2ZWQoelNjYWxlLmRvbWFpbigpKTtcbiAgY29uc3QgckRvbWFpblBvc3NpYmx5TmljZSA9ICRkZXJpdmVkKHJTY2FsZS5kb21haW4oKSk7XG5cbiAgY29uc3QgeFJhbmdlID0gJGRlcml2ZWQoZ2V0UmFuZ2UoeFNjYWxlKSk7XG4gIGNvbnN0IHlSYW5nZSA9ICRkZXJpdmVkKGdldFJhbmdlKHlTY2FsZSkpO1xuICBjb25zdCB6UmFuZ2UgPSAkZGVyaXZlZChnZXRSYW5nZSh6U2NhbGUpKTtcbiAgY29uc3QgclJhbmdlID0gJGRlcml2ZWQoZ2V0UmFuZ2UoclNjYWxlKSk7XG5cbiAgY29uc3QgYXNwZWN0UmF0aW8gPSAkZGVyaXZlZCh3aWR0aCAvIGhlaWdodCk7XG5cbiAgY29uc3QgY29uZmlnOiBQcmVzZXJ2ZWRDaGFydENvbmZpZzxURGF0YSwgWFNjYWxlLCBZU2NhbGU+ID0gJGRlcml2ZWQoe1xuICAgIHg6IHhQcm9wLFxuICAgIHk6IHlQcm9wLFxuICAgIHo6IHpQcm9wLFxuICAgIHI6IHJQcm9wLFxuICAgIGM6IGNQcm9wLFxuICAgIHgxOiB4MVByb3AsXG4gICAgeTE6IHkxUHJvcCxcbiAgICB4RG9tYWluOiBfeERvbWFpbixcbiAgICB5RG9tYWluOiBfeURvbWFpbixcbiAgICB6RG9tYWluOiB6RG9tYWluUHJvcCxcbiAgICByRG9tYWluOiByRG9tYWluUHJvcCxcbiAgICB4MURvbWFpbjogeDFEb21haW5Qcm9wLFxuICAgIHkxRG9tYWluOiB5MURvbWFpblByb3AsXG4gICAgY0RvbWFpbjogY0RvbWFpblByb3AsXG4gICAgeFJhbmdlOiBfeFJhbmdlUHJvcCxcbiAgICB5UmFuZ2U6IF95UmFuZ2VQcm9wLFxuICAgIHpSYW5nZTogelJhbmdlUHJvcCxcbiAgICByUmFuZ2U6IHJSYW5nZVByb3AsXG4gICAgY1JhbmdlOiBjUmFuZ2VQcm9wLFxuICAgIHgxUmFuZ2U6IHgxUmFuZ2VQcm9wLFxuICAgIHkxUmFuZ2U6IHkxUmFuZ2VQcm9wLFxuICB9KTtcblxuICBsZXQgZ2VvQ29udGV4dCA9ICRzdGF0ZTxHZW9Db250ZXh0VmFsdWU+KG51bGwhKTtcbiAgbGV0IHRyYW5zZm9ybUNvbnRleHQgPSAkc3RhdGU8VHJhbnNmb3JtQ29udGV4dFZhbHVlPihudWxsISk7XG4gIGxldCB0b29sdGlwQ29udGV4dCA9ICRzdGF0ZTxUb29sdGlwQ29udGV4dFZhbHVlPihudWxsISk7XG4gIGxldCBicnVzaENvbnRleHQgPSAkc3RhdGU8QnJ1c2hDb250ZXh0VmFsdWU+KG51bGwhKTtcblxuICBjb25zdCBjb250ZXh0OiBDaGFydENvbnRleHRWYWx1ZTxURGF0YSwgWFNjYWxlLCBZU2NhbGU+ID0ge1xuICAgIGdldCBhY3RpdmVHZXR0ZXJzKCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUdldHRlcnM7XG4gICAgfSxcbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9LFxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG4gICAgZ2V0IHBlcmNlbnRSYW5nZSgpIHtcbiAgICAgIHJldHVybiBwZXJjZW50UmFuZ2U7XG4gICAgfSxcbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfSxcbiAgICBnZXQgY29udGFpbmVyV2lkdGgoKSB7XG4gICAgICByZXR1cm4gY29udGFpbmVyV2lkdGg7XG4gICAgfSxcbiAgICBnZXQgY29udGFpbmVySGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckhlaWdodDtcbiAgICB9LFxuICAgIGdldCB4KCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBnZXQgeSgpIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH0sXG4gICAgZ2V0IHooKSB7XG4gICAgICByZXR1cm4gejtcbiAgICB9LFxuICAgIGdldCByKCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBnZXQgYygpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgZ2V0IHgxKCkge1xuICAgICAgcmV0dXJuIHgxO1xuICAgIH0sXG4gICAgZ2V0IHkxKCkge1xuICAgICAgcmV0dXJuIHkxO1xuICAgIH0sXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIGdldCB4TmljZSgpIHtcbiAgICAgIHJldHVybiB4TmljZTtcbiAgICB9LFxuICAgIGdldCB5TmljZSgpIHtcbiAgICAgIHJldHVybiB5TmljZTtcbiAgICB9LFxuICAgIGdldCB6TmljZSgpIHtcbiAgICAgIHJldHVybiB6TmljZTtcbiAgICB9LFxuICAgIGdldCByTmljZSgpIHtcbiAgICAgIHJldHVybiByTmljZTtcbiAgICB9LFxuICAgIGdldCB4RG9tYWluU29ydCgpIHtcbiAgICAgIHJldHVybiB4RG9tYWluU29ydDtcbiAgICB9LFxuICAgIGdldCB5RG9tYWluU29ydCgpIHtcbiAgICAgIHJldHVybiB5RG9tYWluU29ydDtcbiAgICB9LFxuICAgIGdldCB6RG9tYWluU29ydCgpIHtcbiAgICAgIHJldHVybiB6RG9tYWluU29ydDtcbiAgICB9LFxuICAgIGdldCByRG9tYWluU29ydCgpIHtcbiAgICAgIHJldHVybiByRG9tYWluU29ydDtcbiAgICB9LFxuICAgIGdldCB4UmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiB4UmV2ZXJzZTtcbiAgICB9LFxuICAgIGdldCB5UmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiB5UmV2ZXJzZTtcbiAgICB9LFxuICAgIGdldCB6UmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiB6UmV2ZXJzZTtcbiAgICB9LFxuICAgIGdldCByUmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiByUmV2ZXJzZTtcbiAgICB9LFxuICAgIGdldCB4UGFkZGluZygpIHtcbiAgICAgIHJldHVybiB4UGFkZGluZztcbiAgICB9LFxuICAgIGdldCB5UGFkZGluZygpIHtcbiAgICAgIHJldHVybiB5UGFkZGluZztcbiAgICB9LFxuICAgIGdldCB6UGFkZGluZygpIHtcbiAgICAgIHJldHVybiB6UGFkZGluZztcbiAgICB9LFxuICAgIGdldCByUGFkZGluZygpIHtcbiAgICAgIHJldHVybiByUGFkZGluZztcbiAgICB9LFxuICAgIGdldCBwYWRkaW5nKCkge1xuICAgICAgcmV0dXJuIHBhZGRpbmc7XG4gICAgfSxcbiAgICBnZXQgZmxhdERhdGEoKSB7XG4gICAgICByZXR1cm4gZmxhdERhdGE7XG4gICAgfSxcbiAgICBnZXQgZXh0ZW50cygpIHtcbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH0sXG4gICAgZ2V0IHhEb21haW4oKSB7XG4gICAgICByZXR1cm4geERvbWFpblBvc3NpYmx5TmljZTtcbiAgICB9LFxuICAgIGdldCB5RG9tYWluKCkge1xuICAgICAgcmV0dXJuIHlEb21haW5Qb3NzaWJseU5pY2U7XG4gICAgfSxcbiAgICBnZXQgekRvbWFpbigpIHtcbiAgICAgIHJldHVybiB6RG9tYWluUG9zc2libHlOaWNlO1xuICAgIH0sXG4gICAgZ2V0IHJEb21haW4oKSB7XG4gICAgICByZXR1cm4gckRvbWFpblBvc3NpYmx5TmljZTtcbiAgICB9LFxuICAgIGdldCBjRG9tYWluKCkge1xuICAgICAgcmV0dXJuIGNEb21haW47XG4gICAgfSxcbiAgICBnZXQgeDFEb21haW4oKSB7XG4gICAgICByZXR1cm4geDFEb21haW47XG4gICAgfSxcbiAgICBnZXQgeTFEb21haW4oKSB7XG4gICAgICByZXR1cm4geTFEb21haW47XG4gICAgfSxcbiAgICBnZXQgeFJhbmdlKCkge1xuICAgICAgcmV0dXJuIHhSYW5nZTtcbiAgICB9LFxuICAgIGdldCB5UmFuZ2UoKSB7XG4gICAgICByZXR1cm4geVJhbmdlO1xuICAgIH0sXG4gICAgZ2V0IHpSYW5nZSgpIHtcbiAgICAgIHJldHVybiB6UmFuZ2U7XG4gICAgfSxcbiAgICBnZXQgclJhbmdlKCkge1xuICAgICAgcmV0dXJuIHJSYW5nZTtcbiAgICB9LFxuICAgIGdldCBjUmFuZ2UoKSB7XG4gICAgICByZXR1cm4gY1JhbmdlUHJvcDtcbiAgICB9LFxuICAgIGdldCB4MVJhbmdlKCkge1xuICAgICAgcmV0dXJuIHgxUmFuZ2VQcm9wO1xuICAgIH0sXG4gICAgZ2V0IHkxUmFuZ2UoKSB7XG4gICAgICByZXR1cm4geTFSYW5nZVByb3A7XG4gICAgfSxcbiAgICBnZXQgbWV0YSgpIHtcbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH0sXG4gICAgc2V0IG1ldGEodjogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgbWV0YSA9IHY7XG4gICAgfSxcbiAgICBnZXQgeFNjYWxlKCkge1xuICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICB9LFxuICAgIGdldCB5U2NhbGUoKSB7XG4gICAgICByZXR1cm4geVNjYWxlO1xuICAgIH0sXG4gICAgZ2V0IHpTY2FsZSgpIHtcbiAgICAgIHJldHVybiB6U2NhbGU7XG4gICAgfSxcbiAgICBnZXQgclNjYWxlKCkge1xuICAgICAgcmV0dXJuIHJTY2FsZTtcbiAgICB9LFxuICAgIGdldCB5R2V0KCkge1xuICAgICAgcmV0dXJuIHlHZXQ7XG4gICAgfSxcbiAgICBnZXQgeEdldCgpIHtcbiAgICAgIHJldHVybiB4R2V0O1xuICAgIH0sXG4gICAgZ2V0IHpHZXQoKSB7XG4gICAgICByZXR1cm4gekdldDtcbiAgICB9LFxuICAgIGdldCByR2V0KCkge1xuICAgICAgcmV0dXJuIHJHZXQ7XG4gICAgfSxcbiAgICBnZXQgY0dldCgpIHtcbiAgICAgIHJldHVybiBjR2V0O1xuICAgIH0sXG4gICAgZ2V0IHgxR2V0KCkge1xuICAgICAgcmV0dXJuIHgxR2V0O1xuICAgIH0sXG4gICAgZ2V0IHkxR2V0KCkge1xuICAgICAgcmV0dXJuIHkxR2V0O1xuICAgIH0sXG4gICAgZ2V0IGNTY2FsZSgpIHtcbiAgICAgIHJldHVybiBjU2NhbGU7XG4gICAgfSxcbiAgICBnZXQgeDFTY2FsZSgpIHtcbiAgICAgIHJldHVybiB4MVNjYWxlO1xuICAgIH0sXG4gICAgZ2V0IHkxU2NhbGUoKSB7XG4gICAgICByZXR1cm4geTFTY2FsZTtcbiAgICB9LFxuICAgIGdldCByYWRpYWwoKSB7XG4gICAgICByZXR1cm4gcmFkaWFsO1xuICAgIH0sXG4gICAgZ2V0IGNvbnRhaW5lclJlZigpIHtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSxcbiAgICBnZXQgZ2VvKCkge1xuICAgICAgcmV0dXJuIGdlb0NvbnRleHQ7XG4gICAgfSxcbiAgICBnZXQgdHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUNvbnRleHQ7XG4gICAgfSxcbiAgICBnZXQgdG9vbHRpcCgpIHtcbiAgICAgIHJldHVybiB0b29sdGlwQ29udGV4dDtcbiAgICB9LFxuICAgIGdldCBicnVzaCgpIHtcbiAgICAgIHJldHVybiBicnVzaENvbnRleHQ7XG4gICAgfSxcbiAgfTtcblxuICBjb250ZXh0UHJvcCA9IGNvbnRleHQ7XG5cbiAgc2V0Q2hhcnRDb250ZXh0KGNvbnRleHQpO1xuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGlmIChib3ggJiYgZGVidWcgPT09IHRydWUgJiYgKHNzciA9PT0gdHJ1ZSB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgIGxvZ0RlYnVnKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZmxhdERhdGE6IHR5cGVvZiBmbGF0RGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBmbGF0RGF0YSA6IG51bGwsXG4gICAgICAgIGJvdW5kaW5nQm94OiBib3gsXG4gICAgICAgIGFjdGl2ZUdldHRlcnMsXG4gICAgICAgIHg6IHhQcm9wLFxuICAgICAgICB5OiB5UHJvcCxcbiAgICAgICAgejogelByb3AsXG4gICAgICAgIHI6IHJQcm9wLFxuICAgICAgICB4U2NhbGUsXG4gICAgICAgIHlTY2FsZSxcbiAgICAgICAgelNjYWxlLFxuICAgICAgICByU2NhbGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNNb3VudGVkKSByZXR1cm47XG4gICAgb25SZXNpemU/Lih7XG4gICAgICB3aWR0aDogY29udGV4dC53aWR0aCxcbiAgICAgIGhlaWdodDogY29udGV4dC5oZWlnaHQsXG4gICAgICBjb250YWluZXJXaWR0aDogY29udGV4dC5jb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodDogY29udGV4dC5jb250YWluZXJIZWlnaHQsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGluaXRpYWxUcmFuc2Zvcm0gPSAkZGVyaXZlZChcbiAgICBnZW8/LmFwcGx5VHJhbnNmb3JtPy5pbmNsdWRlcygndHJhbnNsYXRlJykgJiYgZ2VvPy5maXRHZW9qc29uICYmIGdlbz8ucHJvamVjdGlvblxuICAgICAgPyBnZW9GaXRPYmplY3RUcmFuc2Zvcm0oZ2VvLnByb2plY3Rpb24oKSwgW3dpZHRoLCBoZWlnaHRdLCBnZW8uZml0R2VvanNvbilcbiAgICAgIDogdW5kZWZpbmVkXG4gICk7XG5cbiAgY29uc3QgcHJvY2Vzc1RyYW5zbGF0ZSA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICBpZiAoIWdlbykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHg6IG51bWJlciwgeTogbnVtYmVyLCBkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChnZW8uYXBwbHlUcmFuc2Zvcm0/LmluY2x1ZGVzKCdyb3RhdGUnKSAmJiBnZW9Db250ZXh0Py5wcm9qZWN0aW9uKSB7XG4gICAgICAgIC8vIFdoZW4gYXBwbHlpbmcgdHJhbnNmb3JtIHRvIHJvdGF0ZSwgaW52ZXJ0IGB5YCB2YWx1ZXMgYW5kIHJlZHVjZSBzZW5zaXRpdml0eSBiYXNlZCBvbiBwcm9qZWN0aW9uIHNjYWxlXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BiZW5vbGRlbmJ1cmcvc2ltcGxlLWdsb2JlIGFuZCBodHRwczovL29ic2VydmFibGVocS5jb20vQG1pY2hhZWwta2VpdGgvZHJhZ2dhYmxlLWdsb2JlLWluLWQzXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25TY2FsZSA9IGdlb0NvbnRleHQucHJvamVjdGlvbi5zY2FsZSgpID8/IDA7XG4gICAgICAgIGNvbnN0IHNlbnNpdGl2aXR5ID0gNzU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCArIGRlbHRhWCAqIChzZW5zaXRpdml0eSAvIHByb2plY3Rpb25TY2FsZSksXG4gICAgICAgICAgeTogeSArIGRlbHRhWSAqIChzZW5zaXRpdml0eSAvIHByb2plY3Rpb25TY2FsZSkgKiAtMSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IGRlZmF1bHQgVHJhbnNmb3JtQ29udGV4dC5wcm9jZXNzVHJhbnNmb3JtIChwYXNzaW5nIGB1bmRlZmluZWRgIGJlbG93IGFwcGVhcnMgdG8gbm90IHdvcmsgd2hlbiBjaGVja2luZyBmb3IgYGdlbz8uYXBwbHlUcmFuc2Zvcm1gIGV4aXN0cylcbiAgICAgICAgcmV0dXJuIHsgeDogeCArIGRlbHRhWCwgeTogeSArIGRlbHRhWSB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IGJydXNoUHJvcHMgPSAkZGVyaXZlZCh0eXBlb2YgYnJ1c2ggPT09ICdvYmplY3QnID8gYnJ1c2ggOiB7IGRpc2FibGVkOiAhYnJ1c2ggfSk7XG4gIGNvbnN0IHRvb2x0aXBQcm9wcyA9ICRkZXJpdmVkKHR5cGVvZiB0b29sdGlwID09PSAnb2JqZWN0JyA/IHRvb2x0aXAgOiB7fSk7XG48L3NjcmlwdD5cblxueyNpZiBzc3IgPT09IHRydWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCd9XG4gIDxkaXZcbiAgICBiaW5kOnRoaXM9e3JlZn1cbiAgICBzdHlsZTpwb3NpdGlvblxuICAgIHN0eWxlOnRvcD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuICAgIHN0eWxlOnJpZ2h0PXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG4gICAgc3R5bGU6Ym90dG9tPXtwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyA/ICcwJyA6IG51bGx9XG4gICAgc3R5bGU6bGVmdD17cG9zaXRpb24gPT09ICdhYnNvbHV0ZScgPyAnMCcgOiBudWxsfVxuICAgIHN0eWxlOnBvaW50ZXItZXZlbnRzPXtwb2ludGVyRXZlbnRzID09PSBmYWxzZSA/ICdub25lJyA6IG51bGx9XG4gICAgYmluZDpjbGllbnRXaWR0aD17Y29udGFpbmVyV2lkdGh9XG4gICAgYmluZDpjbGllbnRIZWlnaHQ9e2NvbnRhaW5lckhlaWdodH1cbiAgICBjbGFzcz17bGF5ZXJDbGFzcygncm9vdC1jb250YWluZXInKX1cbiAgPlxuICAgIHsja2V5IGlzTW91bnRlZH1cbiAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nIC0tPlxuICAgICAgPFRyYW5zZm9ybUNvbnRleHRcbiAgICAgICAgYmluZDp0cmFuc2Zvcm1Db250ZXh0XG4gICAgICAgIG1vZGU9eyh0cmFuc2Zvcm0/Lm1vZGUgPz8gZ2VvPy5hcHBseVRyYW5zZm9ybT8ubGVuZ3RoKSA/ICdtYW51YWwnIDogJ25vbmUnfVxuICAgICAgICBpbml0aWFsVHJhbnNsYXRlPXtpbml0aWFsVHJhbnNmb3JtPy50cmFuc2xhdGV9XG4gICAgICAgIGluaXRpYWxTY2FsZT17aW5pdGlhbFRyYW5zZm9ybT8uc2NhbGV9XG4gICAgICAgIHtwcm9jZXNzVHJhbnNsYXRlfVxuICAgICAgICB7Li4udHJhbnNmb3JtfVxuICAgICAgICB7b25kcmFnc3RhcnR9XG4gICAgICAgIHtvblRyYW5zZm9ybX1cbiAgICAgICAge29uZHJhZ2VuZH1cbiAgICAgID5cbiAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcgLS0+XG4gICAgICAgIDxHZW9Db250ZXh0IHsuLi5nZW99IGJpbmQ6Z2VvQ29udGV4dD5cbiAgICAgICAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgb3duZXJzaGlwX2ludmFsaWRfYmluZGluZyAtLT5cbiAgICAgICAgICA8QnJ1c2hDb250ZXh0IHsuLi5icnVzaFByb3BzfSBiaW5kOmJydXNoQ29udGV4dD5cbiAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nIC0tPlxuICAgICAgICAgICAgPFRvb2x0aXBDb250ZXh0IHsuLi50b29sdGlwUHJvcHN9IGJpbmQ6dG9vbHRpcENvbnRleHQ+XG4gICAgICAgICAgICAgIHtAcmVuZGVyIF9jaGlsZHJlbj8uKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvVG9vbHRpcENvbnRleHQ+XG4gICAgICAgICAgPC9CcnVzaENvbnRleHQ+XG4gICAgICAgIDwvR2VvQ29udGV4dD5cbiAgICAgIDwvVHJhbnNmb3JtQ29udGV4dD5cbiAgICB7L2tleX1cbiAgPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gIC5sYy1yb290LWNvbnRhaW5lcixcbiAgLmxjLXJvb3QtY29udGFpbmVyIDpnbG9iYWwoKikge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbiAgLmxjLXJvb3QtY29udGFpbmVyIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Chart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Chart);
  append_styles($$anchor, $$css);
  let ssr = prop($$props, "ssr", 3, false), pointerEvents = prop($$props, "pointerEvents", 3, true), position = prop($$props, "position", 3, "relative"), percentRange = prop($$props, "percentRange", 3, false), refProp = prop($$props, "ref", 15), data = prop($$props, "data", 19, () => []), xNice = prop($$props, "xNice", 3, false), yNice = prop($$props, "yNice", 3, false), zNice = prop($$props, "zNice", 3, false), rNice = prop($$props, "rNice", 3, false), xScaleProp = prop($$props, "xScale", 19, linear2), yScaleProp = prop($$props, "yScale", 19, linear2), zScaleProp = prop($$props, "zScale", 19, linear2), rScaleProp = prop($$props, "rScale", 19, sqrt2), paddingProp = prop($$props, "padding", 19, () => ({})), verbose = prop($$props, "verbose", 3, true), debug = prop($$props, "debug", 3, false), extentsProp = prop($$props, "extents", 19, () => ({})), xDomainSort = prop($$props, "xDomainSort", 3, false), yDomainSort = prop($$props, "yDomainSort", 3, false), zDomainSort = prop($$props, "zDomainSort", 3, false), rDomainSort = prop($$props, "rDomainSort", 3, false), xReverse = prop($$props, "xReverse", 3, false), zReverse = prop($$props, "zReverse", 3, false), rReverse = prop($$props, "rReverse", 3, false), xBaseline = prop($$props, "xBaseline", 3, null), yBaseline = prop($$props, "yBaseline", 3, null), meta = prop($$props, "meta", 23, () => ({})), radial2 = prop($$props, "radial", 3, false), contextProp = prop($$props, "context", 15);
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const xRangeProp = tag(
    user_derived(() => $$props.xRange ? $$props.xRange : radial2() ? [0, 2 * Math.PI] : void 0),
    "xRangeProp"
  );
  let containerWidth = tag(state(100), "containerWidth");
  let containerHeight = tag(state(100), "containerHeight");
  const logDebug = useDebounce(printDebug, 200);
  const _xDomain = tag(
    user_derived(() => {
      if (strict_equals($$props.xDomain, void 0, false)) return $$props.xDomain;
      if (equals(xBaseline(), null, false) && Array.isArray(data())) {
        const xValues = data().flatMap(accessor($$props.x));
        return [
          min([xBaseline(), ...xValues]),
          max([xBaseline(), ...xValues])
        ];
      }
    }),
    "_xDomain"
  );
  const _yDomain = tag(
    user_derived(() => {
      if (strict_equals($$props.yDomain, void 0, false)) return $$props.yDomain;
      if (equals(yBaseline(), null, false) && Array.isArray(data())) {
        const yValues = data().flatMap(accessor($$props.y));
        return [
          min([yBaseline(), ...yValues]),
          max([yBaseline(), ...yValues])
        ];
      }
    }),
    "_yDomain"
  );
  const yRangeProp = tag(user_derived(() => $$props.yRange ?? (radial2() ? ({ height: height2 }) => [0, height2 / 2] : void 0)), "yRangeProp");
  const yReverse = tag(user_derived(() => yScaleProp() ? !isScaleBand(yScaleProp()) : true), "yReverse");
  const x4 = tag(user_derived(() => makeAccessor($$props.x)), "x");
  const y4 = tag(user_derived(() => makeAccessor($$props.y)), "y");
  const z = tag(user_derived(() => makeAccessor($$props.z)), "z");
  const r = tag(user_derived(() => makeAccessor($$props.r)), "r");
  const c3 = tag(user_derived(() => accessor($$props.c)), "c");
  const x12 = tag(user_derived(() => accessor($$props.x1)), "x1");
  const y12 = tag(user_derived(() => accessor($$props.y1)), "y1");
  const flatData = tag(user_derived(() => $$props.flatData ?? data()), "flatData");
  const filteredExtents = tag(user_derived(() => filterObject(snapshot(extentsProp()))), "filteredExtents");
  const activeGetters = tag(user_derived(() => ({ x: get(x4), y: get(y4), z: get(z), r: get(r) })), "activeGetters");
  const padding = tag(
    user_derived(() => {
      if (strict_equals(typeof paddingProp(), "number")) {
        return {
          ...defaultPadding,
          top: paddingProp(),
          right: paddingProp(),
          bottom: paddingProp(),
          left: paddingProp()
        };
      }
      return { ...defaultPadding, ...paddingProp() };
    }),
    "padding"
  );
  let isMounted = tag(state(false), "isMounted");
  const box = tag(
    user_derived(() => {
      const top = get(padding).top;
      const right2 = get(containerWidth) - get(padding).right;
      const bottom = get(containerHeight) - get(padding).bottom;
      const left2 = get(padding).left;
      const width2 = right2 - left2;
      const height2 = bottom - top;
      if (strict_equals(verbose(), true)) {
        if (width2 <= 0 && strict_equals(get(isMounted), true)) {
          console.warn(`[LayerChart] Target div has zero or negative width (${width2}). Did you forget to set an explicit width in CSS on the container?`);
        }
        if (height2 <= 0 && strict_equals(get(isMounted), true)) {
          console.warn(`[LayerChart] Target div has zero or negative height (${height2}). Did you forget to set an explicit height in CSS on the container?`);
        }
      }
      return { top, left: left2, bottom, right: right2, width: width2, height: height2 };
    }),
    "box"
  );
  const width = tag(user_derived(() => get(box).width), "width");
  const height = tag(user_derived(() => get(box).height), "height");
  const extents = tag(
    user_derived(() => {
      const scaleLookup = {
        x: { scale: xScaleProp(), sort: xDomainSort() },
        y: { scale: yScaleProp(), sort: yDomainSort() },
        z: { scale: zScaleProp(), sort: zDomainSort() },
        r: { scale: rScaleProp(), sort: rDomainSort() }
      };
      const getters = filterObject(get(activeGetters), get(filteredExtents));
      const activeScales = Object.fromEntries(Object.keys(getters).map((k3) => [k3, scaleLookup[k3]]));
      if (Object.keys(getters).length > 0) {
        const calculatedExtents = calcScaleExtents(get(flatData), getters, activeScales);
        return { ...calculatedExtents, ...get(filteredExtents) };
      } else {
        return {};
      }
    }),
    "extents"
  );
  const xDomain = tag(user_derived(() => calcDomain("x", get(extents), get(_xDomain))), "xDomain");
  const yDomain = tag(user_derived(() => calcDomain("y", get(extents), get(_yDomain))), "yDomain");
  const zDomain = tag(user_derived(() => calcDomain("z", get(extents), $$props.zDomain)), "zDomain");
  const rDomain = tag(user_derived(() => calcDomain("r", get(extents), $$props.rDomain)), "rDomain");
  const x1Domain = tag(user_derived(() => $$props.x1Domain ?? extent(chartDataArray(data()), get(x12))), "x1Domain");
  const y1Domain = tag(user_derived(() => $$props.y1Domain ?? extent(chartDataArray(data()), get(y12))), "y1Domain");
  const cDomain = tag(user_derived(() => $$props.cDomain ?? unique2(chartDataArray(data()).map(get(c3)))), "cDomain");
  const snappedPadding = tag(user_derived(() => snapshot($$props.xPadding)), "snappedPadding");
  const snappedExtents = tag(user_derived(() => snapshot(get(extents))), "snappedExtents");
  const xScale = tag(
    user_derived(() => createChartScale("x", {
      scale: xScaleProp(),
      domain: get(xDomain),
      padding: get(snappedPadding),
      nice: xNice(),
      reverse: xReverse(),
      percentRange: percentRange(),
      range: get(xRangeProp),
      height: get(height),
      width: get(width),
      extents: get(snappedExtents)
    })),
    "xScale"
  );
  const xGet = tag(user_derived(() => createGetter(get(x4), get(xScale))), "xGet");
  const yScale = tag(
    user_derived(() => createChartScale("y", {
      scale: yScaleProp(),
      domain: get(yDomain),
      padding: $$props.yPadding,
      nice: yNice(),
      reverse: get(yReverse),
      percentRange: percentRange(),
      range: get(yRangeProp),
      height: get(height),
      width: get(width),
      extents: get(filteredExtents)
    })),
    "yScale"
  );
  const yGet = tag(user_derived(() => createGetter(get(y4), get(yScale))), "yGet");
  const zScale = tag(
    user_derived(() => createChartScale("z", {
      scale: zScaleProp(),
      domain: get(zDomain),
      padding: $$props.zPadding,
      nice: zNice(),
      reverse: zReverse(),
      percentRange: percentRange(),
      range: $$props.zRange,
      height: get(height),
      width: get(width),
      extents: get(filteredExtents)
    })),
    "zScale"
  );
  const zGet = tag(user_derived(() => createGetter(get(z), get(zScale))), "zGet");
  const rScale = tag(
    user_derived(() => createChartScale("r", {
      scale: rScaleProp(),
      domain: get(rDomain),
      padding: $$props.rPadding,
      nice: rNice(),
      reverse: rReverse(),
      percentRange: percentRange(),
      range: $$props.rRange,
      height: get(height),
      width: get(width),
      extents: get(filteredExtents)
    })),
    "rScale"
  );
  const rGet = tag(user_derived(() => createGetter(get(r), get(rScale))), "rGet");
  const x1Scale = tag(
    user_derived(() => $$props.x1Scale && $$props.x1Range ? createScale($$props.x1Scale, get(x1Domain), $$props.x1Range, {
      xScale: get(xScale),
      width: get(width),
      height: get(height)
    }) : null),
    "x1Scale"
  );
  const x1Get = tag(user_derived(() => createGetter(get(x12), get(x1Scale))), "x1Get");
  const y1Scale = tag(
    user_derived(() => $$props.y1Scale && $$props.y1Range ? createScale($$props.y1Scale, get(y1Domain), $$props.y1Range, {
      yScale: get(yScale),
      width: get(width),
      height: get(height)
    }) : null),
    "y1Scale"
  );
  const y1Get = tag(user_derived(() => createGetter(get(y12), get(y1Scale))), "y1Get");
  const cScale = tag(
    user_derived(() => $$props.cRange ? createScale($$props.cScale ?? ordinal(), get(cDomain), $$props.cRange, { width: get(width), height: get(height) }) : null),
    "cScale"
  );
  const cGet = tag(user_derived(() => (d) => get(cScale)?.(get(c3)(d))), "cGet");
  const xDomainPossiblyNice = tag(user_derived(() => get(xScale).domain()), "xDomainPossiblyNice");
  const yDomainPossiblyNice = tag(user_derived(() => get(yScale).domain()), "yDomainPossiblyNice");
  const zDomainPossiblyNice = tag(user_derived(() => get(zScale).domain()), "zDomainPossiblyNice");
  const rDomainPossiblyNice = tag(user_derived(() => get(rScale).domain()), "rDomainPossiblyNice");
  const xRange = tag(user_derived(() => getRange(get(xScale))), "xRange");
  const yRange = tag(user_derived(() => getRange(get(yScale))), "yRange");
  const zRange = tag(user_derived(() => getRange(get(zScale))), "zRange");
  const rRange = tag(user_derived(() => getRange(get(rScale))), "rRange");
  const aspectRatio = tag(user_derived(() => get(width) / get(height)), "aspectRatio");
  const config = tag(
    user_derived(() => ({
      x: $$props.x,
      y: $$props.y,
      z: $$props.z,
      r: $$props.r,
      c: $$props.c,
      x1: $$props.x1,
      y1: $$props.y1,
      xDomain: get(_xDomain),
      yDomain: get(_yDomain),
      zDomain: $$props.zDomain,
      rDomain: $$props.rDomain,
      x1Domain: $$props.x1Domain,
      y1Domain: $$props.y1Domain,
      cDomain: $$props.cDomain,
      xRange: $$props.xRange,
      yRange: $$props.yRange,
      zRange: $$props.zRange,
      rRange: $$props.rRange,
      cRange: $$props.cRange,
      x1Range: $$props.x1Range,
      y1Range: $$props.y1Range
    })),
    "config"
  );
  let geoContext = tag(state(null), "geoContext");
  let transformContext = tag(state(null), "transformContext");
  let tooltipContext = tag(state(null), "tooltipContext");
  let brushContext = tag(state(null), "brushContext");
  const context = {
    get activeGetters() {
      return get(activeGetters);
    },
    get config() {
      return get(config);
    },
    get width() {
      return get(width);
    },
    get height() {
      return get(height);
    },
    get percentRange() {
      return percentRange();
    },
    get aspectRatio() {
      return get(aspectRatio);
    },
    get containerWidth() {
      return get(containerWidth);
    },
    get containerHeight() {
      return get(containerHeight);
    },
    get x() {
      return get(x4);
    },
    get y() {
      return get(y4);
    },
    get z() {
      return get(z);
    },
    get r() {
      return get(r);
    },
    get c() {
      return get(c3);
    },
    get x1() {
      return get(x12);
    },
    get y1() {
      return get(y12);
    },
    get data() {
      return data();
    },
    get xNice() {
      return xNice();
    },
    get yNice() {
      return yNice();
    },
    get zNice() {
      return zNice();
    },
    get rNice() {
      return rNice();
    },
    get xDomainSort() {
      return xDomainSort();
    },
    get yDomainSort() {
      return yDomainSort();
    },
    get zDomainSort() {
      return zDomainSort();
    },
    get rDomainSort() {
      return rDomainSort();
    },
    get xReverse() {
      return xReverse();
    },
    get yReverse() {
      return get(yReverse);
    },
    get zReverse() {
      return zReverse();
    },
    get rReverse() {
      return rReverse();
    },
    get xPadding() {
      return $$props.xPadding;
    },
    get yPadding() {
      return $$props.yPadding;
    },
    get zPadding() {
      return $$props.zPadding;
    },
    get rPadding() {
      return $$props.rPadding;
    },
    get padding() {
      return get(padding);
    },
    get flatData() {
      return get(flatData);
    },
    get extents() {
      return get(extents);
    },
    get xDomain() {
      return get(xDomainPossiblyNice);
    },
    get yDomain() {
      return get(yDomainPossiblyNice);
    },
    get zDomain() {
      return get(zDomainPossiblyNice);
    },
    get rDomain() {
      return get(rDomainPossiblyNice);
    },
    get cDomain() {
      return get(cDomain);
    },
    get x1Domain() {
      return get(x1Domain);
    },
    get y1Domain() {
      return get(y1Domain);
    },
    get xRange() {
      return get(xRange);
    },
    get yRange() {
      return get(yRange);
    },
    get zRange() {
      return get(zRange);
    },
    get rRange() {
      return get(rRange);
    },
    get cRange() {
      return $$props.cRange;
    },
    get x1Range() {
      return $$props.x1Range;
    },
    get y1Range() {
      return $$props.y1Range;
    },
    get meta() {
      return meta();
    },
    set meta(v2) {
      meta(v2);
    },
    get xScale() {
      return get(xScale);
    },
    get yScale() {
      return get(yScale);
    },
    get zScale() {
      return get(zScale);
    },
    get rScale() {
      return get(rScale);
    },
    get yGet() {
      return get(yGet);
    },
    get xGet() {
      return get(xGet);
    },
    get zGet() {
      return get(zGet);
    },
    get rGet() {
      return get(rGet);
    },
    get cGet() {
      return get(cGet);
    },
    get x1Get() {
      return get(x1Get);
    },
    get y1Get() {
      return get(y1Get);
    },
    get cScale() {
      return get(cScale);
    },
    get x1Scale() {
      return get(x1Scale);
    },
    get y1Scale() {
      return get(y1Scale);
    },
    get radial() {
      return radial2();
    },
    get containerRef() {
      return get(ref);
    },
    get geo() {
      return get(geoContext);
    },
    get transform() {
      return get(transformContext);
    },
    get tooltip() {
      return get(tooltipContext);
    },
    get brush() {
      return get(brushContext);
    }
  };
  contextProp(context);
  setChartContext(context);
  user_effect(() => {
    set(isMounted, true);
  });
  onMount(() => {
    if (get(box) && strict_equals(debug(), true) && (strict_equals(ssr(), true) || strict_equals(typeof window, "undefined", false))) {
      logDebug({
        data: data(),
        flatData: strict_equals(typeof get(flatData), "undefined", false) ? get(flatData) : null,
        boundingBox: get(box),
        activeGetters: get(activeGetters),
        x: $$props.x,
        y: $$props.y,
        z: $$props.z,
        r: $$props.r,
        xScale: get(xScale),
        yScale: get(yScale),
        zScale: get(zScale),
        rScale: get(rScale)
      });
    }
  });
  user_effect(() => {
    if (!get(isMounted)) return;
    $$props.onResize?.({
      width: context.width,
      height: context.height,
      containerWidth: context.containerWidth,
      containerHeight: context.containerHeight
    });
  });
  const initialTransform = tag(
    user_derived(() => $$props.geo?.applyTransform?.includes("translate") && $$props.geo?.fitGeojson && $$props.geo?.projection ? geoFitObjectTransform($$props.geo.projection(), [get(width), get(height)], $$props.geo.fitGeojson) : void 0),
    "initialTransform"
  );
  const processTranslate = tag(
    user_derived(() => {
      if (!$$props.geo) return void 0;
      return (x5, y5, deltaX, deltaY) => {
        if ($$props.geo.applyTransform?.includes("rotate") && get(geoContext)?.projection) {
          const projectionScale = get(geoContext).projection.scale() ?? 0;
          const sensitivity = 75;
          return {
            x: x5 + deltaX * (sensitivity / projectionScale),
            y: y5 + deltaY * (sensitivity / projectionScale) * -1
          };
        } else {
          return { x: x5 + deltaX, y: y5 + deltaY };
        }
      };
    }),
    "processTranslate"
  );
  const brushProps = tag(user_derived(() => strict_equals(typeof $$props.brush, "object") ? $$props.brush : { disabled: !$$props.brush }), "brushProps");
  const tooltipProps = tag(user_derived(() => strict_equals(typeof $$props.tooltip, "object") ? $$props.tooltip : {}), "tooltipProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_15();
      let styles;
      var node_1 = child(div);
      add_svelte_meta(
        () => key(node_1, () => get(isMounted), ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            let $0 = user_derived(() => $$props.transform?.mode ?? $$props.geo?.applyTransform?.length ? "manual" : "none");
            let $1 = user_derived(() => get(initialTransform)?.translate);
            let $2 = user_derived(() => get(initialTransform)?.scale);
            add_svelte_meta(
              () => TransformContext_default(node_2, spread_props(
                {
                  get mode() {
                    return get($0);
                  },
                  get initialTranslate() {
                    return get($1);
                  },
                  get initialScale() {
                    return get($2);
                  },
                  get processTranslate() {
                    return get(processTranslate);
                  }
                },
                () => $$props.transform,
                {
                  get ondragstart() {
                    return $$props.ondragstart;
                  },
                  get onTransform() {
                    return $$props.onTransform;
                  },
                  get ondragend() {
                    return $$props.ondragend;
                  },
                  get transformContext() {
                    return get(transformContext);
                  },
                  set transformContext($$value) {
                    set(transformContext, $$value, true);
                  },
                  children: wrap_snippet(Chart, ($$anchor4, $$slotProps) => {
                    var fragment_2 = comment();
                    var node_3 = first_child(fragment_2);
                    add_svelte_meta(
                      () => GeoContext_default(node_3, spread_props(() => $$props.geo, {
                        get geoContext() {
                          return get(geoContext);
                        },
                        set geoContext($$value) {
                          set(geoContext, $$value, true);
                        },
                        children: wrap_snippet(Chart, ($$anchor5, $$slotProps2) => {
                          var fragment_3 = comment();
                          var node_4 = first_child(fragment_3);
                          add_svelte_meta(
                            () => BrushContext_default(node_4, spread_props(() => get(brushProps), {
                              get brushContext() {
                                return get(brushContext);
                              },
                              set brushContext($$value) {
                                set(brushContext, $$value, true);
                              },
                              children: wrap_snippet(Chart, ($$anchor6, $$slotProps3) => {
                                var fragment_4 = comment();
                                var node_5 = first_child(fragment_4);
                                add_svelte_meta(
                                  () => TooltipContext_default(node_5, spread_props(() => get(tooltipProps), {
                                    get tooltipContext() {
                                      return get(tooltipContext);
                                    },
                                    set tooltipContext($$value) {
                                      set(tooltipContext, $$value, true);
                                    },
                                    children: wrap_snippet(Chart, ($$anchor7, $$slotProps4) => {
                                      var fragment_5 = comment();
                                      var node_6 = first_child(fragment_5);
                                      add_svelte_meta(() => snippet(node_6, () => $$props.children ?? noop, () => ({ context })), "render", Chart, 1368, 14);
                                      append($$anchor7, fragment_5);
                                    }),
                                    $$slots: { default: true }
                                  })),
                                  "component",
                                  Chart,
                                  1367,
                                  12,
                                  { componentTag: "TooltipContext" }
                                );
                                append($$anchor6, fragment_4);
                              }),
                              $$slots: { default: true }
                            })),
                            "component",
                            Chart,
                            1365,
                            10,
                            { componentTag: "BrushContext" }
                          );
                          append($$anchor5, fragment_3);
                        }),
                        $$slots: { default: true }
                      })),
                      "component",
                      Chart,
                      1363,
                      8,
                      { componentTag: "GeoContext" }
                    );
                    append($$anchor4, fragment_2);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              Chart,
              1351,
              6,
              { componentTag: "TransformContext" }
            );
          }
          append($$anchor3, fragment_1);
        }),
        "key",
        Chart,
        1349,
        4
      );
      reset(div);
      bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
      template_effect(
        ($0, $1) => {
          set_class(div, 1, $0, "s-uDAH2GcCSDkP");
          styles = set_style(div, "", styles, $1);
        },
        [
          () => clsx(layerClass("root-container")),
          () => ({
            position: position(),
            top: strict_equals(position(), "absolute") ? "0" : null,
            right: strict_equals(position(), "absolute") ? "0" : null,
            bottom: strict_equals(position(), "absolute") ? "0" : null,
            left: strict_equals(position(), "absolute") ? "0" : null,
            "pointer-events": strict_equals(pointerEvents(), false) ? "none" : null
          })
        ]
      );
      bind_element_size(div, "clientWidth", ($$value) => set(containerWidth, $$value));
      bind_element_size(div, "clientHeight", ($$value) => set(containerHeight, $$value));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(ssr(), true) || strict_equals(typeof window, "undefined", false)) $$render(consequent);
      }),
      "if",
      Chart,
      1336,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Chart = hmr(Chart, () => Chart[HMR].source);
  import.meta.hot.accept((module2) => {
    cleanup_styles("s-uDAH2GcCSDkP");
    module2.default[HMR].source = Chart[HMR].source;
    set(Chart[HMR].source, module2.default[HMR].original);
  });
}
var Chart_default = Chart;

// node_modules/layerchart/dist/components/Group.svelte
Group[FILENAME] = "node_modules/layerchart/dist/components/Group.svelte";
var root_34 = add_locations(from_svg(`<g><!></g>`), Group[FILENAME], [[179, 2]]);
var root_43 = add_locations(from_html(`<div><!></div>`), Group[FILENAME], [[191, 2]]);
function Group($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Group);
  const ctx = getChartContext();
  let center2 = prop($$props, "center", 3, false), preventTouchMove = prop($$props, "preventTouchMove", 3, false), opacity = prop($$props, "opacity", 3, void 0), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "initialX",
      "y",
      "initialY",
      "center",
      "preventTouchMove",
      "opacity",
      "motion",
      "transitionIn",
      "transitionInParams",
      "class",
      "children",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const initialX = $$props.initialX ?? $$props.x;
  const initialY = $$props.initialY ?? $$props.y;
  const trueX = tag(user_derived(() => $$props.x ?? (strict_equals(center2(), "x") || strict_equals(center2(), true) ? ctx.width / 2 : 0)), "trueX");
  const trueY = tag(user_derived(() => $$props.y ?? (strict_equals(center2(), "y") || strict_equals(center2(), true) ? ctx.height / 2 : 0)), "trueY");
  const motionX = createMotion(initialX, () => get(trueX), $$props.motion);
  const motionY = createMotion(initialY, () => get(trueY), $$props.motion);
  const transitionIn = tag(
    user_derived(() => $$props.transitionIn ? $$props.transitionIn : extractTweenConfig($$props.motion)?.options ? fade : () => {
    }),
    "transitionIn"
  );
  const transitionInParams = tag(user_derived(() => $$props.transitionInParams ? $$props.transitionInParams : { easing: cubicIn }), "transitionInParams");
  const transform2 = tag(
    user_derived(() => {
      if (center2() || equals($$props.x, null, false) || equals($$props.y, null, false)) {
        return `translate(${motionX.current}px, ${motionY.current}px)`;
      }
    }),
    "transform"
  );
  const renderCtx = getRenderContext();
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Group",
      render: (ctx2) => {
        const currentGlobalAlpha = ctx2.globalAlpha;
        ctx2.globalAlpha = opacity() ?? 1;
        ctx2.translate(motionX.current ?? 0, motionY.current ?? 0);
        ctx2.globalAlpha = currentGlobalAlpha;
      },
      retainState: true,
      events: {
        click: $$props.onclick,
        dblclick: $$props.ondblclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave,
        pointerdown: $$props.onpointerdown
      },
      deps: () => [motionX.current, motionY.current, opacity()]
    });
  }
  const handleTouchMove = (e) => {
    if (preventTouchMove()) {
      e.preventDefault();
    }
    $$props.ontouchmove?.(e);
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Group, 177, 2);
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var g = root_34();
          attribute_effect(
            g,
            ($0, $1) => ({
              class: $0,
              opacity: opacity(),
              ...restProps,
              ontouchmove: handleTouchMove,
              [STYLE]: $1
            }),
            [
              () => cls(layerClass("group-g"), $$props.class),
              () => ({ transform: get(transform2) })
            ]
          );
          var node_3 = child(g);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Group, 188, 4);
          reset(g);
          bind_this(g, ($$value) => set(ref, $$value), () => get(ref));
          transition(1, g, () => get(transitionIn), () => get(transitionInParams));
          append($$anchor3, g);
        };
        var alternate = ($$anchor3) => {
          var div = root_43();
          attribute_effect(
            div,
            ($0, $1) => ({
              ...restProps,
              class: $0,
              ontouchmove: handleTouchMove,
              [STYLE]: $1
            }),
            [
              () => cls(layerClass("group-div"), "absolute", $$props.class),
              () => ({ transform: get(transform2), opacity: opacity() })
            ]
          );
          var node_4 = child(div);
          add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Group, 200, 4);
          reset(div);
          bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
          transition(1, div, () => get(transitionIn), () => get(transitionInParams));
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(renderCtx, "svg")) $$render(consequent_1);
              else $$render(alternate, false);
            },
            true
          ),
          "if",
          Group,
          178,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "canvas")) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Group,
      176,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Group = hmr(Group, () => Group[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Group[HMR].source;
    set(Group[HMR].source, module2.default[HMR].original);
  });
}
var Group_default = Group;

// node_modules/layerchart/dist/utils/path.js
function getEasingPath(easing, count4 = 1e3) {
  let pathData = `M0 ${count4}`;
  for (let i = 1; i <= count4; i++) {
    pathData += `
			L${i / count4 * count4}
			${count4 - easing(i / count4) * count4}
		`;
  }
  return pathData;
}
function circlePath(dimensions) {
  const { cx, cy, r, sweep = "outside" } = dimensions;
  const _sweep = sweep === "outside" ? 1 : 0;
  return `
    M ${cx - r} ${cy}
    a ${r},${r} 0 1,${_sweep} ${r * 2},0
    a ${r},${r} 0 1,${_sweep} -${r * 2},0
  `;
}
function spikePath({ x: x4, y: y4, width, height }) {
  const startPoint = { x: x4 - width / 2, y: y4 };
  const midPoint = { x: x4, y: y4 - height };
  const endPoint = { x: x4 + width / 2, y: y4 };
  const pathData = `
    M ${startPoint.x},${startPoint.y}
    L ${midPoint.x},${midPoint.y}
    L ${endPoint.x},${endPoint.y}
  `;
  return pathData;
}
function roundedPolygonPath(coords, radius) {
  if (radius === 0) {
    return `M${coords[0].x},${coords[0].y}${coords.slice(1).map((p) => `L${p.x},${p.y}`).join("")}Z`;
  }
  let path3 = "";
  const length = coords.length + 1;
  for (let i = 0; i < length; i++) {
    const a5 = coords[i % coords.length];
    const b = coords[(i + 1) % coords.length];
    const t = Math.min(radius / Math.hypot(b.x - a5.x, b.y - a5.y), 0.5);
    if (i == 0)
      path3 += `M${a5.x * (1 - t) + b.x * t},${a5.y * (1 - t) + b.y * t}`;
    if (i > 0)
      path3 += `Q${a5.x},${a5.y} ${a5.x * (1 - t) + b.x * t},${a5.y * (1 - t) + b.y * t}`;
    if (i < length - 1)
      path3 += `L${a5.x * t + b.x * (1 - t)},${a5.y * t + b.y * (1 - t)}`;
  }
  path3 += "Z";
  return path3;
}
function flattenPathData(pathData, yOverride = 0) {
  let result2 = pathData;
  result2 = result2.replace(/([MLTQCSAZ])(-?\d*\.?\d+),(-?\d*\.?\d+)/g, (match, command, x4, y4) => {
    return `${command}${x4},${yOverride}`;
  });
  result2 = result2.replace(/([v])(-?\d*\.?\d+)/g, (match, command, l) => {
    return `${command}${0}`;
  });
  return result2;
}

// node_modules/layerchart/dist/components/Marker.svelte
Marker[FILENAME] = "node_modules/layerchart/dist/components/Marker.svelte";
var root_35 = add_locations(from_svg(`<path d="M 0 0 L 10 5 L 0 10 z"></path>`), Marker[FILENAME], [[133, 6]]);
var root_54 = add_locations(from_svg(`<polyline points="0 0, 10 5, 0 10"></polyline>`), Marker[FILENAME], [[135, 6]]);
var root_7 = add_locations(from_svg(`<circle></circle>`), Marker[FILENAME], [[137, 6]]);
var root_9 = add_locations(from_svg(`<polyline points="5 0, 5 10"></polyline>`), Marker[FILENAME], [[139, 6]]);
var root7 = add_locations(from_svg(`<defs><marker><!></marker></defs>`), Marker[FILENAME], [[97, 0, [[98, 2]]]]);
function Marker($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Marker);
  let id = prop($$props, "id", 19, () => createId("marker-", uid)), size2 = prop($$props, "size", 3, 10), markerWidth = prop($$props, "markerWidth", 19, size2), markerHeight = prop($$props, "markerHeight", 19, size2), markerUnits = prop($$props, "markerUnits", 3, "userSpaceOnUse"), orient = prop($$props, "orient", 3, "auto-start-reverse"), refX = prop($$props, "refX", 19, () => ["arrow", "triangle"].includes($$props.type ?? "") ? 9 : 5), refY = prop($$props, "refY", 3, 5), viewBox = prop($$props, "viewBox", 3, "0 0 10 10"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "type",
      "id",
      "size",
      "markerWidth",
      "markerHeight",
      "markerUnits",
      "orient",
      "refX",
      "refY",
      "viewBox",
      "class",
      "children"
    ],
    "restProps"
  );
  var defs = root7();
  var marker = child(defs);
  attribute_effect(
    marker,
    ($0) => ({
      id: id(),
      markerWidth: markerWidth(),
      markerHeight: markerHeight(),
      markerUnits: markerUnits(),
      orient: orient(),
      refX: refX(),
      refY: refY(),
      viewBox: viewBox(),
      ...restProps,
      class: $0
    }),
    [
      () => cls(
        layerClass("marker"),
        "overflow-visible",
        // stroke
        equals($$props.stroke, null) && (["arrow", "circle-stroke", "line"].includes($$props.type ?? "") ? "stroke-[context-stroke]" : strict_equals($$props.type, "circle") ? "stroke-surface-100" : "stroke-none"),
        // extra stroke attrs
        "[stroke-linecap:round] [stroke-linejoin:round]",
        //fill
        equals($$props.fill, null) && (["triangle", "dot", "circle"].includes($$props.type ?? "") ? "fill-[context-stroke]" : strict_equals($$props.type, "circle-stroke") ? "fill-surface-100" : "fill-none"),
        $$props.class
      )
    ]
  );
  var node = child(marker);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      add_svelte_meta(() => snippet(node_1, () => $$props.children), "render", Marker, 131, 6);
      append($$anchor2, fragment);
    };
    var alternate_3 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var path3 = root_35();
          template_effect(($0) => set_class(path3, 0, $0), [() => clsx(layerClass("marker-triangle"))]);
          append($$anchor3, path3);
        };
        var alternate_2 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          {
            var consequent_2 = ($$anchor4) => {
              var polyline = root_54();
              template_effect(($0) => set_class(polyline, 0, $0), [() => clsx(layerClass("marker-arrow"))]);
              append($$anchor4, polyline);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              {
                var consequent_3 = ($$anchor5) => {
                  var circle = root_7();
                  set_attribute(circle, "cx", 5);
                  set_attribute(circle, "cy", 5);
                  set_attribute(circle, "r", 5);
                  template_effect(($0) => set_class(circle, 0, $0), [() => clsx(layerClass("marker-circle"))]);
                  append($$anchor5, circle);
                };
                var alternate = ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_5 = first_child(fragment_4);
                  {
                    var consequent_4 = ($$anchor6) => {
                      var polyline_1 = root_9();
                      template_effect(($0) => set_class(polyline_1, 0, $0), [() => clsx(layerClass("marker-line"))]);
                      append($$anchor6, polyline_1);
                    };
                    add_svelte_meta(
                      () => if_block(
                        node_5,
                        ($$render) => {
                          if (strict_equals($$props.type, "line")) $$render(consequent_4);
                        },
                        true
                      ),
                      "if",
                      Marker,
                      138,
                      4
                    );
                  }
                  append($$anchor5, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(
                    node_4,
                    ($$render) => {
                      if (strict_equals($$props.type, "circle") || strict_equals($$props.type, "circle-stroke") || strict_equals($$props.type, "dot")) $$render(consequent_3);
                      else $$render(alternate, false);
                    },
                    true
                  ),
                  "if",
                  Marker,
                  136,
                  4
                );
              }
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(
                node_3,
                ($$render) => {
                  if (strict_equals($$props.type, "arrow")) $$render(consequent_2);
                  else $$render(alternate_1, false);
                },
                true
              ),
              "if",
              Marker,
              134,
              4
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals($$props.type, "triangle")) $$render(consequent_1);
              else $$render(alternate_2, false);
            },
            true
          ),
          "if",
          Marker,
          132,
          4
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate_3, false);
      }),
      "if",
      Marker,
      130,
      4
    );
  }
  reset(marker);
  reset(defs);
  append($$anchor, defs);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Marker = hmr(Marker, () => Marker[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Marker[HMR].source;
    set(Marker[HMR].source, module2.default[HMR].original);
  });
}
var Marker_default = Marker;

// node_modules/layerchart/dist/components/MarkerWrapper.svelte
MarkerWrapper[FILENAME] = "node_modules/layerchart/dist/components/MarkerWrapper.svelte";
function MarkerWrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MarkerWrapper);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.marker, () => ({ id: $$props.id })), "render", MarkerWrapper, 28, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            let $0 = user_derived(() => strict_equals(typeof $$props.marker, "string") ? $$props.marker : void 0);
            add_svelte_meta(
              () => Marker_default(node_3, spread_props(
                {
                  get id() {
                    return $$props.id;
                  },
                  get type() {
                    return get($0);
                  }
                },
                () => strict_equals(typeof $$props.marker, "object") ? $$props.marker : null
              )),
              "component",
              MarkerWrapper,
              30,
              2,
              { componentTag: "Marker" }
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if ($$props.marker) $$render(consequent_1);
            },
            true
          ),
          "if",
          MarkerWrapper,
          29,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(typeof $$props.marker, "function")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      MarkerWrapper,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MarkerWrapper = hmr(MarkerWrapper, () => MarkerWrapper[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = MarkerWrapper[HMR].source;
    set(MarkerWrapper[HMR].source, module2.default[HMR].original);
  });
}
var MarkerWrapper_default = MarkerWrapper;

// node_modules/layerchart/dist/components/Spline.svelte
Spline[FILENAME] = "node_modules/layerchart/dist/components/Spline.svelte";
var root_23 = add_locations(from_svg(`<path></path><!><!><!><!><!>`, 1), Spline[FILENAME], [[362, 4]]);
function Spline($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Spline);
  const ctx = getChartContext();
  let pathRefProp = prop($$props, "pathRef", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "pathData",
      "x",
      "y",
      "motion",
      "draw",
      "curve",
      "defined",
      "fill",
      "stroke",
      "strokeWidth",
      "fillOpacity",
      "class",
      "marker",
      "markerStart",
      "markerMid",
      "markerEnd",
      "startContent",
      "endContent",
      "opacity",
      "pathRef"
    ],
    "restProps"
  );
  let pathRef = tag(state(void 0), "pathRef");
  user_pre_effect(() => {
    pathRefProp(get(pathRef));
  });
  const markerStart = tag(user_derived(() => $$props.markerStart ?? $$props.marker), "markerStart");
  const markerMid = tag(user_derived(() => $$props.markerMid ?? $$props.marker), "markerMid");
  const markerEnd = tag(user_derived(() => $$props.markerEnd ?? $$props.marker), "markerEnd");
  const markerStartId = tag(user_derived(() => get(markerStart) ? createId("marker-start", uid) : ""), "markerStartId");
  const markerMidId = tag(user_derived(() => get(markerMid) ? createId("marker-mid", uid) : ""), "markerMidId");
  const markerEndId = tag(user_derived(() => get(markerEnd) ? createId("marker-end", uid) : ""), "markerEndId");
  function getScaleValue(data, scale2, accessor2) {
    let value2 = accessor2(data);
    if (Array.isArray(value2)) {
      value2 = max(value2);
    }
    if (scale2.domain().length) {
      return scale2(value2);
    } else {
      return value2;
    }
  }
  const xAccessor = tag(user_derived(() => $$props.x ? accessor($$props.x) : ctx.x), "xAccessor");
  const yAccessor = tag(user_derived(() => $$props.y ? accessor($$props.y) : ctx.y), "yAccessor");
  const xOffset = tag(user_derived(() => isScaleBand(ctx.xScale) ? ctx.xScale.bandwidth() / 2 : 0), "xOffset");
  const yOffset = tag(user_derived(() => isScaleBand(ctx.yScale) ? ctx.yScale.bandwidth() / 2 : 0), "yOffset");
  const extractedTween = extractTweenConfig($$props.motion);
  const tweenedOptions = extractedTween ? {
    type: extractedTween.type,
    options: { interpolate: interpolatePath, ...extractedTween.options }
  } : void 0;
  function defaultPathData() {
    if (!tweenedOptions) {
      return "";
    } else if ($$props.pathData) {
      return flattenPathData($$props.pathData, Math.min(ctx.yScale(0) ?? ctx.yRange[0], ctx.yRange[0]));
    } else if (ctx.config.x) {
      const path3 = ctx.radial ? lineRadial_default().angle((d2) => ctx.xScale(get(
        xAccessor
        // Never apply xOffset (LineChart radar, BarChart radial, ...)?
      )(d2)) + 0).radius((d2) => Math.min(ctx.yScale(0), ctx.yRange[0])) : line_default().x((d2) => ctx.xScale(get(xAccessor)(d2)) + get(xOffset)).y((d2) => Math.min(ctx.yScale(0), ctx.yRange[0]));
      path3.defined($$props.defined ?? ((d2) => equals(get(xAccessor)(d2), null, false) && equals(get(yAccessor)(d2), null, false)));
      if ($$props.curve) path3.curve($$props.curve);
      return path3($$props.data ?? ctx.data);
    }
  }
  const d = tag(
    user_derived(() => {
      const path3 = ctx.radial ? lineRadial_default().angle((d2) => getScaleValue(
        d2,
        ctx.xScale,
        // Never apply xOffset (LineChart radar, BarChart radial, ...)?
        get(xAccessor)
      ) + 0).radius((d2) => getScaleValue(d2, ctx.yScale, get(yAccessor)) + get(yOffset)) : line_default().x((d2) => getScaleValue(d2, ctx.xScale, get(xAccessor)) + get(xOffset)).y((d2) => getScaleValue(d2, ctx.yScale, get(yAccessor)) + get(yOffset));
      path3.defined($$props.defined ?? ((d2) => equals(get(xAccessor)(d2), null, false) && equals(get(yAccessor)(d2), null, false)));
      if ($$props.curve) path3.curve($$props.curve);
      return $$props.pathData ?? path3($$props.data ?? ctx.data) ?? "";
    }),
    "d"
  );
  const tweenedState = createMotion(defaultPathData(), () => get(d), tweenedOptions);
  const drawTransition = tag(user_derived(() => $$props.draw ? draw : () => ({})), "drawTransition");
  let key2 = tag(state(proxy(Symbol())), "key");
  const renderCtx = getRenderContext();
  function render2(ctx2, styleOverrides) {
    renderPathData(ctx2, tweenedState.current, styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        fillOpacity: $$props.fillOpacity,
        stroke: $$props.stroke,
        strokeWidth: $$props.strokeWidth,
        opacity: $$props.opacity
      },
      classes: $$props.class
    });
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Spline",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave,
        pointerdown: $$props.onpointerdown,
        pointerover: $$props.onpointerover,
        pointerout: $$props.onpointerout,
        touchmove: $$props.ontouchmove
      },
      deps: () => [
        fillKey.current,
        $$props.fillOpacity,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class,
        tweenedState.current
      ]
    });
  }
  let startPoint = tag(state(void 0), "startPoint");
  const endPointDuration = tag(
    user_derived(() => {
      if (strict_equals(typeof $$props.draw, "object") && strict_equals($$props.draw.duration, void 0, false) && strict_equals(typeof $$props.draw.duration, "function", false)) {
        return $$props.draw.duration;
      }
      return 800;
    }),
    "endPointDuration"
  );
  const endPoint = createControlledMotion(void 0, $$props.draw ? {
    type: "tween",
    duration: () => get(endPointDuration),
    easing: strict_equals(typeof $$props.draw, "object") && $$props.draw.easing ? $$props.draw.easing : cubicInOut,
    interpolate() {
      return (t) => {
        const totalLength = get(pathRef)?.getTotalLength() ?? 0;
        const point10 = get(pathRef)?.getPointAtLength(totalLength * t);
        return point10;
      };
    }
  } : { type: "none" });
  user_effect(() => {
    if (!$$props.startContent && !$$props.endContent) return;
    get(d);
    if (!get(pathRef) || !get(pathRef).getTotalLength()) return;
    set(startPoint, get(pathRef).getPointAtLength(0), true);
    const totalLength = get(pathRef).getTotalLength();
    endPoint.target = get(pathRef).getPointAtLength(totalLength);
  });
  user_effect(() => {
    if (!$$props.draw) return;
    [$$props.pathData, $$props.data, ctx.data];
    set(key2, Symbol(), true);
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => key(node_1, () => get(key2), ($$anchor3) => {
          var fragment_2 = root_23();
          var path_1 = first_child(fragment_2);
          attribute_effect(
            path_1,
            ($0) => ({
              d: tweenedState.current,
              ...restProps,
              class: $0,
              fill: $$props.fill,
              "fill-opacity": $$props.fillOpacity,
              stroke: $$props.stroke,
              "stroke-width": $$props.strokeWidth,
              opacity: $$props.opacity,
              "marker-start": get(markerStartId) ? `url(#${get(markerStartId)})` : void 0,
              "marker-mid": get(markerMidId) ? `url(#${get(markerMidId)})` : void 0,
              "marker-end": get(markerEndId) ? `url(#${get(markerEndId)})` : void 0
            }),
            [
              () => cls(layerClass("spline-path"), !$$props.fill && "fill-none", !$$props.stroke && "stroke-surface-content", $$props.class)
            ]
          );
          bind_this(path_1, ($$value) => set(pathRef, $$value), () => get(pathRef));
          var node_2 = sibling(path_1);
          add_svelte_meta(
            () => MarkerWrapper_default(node_2, {
              get id() {
                return get(markerStartId);
              },
              get marker() {
                return get(markerStart);
              }
            }),
            "component",
            Spline,
            382,
            4,
            { componentTag: "MarkerWrapper" }
          );
          var node_3 = sibling(node_2);
          add_svelte_meta(
            () => MarkerWrapper_default(node_3, {
              get id() {
                return get(markerMidId);
              },
              get marker() {
                return get(markerMid);
              }
            }),
            "component",
            Spline,
            383,
            4,
            { componentTag: "MarkerWrapper" }
          );
          var node_4 = sibling(node_3);
          add_svelte_meta(
            () => MarkerWrapper_default(node_4, {
              get id() {
                return get(markerEndId);
              },
              get marker() {
                return get(markerEnd);
              }
            }),
            "component",
            Spline,
            384,
            4,
            { componentTag: "MarkerWrapper" }
          );
          var node_5 = sibling(node_4);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_6 = first_child(fragment_3);
              {
                let $0 = user_derived(() => layerClass("spline-g-start"));
                add_svelte_meta(
                  () => Group_default(node_6, {
                    get x() {
                      return get(startPoint).x;
                    },
                    get y() {
                      return get(startPoint).y;
                    },
                    get class() {
                      return get($0);
                    },
                    children: wrap_snippet(Spline, ($$anchor5, $$slotProps) => {
                      var fragment_4 = comment();
                      var node_7 = first_child(fragment_4);
                      {
                        let $02 = user_derived(() => ({
                          point: get(startPoint),
                          value: {
                            x: ctx.xScale?.invert?.(get(startPoint).x),
                            y: ctx.yScale?.invert?.(get(startPoint).y)
                          }
                        }));
                        add_svelte_meta(() => snippet(node_7, () => $$props.startContent, () => get($02)), "render", Spline, 388, 8);
                      }
                      append($$anchor5, fragment_4);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  Spline,
                  387,
                  6,
                  { componentTag: "Group" }
                );
              }
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_5, ($$render) => {
                if ($$props.startContent && get(startPoint)) $$render(consequent);
              }),
              "if",
              Spline,
              386,
              4
            );
          }
          var node_8 = sibling(node_5);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_9 = first_child(fragment_5);
              {
                let $0 = user_derived(() => layerClass("spline-g-end"));
                add_svelte_meta(
                  () => Group_default(node_9, {
                    get x() {
                      return endPoint.current.x;
                    },
                    get y() {
                      return endPoint.current.y;
                    },
                    get class() {
                      return get($0);
                    },
                    children: wrap_snippet(Spline, ($$anchor5, $$slotProps) => {
                      var fragment_6 = comment();
                      var node_10 = first_child(fragment_6);
                      {
                        let $02 = user_derived(() => ({
                          point: endPoint.current,
                          value: {
                            x: ctx.xScale?.invert?.(endPoint.current.x),
                            y: ctx.yScale?.invert?.(endPoint.current.y)
                          }
                        }));
                        add_svelte_meta(() => snippet(node_10, () => $$props.endContent, () => get($02)), "render", Spline, 400, 8);
                      }
                      append($$anchor5, fragment_6);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  Spline,
                  399,
                  6,
                  { componentTag: "Group" }
                );
              }
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_8, ($$render) => {
                if ($$props.endContent && endPoint.current) $$render(consequent_1);
              }),
              "if",
              Spline,
              398,
              4
            );
          }
          transition(5, path_1, () => get(drawTransition), () => strict_equals(typeof $$props.draw, "object") ? $$props.draw : void 0);
          append($$anchor3, fragment_2);
        }),
        "key",
        Spline,
        361,
        2
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent_2);
      }),
      "if",
      Spline,
      360,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Spline = hmr(Spline, () => Spline[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Spline[HMR].source;
    set(Spline[HMR].source, module2.default[HMR].original);
  });
}
var Spline_default = Spline;

// node_modules/layerchart/dist/utils/arcText.svelte.js
function extractOutsideArc(arcPath) {
  const matches2 = arcPath.match(/(^.+?)(L|Z)/);
  if (!matches2 || !matches2[1]) return arcPath;
  return matches2[1];
}
function normalizeAngle(angle) {
  return (angle % 360 + 360) % 360;
}
function getArcPathMiddle(props) {
  const centerRadius = tag(user_derived(() => (props.innerRadius() + props.outerRadius()) / 2), "centerRadius");
  const cornerAngleOffset = tag(
    user_derived(() => {
      if (props.cornerRadius() <= 0 || get(centerRadius) <= 0) return 0;
      const effectiveCornerRadius = Math.min(props.cornerRadius(), get(centerRadius));
      return effectiveCornerRadius * 0.5 / get(centerRadius);
    }),
    "cornerAngleOffset"
  );
  const effectiveStartAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.startAngle() - get(cornerAngleOffset);
      }
      return props.startAngle() + get(cornerAngleOffset);
    }),
    "effectiveStartAngle"
  );
  const effectiveEndAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.endAngle() + get(cornerAngleOffset);
      }
      return props.endAngle() - get(cornerAngleOffset);
    }),
    "effectiveEndAngle"
  );
  const path3 = tag(user_derived(() => extractOutsideArc(arc_default().outerRadius(get(centerRadius)).innerRadius(get(centerRadius) - 0.5).startAngle(get(effectiveStartAngle)).endAngle(get(effectiveEndAngle))() ?? "")), "path");
  return {
    get current() {
      return get(path3);
    }
  };
}
function getArcPathInner(props) {
  const cornerAngleOffset = tag(
    user_derived(() => {
      if (props.cornerRadius() <= 0 || props.innerRadius() <= 0) return 0;
      if (props.cornerRadius() >= props.innerRadius()) return Math.PI / 4;
      return props.cornerRadius() * 0.5 / props.innerRadius();
    }),
    "cornerAngleOffset"
  );
  const effectiveStartAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.startAngle() - get(cornerAngleOffset);
      }
      return props.startAngle() + get(cornerAngleOffset);
    }),
    "effectiveStartAngle"
  );
  const effectiveEndAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.endAngle() + get(cornerAngleOffset);
      }
      return props.endAngle() - get(cornerAngleOffset);
    }),
    "effectiveEndAngle"
  );
  const path3 = tag(user_derived(() => extractOutsideArc(arc_default().innerRadius(props.innerRadius()).outerRadius(props.innerRadius() + 0.5).startAngle(get(effectiveStartAngle)).endAngle(get(effectiveEndAngle))() ?? "")), "path");
  return {
    get current() {
      return get(path3);
    }
  };
}
function getArcPathOuter(props) {
  const cornerAngleOffset = tag(
    user_derived(() => {
      if (props.cornerRadius() <= 0 || props.outerRadius() <= 0) return 0;
      return props.cornerRadius() * 0.5 / props.outerRadius();
    }),
    "cornerAngleOffset"
  );
  const effectiveStartAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.startAngle() - get(cornerAngleOffset);
      }
      return props.startAngle() + get(cornerAngleOffset);
    }),
    "effectiveStartAngle"
  );
  const effectiveEndAngle = tag(
    user_derived(() => {
      if (props.invertCorner()) {
        return props.endAngle() + get(cornerAngleOffset);
      }
      return props.endAngle() - get(cornerAngleOffset);
    }),
    "effectiveEndAngle"
  );
  const path3 = tag(user_derived(() => extractOutsideArc(arc_default().innerRadius(props.outerRadius() - 0.5).outerRadius(props.outerRadius()).startAngle(get(effectiveStartAngle)).endAngle(get(effectiveEndAngle))() ?? "")), "path");
  return {
    get current() {
      return get(path3);
    }
  };
}
function pointOnCircle(radius, angle) {
  const adjustedAngle = angle - Math.PI / 2;
  return [
    radius * Math.cos(adjustedAngle),
    radius * Math.sin(adjustedAngle)
  ];
}
function createArcTextProps(props, opts = {}, position) {
  const effectiveStartAngleRadians = tag(
    user_derived(() => {
      const start = props.startAngle();
      const end = props.endAngle();
      const offset = opts.startOffset;
      if (offset) {
        try {
          const percentage = parseFloat(offset.slice(0, -1)) / 100;
          if (!isNaN(percentage) && percentage >= 0 && percentage <= 1) {
            const span = end - start;
            return start + span * percentage;
          } else {
            console.warn(...log_if_contains_state("warn", "Invalid percentage for startOffset:", offset));
          }
        } catch (e) {
          console.warn(...log_if_contains_state("warn", "Could not parse startOffset percentage:", offset, e));
        }
      }
      return start;
    }),
    "effectiveStartAngleRadians"
  );
  const effectiveStartDegrees = tag(user_derived(() => radiansToDegrees(get(effectiveStartAngleRadians))), "effectiveStartDegrees");
  const normalizedStartDegrees = tag(user_derived(() => normalizeAngle(get(effectiveStartDegrees))), "normalizedStartDegrees");
  const startDegrees = tag(user_derived(() => radiansToDegrees(props.startAngle())), "startDegrees");
  const endDegrees = tag(user_derived(() => radiansToDegrees(props.endAngle())), "endDegrees");
  const isClockwise = tag(user_derived(() => get(startDegrees) < get(endDegrees)), "isClockwise");
  const isTopCw = tag(user_derived(() => get(isClockwise) && (get(normalizedStartDegrees) >= 270 || get(normalizedStartDegrees) <= 90)), "isTopCw");
  const isTopCcw = tag(user_derived(() => !get(isClockwise) && (get(normalizedStartDegrees) > 270 || get(normalizedStartDegrees) <= 90)), "isTopCcw");
  const isBottomCw = tag(user_derived(() => get(isClockwise) && get(normalizedStartDegrees) < 270 && get(normalizedStartDegrees) >= 90), "isBottomCw");
  const isBottomCcw = tag(user_derived(() => !get(isClockwise) && get(normalizedStartDegrees) <= 270 && get(normalizedStartDegrees) > 90), "isBottomCcw");
  const reverseText = tag(user_derived(() => get(isTopCcw) || get(isBottomCw)), "reverseText");
  const pathGenProps = {
    ...props,
    startAngle: () => get(reverseText) ? props.endAngle() : props.startAngle(),
    endAngle: () => get(reverseText) ? props.startAngle() : props.endAngle(),
    invertCorner: () => get(isBottomCw) || get(isBottomCcw)
  };
  const innerPath = getArcPathInner(pathGenProps);
  const middlePath = getArcPathMiddle(pathGenProps);
  const outerPath = getArcPathOuter(pathGenProps);
  const innerDominantBaseline = tag(
    user_derived(() => {
      if (get(isBottomCw) || get(isBottomCcw)) return "auto";
      if (get(isTopCw) || get(isTopCcw)) return "hanging";
      return "auto";
    }),
    "innerDominantBaseline"
  );
  const outerDominantBaseline = tag(
    user_derived(() => {
      if (get(isBottomCw) || get(isBottomCcw)) return "hanging";
      return void 0;
    }),
    "outerDominantBaseline"
  );
  const sharedProps = tag(
    user_derived(() => {
      if (get(reverseText)) {
        return { startOffset: opts.startOffset ?? "100%", textAnchor: "end" };
      }
      return { startOffset: opts.startOffset ?? void 0 };
    }),
    "sharedProps"
  );
  const radialPositionProps = tag(
    user_derived(() => {
      if (strict_equals(position, "outer-radial", false)) return {};
      const midAngle = (props.startAngle() + props.endAngle()) / 2;
      const basePadding = opts.radialOffset ?? opts.outerPadding ?? 23;
      const midAngleDegrees = normalizeAngle(radiansToDegrees(midAngle));
      let textAnchor = "middle";
      let effectivePadding = basePadding;
      const isBottomZone = midAngleDegrees > 45 && midAngleDegrees < 135;
      const isTopZone = midAngleDegrees > 225 && midAngleDegrees < 315;
      const isRightZone = midAngleDegrees <= 45 || midAngleDegrees >= 315;
      const isLeftZone = midAngleDegrees >= 135 && midAngleDegrees <= 225;
      const positionRadius = props.outerRadius() + effectivePadding;
      const [x4, y4] = pointOnCircle(positionRadius, midAngle);
      if (isRightZone) {
        textAnchor = "start";
        if (midAngleDegrees > 350 || midAngleDegrees < 10) textAnchor = "start";
      } else if (isLeftZone) {
        textAnchor = "end";
        if (midAngleDegrees > 170 && midAngleDegrees < 190) textAnchor = "end";
      } else if (isBottomZone) {
        textAnchor = "middle";
      } else if (isTopZone) {
        textAnchor = "middle";
      }
      return { x: x4, y: y4, textAnchor, dominantBaseline: "middle" };
    }),
    "radialPositionProps"
  );
  const current = tag(
    user_derived(() => {
      if (strict_equals(position, "inner")) {
        return {
          path: innerPath.current,
          ...get(sharedProps),
          dominantBaseline: get(innerDominantBaseline)
        };
      } else if (strict_equals(position, "outer")) {
        return {
          path: outerPath.current,
          ...get(sharedProps),
          dominantBaseline: get(outerDominantBaseline)
        };
      } else if (strict_equals(position, "middle")) {
        return {
          path: middlePath.current,
          ...get(sharedProps),
          dominantBaseline: "middle"
        };
      } else if (strict_equals(position, "centroid")) {
        const centroid = props.centroid();
        return {
          x: centroid[0],
          y: centroid[1],
          textAnchor: "middle",
          verticalAnchor: "middle"
        };
      } else {
        return get(radialPositionProps);
      }
    }),
    "current"
  );
  return {
    get current() {
      return get(current);
    }
  };
}

// node_modules/layerchart/dist/components/Arc.svelte
Arc[FILENAME] = "node_modules/layerchart/dist/components/Arc.svelte";
var root8 = add_locations(from_html(`<!> <!> <!>`, 1), Arc[FILENAME], []);
function Arc($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arc);
  let refProp = prop($$props, "ref", 15), trackRefProp = prop($$props, "trackRef", 15), value2 = prop($$props, "value", 3, 0), initialValue = prop($$props, "initialValue", 3, 0), domain = prop($$props, "domain", 19, () => [0, 100]), range4 = prop($$props, "range", 19, () => [0, 360]), cornerRadius = prop($$props, "cornerRadius", 3, 0), padAngle = prop($$props, "padAngle", 3, 0), stroke = prop($$props, "stroke", 3, "none"), offset = prop($$props, "offset", 3, 0), onpointerenter = prop($$props, "onpointerenter", 3, () => {
  }), onpointermove = prop($$props, "onpointermove", 3, () => {
  }), onpointerleave2 = prop($$props, "onpointerleave", 3, () => {
  }), ontouchmove = prop($$props, "ontouchmove", 3, () => {
  }), track = prop($$props, "track", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "trackRef",
      "motion",
      "value",
      "initialValue",
      "domain",
      "range",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "cornerRadius",
      "padAngle",
      "trackStartAngle",
      "trackEndAngle",
      "trackInnerRadius",
      "trackOuterRadius",
      "trackCornerRadius",
      "trackPadAngle",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "data",
      "offset",
      "onpointerenter",
      "onpointermove",
      "onpointerleave",
      "ontouchmove",
      "tooltipContext",
      "track",
      "children",
      "class"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  let trackRef = tag(state(void 0), "trackRef");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    trackRefProp(get(trackRef));
  });
  const ctx = getChartContext();
  const endAngle = tag(user_derived(() => $$props.endAngle ?? degreesToRadians(ctx.config.xRange ? max(ctx.xRange) : max(range4()))), "endAngle");
  const motionEndAngle = createMotion(initialValue(), () => value2(), $$props.motion);
  const scale2 = tag(user_derived(() => linear2().domain(domain()).range(range4())), "scale");
  function getOuterRadius(outerRadius2, chartRadius) {
    if (!outerRadius2) {
      return chartRadius;
    } else if (outerRadius2 > 1) {
      return outerRadius2;
    } else if (outerRadius2 > 0) {
      return chartRadius * outerRadius2;
    } else if (outerRadius2 < 0) {
      return chartRadius + outerRadius2;
    } else {
      return outerRadius2;
    }
  }
  const outerRadius = tag(user_derived(() => getOuterRadius($$props.outerRadius, (Math.min(ctx.xRange[1], ctx.yRange[0]) ?? 0) / 2)), "outerRadius");
  const trackOuterRadius = tag(
    user_derived(() => $$props.trackOuterRadius ? getOuterRadius($$props.trackOuterRadius, (Math.min(ctx.xRange[1], ctx.yRange[0]) ?? 0) / 2) : get(outerRadius)),
    "trackOuterRadius"
  );
  function getInnerRadius(innerRadius2, outerRadius2) {
    if (equals(innerRadius2, null)) {
      return Math.min(...ctx.yRange);
    } else if (innerRadius2 > 1) {
      return innerRadius2;
    } else if (innerRadius2 > 0) {
      return outerRadius2 * innerRadius2;
    } else if (innerRadius2 < 0) {
      return outerRadius2 + innerRadius2;
    } else {
      return innerRadius2;
    }
  }
  const innerRadius = tag(user_derived(() => getInnerRadius($$props.innerRadius, get(outerRadius))), "innerRadius");
  const trackInnerRadius = tag(
    user_derived(() => $$props.trackInnerRadius ? getInnerRadius($$props.trackInnerRadius, get(trackOuterRadius)) : get(innerRadius)),
    "trackInnerRadius"
  );
  const startAngle = tag(user_derived(() => $$props.startAngle ?? degreesToRadians(range4()[0])), "startAngle");
  const trackStartAngle = tag(user_derived(() => $$props.trackStartAngle ?? $$props.startAngle ?? degreesToRadians(range4()[0])), "trackStartAngle");
  const trackEndAngle = tag(user_derived(() => $$props.trackEndAngle ?? $$props.endAngle ?? degreesToRadians(range4()[1])), "trackEndAngle");
  const trackCornerRadius = tag(user_derived(() => $$props.trackCornerRadius ?? cornerRadius()), "trackCornerRadius");
  const trackPadAngle = tag(user_derived(() => $$props.trackPadAngle ?? padAngle()), "trackPadAngle");
  const arcEndAngle2 = tag(user_derived(() => $$props.endAngle ?? degreesToRadians(get(scale2)(motionEndAngle.current))), "arcEndAngle");
  const arc = tag(user_derived(() => arc_default().innerRadius(get(innerRadius)).outerRadius(get(outerRadius)).startAngle(get(startAngle)).endAngle(get(arcEndAngle2)).cornerRadius(cornerRadius()).padAngle(padAngle())), "arc");
  const trackArc = tag(user_derived(() => arc_default().innerRadius(get(trackInnerRadius)).outerRadius(get(trackOuterRadius)).startAngle(get(trackStartAngle)).endAngle(get(trackEndAngle)).cornerRadius(get(trackCornerRadius)).padAngle(get(trackPadAngle))), "trackArc");
  const angle = tag(user_derived(() => ((get(startAngle) ?? 0) + (get(endAngle) ?? 0)) / 2), "angle");
  const xOffset = tag(user_derived(() => Math.sin(get(angle)) * offset()), "xOffset");
  const yOffset = tag(user_derived(() => -Math.cos(get(angle)) * offset()), "yOffset");
  const trackArcCentroid = tag(
    user_derived(() => {
      const centroid = get(trackArc).centroid();
      return [centroid[0] + get(xOffset), centroid[1] + get(yOffset)];
    }),
    "trackArcCentroid"
  );
  const boundingBox = tag(user_derived(() => get(trackRef) ? get(trackRef).getBBox() : {}), "boundingBox");
  const onPointerEnter = (e) => {
    onpointerenter()?.(e);
    $$props.tooltipContext?.show(e, $$props.data);
  };
  const onPointerMove2 = (e) => {
    onpointermove()?.(e);
    $$props.tooltipContext?.show(e, $$props.data);
  };
  const onPointerLeave = (e) => {
    onpointerleave2()?.(e);
    $$props.tooltipContext?.hide();
  };
  function getTrackTextProps(position, opts = {}) {
    return createArcTextProps(
      {
        startAngle: () => get(trackStartAngle),
        endAngle: () => get(trackEndAngle),
        outerRadius: () => get(trackOuterRadius) + (opts.outerPadding ? opts.outerPadding : 0),
        innerRadius: () => get(trackInnerRadius),
        cornerRadius: () => get(trackCornerRadius),
        centroid: () => get(trackArcCentroid)
      },
      opts,
      position
    ).current;
  }
  function getArcTextProps(position, opts = {}) {
    return createArcTextProps(
      {
        startAngle: () => get(startAngle),
        endAngle: () => get(arcEndAngle2),
        outerRadius: () => get(outerRadius) + (opts.outerPadding ? opts.outerPadding : 0),
        innerRadius: () => get(innerRadius),
        cornerRadius: () => cornerRadius(),
        centroid: () => get(trackArcCentroid)
      },
      opts,
      position
    ).current;
  }
  var fragment = root8();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => get(trackArc)());
        let $1 = user_derived(() => extractLayerProps(track(), "arc-track"));
        add_svelte_meta(
          () => Spline_default(node_1, spread_props(
            {
              get pathData() {
                return get($0);
              },
              stroke: "none"
            },
            () => get($1),
            {
              get pathRef() {
                return get(trackRef);
              },
              set pathRef($$value) {
                set(trackRef, $$value, true);
              }
            }
          )),
          "component",
          Arc,
          401,
          2,
          { componentTag: "Spline" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (track()) $$render(consequent);
      }),
      "if",
      Arc,
      400,
      0
    );
  }
  var node_2 = sibling(node, 2);
  {
    let $0 = user_derived(() => get(arc)());
    let $1 = user_derived(() => cls(layerClass("arc-line"), $$props.class));
    add_svelte_meta(
      () => Spline_default(node_2, spread_props(
        {
          get pathData() {
            return get($0);
          },
          get transform() {
            return `translate(${get(xOffset) ?? ""}, ${get(yOffset) ?? ""})`;
          },
          get fill() {
            return $$props.fill;
          },
          get fillOpacity() {
            return $$props.fillOpacity;
          },
          get stroke() {
            return stroke();
          },
          get "stroke-width"() {
            return $$props.strokeWidth;
          },
          get opacity() {
            return $$props.opacity;
          }
        },
        () => restProps,
        {
          get class() {
            return get($1);
          },
          onpointerenter: onPointerEnter,
          onpointermove: onPointerMove2,
          onpointerleave: onPointerLeave,
          ontouchmove: (e) => {
            ontouchmove()?.(e);
            if (!$$props.tooltipContext) return;
            e.preventDefault();
          },
          get pathRef() {
            return get(ref);
          },
          set pathRef($$value) {
            set(ref, $$value, true);
          }
        }
      )),
      "component",
      Arc,
      409,
      0,
      { componentTag: "Spline" }
    );
  }
  var node_3 = sibling(node_2, 2);
  add_svelte_meta(
    () => snippet(node_3, () => $$props.children ?? noop, () => ({
      centroid: get(trackArcCentroid),
      boundingBox: get(boundingBox),
      value: motionEndAngle.current,
      getTrackTextProps,
      getArcTextProps
    })),
    "render",
    Arc,
    431,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Arc = hmr(Arc, () => Arc[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Arc[HMR].source;
    set(Arc[HMR].source, module2.default[HMR].original);
  });
}
var Arc_default = Arc;

// node_modules/layerchart/dist/components/layout/Html.svelte
Html[FILENAME] = "node_modules/layerchart/dist/components/layout/Html.svelte";
var root9 = add_locations(from_html(`<div><!></div>`), Html[FILENAME], [[91, 0]]);
function Html($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Html);
  let refProp = prop($$props, "ref", 15), zIndex = prop($$props, "zIndex", 3, 0), pointerEvents = prop($$props, "pointerEvents", 3, true), center2 = prop($$props, "center", 3, false), ignoreTransform = prop($$props, "ignoreTransform", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "zIndex",
      "pointerEvents",
      "role",
      "aria-label",
      "aria-labelledby",
      "aria-describedby",
      "center",
      "ignoreTransform",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const roleVal = tag(user_derived(() => $$props.role || ($$props["aria-label"] || $$props["aria-labelledby"] || $$props["aria-describedby"] ? "figure" : void 0)), "roleVal");
  const ctx = getChartContext();
  const transformCtx = getTransformContext();
  const transform2 = tag(
    user_derived(() => {
      if (strict_equals(transformCtx.mode, "canvas") && !ignoreTransform()) {
        return `translate(${transformCtx.translate.x}px,${transformCtx.translate.y}px) scale(${transformCtx.scale})`;
      } else if (center2()) {
        return `translate(${strict_equals(center2(), "x") || strict_equals(center2(), true) ? ctx.width / 2 : 0}px, ${strict_equals(center2(), "y") || strict_equals(center2(), true) ? ctx.height / 2 : 0}px)`;
      }
    }),
    "transform"
  );
  setRenderContext("html");
  var div = root9();
  attribute_effect(
    div,
    ($0, $1) => ({
      class: $0,
      role: get(roleVal),
      "aria-label": $$props["aria-label"],
      "aria-labelledby": $$props["aria-labelledby"],
      "aria-describedby": $$props["aria-describedby"],
      ...restProps,
      [STYLE]: $1
    }),
    [
      () => cls(layerClass("layout-html"), "absolute top-0 left-0", strict_equals(pointerEvents(), false) && "pointer-events-none", $$props.class),
      () => ({
        transform: get(transform2),
        "transform-origin": "top left",
        "z-index": zIndex(),
        "pointer-events": strict_equals(pointerEvents(), false) ? "none" : null,
        top: `${ctx.padding.top ?? ""}px`,
        bottom: `${ctx.padding.bottom ?? ""}px`,
        left: `${ctx.padding.left ?? ""}px`,
        right: `${ctx.padding.right ?? ""}px`
      })
    ]
  );
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ ref: get(ref) })), "render", Html, 113, 2);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Html = hmr(Html, () => Html[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Html[HMR].source;
    set(Html[HMR].source, module2.default[HMR].original);
  });
}
var Html_default = Html;

// node_modules/layerchart/dist/components/layout/Layer.svelte
Layer[FILENAME] = "node_modules/layerchart/dist/components/layout/Layer.svelte";
function Layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Layer);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "type", "children"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => Canvas_default(node_1, spread_props(() => restProps, {
          children: wrap_snippet(Layer, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Layer, 31, 4);
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        })),
        "component",
        Layer,
        30,
        2,
        { componentTag: "Canvas" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          add_svelte_meta(
            () => Svg_default(node_4, spread_props(() => restProps, {
              children: wrap_snippet(Layer, ($$anchor4, $$slotProps) => {
                var fragment_5 = comment();
                var node_5 = first_child(fragment_5);
                add_svelte_meta(() => snippet(node_5, () => $$props.children ?? noop), "render", Layer, 35, 4);
                append($$anchor4, fragment_5);
              }),
              $$slots: { default: true }
            })),
            "component",
            Layer,
            34,
            2,
            { componentTag: "Svg" }
          );
          append($$anchor3, fragment_4);
        };
        var alternate = ($$anchor3) => {
          var fragment_6 = comment();
          var node_6 = first_child(fragment_6);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_7 = comment();
              var node_7 = first_child(fragment_7);
              add_svelte_meta(
                () => Html_default(node_7, spread_props(() => restProps, {
                  children: wrap_snippet(Layer, ($$anchor5, $$slotProps) => {
                    var fragment_8 = comment();
                    var node_8 = first_child(fragment_8);
                    add_svelte_meta(() => snippet(node_8, () => $$props.children ?? noop), "render", Layer, 39, 4);
                    append($$anchor5, fragment_8);
                  }),
                  $$slots: { default: true }
                })),
                "component",
                Layer,
                38,
                2,
                { componentTag: "Html" }
              );
              append($$anchor4, fragment_7);
            };
            add_svelte_meta(
              () => if_block(
                node_6,
                ($$render) => {
                  if (strict_equals($$props.type, "html")) $$render(consequent_2);
                },
                true
              ),
              "if",
              Layer,
              37,
              0
            );
          }
          append($$anchor3, fragment_6);
        };
        add_svelte_meta(
          () => if_block(
            node_3,
            ($$render) => {
              if (strict_equals($$props.type, "svg")) $$render(consequent_1);
              else $$render(alternate, false);
            },
            true
          ),
          "if",
          Layer,
          33,
          0
        );
      }
      append($$anchor2, fragment_3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals($$props.type, "canvas")) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Layer,
      29,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Layer = hmr(Layer, () => Layer[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Layer[HMR].source;
    set(Layer[HMR].source, module2.default[HMR].original);
  });
}
var Layer_default = Layer;

// node_modules/layerchart/dist/components/ColorRamp.svelte
ColorRamp[FILENAME] = "node_modules/layerchart/dist/components/ColorRamp.svelte";
var root10 = add_locations(from_svg(`<image></image>`), ColorRamp[FILENAME], [[80, 0]]);
function ColorRamp($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ColorRamp);
  let steps = prop($$props, "steps", 3, 10), height = prop($$props, "height", 3, "20px"), width = prop($$props, "width", 3, "100%"), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "interpolator",
      "steps",
      "height",
      "width",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  let href = tag(state(""), "href");
  user_effect(() => {
    const canvas = document.createElement("canvas");
    canvas.width = steps();
    canvas.height = 1;
    const context = canvas.getContext("2d");
    for (let i = 0; i < steps(); ++i) {
      if ($$props.interpolator) {
        context.fillStyle = $$props.interpolator(i / (steps() - 1));
      }
      context.fillRect(i, 0, 1, 1);
    }
    set(href, canvas.toDataURL(), true);
  });
  var image = root10();
  attribute_effect(
    image,
    ($0) => ({
      href: get(href),
      preserveAspectRatio: "none",
      height: height(),
      width: width(),
      ...$0
    }),
    [() => extractLayerProps(restProps, "color-ramp")]
  );
  bind_this(image, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, image);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ColorRamp = hmr(ColorRamp, () => ColorRamp[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ColorRamp[HMR].source;
    set(ColorRamp[HMR].source, module2.default[HMR].original);
  });
}
var ColorRamp_default = ColorRamp;

// node_modules/layerchart/dist/components/Legend.svelte
Legend[FILENAME] = "node_modules/layerchart/dist/components/Legend.svelte";
var root_72 = add_locations(from_svg(`<rect></rect>`), Legend[FILENAME], [[346, 12]]);
var root_92 = add_locations(from_svg(`<line></line>`), Legend[FILENAME], [[369, 12]]);
var root_82 = add_locations(from_svg(`<text text-anchor="middle"> </text><!>`, 1), Legend[FILENAME], [[353, 10]]);
var root_36 = add_locations(from_svg(`<svg><g><!></g><g></g></svg>`), Legend[FILENAME], [[330, 4, [[336, 6], [351, 6]]]]);
var on_click2 = (e, $$props, item) => $$props.onclick?.(e, get(item));
var root_123 = add_locations(from_html(`<button><div></div> <div> </div></button>`), Legend[FILENAME], [[392, 8, [[403, 10], [411, 10]]]]);
var root_11 = add_locations(from_html(`<div></div>`), Legend[FILENAME], [[381, 4]]);
var root11 = add_locations(from_html(`<div><div> </div> <!></div>`), Legend[FILENAME], [[295, 0, [[321, 2]]]]);
function Legend($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Legend);
  let title = prop($$props, "title", 3, ""), width = prop($$props, "width", 3, 320), height = prop($$props, "height", 3, 10), ticks2 = prop($$props, "ticks", 19, () => width() / 64), tickFontSize = prop($$props, "tickFontSize", 3, 10), tickLengthProp = prop($$props, "tickLength", 3, 4), orientation = prop($$props, "orientation", 3, "horizontal"), variant = prop($$props, "variant", 3, "ramp"), classes = prop($$props, "classes", 19, () => ({})), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "scale",
      "title",
      "width",
      "height",
      "ticks",
      "tickFormat",
      "tickValues",
      "tickFontSize",
      "tickLength",
      "placement",
      "orientation",
      "onclick",
      "onpointerenter",
      "onpointerleave",
      "variant",
      "classes",
      "ref",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const ctx = getChartContext();
  const scale2 = tag(user_derived(() => $$props.scale ?? ctx.cScale), "scale");
  const scaleConfig = tag(
    user_derived(() => {
      if (!get(scale2)) {
        return {
          xScale: void 0,
          interpolator: void 0,
          swatches: void 0,
          tickLabelOffset: 0,
          tickLine: true,
          tickLength: tickLengthProp(),
          tickFormat: $$props.tickFormat,
          tickValues: $$props.tickValues
        };
      } else if (get(scale2).interpolate) {
        const n = Math.min(get(scale2).domain().length, get(scale2).range().length);
        const xScale = get(scale2).copy().rangeRound?.(quantize_default(value_default(0, width()), n));
        const interpolator = get(scale2).copy().domain(quantize_default(value_default(0, 1), n));
        const _tickFormat = $$props.tickFormat ?? xScale?.tickFormat?.();
        return {
          xScale,
          interpolator,
          tickFormat: _tickFormat,
          tickLabelOffset: 0,
          tickLine: true,
          tickValues: $$props.tickValues,
          tickLength: tickLengthProp(),
          swatches: void 0
        };
      } else if (get(scale2).interpolator) {
        const xScale = Object.assign(get(scale2).copy().interpolator(round_default2(0, width())), {
          range() {
            return [0, width()];
          }
        });
        const interpolator = get(scale2).interpolator();
        let tickValues = $$props.tickValues;
        if (!xScale.ticks) {
          if (strict_equals(tickValues, void 0)) {
            const n = Math.round(ticks2() + 1);
            tickValues = range(n).map((i) => quantile(get(scale2).domain(), i / (n - 1)));
          }
        }
        const tickFormat2 = $$props.tickFormat ?? xScale.tickFormat?.();
        return {
          interpolator,
          tickValues,
          tickFormat: tickFormat2,
          swatches: void 0,
          tickLabelOffset: 0,
          tickLine: true,
          tickLength: tickLengthProp(),
          xScale
        };
      } else if (get(scale2).invertExtent) {
        const thresholds = get(scale2).thresholds ? get(
          scale2
          // scaleQuantize
        ).thresholds() : get(scale2).quantiles ? get(
          scale2
          // scaleQuantile
        ).quantiles() : get(
          scale2
          // scaleThreshold
        ).domain();
        const xScale = linear2().domain([-1, get(scale2).range().length - 1]).rangeRound([0, width()]);
        const swatches = get(scale2).range().map((d, i) => {
          return {
            x: xScale(i - 1),
            y: 0,
            width: xScale(i) - xScale(i - 1),
            height: height(),
            fill: d
          };
        });
        const tickValues = range(thresholds.length);
        const tickFormat2 = (i) => {
          const value2 = thresholds[i];
          return $$props.tickFormat ? format(value2, $$props.tickFormat) : value2;
        };
        return {
          xScale,
          swatches,
          tickValues,
          tickFormat: tickFormat2,
          tickLabelOffset: 0,
          tickLine: true,
          tickLength: tickLengthProp(),
          interpolator: void 0
        };
      } else {
        const xScale = band().domain(get(scale2).domain()).rangeRound([0, width()]);
        const swatches = get(scale2).domain().map((d) => {
          return {
            x: xScale(d),
            y: 0,
            width: Math.max(0, xScale.bandwidth() - 1),
            height: height(),
            fill: get(scale2)(d)
          };
        });
        const tickValues = get(scale2).domain();
        const tickLabelOffset = xScale.bandwidth() / 2;
        const tickLine = false;
        const tickLength = 0;
        return {
          xScale,
          tickFormat: $$props.tickFormat,
          tickLabelOffset,
          tickLine,
          tickLength,
          tickValues,
          swatches,
          interpolator: void 0
        };
      }
    }),
    "scaleConfig"
  );
  var div = root11();
  attribute_effect(div, ($0) => ({ ...restProps, "data-placement": $$props.placement, class: $0 }), [
    () => cls(
      layerClass("legend-container"),
      "inline-block",
      "z-1",
      // stack above tooltip context layers (band rects, voronoi, ...)
      $$props.placement && [
        "absolute",
        {
          "top-left": "top-0 left-0",
          top: "top-0 left-1/2 -translate-x-1/2",
          "top-right": "top-0 right-0",
          left: "top-1/2 left-0 -translate-y-1/2",
          center: "top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
          right: "top-1/2 right-0 -translate-y-1/2",
          "bottom-left": "bottom-0 left-0",
          bottom: "bottom-0 left-1/2 -translate-x-1/2",
          "bottom-right": "bottom-0 right-0"
        }[$$props.placement]
      ],
      $$props.class,
      classes().root
    )
  ]);
  var div_1 = child(div);
  var text2 = child(div_1, true);
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      {
        let $0 = user_derived(() => ({
          values: get(scaleConfig).tickValues ?? get(scaleConfig).xScale?.ticks?.(ticks2()) ?? [],
          scale: get(scale2)
        }));
        add_svelte_meta(() => snippet(node_1, () => $$props.children, () => get($0)), "render", Legend, 325, 4);
      }
      append($$anchor2, fragment);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent_4 = ($$anchor3) => {
          var svg = root_36();
          var g = child(svg);
          var node_3 = child(g);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_2 = comment();
              var node_4 = first_child(fragment_2);
              {
                let $0 = user_derived(() => layerClass("legend-color-ramp"));
                add_svelte_meta(
                  () => ColorRamp_default(node_4, {
                    get width() {
                      return width();
                    },
                    get height() {
                      return height();
                    },
                    get interpolator() {
                      return get(scaleConfig).interpolator;
                    },
                    get class() {
                      return get($0);
                    }
                  }),
                  "component",
                  Legend,
                  338,
                  10,
                  { componentTag: "ColorRamp" }
                );
              }
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var fragment_3 = comment();
              var node_5 = first_child(fragment_3);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_6 = first_child(fragment_4);
                  add_svelte_meta(
                    () => each(node_6, 17, () => get(scaleConfig).swatches, index, ($$anchor6, swatch) => {
                      var rect = root_72();
                      attribute_effect(rect, ($0) => ({ ...$0 }), [() => extractLayerProps(get(swatch), "legend-swatch")]);
                      append($$anchor6, rect);
                    }),
                    "each",
                    Legend,
                    345,
                    10
                  );
                  append($$anchor5, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(
                    node_5,
                    ($$render) => {
                      if (get(scaleConfig).swatches) $$render(consequent_2);
                    },
                    true
                  ),
                  "if",
                  Legend,
                  344,
                  8
                );
              }
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if (get(scaleConfig).interpolator) $$render(consequent_1);
                else $$render(alternate, false);
              }),
              "if",
              Legend,
              337,
              8
            );
          }
          reset(g);
          var g_1 = sibling(g);
          add_svelte_meta(
            () => each(g_1, 21, () => $$props.tickValues ?? get(scaleConfig).xScale?.ticks?.(ticks2()) ?? [], index, ($$anchor4, tick2) => {
              var fragment_5 = root_82();
              var text_1 = first_child(fragment_5);
              let styles;
              var text_2 = child(text_1, true);
              reset(text_1);
              var node_7 = sibling(text_1);
              {
                var consequent_3 = ($$anchor5) => {
                  var line = root_92();
                  set_attribute(line, "y1", 0);
                  template_effect(
                    ($0, $1, $2) => {
                      set_attribute(line, "x1", $0);
                      set_attribute(line, "x2", $1);
                      set_attribute(line, "y2", height() + tickLengthProp());
                      set_class(line, 0, $2);
                    },
                    [
                      () => get(scaleConfig).xScale?.(get(tick2)),
                      () => get(scaleConfig).xScale?.(get(tick2)),
                      () => clsx(cls(layerClass("legend-tick-line"), "stroke-surface-content", classes().tick))
                    ]
                  );
                  append($$anchor5, line);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if (get(scaleConfig).tickLine) $$render(consequent_3);
                  }),
                  "if",
                  Legend,
                  368,
                  10
                );
              }
              template_effect(
                ($0, $1, $2, $3) => {
                  set_attribute(text_1, "x", $0);
                  set_attribute(text_1, "y", height() + tickLengthProp() + tickFontSize());
                  set_class(text_1, 0, $1);
                  styles = set_style(text_1, "", styles, $2);
                  set_text(text_2, $3);
                },
                [
                  () => get(scaleConfig).xScale?.(get(tick2)) + get(scaleConfig).tickLabelOffset,
                  () => clsx(cls(layerClass("legend-tick-text"), "text-[10px] fill-surface-content", classes().label)),
                  () => ({ "font-size": tickFontSize() }),
                  () => $$props.tickFormat ? format(get(tick2), asAny($$props.tickFormat)) : get(tick2)
                ]
              );
              append($$anchor4, fragment_5);
            }),
            "each",
            Legend,
            352,
            8
          );
          reset(g_1);
          reset(svg);
          template_effect(
            ($0, $1, $2) => {
              set_attribute(svg, "width", width());
              set_attribute(svg, "height", height() + tickLengthProp() + tickFontSize());
              set_attribute(svg, "viewBox", `0 0 ${width() ?? ""} ${height() + tickLengthProp() + tickFontSize()}`);
              set_class(svg, 0, $0);
              set_class(g, 0, $1);
              set_class(g_1, 0, $2);
            },
            [
              () => clsx(cls(layerClass("legend-ramp-svg"), "overflow-visible")),
              () => clsx(layerClass("legend-ramp-g")),
              () => clsx(layerClass("legend-tick-group"))
            ]
          );
          append($$anchor3, svg);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_6 = comment();
          var node_8 = first_child(fragment_6);
          {
            var consequent_5 = ($$anchor4) => {
              var div_2 = root_11();
              add_svelte_meta(
                () => each(div_2, 21, () => get(scaleConfig).tickValues ?? get(scaleConfig).xScale?.ticks?.(ticks2()) ?? [], index, ($$anchor5, tick2) => {
                  var button = root_123();
                  const color2 = tag(user_derived(() => get(scale2)?.(get(tick2)) ?? ""), "color");
                  get(color2);
                  const item = tag(user_derived(() => ({ value: get(tick2), color: get(color2) })), "item");
                  get(item);
                  button.__click = [on_click2, $$props, item];
                  var div_3 = child(button);
                  let styles_1;
                  var div_4 = sibling(div_3, 2);
                  var text_3 = child(div_4, true);
                  reset(div_4);
                  reset(button);
                  template_effect(
                    ($0, $1, $2, $3, $4) => {
                      set_class(button, 1, $0);
                      set_class(div_3, 1, $1);
                      styles_1 = set_style(div_3, "", styles_1, $2);
                      set_class(div_4, 1, $3);
                      set_text(text_3, $4);
                    },
                    [
                      () => clsx(cls(layerClass("legend-swatch-button"), "flex items-center gap-1 truncate", !$$props.onclick && "cursor-auto", strict_equals(typeof classes().item, "function") ? classes().item(get(item)) : classes().item)),
                      () => clsx(cls(layerClass("legend-swatch"), "h-4 w-4 shrink-0 rounded-full", classes().swatch)),
                      () => ({ "background-color": get(color2) }),
                      () => clsx(cls(layerClass("legend-swatch-label"), "text-xs text-surface-content truncate whitespace-nowrap", classes().label)),
                      () => $$props.tickFormat ? format(get(tick2), asAny($$props.tickFormat)) : get(tick2)
                    ]
                  );
                  event("pointerenter", button, (e) => $$props.onpointerenter?.(e, get(item)));
                  event("pointerleave", button, (e) => $$props.onpointerleave?.(e, get(item)));
                  append($$anchor5, button);
                }),
                "each",
                Legend,
                389,
                6
              );
              reset(div_2);
              template_effect(($0) => set_class(div_2, 1, $0), [
                () => clsx(cls(layerClass("legend-swatch-group"), "flex gap-x-4 gap-y-1", strict_equals(orientation(), "vertical") && "flex-col", classes().items))
              ]);
              append($$anchor4, div_2);
            };
            add_svelte_meta(
              () => if_block(
                node_8,
                ($$render) => {
                  if (strict_equals(variant(), "swatches")) $$render(consequent_5);
                },
                true
              ),
              "if",
              Legend,
              380,
              2
            );
          }
          append($$anchor3, fragment_6);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(variant(), "ramp")) $$render(consequent_4);
              else $$render(alternate_1, false);
            },
            true
          ),
          "if",
          Legend,
          329,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate_2, false);
      }),
      "if",
      Legend,
      324,
      2
    );
  }
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(
    ($0) => {
      set_class(div_1, 1, $0);
      set_text(text2, title());
    },
    [
      () => clsx(cls(layerClass("legend-title"), "text-[10px] font-semibold", classes().title))
    ]
  );
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Legend = hmr(Legend, () => Legend[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Legend[HMR].source;
    set(Legend[HMR].source, module2.default[HMR].original);
  });
}
var Legend_default = Legend;
delegate(["click"]);

// node_modules/layerchart/dist/components/tooltip/index.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Context: () => TooltipContext_default,
  Header: () => TooltipHeader_default,
  Item: () => TooltipItem_default,
  List: () => TooltipList_default,
  Root: () => Tooltip_default,
  Separator: () => TooltipSeparator_default,
  getTooltipContext: () => getTooltipContext
});

// node_modules/layerchart/dist/components/tooltip/TooltipHeader.svelte
TooltipHeader[FILENAME] = "node_modules/layerchart/dist/components/tooltip/TooltipHeader.svelte";
var root_16 = add_locations(from_html(`<div></div>`), TooltipHeader[FILENAME], [[103, 4]]);
var root12 = add_locations(from_html(`<div><!> <!></div>`), TooltipHeader[FILENAME], [[91, 0]]);
function TooltipHeader($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TooltipHeader);
  let refProp = prop($$props, "ref", 15), colorRefProp = prop($$props, "colorRef", 15), classes = prop($$props, "classes", 19, () => ({ root: "", color: "" })), props = prop($$props, "props", 19, () => ({ root: {}, color: {} })), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "colorRef",
      "value",
      "format",
      "color",
      "classes",
      "props",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  let colorRef = tag(state(void 0), "colorRef");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    colorRefProp(get(colorRef));
  });
  var div = root12();
  attribute_effect(div, ($0) => ({ class: $0, ...restProps }), [
    () => cls(layerClass("tooltip-header"), "font-semibold whitespace-nowrap border-b mb-1 pb-1 flex items-center gap-2", classes().root, props().root?.class, $$props.class)
  ]);
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var div_1 = root_16();
      let styles;
      bind_this(div_1, ($$value) => set(colorRef, $$value), () => get(colorRef));
      template_effect(
        ($0, $1) => {
          set_class(div_1, 1, $0);
          styles = set_style(div_1, "", styles, $1);
        },
        [
          () => clsx(cls(layerClass("tooltip-header-color"), "color", "inline-block size-2 rounded-full bg-[var(--color)]", classes().color)),
          () => ({ "--color": $$props.color })
        ]
      );
      append($$anchor2, div_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.color) $$render(consequent);
      }),
      "if",
      TooltipHeader,
      102,
      2
    );
  }
  var node_1 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", TooltipHeader, 115, 4);
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var text2 = text();
      template_effect(($0) => set_text(text2, $0), [
        () => $$props.format ? format($$props.value, asAny($$props.format)) : $$props.value
      ]);
      append($$anchor2, text2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.children) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      TooltipHeader,
      114,
      2
    );
  }
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipHeader = hmr(TooltipHeader, () => TooltipHeader[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TooltipHeader[HMR].source;
    set(TooltipHeader[HMR].source, module2.default[HMR].original);
  });
}
var TooltipHeader_default = TooltipHeader;

// node_modules/layerchart/dist/components/tooltip/TooltipItem.svelte
TooltipItem[FILENAME] = "node_modules/layerchart/dist/components/tooltip/TooltipItem.svelte";
var root_17 = add_locations(from_html(`<div></div>`), TooltipItem[FILENAME], [[154, 6]]);
var root13 = add_locations(from_html(`<div><div><!> <!></div> <div><!></div></div>`), TooltipItem[FILENAME], [[130, 0, [[142, 2], [174, 2]]]]);
function TooltipItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TooltipItem);
  let refProp = prop($$props, "ref", 15), labelRefProp = prop($$props, "labelRef", 15), valueRefProp = prop($$props, "valueRef", 15), colorRefProp = prop($$props, "colorRef", 15), valueAlign = prop($$props, "valueAlign", 3, "left"), classes = prop($$props, "classes", 19, () => ({ root: "", label: "", value: "", color: "" })), props = prop($$props, "props", 19, () => ({ root: {}, label: {}, value: {}, color: {} })), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "labelRef",
      "valueRef",
      "colorRef",
      "label",
      "value",
      "format",
      "valueAlign",
      "color",
      "classes",
      "props",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  let labelRef = tag(state(void 0), "labelRef");
  let valueRef = tag(state(void 0), "valueRef");
  let colorRef = tag(state(void 0), "colorRef");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    labelRefProp(get(labelRef));
  });
  user_pre_effect(() => {
    valueRefProp(get(valueRef));
  });
  user_pre_effect(() => {
    colorRefProp(get(colorRef));
  });
  var div = root13();
  attribute_effect(div, ($0) => ({ ...props().root, class: $0, ...restProps }), [
    () => cls(layerClass("tooltip-item-root"), "contents", classes().root, $$props.class, props().root?.class)
  ]);
  var div_1 = child(div);
  attribute_effect(div_1, ($0) => ({ ...props().label, class: $0 }), [
    () => cls(layerClass("tooltip-item-label"), "label", "flex items-center gap-2 whitespace-nowrap", classes().label, props().label?.class)
  ]);
  var node = child(div_1);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_17();
      attribute_effect(div_2, ($0, $1) => ({ ...props().color, class: $0, [STYLE]: $1 }), [
        () => cls(layerClass("tooltip-item-color"), "color", "inline-block size-2 rounded-full bg-[var(--color)]", classes().color, props().color?.class),
        () => ({ "--color": $$props.color })
      ]);
      bind_this(div_2, ($$value) => set(colorRef, $$value), () => get(colorRef));
      append($$anchor2, div_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.color) $$render(consequent);
      }),
      "if",
      TooltipItem,
      153,
      4
    );
  }
  var node_1 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      add_svelte_meta(() => snippet(node_2, () => $$props.label), "render", TooltipItem, 168, 6);
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, $$props.label));
      append($$anchor2, text2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (strict_equals(typeof $$props.label, "function")) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      TooltipItem,
      167,
      4
    );
  }
  reset(div_1);
  bind_this(div_1, ($$value) => set(labelRef, $$value), () => get(labelRef));
  var div_3 = sibling(div_1, 2);
  attribute_effect(div_3, ($0) => ({ ...props().value, class: $0 }), [
    () => cls(
      layerClass("tooltip-item-value"),
      "value",
      "tabular-nums",
      {
        "text-right": strict_equals(valueAlign(), "right"),
        "text-center": strict_equals(valueAlign(), "center")
      },
      classes().value,
      props().value?.class
    )
  ]);
  var node_3 = child(div_3);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_4 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_4, () => $$props.children), "render", TooltipItem, 190, 6);
      append($$anchor2, fragment_2);
    };
    var alternate_1 = ($$anchor2) => {
      var text_1 = text();
      template_effect(($0) => set_text(text_1, $0), [
        () => $$props.format ? format($$props.value, asAny($$props.format)) : $$props.value
      ]);
      append($$anchor2, text_1);
    };
    add_svelte_meta(
      () => if_block(node_3, ($$render) => {
        if ($$props.children) $$render(consequent_2);
        else $$render(alternate_1, false);
      }),
      "if",
      TooltipItem,
      189,
      4
    );
  }
  reset(div_3);
  bind_this(div_3, ($$value) => set(valueRef, $$value), () => get(valueRef));
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipItem = hmr(TooltipItem, () => TooltipItem[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TooltipItem[HMR].source;
    set(TooltipItem[HMR].source, module2.default[HMR].original);
  });
}
var TooltipItem_default = TooltipItem;

// node_modules/layerchart/dist/components/tooltip/TooltipList.svelte
TooltipList[FILENAME] = "node_modules/layerchart/dist/components/tooltip/TooltipList.svelte";
var root14 = add_locations(from_html(`<div><!></div>`), TooltipList[FILENAME], [[22, 0]]);
function TooltipList($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TooltipList);
  let refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  var div = root14();
  attribute_effect(div, ($0) => ({ class: $0, ...restProps }), [
    () => cls(layerClass("tooltip-list"), "grid grid-cols-[1fr_auto] gap-x-2 gap-y-1 items-start", $$props.class)
  ]);
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", TooltipList, 31, 2);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipList = hmr(TooltipList, () => TooltipList[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TooltipList[HMR].source;
    set(TooltipList[HMR].source, module2.default[HMR].original);
  });
}
var TooltipList_default = TooltipList;

// node_modules/layerchart/dist/components/tooltip/TooltipSeparator.svelte
TooltipSeparator[FILENAME] = "node_modules/layerchart/dist/components/tooltip/TooltipSeparator.svelte";
var root15 = add_locations(from_html(`<div><!></div>`), TooltipSeparator[FILENAME], [[21, 0]]);
function TooltipSeparator($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TooltipSeparator);
  let refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "class",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  var div = root15();
  attribute_effect(div, ($0) => ({ class: $0, ...restProps }), [
    () => cls(layerClass("tooltip-separator"), "rounded-sm bg-surface-content/20 my-1 col-span-full h-px", $$props.class)
  ]);
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", TooltipSeparator, 30, 2);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TooltipSeparator = hmr(TooltipSeparator, () => TooltipSeparator[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TooltipSeparator[HMR].source;
    set(TooltipSeparator[HMR].source, module2.default[HMR].original);
  });
}
var TooltipSeparator_default = TooltipSeparator;

// node_modules/layerchart/dist/components/tooltip/Tooltip.svelte
Tooltip[FILENAME] = "node_modules/layerchart/dist/components/tooltip/Tooltip.svelte";
var root_24 = add_locations(from_html(`<div><!></div>`), Tooltip[FILENAME], [[399, 8]]);
var root_18 = add_locations(from_html(`<div><div><!></div></div>`), Tooltip[FILENAME], [[360, 2, [[377, 4]]]]);
var $$css2 = {
  hash: "s-JPGPXkRs_IeU",
  code: "\n  .root.s-JPGPXkRs_IeU {\n    position: absolute;\n    z-index: 50;\n    user-select: none;\n  }\n\n  .pointer-events-none.s-JPGPXkRs_IeU {\n    pointer-events: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9vbHRpcC5zdmVsdGUiLCJzb3VyY2VzIjpbIlRvb2x0aXAuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCIgbW9kdWxlPlxuICBpbXBvcnQgdHlwZSB7IEhUTUxBdHRyaWJ1dGVzIH0gZnJvbSAnc3ZlbHRlL2VsZW1lbnRzJztcbiAgaW1wb3J0IHR5cGUgeyBXaXRob3V0IH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZXMuanMnO1xuICBpbXBvcnQgdHlwZSB7IFRvb2x0aXBQYXlsb2FkIH0gZnJvbSAnLi90b29sdGlwTWV0YUNvbnRleHQuanMnO1xuICBpbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuICBleHBvcnQgdHlwZSBBbGlnbiA9ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnO1xuXG4gIGV4cG9ydCB0eXBlIFRvb2x0aXBQcm9wc1dpdGhvdXRIVE1MPFQgPSBhbnk+ID0ge1xuICAgIC8qKlxuICAgICAqIGB4YCBwb3NpdGlvbiBvZiB0b29sdGlwLiAgQnkgZGVmYXVsdCB1c2VzIHRoZSBwb2ludGVyL21vdXNlLCBjYW4gYWxzbyBzbmFwIHRvIGRhdGEgb3IgYW5cbiAgICAgKiBleHBsaWNpdCBmaXhlZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0ICdwb2ludGVyJ1xuICAgICAqL1xuICAgIHg/OiAncG9pbnRlcicgfCAnZGF0YScgfCBudW1iZXI7XG4gICAgLyoqXG4gICAgICogYHlgIHBvc2l0aW9uIG9mIHRvb2x0aXAuICBCeSBkZWZhdWx0IHVzZXMgdGhlIHBvaW50ZXIvbW91c2UsIGNhbiBhbHNvIHNuYXAgdG8gZGF0YSBvciBhblxuICAgICAqIGV4cGxpY2l0IGZpeGVkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJ3BvaW50ZXInXG4gICAgICovXG4gICAgeT86ICdwb2ludGVyJyB8ICdkYXRhJyB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBhZGRlZCB0byBgeGAgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IHggPT09ICdwb2ludGVyJyA/IDEwIDogMFxuICAgICAqL1xuICAgIHhPZmZzZXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgYWRkZWQgdG8gYHlgIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCB5ID09PSAncG9pbnRlcicgPyAxMCA6IDBcbiAgICAgKi9cbiAgICB5T2Zmc2V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWxpZ24gYmFzZWQgb24gZWRnZSBvZiB0b29sdGlwXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAndG9wLWxlZnQnXG4gICAgICovXG4gICAgYW5jaG9yPzogUGxhY2VtZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbW90aW9uIHN0YXRlIG9mIHRoZSB0b29sdGlwLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgXCJzcHJpbmdcIlxuICAgICAqL1xuICAgIG1vdGlvbj86IE1vdGlvblByb3A7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBwb2ludGVyIGV2ZW50cy4gIERpc2FibGVkIGJ5IGRlZmF1bHQgdG8gcmVkdWNlIGFjY2lkZW50YWwgc2VsZWN0aW9uLCBidXQgdXNlZnVsIHRvXG4gICAgICogZW5hYmxlIHRvIGFsbG93IGludGVyYWN0aXZlIHRvb2x0aXBzICh1c2luZyBgbG9ja2VkYClcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcG9pbnRlckV2ZW50cz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIHBhZGRpbmcgYXJlYSAoZXguIGF4aXMpXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAnY29udGFpbmVyJ1xuICAgICAqL1xuICAgIGNvbnRhaW5lZD86ICdjb250YWluZXInIHwgJ3dpbmRvdycgfCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRvb2x0aXAgdmFyaWFudFxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAgICovXG4gICAgdmFyaWFudD86ICdkZWZhdWx0JyB8ICdpbnZlcnQnIHwgJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3NlcyB0byBhcHBseSB0byB0aGUgdmFyaW91cyBlbGVtZW50cyBvZiB0aGUgdG9vbHRpcC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICovXG4gICAgY2xhc3Nlcz86IHtcbiAgICAgIC8qKlxuICAgICAgICogQ2xhc3NlcyB0byBhcHBseSB0byB0aGUgcm9vdCB0b29sdGlwIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgcm9vdD86IHN0cmluZztcbiAgICAgIC8qKlxuICAgICAgICogQ2xhc3NlcyB0byBhcHBseSB0byB0aGUgdG9vbHRpcCBjb250YWluZXIgZWxlbWVudFxuICAgICAgICovXG4gICAgICBjb250YWluZXI/OiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIENsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgY29udGVudCBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIENsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgaGVhZGVyIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgaGVhZGVyPzogc3RyaW5nO1xuICAgIH07XG5cbiAgICBjaGlsZHJlbj86IFNuaXBwZXQ8XG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgY2hhcnQgZGF0YSB0aGF0IHRyaWdnZXJlZCB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBkYXRhOiBUO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQW4gYXJyYXkgb2YgdG9vbHRpcCBwYXlsb2FkcywgZWFjaCBjb250YWluaW5nIGRhdGEgZm9yIGEgc3BlY2lmaWMgc2VyaWVzLFxuICAgICAgICAgICAqIGFsb25nIHdpdGggdGhlaXIgb3duIGBwYXlsb2FkYCBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBzYW1lIGRhdGEgYXMgYGRhdGFgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB3b3JraW5nIHdpdGggdGhlIHNpbXBsaWZpZWQgY2hhcnRzLCBzdWNoIGFzIGBBcmVhQ2hhcnRgLCBgQmFyQ2hhcnRgLFxuICAgICAgICAgICAqIGBQaWVDaGFydGAsIGV0Yy4sIHdoZXJlIHNlcmllcyBjb25zdHJ1Y3Rpb24gaXMgaGFuZGxlZCBpbnRlcm5hbGx5LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBheWxvYWQ6IFRvb2x0aXBQYXlsb2FkW107XG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgPjtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB0b29sdGlwJ3Mgb3V0ZXJtb3N0IGA8ZGl2PmAgdGFnLlxuICAgICAqXG4gICAgICogQGJpbmRhYmxlXG4gICAgICovXG4gICAgcm9vdFJlZj86IEhUTUxFbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogUHJvcHMgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyBlbGVtZW50cyByZW5kZXJlZFxuICAgICAqIGJ5IHRoZSBUb29sdGlwIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHByb3BzPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9wcyB0byBwYXNzIHRvIHRoZSByb290IHRvb2x0aXAgZWxlbWVudFxuICAgICAgICovXG4gICAgICByb290PzogSFRNTEF0dHJpYnV0ZXM8SFRNTEVsZW1lbnQ+O1xuICAgICAgLyoqXG4gICAgICAgKiBQcm9wcyB0byBwYXNzIHRvIHRoZSB0b29sdGlwIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIGNvbnRhaW5lcj86IEhUTUxBdHRyaWJ1dGVzPEhUTUxFbGVtZW50PjtcbiAgICAgIC8qKlxuICAgICAgICogUHJvcHMgdG8gcGFzcyB0byB0aGUgdG9vbHRpcCBjb250ZW50IGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudD86IEhUTUxBdHRyaWJ1dGVzPEhUTUxFbGVtZW50PjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWxseSBwYXNzIHRoZSBjaGFydCdzIGNvbnRleHQgdG8gdGhlIHRvb2x0aXAgdG8gZ2V0XG4gICAgICogdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIGNvbnRleHQ/OiBDaGFydENvbnRleHRWYWx1ZTxULCBhbnksIGFueT47XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgVG9vbHRpcFByb3BzPFQgPSBhbnk+ID0gVG9vbHRpcFByb3BzV2l0aG91dEhUTUw8VD4gJlxuICAgIFdpdGhvdXQ8SFRNTEF0dHJpYnV0ZXM8SFRNTEVsZW1lbnQ+LCBUb29sdGlwUHJvcHNXaXRob3V0SFRNTDxUPj47XG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIiBnZW5lcmljcz1cIlQgPSBhbnlcIj5cbiAgaW1wb3J0IHsgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcbiAgaW1wb3J0IHsgY2xzIH0gZnJvbSAnQGxheWVyc3RhY2svdGFpbHdpbmQnO1xuXG4gIGltcG9ydCB7IGlzU2NhbGVCYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvc2NhbGVzLnN2ZWx0ZS5qcyc7XG4gIGltcG9ydCB7IGdldENoYXJ0Q29udGV4dCwgdHlwZSBDaGFydENvbnRleHRWYWx1ZSB9IGZyb20gJy4uL0NoYXJ0LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldFRvb2x0aXBDb250ZXh0IH0gZnJvbSAnLi9Ub29sdGlwQ29udGV4dC5zdmVsdGUnO1xuICBpbXBvcnQgeyBjcmVhdGVNb3Rpb24sIHR5cGUgTW90aW9uUHJvcCB9IGZyb20gJy4uLy4uL3V0aWxzL21vdGlvbi5zdmVsdGUuanMnO1xuICBpbXBvcnQgeyB1bnRyYWNrLCB0eXBlIFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBsYXllckNsYXNzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXR0cmlidXRlcy5qcyc7XG5cbiAgbGV0IHtcbiAgICBhbmNob3IgPSAndG9wLWxlZnQnLFxuICAgIGNsYXNzZXMgPSB7fSxcbiAgICBjb250YWluZWQgPSAnY29udGFpbmVyJyxcbiAgICBtb3Rpb24gPSAnc3ByaW5nJyxcbiAgICBwb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgdmFyaWFudCA9ICdkZWZhdWx0JyxcbiAgICB4ID0gJ3BvaW50ZXInLFxuICAgIHhPZmZzZXQgPSB4ID09PSAncG9pbnRlcicgPyAxMCA6IDAsXG4gICAgeSA9ICdwb2ludGVyJyxcbiAgICB5T2Zmc2V0ID0geSA9PT0gJ3BvaW50ZXInID8gMTAgOiAwLFxuICAgIGNoaWxkcmVuLFxuICAgIHJvb3RSZWY6IHJvb3RSZWZQcm9wID0gJGJpbmRhYmxlKCksXG4gICAgcHJvcHMgPSB7XG4gICAgICByb290OiB7fSxcbiAgICAgIGNvbnRhaW5lcjoge30sXG4gICAgICBjb250ZW50OiB7fSxcbiAgICB9LFxuICAgIGNsYXNzOiBjbGFzc05hbWUsXG4gIH06IFRvb2x0aXBQcm9wczxUPiA9ICRwcm9wcygpO1xuXG4gIGxldCByb290UmVmID0gJHN0YXRlPEhUTUxFbGVtZW50PigpO1xuICAkZWZmZWN0LnByZSgoKSA9PiB7XG4gICAgcm9vdFJlZlByb3AgPSByb290UmVmO1xuICB9KTtcblxuICBjb25zdCBjdHggPSBnZXRDaGFydENvbnRleHQoKTtcbiAgY29uc3QgdG9vbHRpcEN0eCA9IGdldFRvb2x0aXBDb250ZXh0KCk7XG5cbiAgbGV0IHRvb2x0aXBXaWR0aCA9ICRzdGF0ZSgwKTtcbiAgbGV0IHRvb2x0aXBIZWlnaHQgPSAkc3RhdGUoMCk7XG5cbiAgZnVuY3Rpb24gYWxpZ25WYWx1ZSh2YWx1ZTogbnVtYmVyLCBhbGlnbjogQWxpZ24sIGFkZGl0aW9uYWxPZmZzZXQ6IG51bWJlciwgdG9vbHRpcFNpemU6IG51bWJlcikge1xuICAgIGNvbnN0IGFsaWduT2Zmc2V0ID0gYWxpZ24gPT09ICdjZW50ZXInID8gdG9vbHRpcFNpemUgLyAyIDogYWxpZ24gPT09ICdlbmQnID8gdG9vbHRpcFNpemUgOiAwO1xuICAgIHJldHVybiB2YWx1ZSArIChhbGlnbiA9PT0gJ2VuZCcgPyAtYWRkaXRpb25hbE9mZnNldCA6IGFkZGl0aW9uYWxPZmZzZXQpIC0gYWxpZ25PZmZzZXQ7XG4gIH1cblxuICBjb25zdCBwb3NpdGlvbnMgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgaWYgKCF0b29sdGlwQ3R4LmRhdGEpIHtcbiAgICAgIC8vIGlmIG5vIGRhdGEsIGZhbGxiYWNrP1xuICAgICAgY29uc3QgdG9vbHRpcFggPSB1bnRyYWNrKCgpID0+IHRvb2x0aXBDdHgueCk7XG4gICAgICBjb25zdCB0b29sdGlwWSA9IHVudHJhY2soKCkgPT4gdG9vbHRpcEN0eC55KTtcbiAgICAgIHJldHVybiB7IHg6IHRvb2x0aXBYLCB5OiB0b29sdGlwWSB9O1xuICAgIH1cbiAgICBjb25zdCB4QmFuZE9mZnNldCA9IGlzU2NhbGVCYW5kKGN0eC54U2NhbGUpXG4gICAgICA/IGN0eC54U2NhbGUuc3RlcCgpIC8gMiAtIChjdHgueFNjYWxlLnBhZGRpbmcoKSAqIGN0eC54U2NhbGUuc3RlcCgpKSAvIDJcbiAgICAgIDogMDtcblxuICAgIGNvbnN0IHhWYWx1ZTogbnVtYmVyID1cbiAgICAgIHR5cGVvZiB4ID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHhcbiAgICAgICAgOiB4ID09PSAnZGF0YSdcbiAgICAgICAgICA/IGN0eC54R2V0KHRvb2x0aXBDdHguZGF0YSkgKyBjdHgucGFkZGluZy5sZWZ0ICsgeEJhbmRPZmZzZXRcbiAgICAgICAgICA6IHRvb2x0aXBDdHgueDtcblxuICAgIGxldCB4QWxpZ246IEFsaWduID0gJ3N0YXJ0JztcbiAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHhBbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHhBbGlnbiA9ICdlbmQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCB5QmFuZE9mZnNldCA9IGlzU2NhbGVCYW5kKGN0eC55U2NhbGUpXG4gICAgICA/IGN0eC55U2NhbGUuc3RlcCgpIC8gMiAtIChjdHgueVNjYWxlLnBhZGRpbmcoKSAqIGN0eC55U2NhbGUuc3RlcCgpKSAvIDJcbiAgICAgIDogMDtcbiAgICBjb25zdCB5VmFsdWU6IG51bWJlciA9XG4gICAgICB0eXBlb2YgeSA9PT0gJ251bWJlcidcbiAgICAgICAgPyB5XG4gICAgICAgIDogeSA9PT0gJ2RhdGEnXG4gICAgICAgICAgPyBjdHgueUdldCh0b29sdGlwQ3R4LmRhdGEpICsgY3R4LnBhZGRpbmcudG9wICsgeUJhbmRPZmZzZXRcbiAgICAgICAgICA6IHRvb2x0aXBDdHgueTtcblxuICAgIGxldCB5QWxpZ246IEFsaWduID0gJ3N0YXJ0JztcbiAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgY2FzZSAndG9wJzpcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHlBbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHlBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHlBbGlnbiA9ICdlbmQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCByZWN0ID0ge1xuICAgICAgdG9wOiBhbGlnblZhbHVlKHlWYWx1ZSwgeUFsaWduLCB5T2Zmc2V0LCB0b29sdGlwSGVpZ2h0KSxcbiAgICAgIGxlZnQ6IGFsaWduVmFsdWUoeFZhbHVlLCB4QWxpZ24sIHhPZmZzZXQsIHRvb2x0aXBXaWR0aCksXG4gICAgICAvLyBzZXQgYmVsb3dcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH07XG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHRvb2x0aXBIZWlnaHQ7XG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHRvb2x0aXBXaWR0aDtcblxuICAgIGlmIChjb250YWluZWQgPT09ICdjb250YWluZXInKSB7XG4gICAgICAvLyBPbmx5IGF0dGVtcHQgcmVwb3NpdGlvbmluZyBpZiBub3QgZml4ZWQgKGllLiBgcG9pbnRlcmAvYGRhdGFgKVxuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDaGVjayBpZiBvdXRzaWRlIG9mIGNvbnRhaW5lciBhbmQgc3dhcCBhbGlnbiBzaWRlIGFjY29yZGluZ2x5XG4gICAgICAgIGlmICgoeEFsaWduID09PSAnc3RhcnQnIHx8IHhBbGlnbiA9PT0gJ2NlbnRlcicpICYmIHJlY3QucmlnaHQgPiBjdHguY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICByZWN0LmxlZnQgPSBhbGlnblZhbHVlKHhWYWx1ZSwgJ2VuZCcsIHhPZmZzZXQsIHRvb2x0aXBXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh4QWxpZ24gPT09ICdlbmQnIHx8IHhBbGlnbiA9PT0gJ2NlbnRlcicpICYmIHJlY3QubGVmdCA8IGN0eC5wYWRkaW5nLmxlZnQpIHtcbiAgICAgICAgICByZWN0LmxlZnQgPSBhbGlnblZhbHVlKHhWYWx1ZSwgJ3N0YXJ0JywgeE9mZnNldCwgdG9vbHRpcFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHRvb2x0aXBXaWR0aDtcblxuICAgICAgaWYgKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoKHlBbGlnbiA9PT0gJ3N0YXJ0JyB8fCB5QWxpZ24gPT09ICdjZW50ZXInKSAmJiByZWN0LmJvdHRvbSA+IGN0eC5jb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICByZWN0LnRvcCA9IGFsaWduVmFsdWUoeVZhbHVlLCAnZW5kJywgeU9mZnNldCwgdG9vbHRpcEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh5QWxpZ24gPT09ICdlbmQnIHx8IHlBbGlnbiA9PT0gJ2NlbnRlcicpICYmIHJlY3QudG9wIDwgY3R4LnBhZGRpbmcudG9wKSB7XG4gICAgICAgICAgcmVjdC50b3AgPSBhbGlnblZhbHVlKHlWYWx1ZSwgJ3N0YXJ0JywgeU9mZnNldCwgdG9vbHRpcEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyB0b29sdGlwSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVkID09PSAnd2luZG93Jykge1xuICAgICAgLy8gQ2hlY2sgaWYgb3V0c2lkZSBvZiB3aW5kb3cgLyB2aWV3cG9ydCBhbmQgc3dhcCBhbGlnbiBzaWRlIGFjY29yZGluZ2x5XG4gICAgICAvLyBSb290IDxkaXY+IHdvbid0IGJlIGF2YWlsYWJsZSBvbiBpbml0aWFsIG1vdW50XG4gICAgICBpZiAocm9vdFJlZj8ucGFyZW50RWxlbWVudCkge1xuICAgICAgICBjb25zdCBwYXJlbnRWaWV3cG9ydFJlY3QgPSByb290UmVmLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gT25seSBhdHRlbXB0IHJlcG9zaXRpb25pbmcgaWYgbm90IGZpeGVkIChpZS4gYHBvaW50ZXJgL2BkYXRhYClcbiAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh4QWxpZ24gPT09ICdzdGFydCcgfHwgeEFsaWduID09PSAnY2VudGVyJykgJiZcbiAgICAgICAgICAgIHBhcmVudFZpZXdwb3J0UmVjdC5sZWZ0ICsgcmVjdC5yaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZWN0LmxlZnQgPSBhbGlnblZhbHVlKHhWYWx1ZSwgJ2VuZCcsIHhPZmZzZXQsIHRvb2x0aXBXaWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh4QWxpZ24gPT09ICdlbmQnIHx8IHhBbGlnbiA9PT0gJ2NlbnRlcicpICYmXG4gICAgICAgICAgICBwYXJlbnRWaWV3cG9ydFJlY3QubGVmdCArIHJlY3QubGVmdCA8IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlY3QubGVmdCA9IGFsaWduVmFsdWUoeFZhbHVlLCAnc3RhcnQnLCB4T2Zmc2V0LCB0b29sdGlwV2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgdG9vbHRpcFdpZHRoO1xuXG4gICAgICAgIGlmICh0eXBlb2YgeSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeUFsaWduID09PSAnc3RhcnQnIHx8IHlBbGlnbiA9PT0gJ2NlbnRlcicpICYmXG4gICAgICAgICAgICBwYXJlbnRWaWV3cG9ydFJlY3QudG9wICsgcmVjdC5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlY3QudG9wID0gYWxpZ25WYWx1ZSh5VmFsdWUsICdlbmQnLCB5T2Zmc2V0LCB0b29sdGlwSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCh5QWxpZ24gPT09ICdlbmQnIHx8IHlBbGlnbiA9PT0gJ2NlbnRlcicpICYmIHBhcmVudFZpZXdwb3J0UmVjdC50b3AgKyByZWN0LnRvcCA8IDApIHtcbiAgICAgICAgICAgIHJlY3QudG9wID0gYWxpZ25WYWx1ZSh5VmFsdWUsICdzdGFydCcsIHlPZmZzZXQsIHRvb2x0aXBIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgdG9vbHRpcEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJlY3QubGVmdCxcbiAgICAgIHk6IHJlY3QudG9wLFxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IG1vdGlvblggPSBjcmVhdGVNb3Rpb24odG9vbHRpcEN0eC54LCAoKSA9PiBwb3NpdGlvbnMueCwgbW90aW9uKTtcbiAgY29uc3QgbW90aW9uWSA9IGNyZWF0ZU1vdGlvbih0b29sdGlwQ3R4LnksICgpID0+IHBvc2l0aW9ucy55LCBtb3Rpb24pO1xuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdG9vbHRpcEN0eC5kYXRhKSB7XG4gICAgICB0b29sdGlwQ3R4LmlzSG92ZXJpbmdUb29sdGlwQ29udGVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxueyNpZiB0b29sdGlwQ3R4LmRhdGF9XG4gIDxkaXZcbiAgICB7Li4ucHJvcHMucm9vdH1cbiAgICBjbGFzcz17Y2xzKCdyb290JywgbGF5ZXJDbGFzcygndG9vbHRpcC1yb290JyksIGNsYXNzZXMucm9vdCwgcHJvcHMucm9vdD8uY2xhc3MpfVxuICAgIGNsYXNzOnBvaW50ZXItZXZlbnRzLW5vbmU9eyFwb2ludGVyRXZlbnRzfVxuICAgIHN0eWxlOnRvcD1cInttb3Rpb25ZLmN1cnJlbnR9cHhcIlxuICAgIHN0eWxlOmxlZnQ9XCJ7bW90aW9uWC5jdXJyZW50fXB4XCJcbiAgICB0cmFuc2l0aW9uOmZhZGU9e3sgZHVyYXRpb246IDEwMCB9fVxuICAgIGJpbmQ6Y2xpZW50V2lkdGg9e3Rvb2x0aXBXaWR0aH1cbiAgICBiaW5kOmNsaWVudEhlaWdodD17dG9vbHRpcEhlaWdodH1cbiAgICBiaW5kOnRoaXM9e3Jvb3RSZWZ9XG4gICAgb25wb2ludGVyZW50ZXI9eygpID0+IHtcbiAgICAgIHRvb2x0aXBDdHguaXNIb3ZlcmluZ1Rvb2x0aXBDb250ZW50ID0gdHJ1ZTtcbiAgICB9fVxuICAgIG9ucG9pbnRlcmxlYXZlPXsoKSA9PiB7XG4gICAgICB0b29sdGlwQ3R4LmlzSG92ZXJpbmdUb29sdGlwQ29udGVudCA9IGZhbHNlO1xuICAgIH19XG4gID5cbiAgICA8ZGl2XG4gICAgICB7Li4ucHJvcHMuY29udGFpbmVyfVxuICAgICAgY2xhc3M9e2NscyhcbiAgICAgICAgbGF5ZXJDbGFzcygndG9vbHRpcC1jb250YWluZXInKSxcbiAgICAgICAgdmFyaWFudCAhPT0gJ25vbmUnICYmIFsndGV4dC1zbSBweS0xIHB4LTIgaC1mdWxsIHJvdW5kZWQtc20gZWxldmF0aW9uLTEnXSxcbiAgICAgICAge1xuICAgICAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgICAgICdiZy1zdXJmYWNlLTEwMC85MCBkYXJrOmJnLXN1cmZhY2UtMzAwLzkwIGJhY2tkcm9wLWZpbHRlciBiYWNrZHJvcC1ibHVyLVsycHhdIHRleHQtc3VyZmFjZS1jb250ZW50JyxcbiAgICAgICAgICAgICdbJl8ubGFiZWxdOnRleHQtc3VyZmFjZS1jb250ZW50Lzc1JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGludmVydDogW1xuICAgICAgICAgICAgJ2JnLXN1cmZhY2UtY29udGVudC85MCBiYWNrZHJvcC1maWx0ZXIgYmFja2Ryb3AtYmx1ci1bMnB4XSB0ZXh0LXN1cmZhY2UtMTAwIGJvcmRlciBib3JkZXItc3VyZmFjZS1jb250ZW50JyxcbiAgICAgICAgICAgICdbJl8ubGFiZWxdOnRleHQtc3VyZmFjZS0xMDAvNTAnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbm9uZTogJycsXG4gICAgICAgIH1bdmFyaWFudF0sXG4gICAgICAgIGNsYXNzZXMuY29udGFpbmVyLFxuICAgICAgICBwcm9wcy5jb250YWluZXI/LmNsYXNzLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgPlxuICAgICAgeyNpZiBjaGlsZHJlbn1cbiAgICAgICAgPGRpdiB7Li4ucHJvcHMuY29udGVudH0gY2xhc3M9e2NscyhsYXllckNsYXNzKCd0b29sdGlwLWNvbnRlbnQnKSwgY2xhc3Nlcy5jb250ZW50KX0+XG4gICAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4oeyBkYXRhOiB0b29sdGlwQ3R4LmRhdGEsIHBheWxvYWQ6IHRvb2x0aXBDdHgucGF5bG9hZCB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgLnJvb3Qge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiA1MDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuXG4gIC5wb2ludGVyLWV2ZW50cy1ub25lIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip);
  append_styles($$anchor, $$css2);
  let anchor = prop($$props, "anchor", 3, "top-left"), classes = prop($$props, "classes", 19, () => ({})), contained = prop($$props, "contained", 3, "container"), motion = prop($$props, "motion", 3, "spring"), pointerEvents = prop($$props, "pointerEvents", 3, false), variant = prop($$props, "variant", 3, "default"), x4 = prop($$props, "x", 3, "pointer"), xOffset = prop($$props, "xOffset", 19, () => strict_equals(x4(), "pointer") ? 10 : 0), y4 = prop($$props, "y", 3, "pointer"), yOffset = prop($$props, "yOffset", 19, () => strict_equals(y4(), "pointer") ? 10 : 0), rootRefProp = prop($$props, "rootRef", 15), props = prop($$props, "props", 19, () => ({ root: {}, container: {}, content: {} }));
  let rootRef = tag(state(void 0), "rootRef");
  user_pre_effect(() => {
    rootRefProp(get(rootRef));
  });
  const ctx = getChartContext();
  const tooltipCtx = getTooltipContext();
  let tooltipWidth = tag(state(0), "tooltipWidth");
  let tooltipHeight = tag(state(0), "tooltipHeight");
  function alignValue(value2, align, additionalOffset, tooltipSize) {
    const alignOffset = strict_equals(align, "center") ? tooltipSize / 2 : strict_equals(align, "end") ? tooltipSize : 0;
    return value2 + (strict_equals(align, "end") ? -additionalOffset : additionalOffset) - alignOffset;
  }
  const positions = tag(
    user_derived(() => {
      if (!tooltipCtx.data) {
        const tooltipX = untrack(() => tooltipCtx.x);
        const tooltipY = untrack(() => tooltipCtx.y);
        return { x: tooltipX, y: tooltipY };
      }
      const xBandOffset = isScaleBand(ctx.xScale) ? ctx.xScale.step() / 2 - ctx.xScale.padding() * ctx.xScale.step() / 2 : 0;
      const xValue = strict_equals(typeof x4(), "number") ? x4() : strict_equals(x4(), "data") ? ctx.xGet(tooltipCtx.data) + ctx.padding.left + xBandOffset : tooltipCtx.x;
      let xAlign = "start";
      switch (anchor()) {
        case "top-left":
        case "left":
        case "bottom-left":
          xAlign = "start";
          break;
        case "top":
        case "center":
        case "bottom":
          xAlign = "center";
          break;
        case "top-right":
        case "right":
        case "bottom-right":
          xAlign = "end";
          break;
      }
      const yBandOffset = isScaleBand(ctx.yScale) ? ctx.yScale.step() / 2 - ctx.yScale.padding() * ctx.yScale.step() / 2 : 0;
      const yValue = strict_equals(typeof y4(), "number") ? y4() : strict_equals(y4(), "data") ? ctx.yGet(tooltipCtx.data) + ctx.padding.top + yBandOffset : tooltipCtx.y;
      let yAlign = "start";
      switch (anchor()) {
        case "top-left":
        case "top":
        case "top-right":
          yAlign = "start";
          break;
        case "left":
        case "center":
        case "right":
          yAlign = "center";
          break;
        case "bottom-left":
        case "bottom":
        case "bottom-right":
          yAlign = "end";
          break;
      }
      const rect = {
        top: alignValue(yValue, yAlign, yOffset(), get(tooltipHeight)),
        left: alignValue(xValue, xAlign, xOffset(), get(tooltipWidth)),
        // set below
        bottom: 0,
        right: 0
      };
      rect.bottom = rect.top + get(tooltipHeight);
      rect.right = rect.left + get(tooltipWidth);
      if (strict_equals(contained(), "container")) {
        if (strict_equals(typeof x4(), "number", false)) {
          if ((strict_equals(xAlign, "start") || strict_equals(xAlign, "center")) && rect.right > ctx.containerWidth) {
            rect.left = alignValue(xValue, "end", xOffset(), get(tooltipWidth));
          }
          if ((strict_equals(xAlign, "end") || strict_equals(xAlign, "center")) && rect.left < ctx.padding.left) {
            rect.left = alignValue(xValue, "start", xOffset(), get(tooltipWidth));
          }
        }
        rect.right = rect.left + get(tooltipWidth);
        if (strict_equals(typeof y4(), "number", false)) {
          if ((strict_equals(yAlign, "start") || strict_equals(yAlign, "center")) && rect.bottom > ctx.containerHeight) {
            rect.top = alignValue(yValue, "end", yOffset(), get(tooltipHeight));
          }
          if ((strict_equals(yAlign, "end") || strict_equals(yAlign, "center")) && rect.top < ctx.padding.top) {
            rect.top = alignValue(yValue, "start", yOffset(), get(tooltipHeight));
          }
        }
        rect.bottom = rect.top + get(tooltipHeight);
      } else if (strict_equals(contained(), "window")) {
        if (get(rootRef)?.parentElement) {
          const parentViewportRect = get(rootRef).parentElement.getBoundingClientRect();
          if (strict_equals(typeof x4(), "number", false)) {
            if ((strict_equals(xAlign, "start") || strict_equals(xAlign, "center")) && parentViewportRect.left + rect.right > window.innerWidth) {
              rect.left = alignValue(xValue, "end", xOffset(), get(tooltipWidth));
            }
            if ((strict_equals(xAlign, "end") || strict_equals(xAlign, "center")) && parentViewportRect.left + rect.left < 0) {
              rect.left = alignValue(xValue, "start", xOffset(), get(tooltipWidth));
            }
          }
          rect.right = rect.left + get(tooltipWidth);
          if (strict_equals(typeof y4(), "number", false)) {
            if ((strict_equals(yAlign, "start") || strict_equals(yAlign, "center")) && parentViewportRect.top + rect.bottom > window.innerHeight) {
              rect.top = alignValue(yValue, "end", yOffset(), get(tooltipHeight));
            }
            if ((strict_equals(yAlign, "end") || strict_equals(yAlign, "center")) && parentViewportRect.top + rect.top < 0) {
              rect.top = alignValue(yValue, "start", yOffset(), get(tooltipHeight));
            }
          }
          rect.bottom = rect.top + get(tooltipHeight);
        }
      }
      return { x: rect.left, y: rect.top };
    }),
    "positions"
  );
  const motionX = createMotion(tooltipCtx.x, () => get(positions).x, motion());
  const motionY = createMotion(tooltipCtx.y, () => get(positions).y, motion());
  user_effect(() => {
    if (!tooltipCtx.data) {
      tooltipCtx.isHoveringTooltipContent = false;
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var div = root_18();
      var event_handler = () => {
        tooltipCtx.isHoveringTooltipContent = true;
      };
      var event_handler_1 = () => {
        tooltipCtx.isHoveringTooltipContent = false;
      };
      attribute_effect(
        div,
        ($0, $1, $2) => ({
          ...props().root,
          class: $0,
          onpointerenter: event_handler,
          onpointerleave: event_handler_1,
          [CLASS]: $1,
          [STYLE]: $2
        }),
        [
          () => cls("root", layerClass("tooltip-root"), classes().root, props().root?.class),
          () => ({ "pointer-events-none": !pointerEvents() }),
          () => ({
            top: `${motionY.current ?? ""}px`,
            left: `${motionX.current ?? ""}px`
          })
        ],
        void 0,
        "s-JPGPXkRs_IeU"
      );
      var div_1 = child(div);
      attribute_effect(
        div_1,
        ($0) => ({ ...props().container, class: $0 }),
        [
          () => cls(
            layerClass("tooltip-container"),
            strict_equals(variant(), "none", false) && ["text-sm py-1 px-2 h-full rounded-sm elevation-1"],
            {
              default: [
                "bg-surface-100/90 dark:bg-surface-300/90 backdrop-filter backdrop-blur-[2px] text-surface-content",
                "[&_.label]:text-surface-content/75"
              ],
              invert: [
                "bg-surface-content/90 backdrop-filter backdrop-blur-[2px] text-surface-100 border border-surface-content",
                "[&_.label]:text-surface-100/50"
              ],
              none: ""
            }[variant()],
            classes().container,
            props().container?.class,
            $$props.class
          )
        ],
        void 0,
        "s-JPGPXkRs_IeU"
      );
      var node_1 = child(div_1);
      {
        var consequent = ($$anchor3) => {
          var div_2 = root_24();
          attribute_effect(div_2, ($0) => ({ ...props().content, class: $0 }), [() => cls(layerClass("tooltip-content"), classes().content)], void 0, "s-JPGPXkRs_IeU");
          var node_2 = child(div_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => ({ data: tooltipCtx.data, payload: tooltipCtx.payload })), "render", Tooltip, 400, 10);
          reset(div_2);
          append($$anchor3, div_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
          }),
          "if",
          Tooltip,
          398,
          6
        );
      }
      reset(div_1);
      reset(div);
      bind_this(div, ($$value) => set(rootRef, $$value), () => get(rootRef));
      transition(3, div, () => fade, () => ({ duration: 100 }));
      bind_element_size(div, "clientWidth", ($$value) => set(tooltipWidth, $$value));
      bind_element_size(div, "clientHeight", ($$value) => set(tooltipHeight, $$value));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (tooltipCtx.data) $$render(consequent_1);
      }),
      "if",
      Tooltip,
      359,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module2) => {
    cleanup_styles("s-JPGPXkRs_IeU");
    module2.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module2.default[HMR].original);
  });
}
var Tooltip_default = Tooltip;

// node_modules/layerchart/dist/components/charts/utils.svelte.js
var HighlightKey = class {
  #current = tag(state(null), "HighlightKey.current");
  get current() {
    return get(this.#current);
  }
  set current(value2) {
    set(this.#current, value2, true);
  }
  set = (seriesKey) => {
    this.current = seriesKey;
  };
};
var SeriesState = class {
  #series = tag(state([]), "SeriesState.#series");
  selectedSeries = new SelectionState();
  selectedKeys = new SelectionState();
  highlightKey = new HighlightKey();
  constructor(getSeries) {
    set(this.#series, getSeries());
    user_pre_effect(() => {
      set(this.#series, getSeries());
    });
  }
  get series() {
    return get(this.#series);
  }
  get isDefaultSeries() {
    return strict_equals(get(this.#series).length, 1) && strict_equals(get(this.#series)[0].key, "default");
  }
  get allSeriesData() {
    return get(this.#series).flatMap((s3) => s3.data?.map((d) => ({ seriesKey: s3.key, ...d }))).filter((d) => d);
  }
  get visibleSeries() {
    return get(this.#series).filter((s3) => this.selectedSeries.isEmpty() || this.selectedSeries.isSelected(s3.key));
  }
};
function createLegendProps(opts) {
  return {
    scale: opts.seriesState.isDefaultSeries ? void 0 : ordinal(opts.seriesState.series.map((s3) => s3.key), opts.seriesState.series.map((s3) => s3.color)),
    tickFormat: (key2) => opts.seriesState.series.find((s3) => strict_equals(s3.key, key2))?.label ?? key2,
    placement: "bottom",
    variant: "swatches",
    onclick: (_, item) => opts.seriesState.selectedSeries.toggle(item.value),
    onpointerenter: (_, item) => assign(opts.seriesState.highlightKey, "current", item.value, "node_modules/​layerchart/​dist/​components/​charts/​utils.svelte.js:48:38"),
    onpointerleave: () => assign(opts.seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​utils.svelte.js:49:31"),
    ...opts.props,
    classes: {
      item: (item) => opts.seriesState.visibleSeries.length && !opts.seriesState.visibleSeries.some((s3) => strict_equals(s3.key, item.value)) ? "opacity-50" : "",
      ...opts.props?.classes
    }
  };
}

// node_modules/layerchart/dist/components/charts/ArcChart.svelte
ArcChart[FILENAME] = "node_modules/layerchart/dist/components/charts/ArcChart.svelte";
var root_44 = add_locations(from_html(`<!> <!> <!>`, 1), ArcChart[FILENAME], []);
var root_37 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), ArcChart[FILENAME], []);
function ArcChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ArcChart);
  let data = prop($$props, "data", 19, () => []), key2 = prop($$props, "key", 3, "key"), label = prop($$props, "label", 3, "label"), value2 = prop($$props, "value", 3, "value"), range4 = prop($$props, "range", 19, () => [0, 360]), innerRadius = prop($$props, "innerRadius", 3, 0), outerRadius = prop($$props, "outerRadius", 3, 0), cornerRadius = prop($$props, "cornerRadius", 3, 0), padAngle = prop($$props, "padAngle", 3, 0), placement = prop($$props, "placement", 3, "center"), legend = prop($$props, "legend", 3, false), onArcClick = prop($$props, "onArcClick", 3, () => {
  }), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), tooltip = prop($$props, "tooltip", 3, true), context = prop($$props, "context", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "key",
      "label",
      "value",
      "range",
      "c",
      "innerRadius",
      "outerRadius",
      "cornerRadius",
      "padAngle",
      "placement",
      "maxValue",
      "center",
      "series",
      "legend",
      "onArcClick",
      "onTooltipClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "tooltip",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "arc",
      "context",
      "trackCornerRadius",
      "trackPadAngle",
      "trackStartAngle",
      "trackEndAngle",
      "trackInnerRadius",
      "trackOuterRadius"
    ],
    "restProps"
  );
  const center2 = tag(user_derived(() => $$props.center ?? strict_equals(placement(), "center")), "center");
  const c3 = tag(user_derived(() => $$props.c ?? key2()), "c");
  const keyAccessor = tag(user_derived(() => accessor(key2())), "keyAccessor");
  const labelAccessor = tag(user_derived(() => accessor(label())), "labelAccessor");
  const valueAccessor = tag(user_derived(() => accessor(value2())), "valueAccessor");
  const cAccessor = tag(user_derived(() => accessor(get(c3))), "cAccessor");
  const _series = tag(user_derived(() => strict_equals($$props.series, void 0) ? [{ key: "default", value: value2() }] : $$props.series), "_series");
  const isDefaultSeries = tag(user_derived(() => strict_equals(get(_series).length, 1) && strict_equals(get(_series)[0].key, "default")), "isDefaultSeries");
  const series = tag(
    user_derived(() => {
      if (!get(isDefaultSeries)) return get(_series);
      return data().map((d) => {
        return {
          key: get(keyAccessor)(d),
          value: get(valueAccessor)(d),
          label: get(labelAccessor)(d),
          color: getColorIfDefined(d),
          maxValue: $$props.maxValue,
          data: [d]
        };
      });
    }),
    "series"
  );
  const selectedSeries = new SelectionState();
  const visibleSeries = tag(user_derived(() => get(series).filter((s3) => selectedSeries.isEmpty() || selectedSeries.isSelected(s3.key))), "visibleSeries");
  const allSeriesData = tag(
    user_derived(() => get(visibleSeries).flatMap((s3) => s3.data?.map((d) => {
      return { seriesKey: s3.key, ...d };
    })).filter((d) => d)),
    "allSeriesData"
  );
  const chartData = tag(user_derived(() => get(allSeriesData).length ? get(allSeriesData) : chartDataArray(data())), "chartData");
  const seriesColors = tag(user_derived(() => get(series).map((s3) => s3.color).filter((d) => equals(d, null, false))), "seriesColors");
  const highlightKey = new HighlightKey();
  const selectedKeys = new SelectionState();
  const visibleData = tag(
    user_derived(() => get(chartData).filter((d) => {
      const dataKey = get(keyAccessor)(d);
      return selectedKeys.isEmpty() || selectedKeys.isSelected(dataKey);
    })),
    "visibleData"
  );
  function getLegendProps() {
    return {
      tickFormat: (tick2) => {
        const item = get(chartData).find((d) => strict_equals(get(keyAccessor)(d), tick2));
        return item ? get(labelAccessor)(item) ?? tick2 : tick2;
      },
      placement: "bottom",
      variant: "swatches",
      onclick: (e, item) => {
        selectedKeys.toggle(item.value);
        selectedSeries.toggle(item.value);
      },
      onpointerenter: (e, item) => assign(highlightKey, "current", item.value, "node_modules/​layerchart/​dist/​components/​charts/​ArcChart.svelte:270:36"),
      onpointerleave: (e) => assign(highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​ArcChart.svelte:271:30"),
      ...props().legend,
      ...strict_equals(typeof legend(), "object") ? legend() : null,
      classes: {
        item: (item) => get(visibleData).length && !get(visibleData).some((d) => strict_equals(get(keyAccessor)(d), item.value)) ? "opacity-50" : "",
        ...props().legend?.classes,
        ...strict_equals(typeof legend(), "object") ? legend().classes : null
      }
    };
  }
  function getGroupProps() {
    if (!context()) return {};
    return {
      x: strict_equals(placement(), "left") ? context().height / 2 : strict_equals(placement(), "right") ? context().width - context().height / 2 : void 0,
      center: ["left", "right"].includes(placement()) ? "y" : void 0,
      ...props().group
    };
  }
  function getArcProps(s3, i) {
    if (!context()) return {};
    const d = s3.data?.[0] || get(chartData)[0];
    const multiSeries = data().length > 1 || get(series).length > 1;
    return {
      value: get(valueAccessor)(d),
      domain: [
        0,
        s3.maxValue ?? $$props.maxValue ?? sum(get(chartData), get(valueAccessor))
      ],
      range: range4(),
      innerRadius: innerRadius(),
      outerRadius: multiSeries && (outerRadius() ?? 0) < 0 ? i * (outerRadius() ?? 0) : outerRadius(),
      cornerRadius: cornerRadius(),
      padAngle: padAngle(),
      trackCornerRadius: $$props.trackCornerRadius,
      trackPadAngle: $$props.trackPadAngle,
      trackStartAngle: $$props.trackStartAngle,
      trackEndAngle: $$props.trackEndAngle,
      trackInnerRadius: $$props.trackInnerRadius,
      trackOuterRadius: multiSeries && ($$props.trackOuterRadius ?? 0) < 0 ? i * ($$props.trackOuterRadius ?? 0) : $$props.trackOuterRadius,
      fill: s3.color ?? context().cScale?.(context().c(d)),
      track: {
        fill: s3.color ?? context().cScale?.(context().c(d)),
        fillOpacity: 0.1
      },
      tooltipContext: context().tooltip,
      data: d,
      onclick: (e) => {
        onArcClick()(e, { data: d, series: s3 });
        onTooltipClick()(e, { data: d });
      },
      ...props().arc,
      ...s3.props,
      class: cls("transition-opacity", highlightKey.current && strict_equals(highlightKey.current, get(keyAccessor)(d), false) && "opacity-50", props().arc?.class, s3.props?.class)
    };
  }
  if (profile()) {
    console.time("ArcChart render");
    onMount(() => {
      console.timeEnd("ArcChart render");
    });
  }
  setTooltipMetaContext({
    type: "arc",
    get color() {
      return get(c3);
    },
    get value() {
      return value2();
    },
    get label() {
      return label();
    },
    get key() {
      return key2();
    },
    get visibleSeries() {
      return get(visibleSeries);
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(ArcChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          label: get(labelAccessor),
          key: get(keyAccessor),
          value: get(valueAccessor),
          color: get(cAccessor),
          context: context2(),
          series: get(series),
          visibleSeries: get(visibleSeries),
          visibleData: get(visibleData),
          highlightKey: highlightKey.current,
          setHighlightKey: highlightKey.set,
          getLegendProps,
          getGroupProps,
          getArcProps
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", ArcChart, 408, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_4 = ($$anchor3) => {
          var fragment_3 = root_37();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", ArcChart, 410, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get center() {
                    return get(center2);
                  },
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(ArcChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_44();
                    var node_5 = first_child(fragment_4);
                    add_svelte_meta(() => snippet(node_5, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", ArcChart, 418, 8);
                    var node_6 = sibling(node_5, 2);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_7 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_7, () => $$props.marks, () => get(snippetProps)), "render", ArcChart, 421, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate_1 = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_8 = first_child(fragment_6);
                        {
                          let $03 = user_derived(getGroupProps);
                          add_svelte_meta(
                            () => Group_default(node_8, spread_props(() => get($03), {
                              children: wrap_snippet(ArcChart, ($$anchor6, $$slotProps2) => {
                                var fragment_7 = comment();
                                var node_9 = first_child(fragment_7);
                                validate_each_keys(() => get(series), (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_9, 19, () => get(series), (s3) => s3.key, ($$anchor7, s3, i) => {
                                    var fragment_8 = comment();
                                    var node_10 = first_child(fragment_8);
                                    {
                                      var consequent_2 = ($$anchor8) => {
                                        var fragment_9 = comment();
                                        var node_11 = first_child(fragment_9);
                                        {
                                          let $04 = user_derived(() => ({
                                            ...get(snippetProps),
                                            seriesIndex: get(i),
                                            props: getArcProps(get(s3), get(i))
                                          }));
                                          add_svelte_meta(() => snippet(node_11, () => $$props.arc, () => get($04)), "render", ArcChart, 426, 16);
                                        }
                                        append($$anchor8, fragment_9);
                                      };
                                      var alternate = ($$anchor8) => {
                                        var fragment_10 = comment();
                                        var node_12 = first_child(fragment_10);
                                        {
                                          let $04 = user_derived(() => getArcProps(get(s3), get(i)));
                                          add_svelte_meta(() => Arc_default(node_12, spread_props(() => get($04))), "component", ArcChart, 428, 16, { componentTag: "Arc" });
                                        }
                                        append($$anchor8, fragment_10);
                                      };
                                      add_svelte_meta(
                                        () => if_block(node_10, ($$render) => {
                                          if (strict_equals(typeof $$props.arc, "function")) $$render(consequent_2);
                                          else $$render(alternate, false);
                                        }),
                                        "if",
                                        ArcChart,
                                        425,
                                        14
                                      );
                                    }
                                    append($$anchor7, fragment_8);
                                  }),
                                  "each",
                                  ArcChart,
                                  424,
                                  12
                                );
                                append($$anchor6, fragment_7);
                              }),
                              $$slots: { default: true }
                            })),
                            "component",
                            ArcChart,
                            423,
                            10,
                            { componentTag: "Group" }
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_6, ($$render) => {
                          if (strict_equals(typeof $$props.marks, "function")) $$render(consequent_1);
                          else $$render(alternate_1, false);
                        }),
                        "if",
                        ArcChart,
                        420,
                        8
                      );
                    }
                    var node_13 = sibling(node_6, 2);
                    add_svelte_meta(() => snippet(node_13, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", ArcChart, 434, 8);
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              ArcChart,
              412,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_14 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_14, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", ArcChart, 437, 6);
          var node_15 = sibling(node_14, 2);
          {
            var consequent_3 = ($$anchor4) => {
              var fragment_11 = comment();
              var node_16 = first_child(fragment_11);
              add_svelte_meta(() => snippet(node_16, legend, () => get(snippetProps)), "render", ArcChart, 440, 8);
              append($$anchor4, fragment_11);
            };
            var alternate_2 = ($$anchor4) => {
              var fragment_12 = comment();
              var node_17 = first_child(fragment_12);
              {
                var consequent_4 = ($$anchor5) => {
                  var fragment_13 = comment();
                  var node_18 = first_child(fragment_13);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_18, spread_props(() => get($02))), "component", ArcChart, 442, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_13);
                };
                add_svelte_meta(
                  () => if_block(
                    node_17,
                    ($$render) => {
                      if (legend()) $$render(consequent_4);
                    },
                    true
                  ),
                  "if",
                  ArcChart,
                  441,
                  6
                );
              }
              append($$anchor4, fragment_12);
            };
            add_svelte_meta(
              () => if_block(node_15, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_3);
                else $$render(alternate_2, false);
              }),
              "if",
              ArcChart,
              439,
              6
            );
          }
          var node_19 = sibling(node_15, 2);
          {
            var consequent_5 = ($$anchor4) => {
              var fragment_14 = comment();
              var node_20 = first_child(fragment_14);
              add_svelte_meta(() => snippet(node_20, tooltip, () => get(snippetProps)), "render", ArcChart, 446, 8);
              append($$anchor4, fragment_14);
            };
            var alternate_3 = ($$anchor4) => {
              var fragment_15 = comment();
              var node_21 = first_child(fragment_15);
              {
                var consequent_6 = ($$anchor5) => {
                  var fragment_16 = comment();
                  var node_22 = first_child(fragment_16);
                  {
                    const children2 = wrap_snippet(ArcChart, function($$anchor6, $$arg02) {
                      validate_snippet_args(...arguments);
                      let data2 = () => $$arg02?.().data;
                      data2();
                      var fragment_17 = comment();
                      var node_23 = first_child(fragment_17);
                      add_svelte_meta(
                        () => component(node_23, () => TooltipList_default, ($$anchor7, Tooltip_List) => {
                          Tooltip_List($$anchor7, spread_props(() => props().tooltip?.list, {
                            children: wrap_snippet(ArcChart, ($$anchor8, $$slotProps) => {
                              var fragment_18 = comment();
                              var node_24 = first_child(fragment_18);
                              {
                                let $02 = user_derived(() => get(labelAccessor)(data2()) || get(keyAccessor)(data2()));
                                let $12 = user_derived(() => get(valueAccessor)(data2()));
                                let $22 = user_derived(() => context2().cScale?.(context2().c(data2())));
                                add_svelte_meta(
                                  () => component(node_24, () => TooltipItem_default, ($$anchor9, Tooltip_Item) => {
                                    Tooltip_Item($$anchor9, spread_props(
                                      {
                                        get label() {
                                          return get($02);
                                        },
                                        get value() {
                                          return get($12);
                                        },
                                        get color() {
                                          return get($22);
                                        },
                                        get format() {
                                          return format;
                                        },
                                        onpointerenter: () => assign(highlightKey, "current", get(keyAccessor)(data2()), "node_modules/​layerchart/​dist/​components/​charts/​ArcChart.svelte:456:39"),
                                        onpointerleave: () => assign(highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​ArcChart.svelte:457:39")
                                      },
                                      () => props().tooltip?.item
                                    ));
                                  }),
                                  "component",
                                  ArcChart,
                                  451,
                                  14,
                                  { componentTag: "Tooltip.Item" }
                                );
                              }
                              append($$anchor8, fragment_18);
                            }),
                            $$slots: { default: true }
                          }));
                        }),
                        "component",
                        ArcChart,
                        450,
                        12,
                        { componentTag: "Tooltip.List" }
                      );
                      append($$anchor6, fragment_17);
                    });
                    add_svelte_meta(
                      () => component(node_22, () => Tooltip_default, ($$anchor6, Tooltip_Root) => {
                        Tooltip_Root($$anchor6, spread_props(
                          {
                            get context() {
                              return context2();
                            }
                          },
                          () => props().tooltip?.root,
                          { children: children2, $$slots: { default: true } }
                        ));
                      }),
                      "component",
                      ArcChart,
                      448,
                      8,
                      { componentTag: "Tooltip.Root" }
                    );
                  }
                  append($$anchor5, fragment_16);
                };
                add_svelte_meta(
                  () => if_block(
                    node_21,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_6);
                    },
                    true
                  ),
                  "if",
                  ArcChart,
                  447,
                  6
                );
              }
              append($$anchor4, fragment_15);
            };
            add_svelte_meta(
              () => if_block(node_19, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_5);
                else $$render(alternate_3, false);
              }),
              "if",
              ArcChart,
              445,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_4, false);
          }),
          "if",
          ArcChart,
          407,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => get(chartData).map(get(keyAccessor)));
    let $1 = user_derived(() => get(seriesColors).length ? get(seriesColors) : strict_equals(get(c3), key2(), false) ? get(chartData).map((d) => get(cAccessor)(d)) : [
      "var(--color-primary)",
      "var(--color-secondary)",
      "var(--color-info)",
      "var(--color-success)",
      "var(--color-warning)",
      "var(--color-danger)"
    ]);
    let $2 = user_derived(() => ({ bottom: strict_equals(legend(), true) ? 32 : 0 }));
    let $3 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(visibleData);
          },
          get x() {
            return value2();
          },
          get y() {
            return key2();
          },
          get c() {
            return get(c3);
          },
          get cDomain() {
            return get($0);
          },
          get cRange() {
            return get($1);
          },
          get padding() {
            return get($2);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($3);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      ArcChart,
      366,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArcChart = hmr(ArcChart, () => ArcChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ArcChart[HMR].source;
    set(ArcChart[HMR].source, module2.default[HMR].original);
  });
}
var ArcChart_default = ArcChart;

// node_modules/layerchart/dist/components/Area.svelte
Area[FILENAME] = "node_modules/layerchart/dist/components/Area.svelte";
var root_25 = add_locations(from_svg(`<path></path>`), Area[FILENAME], [[246, 2]]);
var root16 = add_locations(from_svg(`<!><!>`, 1), Area[FILENAME], []);
function Area($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Area);
  const ctx = getChartContext();
  const renderCtx = getRenderContext();
  let line = prop($$props, "line", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "clipPath",
      "curve",
      "data",
      "defined",
      "fill",
      "fillOpacity",
      "line",
      "opacity",
      "pathData",
      "stroke",
      "strokeWidth",
      "motion",
      "x",
      "y0",
      "y1"
    ],
    "restProps"
  );
  const xAccessor = tag(user_derived(() => $$props.x ? accessor($$props.x) : ctx.x), "xAccessor");
  const y0Accessor = tag(user_derived(() => $$props.y0 ? accessor($$props.y0) : (d2) => min(ctx.yDomain)), "y0Accessor");
  const y1Accessor = tag(user_derived(() => $$props.y1 ? accessor($$props.y1) : ctx.y), "y1Accessor");
  const xOffset = tag(user_derived(() => isScaleBand(ctx.xScale) ? ctx.xScale.bandwidth() / 2 : 0), "xOffset");
  const yOffset = tag(user_derived(() => isScaleBand(ctx.yScale) ? ctx.yScale.bandwidth() / 2 : 0), "yOffset");
  const extractedTween = extractTweenConfig($$props.motion);
  const tweenOptions = extractedTween ? {
    type: extractedTween.type,
    options: { interpolate: interpolatePath, ...extractedTween.options }
  } : void 0;
  function defaultPathData() {
    if (!tweenOptions) {
      return "";
    } else if ($$props.pathData) {
      return flattenPathData($$props.pathData, Math.min(ctx.yScale(0), ctx.yRange[0]));
    } else if (ctx.config.x) {
      const path3 = ctx.radial ? areaRadial_default().angle((d2) => ctx.xScale(get(xAccessor)(d2))).innerRadius(() => Math.min(ctx.yScale(0), ctx.yRange[0])).outerRadius(() => Math.min(ctx.yScale(0), ctx.yRange[0])) : area_default().x((d2) => ctx.xScale(get(xAccessor)(d2)) + get(xOffset)).y0(() => Math.min(ctx.yScale(0), ctx.yRange[0])).y1(() => Math.min(ctx.yScale(0), ctx.yRange[0]));
      path3.defined($$props.defined ?? ((d2) => equals(get(xAccessor)(d2), null, false) && equals(get(y1Accessor)(d2), null, false)));
      if ($$props.curve) path3.curve($$props.curve);
      return path3($$props.data ?? ctx.data);
    }
  }
  const d = tag(
    user_derived(() => {
      const _path = ctx.radial ? areaRadial_default().angle((d2) => ctx.xScale(get(xAccessor)(d2))).innerRadius((d2) => ctx.yScale(get(y0Accessor)(d2))).outerRadius((d2) => ctx.yScale(get(y1Accessor)(d2))) : area_default().x((d2) => {
        const v2 = get(xAccessor)(d2);
        return ctx.xScale(v2) + get(xOffset);
      }).y0((d2) => {
        let value2 = max(ctx.yRange);
        if ($$props.y0) {
          value2 = ctx.yScale(get(y0Accessor)(d2));
        } else if (Array.isArray(ctx.config.y) && strict_equals(ctx.config.y[0], 0)) {
          value2 = ctx.yScale(ctx.y(d2)[0]);
        }
        return value2 + get(yOffset);
      }).y1((d2) => {
        let value2 = max(ctx.yRange);
        if ($$props.y1) {
          value2 = ctx.yScale(get(y1Accessor)(d2));
        } else if (Array.isArray(ctx.config.y) && strict_equals(ctx.config.y[1], 1)) {
          value2 = ctx.yScale(ctx.y(d2)[1]);
        } else {
          value2 = ctx.yScale(ctx.y(d2));
        }
        return value2 + get(yOffset);
      });
      _path.defined($$props.defined ?? ((d2) => equals(get(xAccessor)(d2), null, false) && equals(get(y1Accessor)(d2), null, false)));
      if ($$props.curve) _path.curve($$props.curve);
      return $$props.pathData ?? _path($$props.data ?? ctx.data) ?? defaultPathData();
    }),
    "d"
  );
  const tweenState = createMotion(defaultPathData(), () => get(d), tweenOptions);
  function render2(ctx2, styleOverrides) {
    renderPathData(ctx2, tweenState.current, styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        fillOpacity: $$props.fillOpacity,
        stroke: $$props.stroke,
        strokeWidth: $$props.strokeWidth,
        opacity: $$props.opacity
      },
      classes: $$props.class ?? ""
    });
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Area",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave
      },
      deps: () => [
        fillKey.current,
        $$props.fillOpacity,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class,
        tweenState.current
      ]
    });
  }
  var fragment = root16();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => extractLayerProps(line(), "area-line"));
        add_svelte_meta(
          () => Spline_default(node_1, spread_props(
            {
              get data() {
                return $$props.data;
              },
              get x() {
                return $$props.x;
              },
              get y() {
                return $$props.y1;
              },
              get curve() {
                return $$props.curve;
              },
              get defined() {
                return $$props.defined;
              },
              get motion() {
                return $$props.motion;
              }
            },
            () => get($0)
          )),
          "component",
          Area,
          242,
          2,
          { componentTag: "Spline" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (line()) $$render(consequent);
      }),
      "if",
      Area,
      241,
      0
    );
  }
  var node_2 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var path_1 = root_25();
      attribute_effect(
        path_1,
        ($0) => ({
          d: tweenState.current,
          "clip-path": $$props.clipPath,
          fill: $$props.fill,
          "fill-opacity": $$props.fillOpacity,
          stroke: $$props.stroke,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          ...$0
        }),
        [() => extractLayerProps(restProps, "area-path")]
      );
      append($$anchor2, path_1);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent_1);
      }),
      "if",
      Area,
      245,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Area = hmr(Area, () => Area[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Area[HMR].source;
    set(Area[HMR].source, module2.default[HMR].original);
  });
}
var Area_default = Area;

// node_modules/layerchart/dist/components/Line.svelte
Line[FILENAME] = "node_modules/layerchart/dist/components/Line.svelte";
var root_19 = add_locations(from_svg(`<line></line><!><!><!>`, 1), Line[FILENAME], [[185, 2]]);
function Line($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Line);
  let initialX1 = prop($$props, "initialX1", 19, () => $$props.x1), initialY1 = prop($$props, "initialY1", 19, () => $$props.y1), initialX2 = prop($$props, "initialX2", 19, () => $$props.x2), initialY2 = prop($$props, "initialY2", 19, () => $$props.y2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x1",
      "initialX1",
      "y1",
      "initialY1",
      "x2",
      "initialX2",
      "y2",
      "initialY2",
      "class",
      "strokeWidth",
      "opacity",
      "fill",
      "stroke",
      "marker",
      "markerEnd",
      "markerStart",
      "markerMid",
      "motion",
      "fillOpacity"
    ],
    "restProps"
  );
  const markerStartId = tag(user_derived(() => $$props.markerStart || $$props.marker ? createId("marker-start", uid) : ""), "markerStartId");
  const markerMidId = tag(user_derived(() => $$props.markerMid || $$props.marker ? createId("marker-mid", uid) : ""), "markerMidId");
  const markerEndId = tag(user_derived(() => $$props.markerEnd || $$props.marker ? createId("marker-end", uid) : ""), "markerEndId");
  const motionX1 = createMotion(initialX1(), () => $$props.x1, $$props.motion);
  const motionY1 = createMotion(initialY1(), () => $$props.y1, $$props.motion);
  const motionX2 = createMotion(initialX2(), () => $$props.x2, $$props.motion);
  const motionY2 = createMotion(initialY2(), () => $$props.y2, $$props.motion);
  const renderCtx = getRenderContext();
  function render2(ctx, styleOverrides) {
    const pathData = `M ${motionX1.current},${motionY1.current} L ${motionX2.current},${motionY2.current}`;
    renderPathData(ctx, pathData, styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        stroke: $$props.stroke,
        strokeWidth: $$props.strokeWidth,
        opacity: $$props.opacity
      },
      classes: $$props.class
    });
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Line",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave
      },
      deps: () => [
        motionX1.current,
        motionY1.current,
        motionX2.current,
        motionY2.current,
        fillKey.current,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_19();
      var line = first_child(fragment_1);
      attribute_effect(
        line,
        ($0) => ({
          x1: motionX1.current,
          y1: motionY1.current,
          x2: motionX2.current,
          y2: motionY2.current,
          fill: $$props.fill,
          stroke: $$props.stroke,
          "fill-opacity": $$props.fillOpacity,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          "marker-start": get(markerStartId) ? `url(#${get(markerStartId)})` : void 0,
          "marker-mid": get(markerMidId) ? `url(#${get(markerMidId)})` : void 0,
          "marker-end": get(markerEndId) ? `url(#${get(markerEndId)})` : void 0,
          class: $0,
          ...restProps
        }),
        [
          () => cls(layerClass("line"), strict_equals($$props.stroke, void 0) && "stroke-surface-content", $$props.class)
        ]
      );
      var node_1 = sibling(line);
      {
        let $0 = user_derived(() => $$props.markerStart ?? $$props.marker);
        add_svelte_meta(
          () => MarkerWrapper_default(node_1, {
            get id() {
              return get(markerStartId);
            },
            get marker() {
              return get($0);
            }
          }),
          "component",
          Line,
          201,
          2,
          { componentTag: "MarkerWrapper" }
        );
      }
      var node_2 = sibling(node_1);
      {
        let $0 = user_derived(() => $$props.markerMid ?? $$props.marker);
        add_svelte_meta(
          () => MarkerWrapper_default(node_2, {
            get id() {
              return get(markerMidId);
            },
            get marker() {
              return get($0);
            }
          }),
          "component",
          Line,
          202,
          2,
          { componentTag: "MarkerWrapper" }
        );
      }
      var node_3 = sibling(node_2);
      {
        let $0 = user_derived(() => $$props.markerEnd ?? $$props.marker);
        add_svelte_meta(
          () => MarkerWrapper_default(node_3, {
            get id() {
              return get(markerEndId);
            },
            get marker() {
              return get($0);
            }
          }),
          "component",
          Line,
          203,
          2,
          { componentTag: "MarkerWrapper" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent);
      }),
      "if",
      Line,
      184,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Line = hmr(Line, () => Line[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Line[HMR].source;
    set(Line[HMR].source, module2.default[HMR].original);
  });
}
var Line_default = Line;

// node_modules/layerchart/dist/components/Rule.svelte
Rule[FILENAME] = "node_modules/layerchart/dist/components/Rule.svelte";
var root_110 = add_locations(from_html(`<!> <!>`, 1), Rule[FILENAME], []);
function Rule($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Rule);
  let x4 = prop($$props, "x", 3, false), xOffset = prop($$props, "xOffset", 3, 0), y4 = prop($$props, "y", 3, false), yOffset = prop($$props, "yOffset", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "xOffset",
      "y",
      "yOffset",
      "class",
      "children"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const xRangeMinMax = tag(user_derived(() => extent(ctx.xRange)), "xRangeMinMax");
  const yRangeMinMax = tag(user_derived(() => extent(ctx.yRange)), "yRangeMinMax");
  function showRule(value2, axis) {
    switch (typeof value2) {
      case "boolean":
        return value2;
      case "string":
        return true;
      default:
        if (strict_equals(axis, "x")) {
          return ctx.xScale(value2) >= get(xRangeMinMax)[0] && ctx.xScale(value2) <= get(xRangeMinMax)[1];
        } else {
          return ctx.yScale(value2) >= get(yRangeMinMax)[0] && ctx.yScale(value2) <= get(yRangeMinMax)[1];
        }
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => layerClass("rule-g"));
    add_svelte_meta(
      () => Group_default(node, {
        get class() {
          return get($0);
        },
        children: wrap_snippet(Rule, ($$anchor2, $$slotProps) => {
          var fragment_1 = root_110();
          var node_1 = first_child(fragment_1);
          {
            var consequent_1 = ($$anchor3) => {
              var fragment_2 = comment();
              const xCoord = tag(
                user_derived(() => strict_equals(x4(), true) || strict_equals(x4(), "left") ? get(xRangeMinMax)[0] : strict_equals(x4(), "right") ? get(xRangeMinMax)[1] : ctx.xScale(x4()) + xOffset()),
                "xCoord"
              );
              get(xCoord);
              var node_2 = first_child(fragment_2);
              {
                var consequent = ($$anchor4) => {
                  var fragment_3 = comment();
                  const computed_const = tag(
                    user_derived(() => {
                      const [x12, y12] = pointRadial_default(get(xCoord), Number(get(yRangeMinMax)[0]));
                      return { x1: x12, y1: y12 };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  const computed_const_1 = tag(
                    user_derived(() => {
                      const [x22, y22] = pointRadial_default(get(xCoord), Number(get(yRangeMinMax)[1]));
                      return { x2: x22, y2: y22 };
                    }),
                    "[@const]"
                  );
                  get(computed_const_1);
                  var node_3 = first_child(fragment_3);
                  {
                    let $02 = user_derived(() => cls(layerClass("rule-x-radial-line"), "stroke-surface-content/10", $$props.class));
                    add_svelte_meta(
                      () => Line_default(node_3, spread_props(() => restProps, {
                        get x1() {
                          return get(computed_const).x1;
                        },
                        get y1() {
                          return get(computed_const).y1;
                        },
                        get x2() {
                          return get(computed_const_1).x2;
                        },
                        get y2() {
                          return get(computed_const_1).y2;
                        },
                        get class() {
                          return get($02);
                        }
                      })),
                      "component",
                      Rule,
                      104,
                      6,
                      { componentTag: "Line" }
                    );
                  }
                  append($$anchor4, fragment_3);
                };
                var alternate = ($$anchor4) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  {
                    let $02 = user_derived(() => ctx.yRange[0] || 0);
                    let $1 = user_derived(() => ctx.yRange[1] || 0);
                    let $2 = user_derived(() => cls(layerClass("rule-x-line"), "stroke-surface-content/50", $$props.class));
                    add_svelte_meta(
                      () => Line_default(node_4, spread_props(() => restProps, {
                        get x1() {
                          return get(xCoord);
                        },
                        get x2() {
                          return get(xCoord);
                        },
                        get y1() {
                          return get($02);
                        },
                        get y2() {
                          return get($1);
                        },
                        get class() {
                          return get($2);
                        }
                      })),
                      "component",
                      Rule,
                      113,
                      6,
                      { componentTag: "Line" }
                    );
                  }
                  append($$anchor4, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(node_2, ($$render) => {
                    if (ctx.radial) $$render(consequent);
                    else $$render(alternate, false);
                  }),
                  "if",
                  Rule,
                  100,
                  4
                );
              }
              append($$anchor3, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (showRule(x4(), "x")) $$render(consequent_1);
              }),
              "if",
              Rule,
              92,
              2
            );
          }
          var node_5 = sibling(node_1, 2);
          {
            var consequent_3 = ($$anchor3) => {
              var fragment_5 = comment();
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor4) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  {
                    let $02 = user_derived(() => strict_equals(y4(), true) || strict_equals(y4(), "bottom") ? get(yRangeMinMax)[1] : strict_equals(y4(), "top") ? get(yRangeMinMax)[0] : ctx.yScale(y4()) + yOffset());
                    let $1 = user_derived(() => cls(layerClass("rule-y-radial-circle"), "fill-none stroke-surface-content/50", $$props.class));
                    add_svelte_meta(
                      () => Circle_default(node_7, {
                        get r() {
                          return get($02);
                        },
                        get class() {
                          return get($1);
                        }
                      }),
                      "component",
                      Rule,
                      126,
                      6,
                      { componentTag: "Circle" }
                    );
                  }
                  append($$anchor4, fragment_6);
                };
                var alternate_1 = ($$anchor4) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $02 = user_derived(() => ctx.xRange[0] || 0);
                    let $1 = user_derived(() => ctx.xRange[1] || 0);
                    let $2 = user_derived(() => strict_equals(y4(), true) || strict_equals(y4(), "bottom") ? get(yRangeMinMax)[1] : strict_equals(y4(), "top") ? get(yRangeMinMax)[0] : ctx.yScale(y4()) + yOffset());
                    let $3 = user_derived(() => strict_equals(y4(), true) || strict_equals(y4(), "bottom") ? get(yRangeMinMax)[1] : strict_equals(y4(), "top") ? get(yRangeMinMax)[0] : ctx.yScale(y4()) + yOffset());
                    let $4 = user_derived(() => cls(layerClass("rule-y-line"), "stroke-surface-content/50", $$props.class));
                    add_svelte_meta(
                      () => Line_default(node_8, spread_props(() => restProps, {
                        get x1() {
                          return get($02);
                        },
                        get x2() {
                          return get($1);
                        },
                        get y1() {
                          return get($2);
                        },
                        get y2() {
                          return get($3);
                        },
                        get class() {
                          return get($4);
                        }
                      })),
                      "component",
                      Rule,
                      139,
                      6,
                      { componentTag: "Line" }
                    );
                  }
                  append($$anchor4, fragment_7);
                };
                add_svelte_meta(
                  () => if_block(node_6, ($$render) => {
                    if (ctx.radial) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Rule,
                  125,
                  4
                );
              }
              append($$anchor3, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_5, ($$render) => {
                if (showRule(y4(), "y")) $$render(consequent_3);
              }),
              "if",
              Rule,
              124,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      Rule,
      91,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rule = hmr(Rule, () => Rule[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Rule[HMR].source;
    set(Rule[HMR].source, module2.default[HMR].original);
  });
}
var Rule_default = Rule;

// node_modules/layerchart/dist/components/Text.svelte
Text[FILENAME] = "node_modules/layerchart/dist/components/Text.svelte";
function getPathLength(pathRef) {
  if (pathRef && strict_equals(typeof pathRef.getTotalLength, "function")) {
    try {
      return pathRef.getTotalLength();
    } catch (e) {
      console.error(...log_if_contains_state("error", "Error getting path length:", e));
      return 0;
    }
  }
  return 0;
}
var root_38 = add_locations(from_svg(`<path></path>`), Text[FILENAME], [[486, 10]]);
var root_26 = add_locations(from_svg(`<defs><!></defs><text><textPath> </textPath></text>`, 1), Text[FILENAME], [[484, 6], [489, 6, [[501, 8]]]]);
var root_6 = add_locations(from_svg(`<tspan> </tspan>`), Text[FILENAME], [[528, 10]]);
var root_55 = add_locations(from_svg(`<text></text>`), Text[FILENAME], [[512, 6]]);
var root_111 = add_locations(from_svg(`<svg><!></svg>`), Text[FILENAME], [[476, 2]]);
function Text($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Text);
  let x4 = prop($$props, "x", 3, 0), initialX = prop($$props, "initialX", 19, x4), y4 = prop($$props, "y", 3, 0), initialY = prop($$props, "initialY", 19, y4), dx = prop($$props, "dx", 3, 0), dy = prop($$props, "dy", 3, 0), lineHeight = prop($$props, "lineHeight", 3, "1em"), capHeight = prop($$props, "capHeight", 3, "0.71em"), scaleToFit = prop($$props, "scaleToFit", 3, false), textAnchor = prop($$props, "textAnchor", 3, "start"), verticalAnchor = prop($$props, "verticalAnchor", 3, "end"), dominantBaseline = prop($$props, "dominantBaseline", 3, "auto"), opacity = prop($$props, "opacity", 3, 1), strokeWidth = prop($$props, "strokeWidth", 3, 0), svgRefProp = prop($$props, "svgRef", 15), refProp = prop($$props, "ref", 15), svgProps = prop($$props, "svgProps", 19, () => ({})), truncate2 = prop($$props, "truncate", 3, false), pathId = prop($$props, "pathId", 19, () => createId("text-path", uid)), startOffset = prop($$props, "startOffset", 3, "0%"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "x",
      "initialX",
      "y",
      "initialY",
      "dx",
      "dy",
      "lineHeight",
      "capHeight",
      "width",
      "scaleToFit",
      "textAnchor",
      "verticalAnchor",
      "dominantBaseline",
      "rotate",
      "opacity",
      "strokeWidth",
      "stroke",
      "fill",
      "fillOpacity",
      "motion",
      "svgRef",
      "ref",
      "class",
      "svgProps",
      "truncate",
      "path",
      "pathId",
      "startOffset",
      "transform"
    ],
    "restProps"
  );
  const renderCtx = getRenderContext();
  let ref = tag(state(void 0), "ref");
  let svgRef = tag(state(void 0), "svgRef");
  let pathRef = tag(state(void 0), "pathRef");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_pre_effect(() => {
    svgRefProp(get(svgRef));
  });
  let style = void 0;
  const resolvedWidth = tag(user_derived(() => $$props.path ? getPathLength(get(pathRef)) : $$props.width), "resolvedWidth");
  const defaultTruncateOptions = tag(
    user_derived(() => ({
      maxChars: void 0,
      position: "end",
      maxWidth: get(resolvedWidth)
    })),
    "defaultTruncateOptions"
  );
  const truncateConfig = tag(
    user_derived(() => {
      if (strict_equals(typeof truncate2(), "boolean")) {
        if (truncate2()) return get(defaultTruncateOptions);
        return false;
      }
      return { ...get(defaultTruncateOptions), ...truncate2() };
    }),
    "truncateConfig"
  );
  const rawText = tag(user_derived(() => equals($$props.value, null, false) ? $$props.value.toString().replace(/\\n/g, "\n") : ""), "rawText");
  const textValue = tag(
    user_derived(() => {
      if (!get(truncateConfig)) return get(rawText);
      return truncateText(get(rawText), get(truncateConfig));
    }),
    "textValue"
  );
  const spaceWidth = tag(user_derived(() => getStringWidth(" ", style) || 0), "spaceWidth");
  const wordsByLines = tag(
    user_derived(() => {
      const lines = get(textValue).split("\n");
      return lines.flatMap((line) => {
        const words2 = line.split(/(?:(?!\u00A0+)\s+)/);
        if (equals($$props.width, null)) {
          return [{ words: words2 }];
        } else {
          return words2.reduce(
            (result2, item) => {
              const currentLine = result2[result2.length - 1];
              const itemWidth = getStringWidth(item, style) || 0;
              if (currentLine && (equals($$props.width, null) || scaleToFit() || (currentLine.width || 0) + itemWidth + get(spaceWidth) < $$props.width)) {
                currentLine.words.push(item);
                currentLine.width = currentLine.width || 0;
                currentLine.width += itemWidth + get(spaceWidth);
              } else {
                const newLine = { words: [item], width: itemWidth };
                result2.push(newLine);
              }
              return result2;
            },
            []
          );
        }
      });
    }),
    "wordsByLines"
  );
  const lineCount = tag(user_derived(() => get(wordsByLines).length), "lineCount");
  function getPixelValue(cssValue) {
    if (strict_equals(typeof cssValue, "number")) return cssValue;
    const result2 = cssValue.match(/([\d.]+)(\D+)/);
    const number4 = Number(result2?.[1]);
    switch (result2?.[2]) {
      case "px":
        return number4;
      case "em":
      case "rem":
        return number4 * 16;
      default:
        return 0;
    }
  }
  const startDy = tag(
    user_derived(() => {
      if (strict_equals(verticalAnchor(), "start")) {
        return getPixelValue(lineHeight());
      } else if (strict_equals(verticalAnchor(), "middle")) {
        return (get(lineCount) - 1) / 2 * -getPixelValue(lineHeight()) + getPixelValue(capHeight()) / 2;
      } else {
        return (get(lineCount) - 1) * -getPixelValue(lineHeight()) - getPixelValue(capHeight()) / 2;
      }
    }),
    "startDy"
  );
  const scaleTransform = tag(
    user_derived(() => {
      if (scaleToFit() && get(lineCount) > 0 && equals(typeof x4(), "number") && equals(typeof y4(), "number") && equals(typeof $$props.width, "number")) {
        const lineWidth = get(wordsByLines)[0].width || 1;
        const sx = $$props.width / lineWidth;
        const sy = sx;
        const originX = x4() - sx * x4();
        const originY = y4() - sy * y4();
        return `matrix(${sx}, 0, 0, ${sy}, ${originX}, ${originY})`;
      } else {
        return "";
      }
    }),
    "scaleTransform"
  );
  const rotateTransform = tag(user_derived(() => $$props.rotate ? `rotate(${$$props.rotate}, ${x4()}, ${y4()})` : ""), "rotateTransform");
  const transform2 = tag(user_derived(() => $$props.transform ?? `${get(scaleTransform)} ${get(rotateTransform)}`), "transform");
  function isValidXOrY(xOrY) {
    return (
      // number that is not NaN or Infinity
      strict_equals(typeof xOrY, "number") && Number.isFinite(xOrY) || strict_equals(
        // for percentage
        typeof xOrY,
        "string"
      )
    );
  }
  const motionX = createMotion(initialX(), () => x4(), $$props.motion);
  const motionY = createMotion(initialY(), () => y4(), $$props.motion);
  function render2(ctx, styleOverrides) {
    const effectiveLineHeight = getPixelValue(lineHeight());
    const baseY = getPixelValue(motionY.current) + getPixelValue(dy()) + getPixelValue(get(startDy));
    const baseX = getPixelValue(motionX.current) + getPixelValue(dx());
    ctx.save();
    if (strict_equals($$props.rotate, void 0, false)) {
      const centerX = getPixelValue(x4());
      const centerY = getPixelValue(y4());
      const radians4 = degreesToRadians($$props.rotate);
      ctx.translate(centerX, centerY);
      ctx.rotate(radians4);
      ctx.translate(-centerX, -centerY);
    }
    const styles = styleOverrides ? merge_default({ styles: { strokeWidth: strokeWidth() } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        fillOpacity: $$props.fillOpacity,
        stroke: $$props.stroke,
        strokeWidth: strokeWidth(),
        opacity: opacity(),
        paintOrder: "stroke",
        textAnchor: textAnchor()
      },
      classes: cls(strict_equals($$props.fill, void 0) && "fill-surface-content", $$props.class)
    };
    const computedStyles = getComputedStyles(ctx.canvas, styles);
    ctx.font = `${computedStyles.fontSize} ${computedStyles.fontFamily}`;
    const textAlign = strict_equals(textAnchor(), "middle") ? "center" : strict_equals(textAnchor(), "end") ? "end" : "start";
    ctx.textAlign = textAlign;
    for (let index4 = 0; index4 < get(wordsByLines).length; index4++) {
      const line = get(wordsByLines)[index4];
      const text2 = line.words.join(" ");
      const xPos = baseX;
      const yPos = baseY + index4 * effectiveLineHeight;
      renderText(ctx, text2, { x: xPos, y: yPos }, styles);
    }
    ctx.restore();
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Text",
      render: render2,
      deps: () => [
        $$props.value,
        motionX.current,
        motionY.current,
        fillKey.current,
        strokeKey.current,
        strokeWidth(),
        opacity(),
        $$props.class,
        get(truncateConfig),
        $$props.rotate,
        lineHeight(),
        textAnchor(),
        verticalAnchor()
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_2 = ($$anchor2) => {
      var svg = root_111();
      attribute_effect(svg, ($0) => ({ x: dx(), y: dy(), ...svgProps(), class: $0 }), [
        () => cls(layerClass("text-svg"), "overflow-visible [paint-order:stroke]", svgProps()?.class)
      ]);
      var node_1 = child(svg);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = root_26();
          var defs = first_child(fragment_1);
          var node_2 = child(defs);
          add_svelte_meta(
            () => key(node_2, () => $$props.path, ($$anchor4) => {
              var path_1 = root_38();
              bind_this(path_1, ($$value) => set(pathRef, $$value), () => get(pathRef));
              template_effect(() => {
                set_attribute(path_1, "id", pathId());
                set_attribute(path_1, "d", $$props.path);
              });
              append($$anchor4, path_1);
            }),
            "key",
            Text,
            485,
            8
          );
          reset(defs);
          var text_1 = sibling(defs);
          attribute_effect(
            text_1,
            ($0) => ({
              dy: dy(),
              ...restProps,
              fill: $$props.fill,
              "fill-opacity": $$props.fillOpacity,
              stroke: $$props.stroke,
              "stroke-width": strokeWidth(),
              opacity: opacity(),
              transform: $$props.transform,
              class: $0
            }),
            [
              () => cls(layerClass("text"), strict_equals($$props.fill, void 0) && "fill-surface-content", $$props.class)
            ]
          );
          var textPath = child(text_1);
          var text_2 = child(textPath, true);
          reset(textPath);
          reset(text_1);
          bind_this(text_1, ($$value) => set(ref, $$value), () => get(ref));
          template_effect(
            ($0, $1) => {
              set_style(textPath, `text-anchor: ${textAnchor() ?? ""};`);
              set_attribute(textPath, "dominant-baseline", dominantBaseline());
              set_attribute(textPath, "href", `#${pathId() ?? ""}`);
              set_attribute(textPath, "startOffset", startOffset());
              set_class(textPath, 0, $0);
              set_text(text_2, $1);
            },
            [
              () => clsx(cls(layerClass("text-path"))),
              () => get(wordsByLines).map((line) => line.words.join(" ")).join()
            ]
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          {
            var consequent_1 = ($$anchor4) => {
              var text_3 = root_55();
              attribute_effect(
                text_3,
                ($0) => ({
                  x: motionX.current,
                  y: motionY.current,
                  transform: get(transform2),
                  "text-anchor": textAnchor(),
                  "dominant-baseline": dominantBaseline(),
                  ...restProps,
                  fill: $$props.fill,
                  "fill-opacity": $$props.fillOpacity,
                  stroke: $$props.stroke,
                  "stroke-width": strokeWidth(),
                  opacity: opacity(),
                  class: $0
                }),
                [
                  () => cls(layerClass("text"), strict_equals($$props.fill, void 0) && "fill-surface-content", $$props.class)
                ]
              );
              add_svelte_meta(
                () => each(text_3, 21, () => get(wordsByLines), index, ($$anchor5, line, index4) => {
                  var tspan = root_6();
                  var text_4 = child(tspan, true);
                  reset(tspan);
                  template_effect(
                    ($0, $1, $2) => {
                      set_attribute(tspan, "x", motionX.current);
                      set_attribute(tspan, "dy", $0);
                      set_class(tspan, 0, $1);
                      set_text(text_4, $2);
                    },
                    [
                      () => strict_equals(index4, 0) ? get(startDy) : getPixelValue(lineHeight()),
                      () => clsx(layerClass("text-tspan")),
                      () => get(line).words.join(" ")
                    ]
                  );
                  append($$anchor5, tspan);
                }),
                "each",
                Text,
                527,
                8
              );
              reset(text_3);
              bind_this(text_3, ($$value) => set(ref, $$value), () => get(ref));
              append($$anchor4, text_3);
            };
            add_svelte_meta(
              () => if_block(
                node_3,
                ($$render) => {
                  if (isValidXOrY(x4()) && isValidXOrY(y4())) $$render(consequent_1);
                },
                true
              ),
              "if",
              Text,
              511,
              4
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.path) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Text,
          483,
          4
        );
      }
      reset(svg);
      bind_this(svg, ($$value) => set(svgRef, $$value), () => get(svgRef));
      append($$anchor2, svg);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent_2);
      }),
      "if",
      Text,
      473,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text = hmr(Text, () => Text[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Text[HMR].source;
    set(Text[HMR].source, module2.default[HMR].original);
  });
}
var Text_default = Text;

// node_modules/layerchart/dist/utils/ticks.js
function getDurationFormat(duration, options = {
  multiline: false
}) {
  const { multiline = false, placement = "bottom" } = options;
  return function(date2, i) {
    let result2 = "";
    if (+duration >= +new Duration({ duration: { years: 1 } })) {
      result2 = format(date2, "year");
    } else if (+duration >= +new Duration({ duration: { days: 28 } })) {
      const isFirst = i === 0 || +timeYear.floor(date2) === +date2;
      if (multiline) {
        result2 = [format(date2, "month", { variant: "short" }), isFirst && format(date2, "year")];
      } else {
        result2 = format(date2, "month", { variant: "short" }) + (isFirst ? ` '${format(date2, "year", { variant: "short" })}` : "");
      }
    } else if (+duration >= +new Duration({ duration: { days: 1 } })) {
      const isFirst = i === 0 || date2.getDate() <= duration.days;
      if (multiline) {
        result2 = [
          format(date2, "custom", { custom: DateToken.DayOfMonth_numeric }),
          isFirst && format(date2, "month", { variant: "short" })
        ];
      } else {
        result2 = format(date2, "day", { variant: "short" });
      }
    } else if (+duration >= +new Duration({ duration: { hours: 1 } })) {
      const isFirst = i === 0 || +timeDay.floor(date2) === +date2;
      if (multiline) {
        result2 = [
          format(date2, "custom", { custom: DateToken.Hour_numeric }),
          isFirst && format(date2, "day", { variant: "short" })
        ];
      } else {
        result2 = isFirst ? format(date2, "day", { variant: "short" }) : format(date2, "custom", { custom: DateToken.Hour_numeric });
      }
    } else if (+duration >= +new Duration({ duration: { minutes: 1 } })) {
      const isFirst = i === 0 || +timeDay.floor(date2) === +date2;
      if (multiline) {
        result2 = [
          format(date2, "time", { variant: "short" }),
          isFirst && format(date2, "day", { variant: "short" })
        ];
      } else {
        result2 = format(date2, "time", { variant: "short" });
      }
    } else if (+duration >= +new Duration({ duration: { seconds: 1 } })) {
      const isFirst = i === 0 || +timeDay.floor(date2) === +date2;
      result2 = [
        format(date2, "time"),
        multiline && isFirst && format(date2, "day", { variant: "short" })
      ];
    } else if (+duration >= +new Duration({ duration: { milliseconds: 1 } })) {
      const isFirst = i === 0 || +timeDay.floor(date2) === +date2;
      result2 = [
        format(date2, "custom", {
          custom: [
            DateToken.Hour_2Digit,
            DateToken.Minute_2Digit,
            DateToken.Second_2Digit,
            DateToken.MiliSecond_3,
            DateToken.Hour_woAMPM
          ]
        }),
        multiline && isFirst && format(date2, "day", { variant: "short" })
      ];
    } else {
      result2 = date2.toString();
    }
    if (Array.isArray(result2)) {
      switch (placement) {
        case "top":
          return result2.filter(Boolean).reverse().join("\n");
        case "bottom":
          return result2.filter(Boolean).join("\n");
        case "left":
          return result2.filter(Boolean).reverse().join(" ");
        case "right":
          return result2.filter(Boolean).join(" ");
        default:
          return result2.filter(Boolean).join("\n");
      }
    } else {
      return result2;
    }
  };
}
function resolveTickVals(scale2, ticks2, count4) {
  if (Array.isArray(ticks2))
    return ticks2;
  if (typeof ticks2 === "function")
    return ticks2(scale2) ?? [];
  if (isLiteralObject(ticks2) && "interval" in ticks2) {
    if (ticks2.interval === null || !("ticks" in scale2) || typeof scale2.ticks !== "function") {
      return [];
    }
    return scale2.ticks(ticks2.interval);
  }
  if (isScaleBand(scale2)) {
    return ticks2 && typeof ticks2 === "number" ? scale2.domain().filter((_, i) => i % ticks2 === 0) : scale2.domain();
  }
  if (scale2.ticks && typeof scale2.ticks === "function") {
    return scale2.ticks(count4 ?? (typeof ticks2 === "number" ? ticks2 : void 0));
  }
  return [];
}
function resolveTickFormat(options) {
  const { scale: scale2, ticks: ticks2, count: count4, formatType, multiline, placement } = options;
  if (formatType) {
    return (tick2) => format(tick2, formatType);
  }
  if (isScaleTime(scale2) && count4) {
    if (isLiteralObject(ticks2) && "interval" in ticks2 && ticks2.interval != null) {
      const start = ticks2.interval.floor(/* @__PURE__ */ new Date());
      const end = ticks2.interval.ceil(/* @__PURE__ */ new Date());
      return getDurationFormat(new Duration({ start, end }), { multiline, placement });
    } else {
      const [start, end] = timeTicks(scale2.domain()[0], scale2.domain()[1], count4);
      return getDurationFormat(new Duration({ start, end }), { multiline, placement });
    }
  }
  if (scale2.tickFormat) {
    return scale2.tickFormat(count4);
  }
  return (tick2) => `${tick2}`;
}

// node_modules/layerchart/dist/components/Axis.svelte
Axis[FILENAME] = "node_modules/layerchart/dist/components/Axis.svelte";
var root_73 = add_locations(from_html(`<!> <!> <!>`, 1), Axis[FILENAME], []);
var root_112 = add_locations(from_html(`<!> <!> <!>`, 1), Axis[FILENAME], []);
function Axis($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Axis);
  let label = prop($$props, "label", 3, ""), labelPlacement = prop($$props, "labelPlacement", 3, "middle"), rule = prop($$props, "rule", 3, false), grid = prop($$props, "grid", 3, false), tickSpacing = prop($$props, "tickSpacing", 19, () => ["top", "bottom", "angle"].includes($$props.placement) ? 80 : ["left", "right", "radius"].includes($$props.placement) ? 50 : void 0), tickMultiline = prop($$props, "tickMultiline", 3, false), tickLength = prop($$props, "tickLength", 3, 4), tickMarks = prop($$props, "tickMarks", 3, true), classes = prop($$props, "classes", 19, () => ({})), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "placement",
      "label",
      "labelPlacement",
      "labelProps",
      "rule",
      "grid",
      "ticks",
      "tickSpacing",
      "tickMultiline",
      "tickLength",
      "tickMarks",
      "format",
      "tickLabelProps",
      "motion",
      "transitionIn",
      "transitionInParams",
      "scale",
      "classes",
      "class",
      "tickLabel"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const orientation = tag(
    user_derived(() => strict_equals($$props.placement, "angle") ? "angle" : strict_equals($$props.placement, "radius") ? "radius" : ["top", "bottom"].includes($$props.placement) ? "horizontal" : "vertical"),
    "orientation"
  );
  const scale2 = tag(user_derived(() => $$props.scale ?? (["horizontal", "angle"].includes(get(orientation)) ? ctx.xScale : ctx.yScale)), "scale");
  const xRangeMinMax = tag(user_derived(() => extent(ctx.xRange)), "xRangeMinMax");
  const yRangeMinMax = tag(user_derived(() => extent(ctx.yRange)), "yRangeMinMax");
  const ctxSize = tag(
    user_derived(() => strict_equals(get(orientation), "vertical") ? ctx.height : strict_equals(get(orientation), "horizontal") ? ctx.width : strict_equals(get(orientation), "radius") ? ctx.height / 2 : strict_equals(get(orientation), "angle") ? ctx.width : null),
    "ctxSize"
  );
  const tickCount = tag(
    user_derived(() => strict_equals(typeof $$props.ticks, "number") ? $$props.ticks : tickSpacing() && get(ctxSize) ? Math.round(get(ctxSize) / tickSpacing()) : void 0),
    "tickCount"
  );
  const tickVals = tag(user_derived(() => resolveTickVals(get(scale2), $$props.ticks, get(tickCount))), "tickVals");
  const tickFormat2 = tag(
    user_derived(() => resolveTickFormat({
      scale: get(scale2),
      ticks: $$props.ticks,
      count: get(tickCount),
      formatType: $$props.format,
      multiline: tickMultiline(),
      placement: $$props.placement
    })),
    "tickFormat"
  );
  function getCoords(tick2) {
    switch ($$props.placement) {
      case "top":
        return {
          x: get(scale2)(tick2) + (isScaleBand(get(scale2)) ? get(scale2).bandwidth() / 2 : 0),
          y: get(yRangeMinMax)[0]
        };
      case "bottom":
        return {
          x: get(scale2)(tick2) + (isScaleBand(get(scale2)) ? get(scale2).bandwidth() / 2 : 0),
          y: get(yRangeMinMax)[1]
        };
      case "left":
        return {
          x: get(xRangeMinMax)[0],
          y: get(scale2)(tick2) + (isScaleBand(get(scale2)) ? get(scale2).bandwidth() / 2 : 0)
        };
      case "right":
        return {
          x: get(xRangeMinMax)[1],
          y: get(scale2)(tick2) + (isScaleBand(get(scale2)) ? get(scale2).bandwidth() / 2 : 0)
        };
      case "angle":
        return { x: get(scale2)(tick2), y: get(yRangeMinMax)[1] };
      case "radius":
        return {
          x: get(xRangeMinMax)[0],
          y: get(scale2)(tick2) + (isScaleBand(get(scale2)) ? get(scale2).bandwidth() / 2 : 0)
        };
    }
  }
  function getDefaultTickLabelProps(tick2) {
    switch ($$props.placement) {
      case "top":
        return {
          textAnchor: "middle",
          verticalAnchor: "end",
          dy: -tickLength()
        };
      case "bottom":
        return {
          textAnchor: "middle",
          verticalAnchor: "start",
          dy: tickLength()
        };
      case "left":
        return {
          textAnchor: "end",
          verticalAnchor: "middle",
          dx: -tickLength()
        };
      case "right":
        return {
          textAnchor: "start",
          verticalAnchor: "middle",
          dx: tickLength()
        };
      case "angle":
        const xValue = get(
          scale2
          // angle in radians
        )(tick2);
        return {
          textAnchor: strict_equals(xValue, 0) || Math.abs(xValue - Math.PI) < 0.01 || // ~180deg
          Math.abs(xValue - Math.PI * 2) < 0.01 ? (
            // ~360deg
            // ~360deg
            "middle"
          ) : xValue > Math.PI ? "end" : "start",
          verticalAnchor: "middle",
          dx: Math.sin(xValue) * tickLength(),
          dy: -Math.cos(xValue) * (tickLength() + 4)
          // manually adjusted until Text supports custom styles
        };
      case "radius":
        return { textAnchor: "middle", verticalAnchor: "middle", dx: 2 };
    }
  }
  const resolvedLabelX = tag(
    user_derived(() => {
      if (strict_equals($$props.placement, "left") || strict_equals(get(orientation), "horizontal") && strict_equals(labelPlacement(), "start")) {
        return -ctx.padding.left;
      } else if (strict_equals($$props.placement, "right") || strict_equals(get(orientation), "horizontal") && strict_equals(labelPlacement(), "end")) {
        return ctx.width + ctx.padding.right;
      }
      return ctx.width / 2;
    }),
    "resolvedLabelX"
  );
  const resolvedLabelY = tag(
    user_derived(() => {
      if (strict_equals($$props.placement, "top") || strict_equals(get(orientation), "vertical") && strict_equals(labelPlacement(), "start")) {
        return -ctx.padding.top;
      } else if (strict_equals(get(orientation), "vertical") && strict_equals(labelPlacement(), "middle")) {
        return ctx.height / 2;
      } else if (strict_equals($$props.placement, "bottom") || strict_equals(labelPlacement(), "end")) {
        return ctx.height + ctx.padding.bottom;
      }
      return "0";
    }),
    "resolvedLabelY"
  );
  const resolvedLabelTextAnchor = tag(
    user_derived(() => {
      if (strict_equals(labelPlacement(), "middle")) {
        return "middle";
      } else if (strict_equals($$props.placement, "right") || strict_equals(get(orientation), "horizontal") && strict_equals(labelPlacement(), "end")) {
        return "end";
      }
      return "start";
    }),
    "resolvedLabelTextAnchor"
  );
  const resolvedLabelVerticalAnchor = tag(
    user_derived(() => {
      if (strict_equals($$props.placement, "top") || strict_equals(get(orientation), "vertical") && strict_equals(labelPlacement(), "start") || strict_equals($$props.placement, "left") && strict_equals(labelPlacement(), "middle")) {
        return "start";
      }
      return "end";
    }),
    "resolvedLabelVerticalAnchor"
  );
  const resolvedLabelProps = tag(
    user_derived(() => ({
      value: strict_equals(typeof label(), "function") ? "" : void 0,
      x: get(resolvedLabelX),
      y: get(resolvedLabelY),
      textAnchor: get(resolvedLabelTextAnchor),
      verticalAnchor: get(resolvedLabelVerticalAnchor),
      rotate: strict_equals(get(orientation), "vertical") && strict_equals(labelPlacement(), "middle") ? -90 : 0,
      capHeight: ".5rem",
      // text-[10px]
      ...$$props.labelProps,
      class: cls(layerClass("axis-label"), "text-[10px] stroke-surface-100 [stroke-width:2px] font-light", classes().label, $$props.labelProps?.class)
    })),
    "resolvedLabelProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls(layerClass("axis"), `placement-${$$props.placement}`, classes().root, $$props.class));
    add_svelte_meta(
      () => Group_default(node, spread_props(() => restProps, {
        get "data-placement"() {
          return $$props.placement;
        },
        get class() {
          return get($0);
        },
        children: wrap_snippet(Axis, ($$anchor2, $$slotProps) => {
          var fragment_1 = root_112();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              const ruleProps = tag(user_derived(() => extractLayerProps(rule(), "axis-rule")), "ruleProps");
              get(ruleProps);
              var node_2 = first_child(fragment_2);
              {
                let $02 = user_derived(() => strict_equals($$props.placement, "left") || strict_equals($$props.placement, "right") ? $$props.placement : strict_equals($$props.placement, "angle"));
                let $1 = user_derived(() => strict_equals($$props.placement, "top") || strict_equals($$props.placement, "bottom") ? $$props.placement : strict_equals($$props.placement, "radius"));
                let $2 = user_derived(() => cls("stroke-surface-content/50", classes().rule, get(ruleProps)?.class));
                add_svelte_meta(
                  () => Rule_default(node_2, spread_props(
                    {
                      get x() {
                        return get($02);
                      },
                      get y() {
                        return get($1);
                      },
                      get motion() {
                        return $$props.motion;
                      }
                    },
                    () => get(ruleProps),
                    {
                      get class() {
                        return get($2);
                      }
                    }
                  )),
                  "component",
                  Axis,
                  388,
                  4,
                  { componentTag: "Rule" }
                );
              }
              append($$anchor3, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (strict_equals(rule(), false, false)) $$render(consequent);
              }),
              "if",
              Axis,
              386,
              2
            );
          }
          var node_3 = sibling(node_1, 2);
          {
            var consequent_1 = ($$anchor3) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              add_svelte_meta(() => snippet(node_4, label, () => ({ props: get(resolvedLabelProps) })), "render", Axis, 398, 4);
              append($$anchor3, fragment_3);
            };
            var alternate = ($$anchor3) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              {
                var consequent_2 = ($$anchor4) => {
                  var fragment_5 = comment();
                  var node_6 = first_child(fragment_5);
                  add_svelte_meta(() => Text_default(node_6, spread_props(() => get(resolvedLabelProps))), "component", Axis, 400, 4, { componentTag: "Text" });
                  append($$anchor4, fragment_5);
                };
                add_svelte_meta(
                  () => if_block(
                    node_5,
                    ($$render) => {
                      if (label()) $$render(consequent_2);
                    },
                    true
                  ),
                  "if",
                  Axis,
                  399,
                  2
                );
              }
              append($$anchor3, fragment_4);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if (strict_equals(typeof label(), "function")) $$render(consequent_1);
                else $$render(alternate, false);
              }),
              "if",
              Axis,
              397,
              2
            );
          }
          var node_7 = sibling(node_3, 2);
          validate_each_keys(() => get(tickVals), (tick2) => tick2);
          add_svelte_meta(
            () => each(node_7, 18, () => get(tickVals), (tick2) => tick2, ($$anchor3, tick2, index4) => {
              var fragment_6 = comment();
              const tickCoords = tag(user_derived(() => getCoords(tick2)), "tickCoords");
              get(tickCoords);
              const computed_const = tag(
                user_derived(() => {
                  const [radialTickCoordsX, radialTickCoordsY] = pointRadial_default(get(tickCoords).x, get(tickCoords).y);
                  return { radialTickCoordsX, radialTickCoordsY };
                }),
                "[@const]"
              );
              get(computed_const);
              const computed_const_1 = tag(
                user_derived(() => {
                  const [radialTickMarkCoordsX, radialTickMarkCoordsY] = pointRadial_default(get(tickCoords).x, get(tickCoords).y + tickLength());
                  return { radialTickMarkCoordsX, radialTickMarkCoordsY };
                }),
                "[@const]"
              );
              get(computed_const_1);
              const resolvedTickLabelProps = tag(
                user_derived(() => ({
                  x: strict_equals(get(orientation), "angle") ? get(computed_const).radialTickCoordsX : get(tickCoords).x,
                  y: strict_equals(get(orientation), "angle") ? get(computed_const).radialTickCoordsY : get(tickCoords).y,
                  value: get(tickFormat2)(tick2, get(index4)),
                  ...getDefaultTickLabelProps(tick2),
                  motion: $$props.motion,
                  capHeight: "7px",
                  lineHeight: "11px",
                  ...$$props.tickLabelProps,
                  class: cls(layerClass("axis-tick-label"), "text-[10px] stroke-surface-100 [stroke-width:2px] font-light", classes().tickLabel, $$props.tickLabelProps?.class)
                })),
                "resolvedTickLabelProps"
              );
              get(resolvedTickLabelProps);
              var node_8 = first_child(fragment_6);
              {
                let $02 = user_derived(() => layerClass("axis-tick-group"));
                add_svelte_meta(
                  () => Group_default(node_8, {
                    get transitionIn() {
                      return $$props.transitionIn;
                    },
                    get transitionInParams() {
                      return $$props.transitionInParams;
                    },
                    get class() {
                      return get($02);
                    },
                    children: wrap_snippet(Axis, ($$anchor4, $$slotProps2) => {
                      var fragment_7 = root_73();
                      var node_9 = first_child(fragment_7);
                      {
                        var consequent_3 = ($$anchor5) => {
                          var fragment_8 = comment();
                          const ruleProps = tag(user_derived(() => extractLayerProps(grid(), "axis-grid")), "ruleProps");
                          get(ruleProps);
                          var node_10 = first_child(fragment_8);
                          {
                            let $03 = user_derived(() => strict_equals(get(orientation), "horizontal") || strict_equals(get(orientation), "angle") ? tick2 : false);
                            let $1 = user_derived(() => strict_equals(get(orientation), "vertical") || strict_equals(get(orientation), "radius") ? tick2 : false);
                            let $2 = user_derived(() => cls("stroke-surface-content/10", classes().rule, get(ruleProps)?.class));
                            add_svelte_meta(
                              () => Rule_default(node_10, spread_props(
                                {
                                  get x() {
                                    return get($03);
                                  },
                                  get y() {
                                    return get($1);
                                  },
                                  get motion() {
                                    return $$props.motion;
                                  }
                                },
                                () => get(ruleProps),
                                {
                                  get class() {
                                    return get($2);
                                  }
                                }
                              )),
                              "component",
                              Axis,
                              431,
                              8,
                              { componentTag: "Rule" }
                            );
                          }
                          append($$anchor5, fragment_8);
                        };
                        add_svelte_meta(
                          () => if_block(node_9, ($$render) => {
                            if (strict_equals(grid(), false, false)) $$render(consequent_3);
                          }),
                          "if",
                          Axis,
                          429,
                          6
                        );
                      }
                      var node_11 = sibling(node_9, 2);
                      {
                        var consequent_7 = ($$anchor5) => {
                          var fragment_9 = comment();
                          const tickClasses = tag(user_derived(() => cls(layerClass("axis-tick"), "stroke-surface-content/50", classes().tick)), "tickClasses");
                          get(tickClasses);
                          var node_12 = first_child(fragment_9);
                          {
                            var consequent_4 = ($$anchor6) => {
                              var fragment_10 = comment();
                              var node_13 = first_child(fragment_10);
                              {
                                let $03 = user_derived(() => get(tickCoords).y + (strict_equals($$props.placement, "top") ? -tickLength() : tickLength()));
                                add_svelte_meta(
                                  () => Line_default(node_13, {
                                    get x1() {
                                      return get(tickCoords).x;
                                    },
                                    get y1() {
                                      return get(tickCoords).y;
                                    },
                                    get x2() {
                                      return get(tickCoords).x;
                                    },
                                    get y2() {
                                      return get($03);
                                    },
                                    get motion() {
                                      return $$props.motion;
                                    },
                                    get class() {
                                      return get(tickClasses);
                                    }
                                  }),
                                  "component",
                                  Axis,
                                  447,
                                  10,
                                  { componentTag: "Line" }
                                );
                              }
                              append($$anchor6, fragment_10);
                            };
                            var alternate_2 = ($$anchor6) => {
                              var fragment_11 = comment();
                              var node_14 = first_child(fragment_11);
                              {
                                var consequent_5 = ($$anchor7) => {
                                  var fragment_12 = comment();
                                  var node_15 = first_child(fragment_12);
                                  {
                                    let $03 = user_derived(() => get(tickCoords).x + (strict_equals($$props.placement, "left") ? -tickLength() : tickLength()));
                                    add_svelte_meta(
                                      () => Line_default(node_15, {
                                        get x1() {
                                          return get(tickCoords).x;
                                        },
                                        get y1() {
                                          return get(tickCoords).y;
                                        },
                                        get x2() {
                                          return get($03);
                                        },
                                        get y2() {
                                          return get(tickCoords).y;
                                        },
                                        get motion() {
                                          return $$props.motion;
                                        },
                                        get class() {
                                          return get(tickClasses);
                                        }
                                      }),
                                      "component",
                                      Axis,
                                      456,
                                      10,
                                      { componentTag: "Line" }
                                    );
                                  }
                                  append($$anchor7, fragment_12);
                                };
                                var alternate_1 = ($$anchor7) => {
                                  var fragment_13 = comment();
                                  var node_16 = first_child(fragment_13);
                                  {
                                    var consequent_6 = ($$anchor8) => {
                                      var fragment_14 = comment();
                                      var node_17 = first_child(fragment_14);
                                      add_svelte_meta(
                                        () => Line_default(node_17, {
                                          get x1() {
                                            return get(computed_const).radialTickCoordsX;
                                          },
                                          get y1() {
                                            return get(computed_const).radialTickCoordsY;
                                          },
                                          get x2() {
                                            return get(computed_const_1).radialTickMarkCoordsX;
                                          },
                                          get y2() {
                                            return get(computed_const_1).radialTickMarkCoordsY;
                                          },
                                          get motion() {
                                            return $$props.motion;
                                          },
                                          get class() {
                                            return get(tickClasses);
                                          }
                                        }),
                                        "component",
                                        Axis,
                                        465,
                                        10,
                                        { componentTag: "Line" }
                                      );
                                      append($$anchor8, fragment_14);
                                    };
                                    add_svelte_meta(
                                      () => if_block(
                                        node_16,
                                        ($$render) => {
                                          if (strict_equals(get(orientation), "angle")) $$render(consequent_6);
                                        },
                                        true
                                      ),
                                      "if",
                                      Axis,
                                      464,
                                      8
                                    );
                                  }
                                  append($$anchor7, fragment_13);
                                };
                                add_svelte_meta(
                                  () => if_block(
                                    node_14,
                                    ($$render) => {
                                      if (strict_equals(get(orientation), "vertical")) $$render(consequent_5);
                                      else $$render(alternate_1, false);
                                    },
                                    true
                                  ),
                                  "if",
                                  Axis,
                                  455,
                                  8
                                );
                              }
                              append($$anchor6, fragment_11);
                            };
                            add_svelte_meta(
                              () => if_block(node_12, ($$render) => {
                                if (strict_equals(get(orientation), "horizontal")) $$render(consequent_4);
                                else $$render(alternate_2, false);
                              }),
                              "if",
                              Axis,
                              446,
                              8
                            );
                          }
                          append($$anchor5, fragment_9);
                        };
                        add_svelte_meta(
                          () => if_block(node_11, ($$render) => {
                            if (tickMarks()) $$render(consequent_7);
                          }),
                          "if",
                          Axis,
                          440,
                          6
                        );
                      }
                      var node_18 = sibling(node_11, 2);
                      {
                        var consequent_8 = ($$anchor5) => {
                          var fragment_15 = comment();
                          var node_19 = first_child(fragment_15);
                          add_svelte_meta(() => snippet(node_19, () => $$props.tickLabel, () => ({ props: get(resolvedTickLabelProps), index: get(index4) })), "render", Axis, 477, 8);
                          append($$anchor5, fragment_15);
                        };
                        var alternate_3 = ($$anchor5) => {
                          var fragment_16 = comment();
                          var node_20 = first_child(fragment_16);
                          add_svelte_meta(() => Text_default(node_20, spread_props(() => get(resolvedTickLabelProps))), "component", Axis, 479, 8, { componentTag: "Text" });
                          append($$anchor5, fragment_16);
                        };
                        add_svelte_meta(
                          () => if_block(node_18, ($$render) => {
                            if ($$props.tickLabel) $$render(consequent_8);
                            else $$render(alternate_3, false);
                          }),
                          "if",
                          Axis,
                          476,
                          6
                        );
                      }
                      append($$anchor4, fragment_7);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  Axis,
                  428,
                  4,
                  { componentTag: "Group" }
                );
              }
              append($$anchor3, fragment_6);
            }),
            "each",
            Axis,
            403,
            2
          );
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      })),
      "component",
      Axis,
      381,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Axis = hmr(Axis, () => Axis[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Axis[HMR].source;
    set(Axis[HMR].source, module2.default[HMR].original);
  });
}
var Axis_default = Axis;

// node_modules/layerchart/dist/components/Grid.svelte
Grid[FILENAME] = "node_modules/layerchart/dist/components/Grid.svelte";
var root_39 = add_locations(from_html(`<!> <!>`, 1), Grid[FILENAME], []);
var root_93 = add_locations(from_html(`<!> <!>`, 1), Grid[FILENAME], []);
var root_113 = add_locations(from_html(`<!> <!>`, 1), Grid[FILENAME], []);
function Grid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Grid);
  const ctx = getChartContext();
  let x4 = prop($$props, "x", 3, false), y4 = prop($$props, "y", 3, false), bandAlign = prop($$props, "bandAlign", 3, "center"), radialY = prop($$props, "radialY", 3, "circle"), transitionInParams = prop($$props, "transitionInParams", 19, () => ({ easing: cubicIn })), classes = prop($$props, "classes", 19, () => ({})), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "xTicks",
      "yTicks",
      "bandAlign",
      "radialY",
      "motion",
      "transitionIn",
      "transitionInParams",
      "classes",
      "class",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const yTicks = tag(user_derived(() => $$props.yTicks ?? (!isScaleBand(ctx.yScale) ? 4 : void 0)), "yTicks");
  const tweenConfig = tag(user_derived(() => extractTweenConfig($$props.motion)), "tweenConfig");
  const transitionIn = tag(user_derived(() => $$props.transitionIn ?? get(tweenConfig)?.options ? fade : () => ({})), "transitionIn");
  const xTickVals = tag(user_derived(() => resolveTickVals(ctx.xScale, $$props.xTicks)), "xTickVals");
  const yTickVals = tag(user_derived(() => resolveTickVals(ctx.yScale, get(yTicks))), "yTickVals");
  const xBandOffset = tag(
    user_derived(() => isScaleBand(ctx.xScale) ? strict_equals(bandAlign(), "between") ? -(ctx.xScale.padding() * ctx.xScale.step()) / 2 : (
      // before
      ctx.xScale.step() / 2 - ctx.xScale.padding() * ctx.xScale.step() / 2
    ) : (
      // center
      0
    )),
    "xBandOffset"
  );
  const yBandOffset = tag(
    user_derived(() => isScaleBand(ctx.yScale) ? strict_equals(bandAlign(), "between") ? -(ctx.yScale.padding() * ctx.yScale.step()) / 2 : (
      // before
      ctx.yScale.step() / 2 - ctx.yScale.padding() * ctx.yScale.step() / 2
    ) : (
      // center
      0
    )),
    "yBandOffset"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls(layerClass("grid"), classes().root, $$props.class));
    add_svelte_meta(
      () => Group_default(node, spread_props(
        {
          get class() {
            return get($0);
          }
        },
        () => restProps,
        {
          get ref() {
            return get(ref);
          },
          set ref($$value) {
            set(ref, $$value, true);
          },
          children: wrap_snippet(Grid, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_113();
            var node_1 = first_child(fragment_1);
            {
              var consequent_2 = ($$anchor3) => {
                var fragment_2 = comment();
                const splineProps = tag(user_derived(() => extractLayerProps(x4(), "grid-x-line")), "splineProps");
                get(splineProps);
                var node_2 = first_child(fragment_2);
                {
                  let $02 = user_derived(() => layerClass("grid-x"));
                  add_svelte_meta(
                    () => Group_default(node_2, {
                      get transitionIn() {
                        return get(transitionIn);
                      },
                      get transitionInParams() {
                        return transitionInParams();
                      },
                      get class() {
                        return get($02);
                      },
                      children: wrap_snippet(Grid, ($$anchor4, $$slotProps2) => {
                        var fragment_3 = root_39();
                        var node_3 = first_child(fragment_3);
                        validate_each_keys(() => get(xTickVals), (x5) => x5);
                        add_svelte_meta(
                          () => each(node_3, 16, () => get(xTickVals), (x5) => x5, ($$anchor5, x5, $$index, $$array) => {
                            var fragment_4 = comment();
                            var node_4 = first_child(fragment_4);
                            {
                              var consequent = ($$anchor6) => {
                                var fragment_5 = comment();
                                const computed_const = tag(
                                  user_derived(() => {
                                    const [x12, y12] = pointRadial_default(ctx.xScale(x5), ctx.yRange[0]);
                                    return { x1: x12, y1: y12 };
                                  }),
                                  "[@const]"
                                );
                                get(computed_const);
                                const computed_const_1 = tag(
                                  user_derived(() => {
                                    const [x22, y22] = pointRadial_default(ctx.xScale(x5), ctx.yRange[1]);
                                    return { x2: x22, y2: y22 };
                                  }),
                                  "[@const]"
                                );
                                get(computed_const_1);
                                var node_5 = first_child(fragment_5);
                                {
                                  let $03 = user_derived(() => cls(layerClass("grid-x-radial-line"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                  add_svelte_meta(
                                    () => Line_default(node_5, spread_props(
                                      {
                                        get x1() {
                                          return get(computed_const).x1;
                                        },
                                        get y1() {
                                          return get(computed_const).y1;
                                        },
                                        get x2() {
                                          return get(computed_const_1).x2;
                                        },
                                        get y2() {
                                          return get(computed_const_1).y2;
                                        },
                                        get motion() {
                                          return get(tweenConfig);
                                        }
                                      },
                                      () => get(splineProps),
                                      {
                                        get class() {
                                          return get($03);
                                        }
                                      }
                                    )),
                                    "component",
                                    Grid,
                                    163,
                                    10,
                                    { componentTag: "Line" }
                                  );
                                }
                                append($$anchor6, fragment_5);
                              };
                              var alternate = ($$anchor6) => {
                                var fragment_6 = comment();
                                var node_6 = first_child(fragment_6);
                                {
                                  let $03 = user_derived(() => cls(layerClass("grid-x-rule"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                  add_svelte_meta(
                                    () => Rule_default(node_6, spread_props(
                                      {
                                        get x() {
                                          return x5;
                                        },
                                        get xOffset() {
                                          return get(xBandOffset);
                                        },
                                        get motion() {
                                          return $$props.motion;
                                        }
                                      },
                                      () => get(splineProps),
                                      {
                                        get class() {
                                          return get($03);
                                        }
                                      }
                                    )),
                                    "component",
                                    Grid,
                                    178,
                                    10,
                                    { componentTag: "Rule" }
                                  );
                                }
                                append($$anchor6, fragment_6);
                              };
                              add_svelte_meta(
                                () => if_block(node_4, ($$render) => {
                                  if (ctx.radial) $$render(consequent);
                                  else $$render(alternate, false);
                                }),
                                "if",
                                Grid,
                                160,
                                8
                              );
                            }
                            append($$anchor5, fragment_4);
                          }),
                          "each",
                          Grid,
                          159,
                          6
                        );
                        var node_7 = sibling(node_3, 2);
                        {
                          var consequent_1 = ($$anchor5) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            {
                              let $03 = user_derived(() => ctx.xScale.step() + get(xBandOffset));
                              let $1 = user_derived(() => cls(layerClass("grid-x-end-rule"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                              add_svelte_meta(
                                () => Rule_default(node_8, spread_props(
                                  {
                                    get x() {
                                      return get(xTickVals)[get(xTickVals).length - 1];
                                    },
                                    get xOffset() {
                                      return get($03);
                                    },
                                    get motion() {
                                      return $$props.motion;
                                    }
                                  },
                                  () => get(splineProps),
                                  {
                                    get class() {
                                      return get($1);
                                    }
                                  }
                                )),
                                "component",
                                Grid,
                                195,
                                8,
                                { componentTag: "Rule" }
                              );
                            }
                            append($$anchor5, fragment_7);
                          };
                          add_svelte_meta(
                            () => if_block(node_7, ($$render) => {
                              if (isScaleBand(ctx.xScale) && strict_equals(bandAlign(), "between") && !ctx.radial && get(xTickVals).length) $$render(consequent_1);
                            }),
                            "if",
                            Grid,
                            194,
                            6
                          );
                        }
                        append($$anchor4, fragment_3);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Grid,
                    158,
                    4,
                    { componentTag: "Group" }
                  );
                }
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if (x4()) $$render(consequent_2);
                }),
                "if",
                Grid,
                155,
                2
              );
            }
            var node_9 = sibling(node_1, 2);
            {
              var consequent_7 = ($$anchor3) => {
                var fragment_8 = comment();
                const splineProps = tag(user_derived(() => extractLayerProps(y4(), "grid-y-line")), "splineProps");
                get(splineProps);
                var node_10 = first_child(fragment_8);
                {
                  let $02 = user_derived(() => layerClass("grid-y"));
                  add_svelte_meta(
                    () => Group_default(node_10, {
                      get transitionIn() {
                        return get(transitionIn);
                      },
                      get transitionInParams() {
                        return transitionInParams();
                      },
                      get class() {
                        return get($02);
                      },
                      children: wrap_snippet(Grid, ($$anchor4, $$slotProps2) => {
                        var fragment_9 = root_93();
                        var node_11 = first_child(fragment_9);
                        validate_each_keys(() => get(yTickVals), (y5) => y5);
                        add_svelte_meta(
                          () => each(node_11, 16, () => get(yTickVals), (y5) => y5, ($$anchor5, y5, $$index_1, $$array_1) => {
                            var fragment_10 = comment();
                            var node_12 = first_child(fragment_10);
                            {
                              var consequent_4 = ($$anchor6) => {
                                var fragment_11 = comment();
                                var node_13 = first_child(fragment_11);
                                {
                                  var consequent_3 = ($$anchor7) => {
                                    var fragment_12 = comment();
                                    var node_14 = first_child(fragment_12);
                                    {
                                      let $03 = user_derived(() => ctx.yScale(y5) + get(yBandOffset));
                                      let $1 = user_derived(() => cls(layerClass("grid-y-radial-circle"), "fill-none stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                      add_svelte_meta(
                                        () => Circle_default(node_14, spread_props(
                                          {
                                            get r() {
                                              return get($03);
                                            },
                                            get motion() {
                                              return $$props.motion;
                                            }
                                          },
                                          () => get(splineProps),
                                          {
                                            get class() {
                                              return get($1);
                                            }
                                          }
                                        )),
                                        "component",
                                        Grid,
                                        217,
                                        12,
                                        { componentTag: "Circle" }
                                      );
                                    }
                                    append($$anchor7, fragment_12);
                                  };
                                  var alternate_1 = ($$anchor7) => {
                                    var fragment_13 = comment();
                                    var node_15 = first_child(fragment_13);
                                    {
                                      let $03 = user_derived(() => get(xTickVals).map((x5) => ({ x: x5, y: y5 })));
                                      let $1 = user_derived(() => cls(layerClass("grid-y-radial-line"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                      add_svelte_meta(
                                        () => Spline_default(node_15, spread_props(
                                          {
                                            get data() {
                                              return get($03);
                                            },
                                            x: "x",
                                            y: "y",
                                            get motion() {
                                              return get(tweenConfig);
                                            },
                                            get curve() {
                                              return linearClosed_default;
                                            }
                                          },
                                          () => get(splineProps),
                                          {
                                            get class() {
                                              return get($1);
                                            }
                                          }
                                        )),
                                        "component",
                                        Grid,
                                        229,
                                        12,
                                        { componentTag: "Spline" }
                                      );
                                    }
                                    append($$anchor7, fragment_13);
                                  };
                                  add_svelte_meta(
                                    () => if_block(node_13, ($$render) => {
                                      if (strict_equals(radialY(), "circle")) $$render(consequent_3);
                                      else $$render(alternate_1, false);
                                    }),
                                    "if",
                                    Grid,
                                    216,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_11);
                              };
                              var alternate_2 = ($$anchor6) => {
                                var fragment_14 = comment();
                                var node_16 = first_child(fragment_14);
                                {
                                  let $03 = user_derived(() => cls(layerClass("grid-y-rule"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                  add_svelte_meta(
                                    () => Rule_default(node_16, spread_props(
                                      {
                                        get y() {
                                          return y5;
                                        },
                                        get yOffset() {
                                          return get(yBandOffset);
                                        },
                                        get motion() {
                                          return $$props.motion;
                                        }
                                      },
                                      () => get(splineProps),
                                      {
                                        get class() {
                                          return get($03);
                                        }
                                      }
                                    )),
                                    "component",
                                    Grid,
                                    245,
                                    10,
                                    { componentTag: "Rule" }
                                  );
                                }
                                append($$anchor6, fragment_14);
                              };
                              add_svelte_meta(
                                () => if_block(node_12, ($$render) => {
                                  if (ctx.radial) $$render(consequent_4);
                                  else $$render(alternate_2, false);
                                }),
                                "if",
                                Grid,
                                215,
                                8
                              );
                            }
                            append($$anchor5, fragment_10);
                          }),
                          "each",
                          Grid,
                          214,
                          6
                        );
                        var node_17 = sibling(node_11, 2);
                        {
                          var consequent_6 = ($$anchor5) => {
                            var fragment_15 = comment();
                            var node_18 = first_child(fragment_15);
                            {
                              var consequent_5 = ($$anchor6) => {
                                var fragment_16 = comment();
                                var node_19 = first_child(fragment_16);
                                {
                                  let $03 = user_derived(() => ctx.yScale(get(yTickVals)[get(yTickVals).length - 1]) + ctx.yScale.step() + get(yBandOffset));
                                  let $1 = user_derived(() => cls(layerClass("grid-y-radial-circle"), "fill-none stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                  add_svelte_meta(
                                    () => Circle_default(node_19, spread_props(
                                      {
                                        get r() {
                                          return get($03);
                                        },
                                        get motion() {
                                          return $$props.motion;
                                        }
                                      },
                                      () => get(splineProps),
                                      {
                                        get class() {
                                          return get($1);
                                        }
                                      }
                                    )),
                                    "component",
                                    Grid,
                                    263,
                                    10,
                                    { componentTag: "Circle" }
                                  );
                                }
                                append($$anchor6, fragment_16);
                              };
                              var alternate_3 = ($$anchor6) => {
                                var fragment_17 = comment();
                                var node_20 = first_child(fragment_17);
                                {
                                  let $03 = user_derived(() => ctx.yScale.step() + get(yBandOffset));
                                  let $1 = user_derived(() => cls(layerClass("grid-y-end-rule"), "stroke-surface-content/10", classes().line, get(splineProps)?.class));
                                  add_svelte_meta(
                                    () => Rule_default(node_20, spread_props(
                                      {
                                        get y() {
                                          return get(yTickVals)[get(yTickVals).length - 1];
                                        },
                                        get yOffset() {
                                          return get($03);
                                        },
                                        get motion() {
                                          return $$props.motion;
                                        }
                                      },
                                      () => get(splineProps),
                                      {
                                        get class() {
                                          return get($1);
                                        }
                                      }
                                    )),
                                    "component",
                                    Grid,
                                    275,
                                    10,
                                    { componentTag: "Rule" }
                                  );
                                }
                                append($$anchor6, fragment_17);
                              };
                              add_svelte_meta(
                                () => if_block(node_18, ($$render) => {
                                  if (ctx.radial) $$render(consequent_5);
                                  else $$render(alternate_3, false);
                                }),
                                "if",
                                Grid,
                                262,
                                8
                              );
                            }
                            append($$anchor5, fragment_15);
                          };
                          add_svelte_meta(
                            () => if_block(node_17, ($$render) => {
                              if (isScaleBand(ctx.yScale) && strict_equals(bandAlign(), "between") && get(yTickVals).length) $$render(consequent_6);
                            }),
                            "if",
                            Grid,
                            261,
                            6
                          );
                        }
                        append($$anchor4, fragment_9);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Grid,
                    213,
                    4,
                    { componentTag: "Group" }
                  );
                }
                append($$anchor3, fragment_8);
              };
              add_svelte_meta(
                () => if_block(node_9, ($$render) => {
                  if (y4()) $$render(consequent_7);
                }),
                "if",
                Grid,
                211,
                2
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      Grid,
      154,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Grid = hmr(Grid, () => Grid[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Grid[HMR].source;
    set(Grid[HMR].source, module2.default[HMR].original);
  });
}
var Grid_default = Grid;

// node_modules/layerchart/dist/utils/rect.svelte.js
function resolveInsets(insets) {
  const all = insets?.all ?? 0;
  const x4 = insets?.x ?? all;
  const y4 = insets?.y ?? all;
  const left2 = insets?.left ?? x4;
  const right2 = insets?.right ?? x4;
  const top = insets?.top ?? y4;
  const bottom = insets?.bottom ?? y4;
  return { left: left2, right: right2, bottom, top };
}
function createDimensionGetter(ctx, getOptions) {
  const options = tag(user_derived(() => getOptions?.()), "options");
  return (item) => {
    const insets = resolveInsets(get(options)?.insets);
    const xDomainMinMax = ctx.xScale.domain();
    const yDomainMinMax = ctx.yScale.domain();
    const _x = accessor(get(options)?.x ?? ctx.x);
    const _y = accessor(get(options)?.y ?? ctx.y);
    const _x1 = accessor(get(options)?.x1 ?? ctx.x1);
    const _y1 = accessor(get(options)?.y1 ?? ctx.y1);
    if (isScaleBand(ctx.yScale)) {
      const y4 = firstValue(ctx.yScale(_y(item)) ?? 0) + (ctx.y1Scale ? ctx.y1Scale(_y1(item)) : 0) + insets.top;
      const height = Math.max(0, ctx.yScale.bandwidth ? (ctx.y1Scale ? ctx.y1Scale.bandwidth?.() ?? 0 : ctx.yScale.bandwidth()) - insets.bottom - insets.top : 0);
      const xValue = _x(item);
      let left2 = 0;
      let right2 = 0;
      if (Array.isArray(xValue)) {
        left2 = min(xValue);
        right2 = max(xValue);
      } else if (equals(xValue, null)) {
        left2 = 0;
        right2 = 0;
      } else if (xValue > 0) {
        left2 = max([0, xDomainMinMax[0]]);
        right2 = xValue;
      } else {
        left2 = xValue;
        right2 = min([0, xDomainMinMax[1]]);
      }
      const x4 = ctx.xScale(left2) + insets.left;
      const width = Math.max(0, ctx.xScale(right2) - ctx.xScale(left2) - insets.left - insets.right);
      return { x: x4, y: y4, width, height };
    } else {
      const x4 = firstValue(ctx.xScale(_x(item))) + (ctx.x1Scale ? ctx.x1Scale(_x1(item)) : 0) + insets.left;
      const width = Math.max(0, ctx.xScale.bandwidth ? (ctx.x1Scale ? ctx.x1Scale.bandwidth?.() ?? 0 : ctx.xScale.bandwidth()) - insets.left - insets.right : 0);
      const yValue = _y(item);
      let top = 0;
      let bottom = 0;
      if (Array.isArray(yValue)) {
        top = max(yValue);
        bottom = min(yValue);
      } else if (equals(yValue, null)) {
        top = 0;
        bottom = 0;
      } else if (yValue > 0) {
        top = yValue;
        bottom = max([0, yDomainMinMax[0]]);
      } else {
        top = min([0, yDomainMinMax[1]]);
        bottom = yValue;
      }
      const y4 = ctx.yScale(top) + insets.top;
      const height = ctx.yScale(bottom) - ctx.yScale(top) - insets.bottom - insets.top;
      return { x: x4, y: y4, width, height };
    }
  };
}
function firstValue(value2) {
  return Array.isArray(value2) ? value2[0] : value2;
}

// node_modules/layerchart/dist/components/Bar.svelte
Bar[FILENAME] = "node_modules/layerchart/dist/components/Bar.svelte";
function Bar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Bar);
  const ctx = getChartContext();
  let x4 = prop($$props, "x", 19, () => ctx.x), y4 = prop($$props, "y", 19, () => ctx.y), strokeProp = prop($$props, "stroke", 3, "black"), strokeWidth = prop($$props, "strokeWidth", 3, 0), radius = prop($$props, "radius", 3, 0), roundedProp = prop($$props, "rounded", 3, "all"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "x1",
      "y1",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "radius",
      "rounded",
      "motion",
      "insets",
      "initialX",
      "initialY",
      "initialHeight",
      "initialWidth"
    ],
    "restProps"
  );
  const stroke = tag(user_derived(() => strict_equals(strokeProp(), null) || strict_equals(strokeProp(), void 0) ? "black" : strokeProp()), "stroke");
  const getDimensions = tag(
    user_derived(() => createDimensionGetter(ctx, () => ({
      x: x4(),
      y: y4(),
      x1: $$props.x1,
      y1: $$props.y1,
      insets: $$props.insets
    }))),
    "getDimensions"
  );
  const dimensions = tag(user_derived(() => get(getDimensions)($$props.data) ?? { x: 0, y: 0, width: 0, height: 0 }), "dimensions");
  const isVertical = tag(user_derived(() => isScaleBand(ctx.xScale)), "isVertical");
  const valueAccessor = tag(user_derived(() => accessor(get(isVertical) ? y4() : x4())), "valueAccessor");
  const value2 = tag(user_derived(() => get(valueAccessor)($$props.data)), "value");
  const resolvedValue = tag(user_derived(() => Array.isArray(get(value2)) ? greatestAbs(get(value2)) : get(value2)), "resolvedValue");
  const rounded = tag(
    user_derived(() => strict_equals(roundedProp(), "edge") ? get(isVertical) ? get(resolvedValue) >= 0 ? "top" : "bottom" : get(resolvedValue) >= 0 ? "right" : "left" : roundedProp()),
    "rounded"
  );
  const topLeft = tag(user_derived(() => ["all", "top", "left", "top-left"].includes(get(rounded))), "topLeft");
  const topRight = tag(user_derived(() => ["all", "top", "right", "top-right"].includes(get(rounded))), "topRight");
  const bottomLeft = tag(user_derived(() => ["all", "bottom", "left", "bottom-left"].includes(get(rounded))), "bottomLeft");
  const bottomRight = tag(user_derived(() => ["all", "bottom", "right", "bottom-right"].includes(get(rounded))), "bottomRight");
  const width = tag(user_derived(() => get(dimensions).width), "width");
  const height = tag(user_derived(() => get(dimensions).height), "height");
  const diameter = tag(user_derived(() => 2 * radius()), "diameter");
  const pathData = tag(
    user_derived(() => `M${get(dimensions).x + radius()},${get(dimensions).y} h${get(width) - get(diameter)}
      ${get(topRight) ? `a${radius()},${radius()} 0 0 1 ${radius()},${radius()}` : `h${radius()}v${radius()}`}
      v${get(height) - get(diameter)}
      ${get(bottomRight) ? `a${radius()},${radius()} 0 0 1 ${-radius()},${radius()}` : `v${radius()}h${-radius()}`}
      h${get(diameter) - get(width)}
      ${get(bottomLeft) ? `a${radius()},${radius()} 0 0 1 ${-radius()},${-radius()}` : `h${-radius()}v${-radius()}`}
      v${get(diameter) - get(height)}
      ${get(topLeft) ? `a${radius()},${radius()} 0 0 1 ${radius()},${-radius()}` : `v${-radius()}h${radius()}`}
      z`.split("\n").join("")),
    "pathData"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => get(dimensions).y + get(dimensions).height);
        let $1 = user_derived(() => get(dimensions).x + get(dimensions).width);
        let $2 = user_derived(() => extractLayerProps(restProps, "bar"));
        add_svelte_meta(
          () => Arc_default(node_1, spread_props(
            {
              get innerRadius() {
                return get(dimensions).y;
              },
              get outerRadius() {
                return get($0);
              },
              get startAngle() {
                return get(dimensions).x;
              },
              get endAngle() {
                return get($1);
              },
              get fill() {
                return $$props.fill;
              },
              get fillOpacity() {
                return $$props.fillOpacity;
              },
              get stroke() {
                return get(stroke);
              },
              get strokeWidth() {
                return strokeWidth();
              },
              get opacity() {
                return $$props.opacity;
              },
              get cornerRadius() {
                return radius();
              }
            },
            () => get($2)
          )),
          "component",
          Bar,
          171,
          2,
          { componentTag: "Arc" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            let $0 = user_derived(() => strict_equals(get(rounded), "none") ? 0 : radius());
            let $1 = user_derived(() => extractLayerProps(restProps, "bar"));
            add_svelte_meta(
              () => Rect_default(node_3, spread_props(
                {
                  get fill() {
                    return $$props.fill;
                  },
                  get fillOpacity() {
                    return $$props.fillOpacity;
                  },
                  get stroke() {
                    return get(stroke);
                  },
                  get strokeWidth() {
                    return strokeWidth();
                  },
                  get opacity() {
                    return $$props.opacity;
                  },
                  get rx() {
                    return get($0);
                  },
                  get motion() {
                    return $$props.motion;
                  },
                  get initialX() {
                    return $$props.initialX;
                  },
                  get initialY() {
                    return $$props.initialY;
                  },
                  get initialHeight() {
                    return $$props.initialHeight;
                  },
                  get initialWidth() {
                    return $$props.initialWidth;
                  }
                },
                () => get(dimensions),
                () => get($1)
              )),
              "component",
              Bar,
              185,
              2,
              { componentTag: "Rect" }
            );
          }
          append($$anchor3, fragment_3);
        };
        var alternate = ($$anchor3) => {
          var fragment_4 = comment();
          const tweenMotion = tag(user_derived(() => extractTweenConfig($$props.motion)), "tweenMotion");
          get(tweenMotion);
          var node_4 = first_child(fragment_4);
          {
            let $0 = user_derived(() => extractLayerProps(restProps, "bar"));
            add_svelte_meta(
              () => Spline_default(node_4, spread_props(
                {
                  get pathData() {
                    return get(pathData);
                  },
                  get fill() {
                    return $$props.fill;
                  },
                  get fillOpacity() {
                    return $$props.fillOpacity;
                  },
                  get stroke() {
                    return get(stroke);
                  },
                  get strokeWidth() {
                    return strokeWidth();
                  },
                  get opacity() {
                    return $$props.opacity;
                  },
                  get motion() {
                    return get(tweenMotion);
                  }
                },
                () => get($0)
              )),
              "component",
              Bar,
              202,
              2,
              { componentTag: "Spline" }
            );
          }
          append($$anchor3, fragment_4);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(get(rounded), "all") || strict_equals(get(rounded), "none") || strict_equals(radius(), 0)) $$render(consequent_1);
              else $$render(alternate, false);
            },
            true
          ),
          "if",
          Bar,
          184,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (ctx.radial) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Bar,
      170,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Bar = hmr(Bar, () => Bar[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Bar[HMR].source;
    set(Bar[HMR].source, module2.default[HMR].original);
  });
}
var Bar_default = Bar;

// node_modules/layerchart/dist/components/Highlight.svelte
Highlight[FILENAME] = "node_modules/layerchart/dist/components/Highlight.svelte";
var root_114 = add_locations(from_html(`<!> <!> <!> <!>`, 1), Highlight[FILENAME], []);
function Highlight($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Highlight);
  const ctx = getChartContext();
  const tooltipCtx = getTooltipContext();
  let xProp = prop($$props, "x", 19, () => ctx.x), yProp = prop($$props, "y", 19, () => ctx.y), points = prop($$props, "points", 3, false), linesProp = prop($$props, "lines", 3, false), area = prop($$props, "area", 3, false), bar = prop($$props, "bar", 3, false), motion = prop($$props, "motion", 3, "spring");
  const x4 = tag(user_derived(() => accessor(xProp())), "x");
  const y4 = tag(user_derived(() => accessor(yProp())), "y");
  const highlightData = tag(user_derived(() => $$props.data ?? tooltipCtx.data), "highlightData");
  const xValue = tag(user_derived(() => get(x4)(get(highlightData))), "xValue");
  const xCoord = tag(
    user_derived(() => Array.isArray(get(xValue)) ? get(xValue).map((v2) => ctx.xScale(v2)) : ctx.xScale(get(xValue))),
    "xCoord"
  );
  const xOffset = tag(user_derived(() => isScaleBand(ctx.xScale) && !ctx.radial ? ctx.xScale.bandwidth() / 2 : 0), "xOffset");
  const yValue = tag(user_derived(() => get(y4)(get(highlightData))), "yValue");
  const yCoord = tag(
    user_derived(() => Array.isArray(get(yValue)) ? get(yValue).map((v2) => ctx.yScale(v2)) : ctx.yScale(get(yValue))),
    "yCoord"
  );
  const yOffset = tag(user_derived(() => isScaleBand(ctx.yScale) && !ctx.radial ? ctx.yScale.bandwidth() / 2 : 0), "yOffset");
  const axis = tag(user_derived(() => equals($$props.axis, null) ? isScaleBand(ctx.yScale) ? "y" : "x" : $$props.axis), "axis");
  const _lines = tag(
    user_derived(() => {
      let tmpLines = [];
      if (!get(highlightData)) return tmpLines;
      if (strict_equals(get(axis), "x") || strict_equals(get(axis), "both")) {
        if (Array.isArray(get(xCoord))) {
          tmpLines = [
            ...tmpLines,
            ...get(xCoord).filter(notNull).map((xItem, i) => ({
              x1: xItem + get(xOffset),
              y1: min(ctx.yRange),
              x2: xItem + get(xOffset),
              y2: max(ctx.yRange)
            }))
          ];
        } else if (equals(get(xCoord), null, false)) {
          tmpLines = [
            ...tmpLines,
            {
              x1: get(xCoord) + get(xOffset),
              y1: min(ctx.yRange),
              x2: get(xCoord) + get(xOffset),
              y2: max(ctx.yRange)
            }
          ];
        }
      }
      if (strict_equals(get(axis), "y") || strict_equals(get(axis), "both")) {
        if (Array.isArray(get(yCoord))) {
          tmpLines = [
            ...tmpLines,
            ...get(yCoord).filter(notNull).map((yItem, i) => ({
              x1: min(ctx.xRange),
              y1: yItem + get(yOffset),
              x2: max(ctx.xRange),
              y2: yItem + get(yOffset)
            }))
          ];
        } else if (equals(get(yCoord), null, false)) {
          tmpLines = [
            ...tmpLines,
            {
              x1: min(ctx.xRange),
              y1: get(yCoord) + get(yOffset),
              x2: max(ctx.xRange),
              y2: get(yCoord) + get(yOffset)
            }
          ];
        }
      }
      if (ctx.radial) {
        tmpLines = tmpLines.map((l) => {
          const [x12, y12] = pointRadial_default(l.x1, l.y1);
          const [x22, y22] = pointRadial_default(l.x2, l.y2);
          return { ...l, x1: x12, y1: y12, x2: x22, y2: y22 };
        });
      }
      return tmpLines;
    }),
    "_lines"
  );
  const _area = tag(
    user_derived(() => {
      const tmpArea = { x: 0, y: 0, width: 0, height: 0 };
      if (!get(highlightData)) return tmpArea;
      if (strict_equals(get(axis), "x") || strict_equals(get(axis), "both")) {
        if (Array.isArray(get(xCoord))) {
          tmpArea.width = max(get(
            xCoord
            // Use first/last values for width
          )) - min(get(xCoord));
        } else if (isScaleBand(ctx.xScale)) {
          tmpArea.width = ctx.xScale.step();
        } else {
          const index4 = ctx.flatData.findIndex((d) => strict_equals(Number(get(x4)(d)), Number(get(x4)(get(highlightData)))));
          const isLastPoint = strict_equals(index4 + 1, ctx.flatData.length);
          const nextDataPoint = isLastPoint ? max(ctx.xDomain) : get(x4)(ctx.flatData[index4 + 1]);
          tmpArea.width = (ctx.xScale(nextDataPoint) ?? 0) - (get(xCoord) ?? 0);
        }
        tmpArea.x = (Array.isArray(get(xCoord)) ? min(get(xCoord)) : get(xCoord)) - (isScaleBand(ctx.xScale) ? ctx.xScale.padding() * ctx.xScale.step() / 2 : 0);
        if (strict_equals(get(axis), "x")) {
          tmpArea.y = min(ctx.yRange);
          tmpArea.height = max(ctx.yRange) - min(ctx.yRange);
        }
      }
      if (strict_equals(get(axis), "y") || strict_equals(get(axis), "both")) {
        if (Array.isArray(get(yCoord))) {
          tmpArea.height = max(get(
            yCoord
            // Use first/last values for width
          )) - min(get(yCoord));
        } else if (isScaleBand(ctx.yScale)) {
          tmpArea.height = ctx.yScale.step();
        } else {
          const index4 = ctx.flatData.findIndex((d) => strict_equals(Number(get(x4)(d)), Number(get(x4)(get(highlightData)))));
          const isLastPoint = strict_equals(index4 + 1, ctx.flatData.length);
          const nextDataPoint = isLastPoint ? max(ctx.yDomain) : get(x4)(ctx.flatData[index4 + 1]);
          tmpArea.height = (ctx.yScale(nextDataPoint) ?? 0) - (get(yCoord) ?? 0);
        }
        tmpArea.y = (Array.isArray(get(yCoord)) ? min(get(yCoord)) : get(yCoord)) - (isScaleBand(ctx.yScale) ? ctx.yScale.padding() * ctx.yScale.step() / 2 : 0);
        if (strict_equals(get(axis), "y")) {
          tmpArea.width = max(ctx.xRange);
        }
      }
      return tmpArea;
    }),
    "_area"
  );
  const _points = tag(
    user_derived(() => {
      let tmpPoints = [];
      if (!get(highlightData)) return tmpPoints;
      if (Array.isArray(get(xCoord))) {
        if (Array.isArray(get(highlightData))) {
          const highlightSeriesPoint = get(highlightData);
          if (Array.isArray(ctx.data)) {
            const seriesPointsData = ctx.data.map((series) => {
              return {
                series,
                point: series.find((d) => strict_equals(get(y4)(d), get(y4)(highlightSeriesPoint)))
              };
            }).filter((d) => d.point);
            tmpPoints = seriesPointsData.map((seriesPoint, i) => {
              return {
                x: ctx.xScale(seriesPoint.point[1]) + get(xOffset),
                y: get(yCoord) + get(yOffset),
                fill: ctx.config.c ? ctx.cGet(seriesPoint.series) : null,
                data: { x: seriesPoint.point[1], y: get(yValue) }
              };
            });
          }
        } else {
          tmpPoints = get(xCoord).filter(notNull).map((xItem, i) => {
            const _key = ctx.config.x?.[i];
            return {
              x: xItem + get(xOffset),
              y: get(yCoord) + get(yOffset),
              // TODO: is there a better way to expose the series key/value?
              fill: ctx.config.c ? ctx.cGet({ ...get(highlightData), $key: _key }) : null,
              data: {
                x: get(
                  xValue
                  // TODO: use highlightData[$key]?
                ),
                y: get(yValue)
              }
            };
          });
        }
      } else if (Array.isArray(get(yCoord))) {
        if (Array.isArray(get(highlightData))) {
          const highlightSeriesPoint = get(highlightData);
          if (Array.isArray(ctx.data)) {
            const seriesPointsData = ctx.data.map((series) => {
              return {
                series,
                point: series.find((d) => strict_equals(get(x4)(d), get(x4)(highlightSeriesPoint)))
              };
            }).filter((d) => d.point);
            tmpPoints = seriesPointsData.map((seriesPoint, i) => ({
              x: get(xCoord) + get(xOffset),
              y: ctx.yScale(seriesPoint.point[1]) + get(yOffset),
              fill: ctx.config.c ? ctx.cGet(seriesPoint.series) : null,
              data: { x: get(xValue), y: seriesPoint.point[1] }
            }));
          }
        } else {
          tmpPoints = get(yCoord).filter(notNull).map((yItem, i) => {
            const _key = ctx.config.y[i];
            return {
              x: get(xCoord) + get(xOffset),
              y: yItem + get(yOffset),
              // TODO: is there a better way to expose the series key/value?
              fill: ctx.config.c ? ctx.cGet({ ...get(highlightData), $key: _key }) : null,
              data: {
                x: get(xValue),
                y: get(
                  yValue
                  // TODO: use highlightData[$key] ?
                )
              }
            };
          });
        }
      } else if (equals(get(xCoord), null, false) && equals(get(yCoord), null, false)) {
        tmpPoints = [
          {
            x: get(xCoord) + get(xOffset),
            y: get(yCoord) + get(yOffset),
            fill: ctx.config.c ? ctx.cGet(get(highlightData)) : null,
            data: { x: get(xValue), y: get(yValue) }
          }
        ];
      } else {
        tmpPoints = [];
      }
      if (ctx.radial) {
        tmpPoints = tmpPoints.map((p) => {
          const [x5, y5] = pointRadial_default(p.x, p.y);
          return { ...p, x: x5, y: y5 };
        });
      }
      return tmpPoints;
    }),
    "_points"
  );
  const areaProps = tag(user_derived(() => extractLayerProps(area(), "highlight-area")), "areaProps");
  const barProps = tag(user_derived(() => extractLayerProps(bar(), "highlight-bar")), "barProps");
  const linesProps = tag(user_derived(() => extractLayerProps(linesProp(), "highlight-line")), "linesProps");
  const pointsProps = tag(user_derived(() => extractLayerProps(points(), "highlight-point")), "pointsProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_9 = ($$anchor2) => {
      var fragment_1 = root_114();
      var node_1 = first_child(fragment_1);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              add_svelte_meta(() => snippet(node_3, area, () => ({ area: get(_area) })), "render", Highlight, 445, 6);
              append($$anchor4, fragment_3);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              {
                var consequent_1 = ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_5 = first_child(fragment_5);
                  {
                    let $0 = user_derived(() => strict_equals(motion(), "spring") ? "spring" : void 0);
                    let $1 = user_derived(() => get(_area).x + get(_area).width);
                    let $2 = user_derived(() => get(_area).y + get(_area).height);
                    let $3 = user_derived(() => cls(!get(areaProps).fill && "fill-surface-content/5", get(areaProps).class));
                    let $4 = user_derived(() => $$props.onAreaClick && ((e) => $$props.onAreaClick(e, { data: get(highlightData) })));
                    add_svelte_meta(
                      () => Arc_default(node_5, {
                        get motion() {
                          return get($0);
                        },
                        get startAngle() {
                          return get(_area).x;
                        },
                        get endAngle() {
                          return get($1);
                        },
                        get innerRadius() {
                          return get(_area).y;
                        },
                        get outerRadius() {
                          return get($2);
                        },
                        get class() {
                          return get($3);
                        },
                        get onclick() {
                          return get($4);
                        }
                      }),
                      "component",
                      Highlight,
                      448,
                      6,
                      { componentTag: "Arc" }
                    );
                  }
                  append($$anchor5, fragment_5);
                };
                var alternate = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_6 = first_child(fragment_6);
                  {
                    let $0 = user_derived(() => strict_equals(motion(), "spring") ? "spring" : void 0);
                    let $1 = user_derived(() => cls(!get(areaProps).fill && "fill-surface-content/5", get(areaProps).class));
                    let $2 = user_derived(() => $$props.onAreaClick && ((e) => $$props.onAreaClick(e, { data: get(highlightData) })));
                    add_svelte_meta(
                      () => Rect_default(node_6, spread_props(
                        {
                          get motion() {
                            return get($0);
                          }
                        },
                        () => get(_area),
                        () => get(areaProps),
                        {
                          get class() {
                            return get($1);
                          },
                          get onclick() {
                            return get($2);
                          }
                        }
                      )),
                      "component",
                      Highlight,
                      458,
                      6,
                      { componentTag: "Rect" }
                    );
                  }
                  append($$anchor5, fragment_6);
                };
                add_svelte_meta(
                  () => if_block(
                    node_4,
                    ($$render) => {
                      if (ctx.radial) $$render(consequent_1);
                      else $$render(alternate, false);
                    },
                    true
                  ),
                  "if",
                  Highlight,
                  446,
                  4
                );
              }
              append($$anchor4, fragment_4);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (strict_equals(typeof area(), "function")) $$render(consequent);
                else $$render(alternate_1, false);
              }),
              "if",
              Highlight,
              444,
              4
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (area()) $$render(consequent_2);
          }),
          "if",
          Highlight,
          443,
          2
        );
      }
      var node_7 = sibling(node_1, 2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_7 = comment();
          var node_8 = first_child(fragment_7);
          {
            var consequent_3 = ($$anchor4) => {
              var fragment_8 = comment();
              var node_9 = first_child(fragment_8);
              add_svelte_meta(() => snippet(node_9, bar), "render", Highlight, 470, 6);
              append($$anchor4, fragment_8);
            };
            var alternate_2 = ($$anchor4) => {
              var fragment_9 = comment();
              var node_10 = first_child(fragment_9);
              {
                let $0 = user_derived(() => strict_equals(motion(), "spring") ? "spring" : void 0);
                let $1 = user_derived(() => cls(!get(barProps).fill && "fill-primary", get(barProps).class));
                let $2 = user_derived(() => $$props.onBarClick && ((e) => $$props.onBarClick(e, { data: get(highlightData) })));
                add_svelte_meta(
                  () => Bar_default(node_10, spread_props(
                    {
                      get motion() {
                        return get($0);
                      },
                      get data() {
                        return get(highlightData);
                      }
                    },
                    () => get(barProps),
                    {
                      get class() {
                        return get($1);
                      },
                      get onclick() {
                        return get($2);
                      }
                    }
                  )),
                  "component",
                  Highlight,
                  472,
                  6,
                  { componentTag: "Bar" }
                );
              }
              append($$anchor4, fragment_9);
            };
            add_svelte_meta(
              () => if_block(node_8, ($$render) => {
                if (strict_equals(typeof bar(), "function")) $$render(consequent_3);
                else $$render(alternate_2, false);
              }),
              "if",
              Highlight,
              469,
              4
            );
          }
          append($$anchor3, fragment_7);
        };
        add_svelte_meta(
          () => if_block(node_7, ($$render) => {
            if (bar()) $$render(consequent_4);
          }),
          "if",
          Highlight,
          468,
          2
        );
      }
      var node_11 = sibling(node_7, 2);
      {
        var consequent_6 = ($$anchor3) => {
          var fragment_10 = comment();
          var node_12 = first_child(fragment_10);
          {
            var consequent_5 = ($$anchor4) => {
              var fragment_11 = comment();
              var node_13 = first_child(fragment_11);
              add_svelte_meta(() => snippet(node_13, linesProp, () => ({ lines: get(_lines) })), "render", Highlight, 484, 6);
              append($$anchor4, fragment_11);
            };
            var alternate_3 = ($$anchor4) => {
              var fragment_12 = comment();
              var node_14 = first_child(fragment_12);
              add_svelte_meta(
                () => each(node_14, 17, () => get(_lines), index, ($$anchor5, line) => {
                  var fragment_13 = comment();
                  var node_15 = first_child(fragment_13);
                  {
                    let $0 = user_derived(() => strict_equals(motion(), "spring") ? "spring" : void 0);
                    let $1 = user_derived(() => cls("stroke-surface-content/20 stroke-2 [stroke-dasharray:2,2] pointer-events-none", get(linesProps).class));
                    add_svelte_meta(
                      () => Line_default(node_15, spread_props(
                        {
                          get motion() {
                            return get($0);
                          },
                          get x1() {
                            return get(line).x1;
                          },
                          get y1() {
                            return get(line).y1;
                          },
                          get x2() {
                            return get(line).x2;
                          },
                          get y2() {
                            return get(line).y2;
                          }
                        },
                        () => get(linesProps),
                        {
                          get class() {
                            return get($1);
                          }
                        }
                      )),
                      "component",
                      Highlight,
                      487,
                      8,
                      { componentTag: "Line" }
                    );
                  }
                  append($$anchor5, fragment_13);
                }),
                "each",
                Highlight,
                486,
                6
              );
              append($$anchor4, fragment_12);
            };
            add_svelte_meta(
              () => if_block(node_12, ($$render) => {
                if (strict_equals(typeof linesProp(), "function")) $$render(consequent_5);
                else $$render(alternate_3, false);
              }),
              "if",
              Highlight,
              483,
              4
            );
          }
          append($$anchor3, fragment_10);
        };
        add_svelte_meta(
          () => if_block(node_11, ($$render) => {
            if (linesProp()) $$render(consequent_6);
          }),
          "if",
          Highlight,
          482,
          2
        );
      }
      var node_16 = sibling(node_11, 2);
      {
        var consequent_8 = ($$anchor3) => {
          var fragment_14 = comment();
          var node_17 = first_child(fragment_14);
          {
            var consequent_7 = ($$anchor4) => {
              var fragment_15 = comment();
              var node_18 = first_child(fragment_15);
              add_svelte_meta(() => snippet(node_18, points, () => ({ points: get(_points) })), "render", Highlight, 505, 6);
              append($$anchor4, fragment_15);
            };
            var alternate_4 = ($$anchor4) => {
              var fragment_16 = comment();
              var node_19 = first_child(fragment_16);
              add_svelte_meta(
                () => each(node_19, 17, () => get(_points), index, ($$anchor5, point10) => {
                  var fragment_17 = comment();
                  var node_20 = first_child(fragment_17);
                  {
                    let $0 = user_derived(() => strict_equals(motion(), "spring") ? "spring" : void 0);
                    let $1 = user_derived(() => cls("stroke-white [paint-order:stroke] drop-shadow-sm", !get(point10).fill && (strict_equals(typeof points(), "boolean") || !points().fill) && "fill-primary", get(pointsProps).class));
                    let $2 = user_derived(() => $$props.onPointClick && ((e) => {
                      e.stopPropagation();
                    }));
                    let $3 = user_derived(() => $$props.onPointClick && ((e) => $$props.onPointClick(e, { point: get(point10), data: get(highlightData) })));
                    let $4 = user_derived(() => $$props.onPointEnter && ((e) => {
                      if ($$props.onPointClick) {
                        asAny(e.target).style.cursor = "pointer";
                      }
                      $$props.onPointEnter(e, { point: get(point10), data: get(highlightData) });
                    }));
                    let $5 = user_derived(() => $$props.onPointLeave && ((e) => {
                      if ($$props.onPointClick) {
                        asAny(e.target).style.cursor = "default";
                      }
                      $$props.onPointLeave(e, { point: get(point10), data: get(highlightData) });
                    }));
                    add_svelte_meta(
                      () => Circle_default(node_20, spread_props(
                        {
                          get motion() {
                            return get($0);
                          },
                          get cx() {
                            return get(point10).x;
                          },
                          get cy() {
                            return get(point10).y;
                          },
                          get fill() {
                            return get(point10).fill;
                          },
                          r: 4,
                          strokeWidth: 6
                        },
                        () => get(pointsProps),
                        {
                          get class() {
                            return get($1);
                          },
                          get onpointerdown() {
                            return get($2);
                          },
                          get onclick() {
                            return get($3);
                          },
                          get onpointerenter() {
                            return get($4);
                          },
                          get onpointerleave() {
                            return get($5);
                          }
                        }
                      )),
                      "component",
                      Highlight,
                      508,
                      8,
                      { componentTag: "Circle" }
                    );
                  }
                  append($$anchor5, fragment_17);
                }),
                "each",
                Highlight,
                507,
                6
              );
              append($$anchor4, fragment_16);
            };
            add_svelte_meta(
              () => if_block(node_17, ($$render) => {
                if (strict_equals(typeof points(), "function")) $$render(consequent_7);
                else $$render(alternate_4, false);
              }),
              "if",
              Highlight,
              504,
              4
            );
          }
          append($$anchor3, fragment_14);
        };
        add_svelte_meta(
          () => if_block(node_16, ($$render) => {
            if (points()) $$render(consequent_8);
          }),
          "if",
          Highlight,
          503,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(highlightData)) $$render(consequent_9);
      }),
      "if",
      Highlight,
      442,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Highlight = hmr(Highlight, () => Highlight[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Highlight[HMR].source;
    set(Highlight[HMR].source, module2.default[HMR].original);
  });
}
var Highlight_default = Highlight;

// node_modules/layerchart/dist/utils/connectorUtils.js
function isSamePoint(p1, p2) {
  return Math.abs(p1.x - p2.x) < 1e-6 && Math.abs(p1.y - p2.y) < 1e-6;
}
function createDirectPath(source, target) {
  if (isSamePoint(source, target))
    return "";
  return `M ${source.x} ${source.y} L ${target.x} ${target.y}`;
}
function isNearZero(value2) {
  return Math.abs(value2) < 1e-6;
}
function createSquarePath({ source, target, sweep }) {
  if (sweep === "horizontal-vertical") {
    return `M ${source.x} ${source.y} L ${target.x} ${source.y} L ${target.x} ${target.y}`;
  } else {
    return `M ${source.x} ${source.y} L ${source.x} ${target.y} L ${target.x} ${target.y}`;
  }
}
function createBeveledPath(opts) {
  const { radius, dx, dy, source, target, sweep } = opts;
  const effectiveRadius = Math.max(0, Math.min(radius, Math.abs(dx), Math.abs(dy)));
  if (isNearZero(effectiveRadius)) {
    return createSquarePath(opts);
  }
  const signX = Math.sign(dx);
  const signY = Math.sign(dy);
  if (sweep === "horizontal-vertical") {
    const pBeforeCorner = { x: target.x - effectiveRadius * signX, y: source.y };
    const pAfterCorner = { x: target.x, y: source.y + effectiveRadius * signY };
    return `M ${source.x} ${source.y} L ${pBeforeCorner.x} ${pBeforeCorner.y} L ${pAfterCorner.x} ${pAfterCorner.y} L ${target.x} ${target.y}`;
  } else {
    const pBeforeCorner = { x: source.x, y: target.y - effectiveRadius * signY };
    const pAfterCorner = { x: source.x + effectiveRadius * signX, y: target.y };
    return `M ${source.x} ${source.y} L ${pBeforeCorner.x} ${pBeforeCorner.y} L ${pAfterCorner.x} ${pAfterCorner.y} L ${target.x} ${target.y}`;
  }
}
function createRoundedPath(opts) {
  const { radius, dx, dy, source, target, sweep } = opts;
  const effectiveRadius = Math.max(0, Math.min(radius, Math.abs(dx), Math.abs(dy)));
  if (isNearZero(effectiveRadius)) {
    return createSquarePath(opts);
  }
  const signX = Math.sign(dx);
  const signY = Math.sign(dy);
  if (sweep === "horizontal-vertical") {
    const pBeforeCorner = { x: target.x - effectiveRadius * signX, y: source.y };
    const pAfterCorner = { x: target.x, y: source.y + effectiveRadius * signY };
    const sweepFlag = signX * signY > 0 ? 1 : 0;
    return `M ${source.x} ${source.y} L ${pBeforeCorner.x} ${pBeforeCorner.y} A ${effectiveRadius} ${effectiveRadius} 0 0 ${sweepFlag} ${pAfterCorner.x} ${pAfterCorner.y} L ${target.x} ${target.y}`;
  } else {
    const pBeforeCorner = { x: source.x, y: target.y - effectiveRadius * signY };
    const pAfterCorner = { x: source.x + effectiveRadius * signX, y: target.y };
    const sweepFlag = signX * signY > 0 ? 0 : 1;
    return `M ${source.x} ${source.y} L ${pBeforeCorner.x} ${pBeforeCorner.y} A ${effectiveRadius} ${effectiveRadius} 0 0 ${sweepFlag} ${pAfterCorner.x} ${pAfterCorner.y} L ${target.x} ${target.y}`;
  }
}
var pathStrategies = {
  square: createSquarePath,
  beveled: createBeveledPath,
  rounded: createRoundedPath
};
function getConnectorPresetPath(opts) {
  const { source, target, type } = opts;
  if (isSamePoint(source, target))
    return "";
  const dx = target.x - source.x;
  const dy = target.y - source.y;
  if (type === "straight" || isNearZero(dx) || isNearZero(dy)) {
    return createDirectPath(source, target);
  }
  return (pathStrategies[type] || pathStrategies.square)({ ...opts, dx, dy });
}
var FALLBACK_PATH = "M0,0L0,0";
function getConnectorD3Path({ source, target, sweep, curve }) {
  const dx = target.x - source.x;
  const dy = target.y - source.y;
  const line = line_default().curve(curve);
  let points = [];
  const isAligned = isNearZero(dx) || isNearZero(dy);
  if (sweep === "none" || isAligned) {
    points = [
      [source.x, source.y],
      [target.x, target.y]
    ];
  } else if (sweep === "horizontal-vertical") {
    points = [
      [source.x, source.y],
      [target.x, source.y],
      [target.x, target.y]
    ];
  } else if (sweep === "vertical-horizontal") {
    points = [
      [source.x, source.y],
      [source.x, target.y],
      [target.x, target.y]
    ];
  }
  if (points.length === 2 && isNearZero(dx) && isNearZero(dx))
    return FALLBACK_PATH;
  const d = line(points);
  if (!d || d.includes("NaN"))
    return FALLBACK_PATH;
  return d;
}

// node_modules/layerchart/dist/components/Connector.svelte
Connector[FILENAME] = "node_modules/layerchart/dist/components/Connector.svelte";
var root17 = add_locations(from_html(`<!> <!> <!> <!>`, 1), Connector[FILENAME], []);
function Connector($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Connector);
  var $$ownership_validator = create_ownership_validator($$props);
  let source = prop($$props, "source", 19, () => ({ x: 0, y: 0 })), target = prop($$props, "target", 19, () => ({ x: 100, y: 100 })), type = prop($$props, "type", 3, "rounded"), radius = prop($$props, "radius", 3, 20), curve = prop($$props, "curve", 3, linear_default), pathRef = prop($$props, "pathRef", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "source",
      "target",
      "sweep",
      "type",
      "radius",
      "curve",
      "pathRef",
      "pathData",
      "marker",
      "markerStart",
      "markerMid",
      "markerEnd",
      "motion"
    ],
    "restProps"
  );
  const sweep = tag(
    user_derived(() => {
      if ($$props.sweep) return $$props.sweep;
      if (strict_equals(type(), "d3")) return "none";
      return "horizontal-vertical";
    }),
    "sweep"
  );
  const markerStartId = tag(user_derived(() => $$props.markerStart || $$props.marker ? createId("marker-start", uid) : ""), "markerStartId");
  const markerMidId = tag(user_derived(() => $$props.markerMid || $$props.marker ? createId("marker-mid", uid) : ""), "markerMidId");
  const markerEndId = tag(user_derived(() => $$props.markerEnd || $$props.marker ? createId("marker-end", uid) : ""), "markerEndId");
  const extractedTween = extractTweenConfig($$props.motion);
  const tweenOptions = extractedTween ? {
    type: extractedTween.type,
    options: { interpolate: interpolatePath, ...extractedTween.options }
  } : void 0;
  const pathData = tag(
    user_derived(() => {
      if ($$props.pathData) return $$props.pathData;
      if (strict_equals(type(), "d3")) {
        return getConnectorD3Path({
          source: source(),
          target: target(),
          sweep: get(sweep),
          curve: curve()
        });
      } else {
        return getConnectorPresetPath({
          source: source(),
          target: target(),
          sweep: get(sweep),
          type: type(),
          radius: radius()
        });
      }
    }),
    "pathData"
  );
  const motionPath = createMotion("", () => get(pathData), tweenOptions ? tweenOptions : { type: "none" });
  var fragment = root17();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => get(markerStartId) ? `url(#${get(markerStartId)})` : void 0);
    let $1 = user_derived(() => get(markerMidId) ? `url(#${get(markerMidId)})` : void 0);
    let $2 = user_derived(() => get(markerEndId) ? `url(#${get(markerEndId)})` : void 0);
    let $3 = user_derived(() => extractLayerProps(restProps, "connector"));
    $$ownership_validator.binding("pathRef", Spline_default, pathRef);
    add_svelte_meta(
      () => Spline_default(node, spread_props(
        {
          get pathData() {
            return motionPath.current;
          },
          get "marker-start"() {
            return get($0);
          },
          get "marker-mid"() {
            return get($1);
          },
          get "marker-end"() {
            return get($2);
          }
        },
        () => get($3),
        () => restProps,
        {
          get pathRef() {
            return pathRef();
          },
          set pathRef($$value) {
            pathRef($$value);
          }
        }
      )),
      "component",
      Connector,
      138,
      0,
      { componentTag: "Spline" }
    );
  }
  var node_1 = sibling(node, 2);
  add_svelte_meta(
    () => MarkerWrapper_default(node_1, {
      get id() {
        return get(markerStartId);
      },
      get marker() {
        return $$props.markerStart;
      }
    }),
    "component",
    Connector,
    147,
    0,
    { componentTag: "MarkerWrapper" }
  );
  var node_2 = sibling(node_1, 2);
  add_svelte_meta(
    () => MarkerWrapper_default(node_2, {
      get id() {
        return get(markerMidId);
      },
      get marker() {
        return $$props.markerMid;
      }
    }),
    "component",
    Connector,
    148,
    0,
    { componentTag: "MarkerWrapper" }
  );
  var node_3 = sibling(node_2, 2);
  add_svelte_meta(
    () => MarkerWrapper_default(node_3, {
      get id() {
        return get(markerEndId);
      },
      get marker() {
        return $$props.markerEnd;
      }
    }),
    "component",
    Connector,
    149,
    0,
    { componentTag: "MarkerWrapper" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Connector = hmr(Connector, () => Connector[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Connector[HMR].source;
    set(Connector[HMR].source, module2.default[HMR].original);
  });
}
var Connector_default = Connector;

// node_modules/layerchart/dist/components/Link.svelte
Link[FILENAME] = "node_modules/layerchart/dist/components/Link.svelte";
var FALLBACK_COORDS = { x: 0, y: 0 };
function Link($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link);
  let sankey = prop($$props, "sankey", 3, false), type = prop($$props, "type", 3, "d3"), sweep = prop($$props, "sweep", 3, "none"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "sankey",
      "source",
      "target",
      "orientation",
      "x",
      "y",
      "curve",
      "explicitCoords",
      "type",
      "sweep"
    ],
    "restProps"
  );
  const sourceAccessor = tag(
    user_derived(() => {
      if ($$props.source) return $$props.source;
      if (sankey()) return (d) => ({ node: d.source, y: d.y0, isSource: true });
      return (d) => d.source;
    }),
    "sourceAccessor"
  );
  const targetAccessor = tag(
    user_derived(() => {
      if ($$props.target) return $$props.target;
      if (sankey()) return (d) => ({ node: d.target, y: d.y1, isSource: false });
      return (d) => d.target;
    }),
    "targetAccessor"
  );
  const orientation = tag(
    user_derived(() => {
      if ($$props.orientation) return $$props.orientation;
      if (sankey()) return "horizontal";
      return "vertical";
    }),
    "orientation"
  );
  const curve = tag(
    user_derived(() => {
      if ($$props.curve) return $$props.curve;
      if (strict_equals(get(orientation), "horizontal")) return bumpX;
      return bumpY;
    }),
    "curve"
  );
  const xAccessor = tag(
    user_derived(() => {
      if ($$props.x) return $$props.x;
      if (sankey()) return (d) => d.isSource ? d.node.x1 : d.node.x0;
      return (d) => strict_equals(get(orientation), "horizontal") ? d.y : d.x;
    }),
    "xAccessor"
  );
  const yAccessor = tag(
    user_derived(() => {
      if ($$props.y) return $$props.y;
      if (sankey()) return (d) => d.y;
      return (d) => strict_equals(get(orientation), "horizontal") ? d.x : d.y;
    }),
    "yAccessor"
  );
  const sourceCoords = tag(
    user_derived(() => {
      if ($$props.explicitCoords) return { x: $$props.explicitCoords.x1, y: $$props.explicitCoords.y1 };
      if (!$$props.data) return FALLBACK_COORDS;
      try {
        const sourceData = get(sourceAccessor)($$props.data);
        if (equals(sourceData, null)) return FALLBACK_COORDS;
        const xVal = get(xAccessor)(sourceData);
        const yVal = get(yAccessor)(sourceData);
        return {
          x: Number.isFinite(xVal) ? xVal : 0,
          y: Number.isFinite(yVal) ? yVal : 0
        };
      } catch (e) {
        console.error(...log_if_contains_state("error", "Error accessing source coordinates:", e, "Data:", $$props.data));
        return FALLBACK_COORDS;
      }
    }),
    "sourceCoords"
  );
  const targetCoords = tag(
    user_derived(() => {
      if ($$props.explicitCoords) return { x: $$props.explicitCoords.x2, y: $$props.explicitCoords.y2 };
      if (!$$props.data) return FALLBACK_COORDS;
      try {
        const targetData = get(targetAccessor)($$props.data);
        if (equals(targetData, null)) return FALLBACK_COORDS;
        const xVal = get(xAccessor)(targetData);
        const yVal = get(yAccessor)(targetData);
        return {
          x: Number.isFinite(xVal) ? xVal : 0,
          y: Number.isFinite(yVal) ? yVal : 0
        };
      } catch (e) {
        console.error(...log_if_contains_state("error", "Error accessing target coordinates:", e, "Data:", $$props.data));
        return FALLBACK_COORDS;
      }
    }),
    "targetCoords"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => extractLayerProps(restProps, "link"));
    add_svelte_meta(
      () => Connector_default(node, spread_props(
        {
          get source() {
            return get(sourceCoords);
          },
          get target() {
            return get(targetCoords);
          },
          get type() {
            return type();
          },
          get curve() {
            return get(curve);
          },
          get sweep() {
            return sweep();
          }
        },
        () => get($0)
      )),
      "component",
      Link,
      170,
      0,
      { componentTag: "Connector" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link = hmr(Link, () => Link[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Link[HMR].source;
    set(Link[HMR].source, module2.default[HMR].original);
  });
}
var Link_default = Link;

// node_modules/layerchart/dist/components/Points.svelte
Points[FILENAME] = "node_modules/layerchart/dist/components/Points.svelte";
var root_27 = add_locations(from_html(`<!> <!>`, 1), Points[FILENAME], []);
function Points($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Points);
  const ctx = getChartContext();
  let r = prop($$props, "r", 3, 5), links = prop($$props, "links", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "r",
      "offsetX",
      "offsetY",
      "links",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "children"
    ],
    "restProps"
  );
  function getOffset(value2, offset, scale2) {
    if (strict_equals(typeof offset, "function")) {
      return offset(value2, ctx);
    } else if (equals(offset, null, false)) {
      return offset;
    } else if (isScaleBand(scale2) && !ctx.radial) {
      return scale2.bandwidth() / 2;
    } else {
      return 0;
    }
  }
  const xAccessor = tag(user_derived(() => $$props.x ? accessor($$props.x) : ctx.x), "xAccessor");
  const yAccessor = tag(user_derived(() => $$props.y ? accessor($$props.y) : ctx.y), "yAccessor");
  const pointsData = tag(user_derived(() => $$props.data ?? ctx.data), "pointsData");
  const getPointObject = (xVal, yVal, d) => {
    const scaledX = ctx.xScale(xVal);
    const scaledY = ctx.yScale(yVal);
    return {
      x: scaledX + getOffset(scaledX, $$props.offsetX, ctx.xScale),
      y: scaledY + getOffset(scaledY, $$props.offsetY, ctx.yScale),
      r: ctx.config.r ? ctx.rGet(d) : r(),
      xValue: xVal,
      yValue: yVal,
      data: d
    };
  };
  const points = tag(
    user_derived(() => get(pointsData).flatMap((d) => {
      const xValue = get(xAccessor)(d);
      const yValue = get(yAccessor)(d);
      if (Array.isArray(xValue)) {
        return xValue.filter(Boolean).map((xVal) => getPointObject(xVal, yValue, d));
      } else if (Array.isArray(yValue)) {
        return yValue.filter(Boolean).map((yVal) => getPointObject(xValue, yVal, d));
      } else if (equals(xValue, null, false) && equals(yValue, null, false)) {
        return getPointObject(xValue, yValue, d);
      }
      return [];
    })),
    "points"
  );
  const _links = tag(
    user_derived(() => get(pointsData).flatMap((d) => {
      const xValue = get(xAccessor)(d);
      const yValue = get(yAccessor)(d);
      if (Array.isArray(xValue)) {
        const [xMin, xMax] = extent(ctx.xGet(d));
        const y4 = ctx.yGet(d) + getOffset(ctx.yGet(d), $$props.offsetY, ctx.yScale);
        return {
          source: {
            x: xMin + getOffset(xMin, $$props.offsetX, ctx.xScale) + (ctx.config.r ? ctx.rGet(d) : r()),
            y: y4
          },
          target: {
            x: xMax + getOffset(xMax, $$props.offsetX, ctx.xScale) - (ctx.config.r ? ctx.rGet(d) : r()),
            y: y4
          },
          data: d
        };
      } else if (Array.isArray(yValue)) {
        const x4 = ctx.xGet(d) + getOffset(ctx.xGet(d), $$props.offsetX, ctx.xScale);
        const [yMin, yMax] = extent(ctx.yGet(d));
        return {
          source: { x: x4, y: yMin + getOffset(yMin, $$props.offsetY, ctx.yScale) },
          target: { x: x4, y: yMax + getOffset(yMax, $$props.offsetY, ctx.yScale) },
          data: d
        };
      }
    })),
    "_links"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children, () => ({ points: get(points) })), "render", Points, 182, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = root_27();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(
            () => each(node_3, 17, () => get(_links), index, ($$anchor4, link3) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              {
                let $0 = user_derived(() => $$props.fill ?? (ctx.config.c ? ctx.cGet(get(link3).data) : null));
                let $1 = user_derived(() => extractLayerProps(links(), "points-link"));
                add_svelte_meta(
                  () => Link_default(node_4, spread_props(
                    {
                      get data() {
                        return get(link3);
                      },
                      get stroke() {
                        return get($0);
                      }
                    },
                    () => get($1)
                  )),
                  "component",
                  Points,
                  186,
                  6,
                  { componentTag: "Link" }
                );
              }
              append($$anchor4, fragment_4);
            }),
            "each",
            Points,
            185,
            4
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (links()) $$render(consequent_1);
          }),
          "if",
          Points,
          184,
          2
        );
      }
      var node_5 = sibling(node_2, 2);
      add_svelte_meta(
        () => each(node_5, 17, () => get(points), index, ($$anchor3, point10) => {
          var fragment_5 = comment();
          const radialPoint = tag(user_derived(() => pointRadial_default(get(point10).x, get(point10).y)), "radialPoint");
          get(radialPoint);
          var node_6 = first_child(fragment_5);
          {
            let $0 = user_derived(() => ctx.radial ? get(radialPoint)[0] : get(point10).x);
            let $1 = user_derived(() => ctx.radial ? get(radialPoint)[1] : get(point10).y);
            let $2 = user_derived(() => $$props.fill ?? (ctx.config.c ? ctx.cGet(get(point10).data) : null));
            let $3 = user_derived(() => extractLayerProps(restProps, "point"));
            add_svelte_meta(
              () => Circle_default(node_6, spread_props(
                {
                  get cx() {
                    return get($0);
                  },
                  get cy() {
                    return get($1);
                  },
                  get r() {
                    return get(point10).r;
                  },
                  get fill() {
                    return get($2);
                  },
                  get fillOpacity() {
                    return $$props.fillOpacity;
                  },
                  get stroke() {
                    return $$props.stroke;
                  },
                  get strokeWidth() {
                    return $$props.strokeWidth;
                  },
                  get opacity() {
                    return $$props.opacity;
                  }
                },
                () => get($3)
              )),
              "component",
              Points,
              196,
              4,
              { componentTag: "Circle" }
            );
          }
          append($$anchor3, fragment_5);
        }),
        "each",
        Points,
        194,
        2
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Points,
      181,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Points = hmr(Points, () => Points[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Points[HMR].source;
    set(Points[HMR].source, module2.default[HMR].original);
  });
}
var Points_default = Points;

// node_modules/layerchart/dist/components/Labels.svelte
Labels[FILENAME] = "node_modules/layerchart/dist/components/Labels.svelte";
function Labels($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Labels);
  const ctx = getChartContext();
  let placement = prop($$props, "placement", 3, "outside"), offset = prop($$props, "offset", 19, () => strict_equals(placement(), "center") ? 0 : 4), key2 = prop($$props, "key", 3, (_, i) => i), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "value",
      "x",
      "y",
      "placement",
      "offset",
      "format",
      "key",
      "children",
      "class",
      "fill"
    ],
    "restProps"
  );
  function getTextProps(point10) {
    const pointValue = isScaleBand(ctx.yScale) ? point10.xValue : point10.yValue;
    const fillValue = strict_equals(typeof $$props.fill, "function") ? accessor($$props.fill)(point10.data) : $$props.fill;
    const displayValue = $$props.value ? accessor($$props.value)(point10.data) : isScaleBand(ctx.yScale) ? point10.xValue : point10.yValue;
    const formattedValue = format(
      displayValue,
      // @ts-expect-error - improve types
      $$props.format ?? ($$props.value ? void 0 : isScaleBand(ctx.yScale) ? ctx.xScale.tickFormat?.() : ctx.yScale.tickFormat?.())
    );
    if (isScaleBand(ctx.yScale)) {
      if (pointValue < 0) {
        return {
          value: formattedValue,
          fill: fillValue,
          x: point10.x + (strict_equals(placement(), "outside") ? -offset() : offset()),
          y: point10.y,
          textAnchor: strict_equals(placement(), "outside") ? "end" : "start",
          verticalAnchor: "middle",
          capHeight: ".6rem"
        };
      } else {
        return {
          value: formattedValue,
          fill: fillValue,
          x: point10.x + (strict_equals(placement(), "outside") ? offset() : -offset()),
          y: point10.y,
          textAnchor: strict_equals(placement(), "outside") ? "start" : "end",
          verticalAnchor: "middle",
          capHeight: ".6rem"
        };
      }
    } else {
      if (pointValue < 0) {
        return {
          value: formattedValue,
          fill: fillValue,
          x: point10.x,
          y: point10.y + (strict_equals(placement(), "outside") ? offset() : -offset()),
          capHeight: ".6rem",
          textAnchor: "middle",
          verticalAnchor: strict_equals(placement(), "center") ? "middle" : strict_equals(placement(), "outside") ? "start" : "end"
        };
      } else {
        return {
          value: formattedValue,
          fill: fillValue,
          x: point10.x,
          y: point10.y + (strict_equals(placement(), "outside") ? -offset() : offset()),
          capHeight: ".6rem",
          textAnchor: "middle",
          verticalAnchor: strict_equals(placement(), "center") ? "middle" : strict_equals(placement(), "outside") ? "end" : "start"
        };
      }
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => layerClass("labels-g"));
    add_svelte_meta(
      () => Group_default(node, {
        get class() {
          return get($0);
        },
        children: wrap_snippet(Labels, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            const children = wrap_snippet(Labels, function($$anchor3, $$arg0) {
              validate_snippet_args(...arguments);
              let points = () => $$arg0?.().points;
              points();
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              validate_each_keys(points, (point10, i) => key2()(point10.data, i));
              add_svelte_meta(
                () => each(node_2, 19, points, (point10, i) => key2()(point10.data, i), ($$anchor4, point10) => {
                  var fragment_3 = comment();
                  const textProps = tag(user_derived(() => extractLayerProps(getTextProps(get(point10)), "labels-text")), "textProps");
                  get(textProps);
                  var node_3 = first_child(fragment_3);
                  {
                    var consequent = ($$anchor5) => {
                      var fragment_4 = comment();
                      var node_4 = first_child(fragment_4);
                      add_svelte_meta(() => snippet(node_4, () => $$props.children, () => ({ data: get(point10), textProps: get(textProps) })), "render", Labels, 183, 10);
                      append($$anchor5, fragment_4);
                    };
                    var alternate = ($$anchor5) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      {
                        let $02 = user_derived(() => cls(
                          "text-xs",
                          strict_equals(placement(), "inside") ? "fill-surface-300 stroke-surface-content" : "fill-surface-content stroke-surface-100",
                          get(textProps).class,
                          $$props.class
                        ));
                        add_svelte_meta(
                          () => Text_default(node_5, spread_props(() => get(textProps), () => restProps, {
                            get class() {
                              return get($02);
                            }
                          })),
                          "component",
                          Labels,
                          185,
                          10,
                          { componentTag: "Text" }
                        );
                      }
                      append($$anchor5, fragment_5);
                    };
                    add_svelte_meta(
                      () => if_block(node_3, ($$render) => {
                        if ($$props.children) $$render(consequent);
                        else $$render(alternate, false);
                      }),
                      "if",
                      Labels,
                      182,
                      8
                    );
                  }
                  append($$anchor4, fragment_3);
                }),
                "each",
                Labels,
                180,
                6
              );
              append($$anchor3, fragment_2);
            });
            add_svelte_meta(
              () => Points_default(node_1, {
                get data() {
                  return $$props.data;
                },
                get x() {
                  return $$props.x;
                },
                get y() {
                  return $$props.y;
                },
                children,
                $$slots: { default: true }
              }),
              "component",
              Labels,
              178,
              2,
              { componentTag: "Points" }
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      Labels,
      177,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Labels = hmr(Labels, () => Labels[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Labels[HMR].source;
    set(Labels[HMR].source, module2.default[HMR].original);
  });
}
var Labels_default = Labels;

// node_modules/layerchart/dist/components/charts/DefaultTooltip.svelte
DefaultTooltip[FILENAME] = "node_modules/layerchart/dist/components/charts/DefaultTooltip.svelte";
var root_45 = add_locations(from_html(`<!> <!>`, 1), DefaultTooltip[FILENAME], []);
var root_28 = add_locations(from_html(`<!> <!>`, 1), DefaultTooltip[FILENAME], []);
var root_115 = add_locations(from_html(`<!> <!>`, 1), DefaultTooltip[FILENAME], []);
function DefaultTooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DefaultTooltip);
  var $$ownership_validator = create_ownership_validator($$props);
  let seriesState = prop($$props, "seriesState", 7), canHaveTotal = prop($$props, "canHaveTotal", 3, false);
  const context = getChartContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(DefaultTooltip, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let data = () => $$arg0?.().data;
      data();
      let payload = () => $$arg0?.().payload;
      payload();
      var fragment_1 = root_115();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => component(node_1, () => TooltipHeader_default, ($$anchor3, Tooltip_Header) => {
          Tooltip_Header($$anchor3, spread_props(
            {
              get value() {
                return payload()[0].label;
              },
              get format() {
                return format;
              }
            },
            () => $$props.tooltipProps?.header
          ));
        }),
        "component",
        DefaultTooltip,
        26,
        4,
        { componentTag: "Tooltip.Header" }
      );
      var node_2 = sibling(node_1, 2);
      add_svelte_meta(
        () => component(node_2, () => TooltipList_default, ($$anchor3, Tooltip_List) => {
          Tooltip_List($$anchor3, spread_props(() => $$props.tooltipProps?.list, {
            children: wrap_snippet(DefaultTooltip, ($$anchor4, $$slotProps) => {
              var fragment_2 = root_28();
              var node_3 = first_child(fragment_2);
              validate_each_keys(payload, (p, i) => p.key ?? i);
              add_svelte_meta(
                () => each(node_3, 19, payload, (p, i) => p.key ?? i, ($$anchor5, p) => {
                  var fragment_3 = comment();
                  var node_4 = first_child(fragment_3);
                  add_svelte_meta(
                    () => component(node_4, () => TooltipItem_default, ($$anchor6, Tooltip_Item) => {
                      Tooltip_Item($$anchor6, spread_props(
                        {
                          get label() {
                            return get(p).name;
                          },
                          get value() {
                            return get(p).value;
                          },
                          get color() {
                            return get(p).color;
                          },
                          get format() {
                            return format;
                          },
                          valueAlign: "right",
                          onpointerenter: () => $$ownership_validator.mutation("seriesState", ["seriesState", "highlightKey", "current"], seriesState().highlightKey.current = get(p).key, 37, 33),
                          onpointerleave: () => $$ownership_validator.mutation("seriesState", ["seriesState", "highlightKey", "current"], seriesState().highlightKey.current = null, 38, 33)
                        },
                        () => $$props.tooltipProps?.item
                      ));
                    }),
                    "component",
                    DefaultTooltip,
                    31,
                    8,
                    { componentTag: "Tooltip.Item" }
                  );
                  append($$anchor5, fragment_3);
                }),
                "each",
                DefaultTooltip,
                30,
                6
              );
              var node_5 = sibling(node_3, 2);
              {
                var consequent = ($$anchor5) => {
                  var fragment_4 = root_45();
                  var node_6 = first_child(fragment_4);
                  add_svelte_meta(
                    () => component(node_6, () => TooltipSeparator_default, ($$anchor6, Tooltip_Separator) => {
                      Tooltip_Separator($$anchor6, spread_props(() => $$props.tooltipProps?.separator, { children: void 0 }));
                    }),
                    "component",
                    DefaultTooltip,
                    44,
                    8,
                    { componentTag: "Tooltip.Separator" }
                  );
                  var node_7 = sibling(node_6, 2);
                  {
                    let $0 = user_derived(() => sum(seriesState().visibleSeries, (s3) => {
                      const seriesTooltipData = s3.data ? findRelatedData(s3.data, data(), context.x) : data();
                      const valueAccessor = accessor(s3.value ?? (s3.data ? context.y : s3.key));
                      return valueAccessor(seriesTooltipData);
                    }));
                    add_svelte_meta(
                      () => component(node_7, () => TooltipItem_default, ($$anchor6, Tooltip_Item_1) => {
                        Tooltip_Item_1($$anchor6, spread_props(
                          {
                            label: "total",
                            get value() {
                              return get($0);
                            },
                            format: "integer",
                            valueAlign: "right"
                          },
                          () => $$props.tooltipProps?.item
                        ));
                      }),
                      "component",
                      DefaultTooltip,
                      46,
                      8,
                      { componentTag: "Tooltip.Item" }
                    );
                  }
                  append($$anchor5, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(node_5, ($$render) => {
                    if (canHaveTotal() && payload().length > 1 && !$$props.tooltipProps?.hideTotal) $$render(consequent);
                  }),
                  "if",
                  DefaultTooltip,
                  43,
                  6
                );
              }
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          }));
        }),
        "component",
        DefaultTooltip,
        28,
        4,
        { componentTag: "Tooltip.List" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => component(node, () => Tooltip_default, ($$anchor2, Tooltip_Root) => {
        Tooltip_Root($$anchor2, spread_props(
          {
            get context() {
              return context;
            }
          },
          () => $$props.tooltipProps?.root,
          { children, $$slots: { default: true } }
        ));
      }),
      "component",
      DefaultTooltip,
      24,
      0,
      { componentTag: "Tooltip.Root" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DefaultTooltip = hmr(DefaultTooltip, () => DefaultTooltip[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = DefaultTooltip[HMR].source;
    set(DefaultTooltip[HMR].source, module2.default[HMR].original);
  });
}
var DefaultTooltip_default = DefaultTooltip;

// node_modules/layerchart/dist/components/AnnotationLine.svelte
AnnotationLine[FILENAME] = "node_modules/layerchart/dist/components/AnnotationLine.svelte";
var root18 = add_locations(from_html(`<!> <!>`, 1), AnnotationLine[FILENAME], []);
function AnnotationLine($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnnotationLine);
  const labelPlacement = prop($$props, "labelPlacement", 3, "top-right"), labelXOffset = prop($$props, "labelXOffset", 3, 0), labelYOffset = prop($$props, "labelYOffset", 3, 0);
  const ctx = getChartContext();
  const isVertical = tag(user_derived(() => equals($$props.x, null, false)), "isVertical");
  const line = tag(
    user_derived(() => ({
      x1: $$props.x ? ctx.xScale($$props.x) : ctx.xRange[0],
      y1: $$props.y && !$$props.x ? ctx.yScale($$props.y) : ctx.yRange[0],
      x2: $$props.x ? ctx.xScale($$props.x) : ctx.xRange[1],
      y2: $$props.y ? ctx.yScale($$props.y) : ctx.yRange[1]
    })),
    "line"
  );
  const labelProps = tag(
    user_derived(() => get(isVertical) ? {
      x: get(line).x1 + (labelPlacement().includes("left") ? -labelXOffset() : labelXOffset()),
      y: (labelPlacement().includes("top") ? get(line).y2 : labelPlacement().includes("bottom") ? get(line).y1 : (get(line).y1 - get(line).y2) / 2) + (["top", "bottom-left", "bottom-right"].includes(labelPlacement()) ? -labelYOffset() : labelYOffset()),
      dy: -2,
      // adjust for smaller font size
      textAnchor: labelPlacement().includes("left") ? "end" : labelPlacement().includes("right") ? "start" : "middle",
      verticalAnchor: strict_equals(labelPlacement(), "top") ? "end" : (
        // place above line
        strict_equals(labelPlacement(), "bottom") ? "start" : (
          // place below line
          labelPlacement().includes("top") ? "start" : labelPlacement().includes("bottom") ? "end" : "middle"
        )
      )
    } : {
      x: (labelPlacement().includes("left") ? get(line).x1 : labelPlacement().includes("right") ? get(line).x2 : (get(line).x2 - get(line).x1) / 2) + (["left", "top-right", "bottom-right"].includes(labelPlacement()) ? -labelXOffset() : labelXOffset()),
      y: get(line).y1 + (labelPlacement().includes("top") ? -labelYOffset() : labelYOffset()),
      dy: -2,
      // adjust for smaller font size
      textAnchor: strict_equals(labelPlacement(), "left") ? "end" : (
        // place beside line
        strict_equals(labelPlacement(), "right") ? "start" : (
          // place beside line
          labelPlacement().includes("left") ? "start" : labelPlacement().includes("right") ? "end" : "middle"
        )
      ),
      verticalAnchor: labelPlacement().includes("top") ? "end" : labelPlacement().includes("bottom") ? "start" : "middle"
    }),
    "labelProps"
  );
  var fragment = root18();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls("stroke-surface-content", $$props.props?.line?.class));
    add_svelte_meta(
      () => Line_default(node, spread_props(
        {
          get x1() {
            return get(line).x1;
          },
          get y1() {
            return get(line).y1;
          },
          get x2() {
            return get(line).x2;
          },
          get y2() {
            return get(line).y2;
          }
        },
        () => $$props.props?.line,
        {
          get class() {
            return get($0);
          }
        }
      )),
      "component",
      AnnotationLine,
      127,
      0,
      { componentTag: "Line" }
    );
  }
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        let $0 = user_derived(() => cls("text-xs pointer-events-none", $$props.props?.label?.class));
        add_svelte_meta(
          () => Text_default(node_2, spread_props(
            {
              get value() {
                return $$props.label;
              }
            },
            () => get(labelProps),
            () => $$props.props?.label,
            {
              get class() {
                return get($0);
              }
            }
          )),
          "component",
          AnnotationLine,
          137,
          2,
          { componentTag: "Text" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.label) $$render(consequent);
      }),
      "if",
      AnnotationLine,
      136,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnnotationLine = hmr(AnnotationLine, () => AnnotationLine[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = AnnotationLine[HMR].source;
    set(AnnotationLine[HMR].source, module2.default[HMR].original);
  });
}
var AnnotationLine_default = AnnotationLine;

// node_modules/layerchart/dist/components/AnnotationPoint.svelte
AnnotationPoint[FILENAME] = "node_modules/layerchart/dist/components/AnnotationPoint.svelte";
var root19 = add_locations(from_html(`<!> <!>`, 1), AnnotationPoint[FILENAME], []);
function AnnotationPoint($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnnotationPoint);
  const r = prop($$props, "r", 3, 4), labelPlacement = prop($$props, "labelPlacement", 3, "center"), labelXOffset = prop($$props, "labelXOffset", 3, 0), labelYOffset = prop($$props, "labelYOffset", 3, 0);
  const ctx = getChartContext();
  const point10 = tag(
    user_derived(() => ({
      x: $$props.x ? ctx.xScale($$props.x) + (isScaleBand(ctx.xScale) ? ctx.xScale.bandwidth() / 2 : 0) : 0,
      y: $$props.y ? ctx.yScale($$props.y) + (isScaleBand(ctx.yScale) ? ctx.yScale.bandwidth() / 2 : 0) : ctx.height
    })),
    "point"
  );
  const labelProps = tag(
    user_derived(() => ({
      x: get(point10).x + ((["top", "center", "bottom"].includes(labelPlacement()) ? 0 : r()) + labelXOffset()) * (labelPlacement().includes("left") ? -1 : 1),
      y: get(point10).y + ((["left", "center", "right"].includes(labelPlacement()) ? 0 : r()) + labelYOffset()) * (labelPlacement().includes("top") ? -1 : 1),
      dy: -2,
      // adjust for smaler font size
      textAnchor: labelPlacement().includes("left") ? "end" : labelPlacement().includes("right") ? "start" : "middle",
      verticalAnchor: labelPlacement().includes("top") ? "end" : labelPlacement().includes("bottom") ? "start" : "middle"
    })),
    "labelProps"
  );
  var fragment = root19();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls("stroke-surface-100", $$props.props?.circle?.class));
    add_svelte_meta(
      () => Circle_default(node, spread_props(
        {
          get cx() {
            return get(point10).x;
          },
          get cy() {
            return get(point10).y;
          },
          get r() {
            return r();
          },
          onpointermove: (e) => {
            if ($$props.details) {
              e.stopPropagation();
              ctx.tooltip.show(e, {
                annotation: { label: $$props.label, details: $$props.details }
              });
            }
          },
          onpointerleave: () => {
            if ($$props.details) {
              ctx.tooltip.hide();
            }
          }
        },
        () => $$props.props?.circle,
        {
          get class() {
            return get($0);
          }
        }
      )),
      "component",
      AnnotationPoint,
      93,
      0,
      { componentTag: "Circle" }
    );
  }
  var node_1 = sibling(node, 2);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        let $0 = user_derived(() => cls("text-xs pointer-events-none", $$props.props?.label?.class));
        add_svelte_meta(
          () => Text_default(node_2, spread_props(
            {
              get value() {
                return $$props.label;
              }
            },
            () => get(labelProps),
            () => $$props.props?.label,
            {
              get class() {
                return get($0);
              }
            }
          )),
          "component",
          AnnotationPoint,
          113,
          2,
          { componentTag: "Text" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.label) $$render(consequent);
      }),
      "if",
      AnnotationPoint,
      112,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnnotationPoint = hmr(AnnotationPoint, () => AnnotationPoint[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = AnnotationPoint[HMR].source;
    set(AnnotationPoint[HMR].source, module2.default[HMR].original);
  });
}
var AnnotationPoint_default = AnnotationPoint;

// node_modules/layerchart/dist/components/LinearGradient.svelte
LinearGradient[FILENAME] = "node_modules/layerchart/dist/components/LinearGradient.svelte";
var root_83 = add_locations(from_svg(`<stop></stop>`), LinearGradient[FILENAME], [[180, 12]]);
var root_94 = add_locations(from_svg(`<stop></stop>`), LinearGradient[FILENAME], [[186, 12]]);
var root_310 = add_locations(from_svg(`<defs><linearGradient><!></linearGradient></defs><!>`, 1), LinearGradient[FILENAME], [[163, 2, [[164, 4]]]]);
function LinearGradient($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, LinearGradient);
  let id = prop($$props, "id", 19, () => createId("linearGradient-", uid)), stops = prop($$props, "stops", 19, () => ["var(--tw-gradient-from)", "var(--tw-gradient-to)"]), vertical = prop($$props, "vertical", 3, false), x12 = prop($$props, "x1", 3, "0%"), y12 = prop($$props, "y1", 3, "0%"), x22 = prop($$props, "x2", 19, () => vertical() ? "0%" : "100%"), y22 = prop($$props, "y2", 19, () => vertical() ? "100%" : "0%"), units = prop($$props, "units", 3, "objectBoundingBox"), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "stops",
      "vertical",
      "x1",
      "y1",
      "x2",
      "y2",
      "rotate",
      "units",
      "ref",
      "class",
      "stopsContent",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const ctx = getChartContext();
  const renderCtx = getRenderContext();
  let canvasGradient = tag(state(void 0), "canvasGradient");
  function render2(_ctx) {
    const _stops = stops().map((stop2, i) => {
      if (Array.isArray(stop2)) {
        const { fill: fill2 } = getComputedStyles(_ctx.canvas, { styles: { fill: stop2[1] }, classes: $$props.class });
        return { offset: parsePercent(stop2[0]), color: fill2 };
      } else {
        const { fill: fill2 } = getComputedStyles(_ctx.canvas, { styles: { fill: stop2 }, classes: $$props.class });
        return { offset: i / (stops().length - 1), color: fill2 };
      }
    });
    const gradient = createLinearGradient(_ctx, ctx.padding.left, ctx.padding.top, vertical() ? ctx.padding.left : ctx.width - ctx.padding.right, vertical() ? ctx.height + ctx.padding.bottom : ctx.padding.top, _stops);
    set(canvasGradient, gradient, true);
  }
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Gradient",
      render: render2,
      deps: () => [x12(), y12(), x22(), y22(), stops(), $$props.class]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ id: id(), gradient: asAny(get(canvasGradient)) }));
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => get($0)), "render", LinearGradient, 161, 2);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_3 = root_310();
          var defs = first_child(fragment_3);
          var linearGradient = child(defs);
          attribute_effect(
            linearGradient,
            ($0) => ({
              id: id(),
              x1: x12(),
              y1: y12(),
              x2: x22(),
              y2: y22(),
              gradientTransform: $$props.rotate ? `rotate(${$$props.rotate})` : "",
              gradientUnits: units(),
              ...$0
            }),
            [() => extractLayerProps(restProps, "linear-gradient")]
          );
          var node_3 = child(linearGradient);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              add_svelte_meta(() => snippet(node_4, () => $$props.stopsContent ?? noop), "render", LinearGradient, 176, 8);
              append($$anchor4, fragment_4);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_5 = first_child(fragment_5);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_6 = first_child(fragment_6);
                  add_svelte_meta(
                    () => each(node_6, 17, stops, index, ($$anchor6, stop2, i) => {
                      var fragment_7 = comment();
                      var node_7 = first_child(fragment_7);
                      {
                        var consequent_2 = ($$anchor7) => {
                          var stop_1 = root_83();
                          template_effect(
                            ($0) => {
                              set_attribute(stop_1, "offset", get(stop2)[0]);
                              set_attribute(stop_1, "stop-color", get(stop2)[1]);
                              set_class(stop_1, 0, $0);
                            },
                            [
                              () => clsx(cls(layerClass("linear-gradient-stop"), $$props.class))
                            ]
                          );
                          append($$anchor7, stop_1);
                        };
                        var alternate = ($$anchor7) => {
                          var stop_2 = root_94();
                          template_effect(
                            ($0) => {
                              set_attribute(stop_2, "offset", `${i * (100 / (stops().length - 1))}%`);
                              set_attribute(stop_2, "stop-color", get(stop2));
                              set_class(stop_2, 0, $0);
                            },
                            [
                              () => clsx(cls(layerClass("linear-gradient-stop"), $$props.class))
                            ]
                          );
                          append($$anchor7, stop_2);
                        };
                        add_svelte_meta(
                          () => if_block(node_7, ($$render) => {
                            if (Array.isArray(get(stop2))) $$render(consequent_2);
                            else $$render(alternate, false);
                          }),
                          "if",
                          LinearGradient,
                          179,
                          10
                        );
                      }
                      append($$anchor6, fragment_7);
                    }),
                    "each",
                    LinearGradient,
                    178,
                    8
                  );
                  append($$anchor5, fragment_6);
                };
                add_svelte_meta(
                  () => if_block(
                    node_5,
                    ($$render) => {
                      if (stops()) $$render(consequent_3);
                    },
                    true
                  ),
                  "if",
                  LinearGradient,
                  177,
                  6
                );
              }
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if ($$props.stopsContent) $$render(consequent_1);
                else $$render(alternate_1, false);
              }),
              "if",
              LinearGradient,
              175,
              6
            );
          }
          reset(linearGradient);
          bind_this(linearGradient, ($$value) => set(ref, $$value), () => get(ref));
          reset(defs);
          var node_8 = sibling(defs);
          add_svelte_meta(() => snippet(node_8, () => $$props.children ?? noop, () => ({ id: id(), gradient: `url(#${id()})` })), "render", LinearGradient, 197, 2);
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(renderCtx, "svg")) $$render(consequent_4);
            },
            true
          ),
          "if",
          LinearGradient,
          162,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "canvas")) $$render(consequent);
        else $$render(alternate_2, false);
      }),
      "if",
      LinearGradient,
      156,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinearGradient = hmr(LinearGradient, () => LinearGradient[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = LinearGradient[HMR].source;
    set(LinearGradient[HMR].source, module2.default[HMR].original);
  });
}
var LinearGradient_default = LinearGradient;

// node_modules/layerchart/dist/components/Pattern.svelte
Pattern[FILENAME] = "node_modules/layerchart/dist/components/Pattern.svelte";
var root_62 = add_locations(from_svg(`<rect></rect>`), Pattern[FILENAME], [[274, 10]]);
var root_74 = add_locations(from_svg(`<path fill="none"></path>`), Pattern[FILENAME], [[278, 10]]);
var root_84 = add_locations(from_svg(`<circle></circle>`), Pattern[FILENAME], [[288, 10]]);
var root_56 = add_locations(from_svg(`<!><!><!>`, 1), Pattern[FILENAME], []);
var root_311 = add_locations(from_svg(`<defs><pattern><!></pattern></defs><!>`, 1), Pattern[FILENAME], [[262, 2, [[263, 4]]]]);
function Pattern($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pattern);
  let id = prop($$props, "id", 19, () => createId("pattern-", uid)), size2 = prop($$props, "size", 3, 4), width = prop($$props, "width", 19, size2), height = prop($$props, "height", 19, size2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "size",
      "width",
      "height",
      "lines",
      "circles",
      "background",
      "patternContent",
      "children"
    ],
    "restProps"
  );
  const renderCtx = getRenderContext();
  let canvasPattern = tag(state(null), "canvasPattern");
  let shapes = tag_proxy(proxy([]), "shapes");
  if ($$props.lines) {
    const lineDefs = Array.isArray($$props.lines) ? $$props.lines : strict_equals($$props.lines, true) ? [{}] : [$$props.lines];
    for (const line of lineDefs) {
      const stroke = line.color ?? "var(--color-surface-content)";
      const strokeWidth = line.width ?? 1;
      const opacity = line.opacity ?? 1;
      let rotate = Math.round(line.rotate ?? 0) % 360;
      if (rotate > 180) rotate = rotate - 360;
      else if (rotate > 90) rotate = rotate - 180;
      else if (rotate < -180) rotate = rotate + 360;
      else if (rotate < -90) rotate = rotate + 180;
      let path3 = "";
      if (strict_equals(rotate, 0)) {
        path3 = `
        M 0 0 L ${width()} 0
        M 0 ${height()} L ${width()} ${height()}
    `;
      } else if (strict_equals(rotate, 90)) {
        path3 = `
        M 0 0 L 0 ${height()}
        M ${width()} 0 L ${width()} ${height()}
    `;
      } else {
        if (rotate > 0) {
          path3 = `
          M 0 ${-height()} L ${width() * 2} ${height()}
          M ${-width()} ${-height()} L ${width()} ${height()}
          M ${-width()} 0 L ${width()} ${height() * 2}
      `;
        } else {
          path3 = `
          M ${-width()} ${height()} L ${width()} ${-height()}
          M ${-width()} ${height() * 2} L ${width() * 2} ${-height()}
          M 0 ${height() * 2} L ${width() * 2} 0
      `;
        }
      }
      shapes.push({ type: "line", path: path3, stroke, strokeWidth, opacity });
    }
  }
  if ($$props.circles) {
    const circleDefs = Array.isArray($$props.circles) ? $$props.circles : strict_equals($$props.circles, true) ? [{}] : [$$props.circles];
    for (const circle of circleDefs) {
      if (circle.stagger) {
        shapes.push(
          {
            type: "circle",
            cx: size2() / 4,
            cy: size2() / 4,
            r: circle.radius ?? 1,
            fill: circle.color ?? "var(--color-surface-content)",
            opacity: circle.opacity ?? 1
          },
          {
            type: "circle",
            cx: size2() * 3 / 4,
            cy: size2() * 3 / 4,
            r: circle.radius ?? 1,
            fill: circle.color ?? "var(--color-surface-content)",
            opacity: circle.opacity ?? 1
          }
        );
      } else {
        shapes.push({
          type: "circle",
          cx: size2() / 2,
          cy: size2() / 2,
          r: circle.radius ?? 1,
          fill: circle.color ?? "var(--color-surface-content)",
          opacity: circle.opacity ?? 1
        });
      }
    }
  }
  function render2(_ctx) {
    const pattern = createPattern(_ctx, width(), height(), shapes, $$props.background);
    set(canvasPattern, pattern, true);
  }
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Pattern",
      render: render2,
      deps: () => [width(), height(), shapes, $$props.background]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ id: id(), pattern: asAny(get(canvasPattern)) }));
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => get($0)), "render", Pattern, 260, 2);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_3 = root_311();
          var defs = first_child(fragment_3);
          var pattern_1 = child(defs);
          attribute_effect(
            pattern_1,
            ($0) => ({
              id: id(),
              width: width(),
              height: height(),
              patternUnits: "userSpaceOnUse",
              ...$0
            }),
            [() => extractLayerProps(restProps, "pattern")]
          );
          var node_3 = child(pattern_1);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              add_svelte_meta(() => snippet(node_4, () => $$props.patternContent ?? noop), "render", Pattern, 271, 8);
              append($$anchor4, fragment_4);
            };
            var alternate = ($$anchor4) => {
              var fragment_5 = root_56();
              var node_5 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var rect = root_62();
                  template_effect(() => {
                    set_attribute(rect, "width", width());
                    set_attribute(rect, "height", height());
                    set_attribute(rect, "fill", $$props.background);
                  });
                  append($$anchor5, rect);
                };
                add_svelte_meta(
                  () => if_block(node_5, ($$render) => {
                    if ($$props.background) $$render(consequent_2);
                  }),
                  "if",
                  Pattern,
                  273,
                  8
                );
              }
              var node_6 = sibling(node_5);
              add_svelte_meta(
                () => each(node_6, 17, () => shapes.filter((shape) => strict_equals(shape.type, "line")), index, ($$anchor5, line) => {
                  var path_1 = root_74();
                  template_effect(() => {
                    set_attribute(path_1, "d", get(line).path);
                    set_attribute(path_1, "stroke", get(line).stroke);
                    set_attribute(path_1, "stroke-width", get(line).strokeWidth);
                    set_attribute(path_1, "opacity", get(line).opacity);
                  });
                  append($$anchor5, path_1);
                }),
                "each",
                Pattern,
                277,
                8
              );
              var node_7 = sibling(node_6);
              add_svelte_meta(
                () => each(node_7, 17, () => shapes.filter((shape) => strict_equals(shape.type, "circle")), index, ($$anchor5, circle) => {
                  var circle_1 = root_84();
                  template_effect(() => {
                    set_attribute(circle_1, "cx", get(circle).cx);
                    set_attribute(circle_1, "cy", get(circle).cy);
                    set_attribute(circle_1, "r", get(circle).r);
                    set_attribute(circle_1, "fill", get(circle).fill);
                    set_attribute(circle_1, "opacity", get(circle).opacity);
                  });
                  append($$anchor5, circle_1);
                }),
                "each",
                Pattern,
                287,
                8
              );
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if ($$props.patternContent) $$render(consequent_1);
                else $$render(alternate, false);
              }),
              "if",
              Pattern,
              270,
              6
            );
          }
          reset(pattern_1);
          reset(defs);
          var node_8 = sibling(defs);
          add_svelte_meta(() => snippet(node_8, () => $$props.children ?? noop, () => ({ id: id(), pattern: `url(#${id()})` })), "render", Pattern, 300, 2);
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(renderCtx, "svg")) $$render(consequent_3);
            },
            true
          ),
          "if",
          Pattern,
          261,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "canvas")) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Pattern,
      259,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pattern = hmr(Pattern, () => Pattern[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Pattern[HMR].source;
    set(Pattern[HMR].source, module2.default[HMR].original);
  });
}
var Pattern_default = Pattern;

// node_modules/layerchart/dist/components/AnnotationRange.svelte
AnnotationRange[FILENAME] = "node_modules/layerchart/dist/components/AnnotationRange.svelte";
var root20 = add_locations(from_html(`<!> <!> <!> <!>`, 1), AnnotationRange[FILENAME], []);
function AnnotationRange($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AnnotationRange);
  const labelPlacement = prop($$props, "labelPlacement", 3, "center"), labelXOffset = prop($$props, "labelXOffset", 3, 0), labelYOffset = prop($$props, "labelYOffset", 3, 0);
  const ctx = getChartContext();
  const rect = tag(
    user_derived(() => ({
      x: $$props.x ? ctx.xScale($$props.x[0] ?? ctx.xDomain[0]) - (isScaleBand(ctx.xScale) ? ctx.xScale.padding() * ctx.xScale.step() / 2 : 0) : ctx.xRange[0],
      y: $$props.y ? ctx.yScale($$props.y[1] ?? ctx.yDomain[1]) : ctx.yRange[1],
      width: $$props.x ? ctx.xScale($$props.x[1] ?? ctx.xDomain[1]) - ctx.xScale($$props.x[0] ?? ctx.xDomain[0]) + (isScaleBand(ctx.xScale) ? ctx.xScale.step() : 0) : ctx.width,
      height: $$props.y ? ctx.yScale($$props.y[0] ?? ctx.yDomain[0]) - ctx.yScale($$props.y[1] ?? ctx.yDomain[1]) : ctx.height
    })),
    "rect"
  );
  const labelProps = tag(
    user_derived(() => ({
      x: ((labelPlacement().includes("left") ? get(rect).x : labelPlacement().includes("right") ? (get(rect).x ?? 0) + get(rect).width : (get(rect).x ?? 0) + get(rect).width / 2) ?? 0) + (labelPlacement().includes("right") ? -labelXOffset() : labelXOffset()),
      y: ((labelPlacement().includes("top") ? get(rect).y : labelPlacement().includes("bottom") ? (get(rect).y ?? 0) + get(rect).height : (get(rect).y ?? 0) + get(rect).height / 2) ?? 0) + (labelPlacement().includes("bottom") ? -labelYOffset() : labelYOffset()),
      dy: -2,
      // adjust for smaler font size
      textAnchor: labelPlacement().includes("left") ? "start" : labelPlacement().includes("right") ? "end" : "middle",
      verticalAnchor: labelPlacement().includes("top") ? "start" : labelPlacement().includes("bottom") ? "end" : "middle"
    })),
    "labelProps"
  );
  var fragment = root20();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => cls($$props.props?.rect?.class, $$props.class));
        add_svelte_meta(
          () => Rect_default(node_1, spread_props(() => get(rect), () => $$props.props?.rect, {
            get fill() {
              return $$props.fill;
            },
            get class() {
              return get($0);
            }
          })),
          "component",
          AnnotationRange,
          121,
          2,
          { componentTag: "Rect" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.fill || $$props.class) $$render(consequent);
      }),
      "if",
      AnnotationRange,
      120,
      0
    );
  }
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        const children = wrap_snippet(AnnotationRange, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let gradient = () => $$arg0?.().gradient;
          gradient();
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          add_svelte_meta(
            () => Rect_default(node_4, spread_props(() => get(rect), () => $$props.props?.rect, {
              get fill() {
                return gradient();
              }
            })),
            "component",
            AnnotationRange,
            127,
            6,
            { componentTag: "Rect" }
          );
          append($$anchor3, fragment_3);
        });
        add_svelte_meta(() => LinearGradient_default(node_3, spread_props(() => $$props.gradient, { children, $$slots: { default: true } })), "component", AnnotationRange, 125, 2, { componentTag: "LinearGradient" });
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if ($$props.gradient) $$render(consequent_1);
      }),
      "if",
      AnnotationRange,
      124,
      0
    );
  }
  var node_5 = sibling(node_2, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_6 = first_child(fragment_4);
      {
        const children = wrap_snippet(AnnotationRange, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let pattern = () => $$arg0?.().pattern;
          pattern();
          var fragment_5 = comment();
          var node_7 = first_child(fragment_5);
          add_svelte_meta(
            () => Rect_default(node_7, spread_props(() => get(rect), () => $$props.props?.rect, {
              get fill() {
                return pattern();
              }
            })),
            "component",
            AnnotationRange,
            135,
            6,
            { componentTag: "Rect" }
          );
          append($$anchor3, fragment_5);
        });
        add_svelte_meta(() => Pattern_default(node_6, spread_props(() => $$props.pattern, { children, $$slots: { default: true } })), "component", AnnotationRange, 133, 2, { componentTag: "Pattern" });
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node_5, ($$render) => {
        if ($$props.pattern) $$render(consequent_2);
      }),
      "if",
      AnnotationRange,
      132,
      0
    );
  }
  var node_8 = sibling(node_5, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_6 = comment();
      var node_9 = first_child(fragment_6);
      {
        let $0 = user_derived(() => cls("text-xs pointer-events-none", $$props.props?.label?.class));
        add_svelte_meta(
          () => Text_default(node_9, spread_props(
            {
              get value() {
                return $$props.label;
              }
            },
            () => get(labelProps),
            () => $$props.props?.label,
            {
              get class() {
                return get($0);
              }
            }
          )),
          "component",
          AnnotationRange,
          141,
          2,
          { componentTag: "Text" }
        );
      }
      append($$anchor2, fragment_6);
    };
    add_svelte_meta(
      () => if_block(node_8, ($$render) => {
        if ($$props.label) $$render(consequent_3);
      }),
      "if",
      AnnotationRange,
      140,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnnotationRange = hmr(AnnotationRange, () => AnnotationRange[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = AnnotationRange[HMR].source;
    set(AnnotationRange[HMR].source, module2.default[HMR].original);
  });
}
var AnnotationRange_default = AnnotationRange;

// node_modules/layerchart/dist/components/charts/ChartAnnotations.svelte
ChartAnnotations[FILENAME] = "node_modules/layerchart/dist/components/charts/ChartAnnotations.svelte";
function ChartAnnotations($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ChartAnnotations);
  let visibleAnnotations = tag(user_derived(() => $$props.annotations.filter((a5) => (strict_equals(a5.layer, $$props.layer) || equals(a5.layer, null) && strict_equals($$props.layer, "above")) && (equals($$props.highlightKey, null) || equals(a5.seriesKey, null) || strict_equals(a5.seriesKey, $$props.highlightKey)) && $$props.visibleSeries.some((s3) => equals(a5.seriesKey, null) || strict_equals(a5.seriesKey, s3.key)))), "visibleAnnotations");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => each(node, 17, () => get(visibleAnnotations), index, ($$anchor2, annotation) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => AnnotationPoint_default(node_2, spread_props(() => get(annotation))), "component", ChartAnnotations, 31, 4, { componentTag: "AnnotationPoint" });
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              add_svelte_meta(() => AnnotationLine_default(node_4, spread_props(() => get(annotation))), "component", ChartAnnotations, 33, 4, { componentTag: "AnnotationLine" });
              append($$anchor4, fragment_4);
            };
            var alternate = ($$anchor4) => {
              var fragment_5 = comment();
              var node_5 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_6 = first_child(fragment_6);
                  add_svelte_meta(() => AnnotationRange_default(node_6, spread_props(() => get(annotation))), "component", ChartAnnotations, 35, 4, { componentTag: "AnnotationRange" });
                  append($$anchor5, fragment_6);
                };
                add_svelte_meta(
                  () => if_block(
                    node_5,
                    ($$render) => {
                      if (strict_equals(get(annotation).type, "range")) $$render(consequent_2);
                    },
                    true
                  ),
                  "if",
                  ChartAnnotations,
                  34,
                  2
                );
              }
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(
                node_3,
                ($$render) => {
                  if (strict_equals(get(annotation).type, "line")) $$render(consequent_1);
                  else $$render(alternate, false);
                },
                true
              ),
              "if",
              ChartAnnotations,
              32,
              2
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (strict_equals(get(annotation).type, "point")) $$render(consequent);
            else $$render(alternate_1, false);
          }),
          "if",
          ChartAnnotations,
          30,
          2
        );
      }
      append($$anchor2, fragment_1);
    }),
    "each",
    ChartAnnotations,
    29,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartAnnotations = hmr(ChartAnnotations, () => ChartAnnotations[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ChartAnnotations[HMR].source;
    set(ChartAnnotations[HMR].source, module2.default[HMR].original);
  });
}
var ChartAnnotations_default = ChartAnnotations;

// node_modules/layerchart/dist/components/charts/AreaChart.svelte
AreaChart[FILENAME] = "node_modules/layerchart/dist/components/charts/AreaChart.svelte";
var root_85 = add_locations(from_html(`<!> <!> <!>`, 1), AreaChart[FILENAME], []);
var root_124 = add_locations(from_html(`<!> <!>`, 1), AreaChart[FILENAME], []);
var root_172 = add_locations(from_html(`<!> <!> <!>`, 1), AreaChart[FILENAME], []);
var root_232 = add_locations(from_html(`<!> <!> <!> <!>`, 1), AreaChart[FILENAME], []);
var root_46 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), AreaChart[FILENAME], []);
var root_312 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), AreaChart[FILENAME], []);
function AreaChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AreaChart);
  let data = prop($$props, "data", 19, () => []), xDomain = prop($$props, "xDomain", 7), radial2 = prop($$props, "radial", 3, false), seriesLayout = prop($$props, "seriesLayout", 3, "overlap"), axis = prop($$props, "axis", 3, true), brush = prop($$props, "brush", 3, false), grid = prop($$props, "grid", 3, true), labels = prop($$props, "labels", 3, false), legend = prop($$props, "legend", 3, false), points = prop($$props, "points", 3, false), tooltip = prop($$props, "tooltip", 3, true), highlight = prop($$props, "highlight", 3, true), annotations = prop($$props, "annotations", 19, () => []), rule = prop($$props, "rule", 3, true), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), context = prop($$props, "context", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "xDomain",
      "radial",
      "series",
      "seriesLayout",
      "axis",
      "brush",
      "grid",
      "labels",
      "legend",
      "points",
      "tooltip",
      "highlight",
      "annotations",
      "rule",
      "onTooltipClick",
      "onPointClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "xScale",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "context"
    ],
    "restProps"
  );
  const series = tag(
    user_derived(() => strict_equals($$props.series, void 0) ? [
      {
        key: "default",
        label: strict_equals(typeof $$props.y, "string") ? $$props.y : "value",
        value: $$props.y,
        color: "var(--color-primary)"
      }
    ] : $$props.series),
    "series"
  );
  const seriesState = new SeriesState(() => get(series));
  const stackSeries2 = tag(user_derived(() => seriesLayout().startsWith("stack")), "stackSeries");
  const chartData = tag(
    user_derived(() => {
      let _chartData = seriesState.allSeriesData.length ? seriesState.allSeriesData : chartDataArray(data());
      if (get(stackSeries2)) {
        const seriesKeys = seriesState.visibleSeries.map((s3) => s3.key);
        const offset = strict_equals(seriesLayout(), "stackExpand") ? expand_default : strict_equals(seriesLayout(), "stackDiverging") ? diverging_default : none_default;
        const stackData = stack_default().keys(seriesKeys).value((d, key2) => {
          const s3 = get(series).find((d2) => strict_equals(d2.key, key2));
          const value2 = accessor(s3.value ?? $$props.y ?? s3.key)(d);
          return value2;
        }).offset(offset)(_chartData);
        for (let [seriesIndex, s3] of get(series).entries()) {
          if (s3.data) {
            s3.data = s3.data.map((d, i) => {
              return { ...d, stackData: stackData[seriesIndex][i] };
            });
          }
        }
        _chartData = _chartData.map((d, i) => {
          return { ...d, stackData: stackData.map((sd) => sd[i]) };
        });
      }
      return _chartData;
    }),
    "chartData"
  );
  const xScale = tag(user_derived(() => $$props.xScale ?? (accessor($$props.x)(get(chartData)[0]) instanceof Date ? time() : linear2())), "xScale");
  function isStackData(d) {
    return d && strict_equals(typeof d, "object") && "stackData" in d;
  }
  function getStackData(s3, d, i) {
    if (s3.data) {
      return d.stackData;
    }
    return d.stackData[i] ?? [];
  }
  function getAreaProps(s3, i) {
    const lineProps = {
      ...props().line,
      ...strict_equals(typeof props().area?.line, "object") ? props().area.line : null,
      ...strict_equals(typeof s3.props?.line, "object") ? s3.props.line : null
    };
    const highlightClass = seriesState.visibleSeries.length > 1 && seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) ? "opacity-10" : "";
    return {
      data: s3.data,
      y0: get(stackSeries2) ? (d) => getStackData(s3, d, i)[0] : Array.isArray(s3.value) ? s3.value[0] : void 0,
      y1: get(stackSeries2) ? (d) => getStackData(s3, d, i)[1] : Array.isArray(s3.value) ? s3.value[1] : s3.value ?? (s3.data ? void 0 : s3.key),
      fill: s3.color,
      fillOpacity: 0.3,
      ...props().area,
      ...s3.props,
      class: cls(
        "transition-opacity",
        // Checking `visibleSeries.length > 1` fixes re-animated tweened areas on hover
        highlightClass,
        props().area?.class,
        s3.props?.class
      ),
      line: {
        stroke: s3.color,
        ...lineProps,
        class: cls("transition-opacity", highlightClass, lineProps.class)
      }
    };
  }
  function getPointsProps(s3, i) {
    return {
      data: s3.data,
      y: get(stackSeries2) ? (d) => getStackData(s3, d, i)[1] : Array.isArray(s3.value) ? s3.value[1] : s3.value ?? (s3.data ? void 0 : s3.key),
      fill: s3.color,
      ...props().points,
      ...strict_equals(typeof points(), "object") ? points() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().points?.class, strict_equals(typeof points(), "object") && points().class)
    };
  }
  function getLabelsProps(s3, i) {
    return {
      data: s3.data,
      y: get(stackSeries2) ? (d) => isStackData(d) ? getStackData(s3, d, i)[1] : void 0 : Array.isArray(s3.value) ? s3.value[1] : s3.value ?? (s3.data ? void 0 : s3.key),
      ...props().labels,
      ...strict_equals(typeof labels(), "object") ? labels() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().labels?.class, strict_equals(typeof labels(), "object") && labels().class)
    };
  }
  const brushProps = tag(
    user_derived(() => ({
      ...strict_equals(typeof brush(), "object") ? brush() : null,
      ...props().brush
    })),
    "brushProps"
  );
  function getHighlightProps(s3, i) {
    if (!context()) return {};
    const seriesTooltipData = s3.data && context().tooltip.data ? findRelatedData(s3.data, context().tooltip.data, context().x) : null;
    const highlightPointsProps = strict_equals(typeof props().highlight?.points, "object") ? props().highlight.points : null;
    return {
      data: seriesTooltipData,
      y: get(stackSeries2) ? (d) => getStackData(s3, d, i)[1] : s3.value ?? (s3.data ? void 0 : s3.key),
      lines: equals(i, 0),
      onPointClick: $$props.onPointClick ? (e, detail) => $$props.onPointClick(e, { ...detail, series: s3 }) : void 0,
      onPointEnter: () => assign(seriesState.highlightKey, "current", s3.key, "node_modules/​layerchart/​dist/​components/​charts/​AreaChart.svelte:338:27"),
      onPointLeave: () => assign(seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​AreaChart.svelte:339:27"),
      ...props().highlight,
      points: equals(props().highlight?.points, false) ? false : {
        ...highlightPointsProps,
        fill: s3.color,
        class: cls("transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", highlightPointsProps?.class)
      }
    };
  }
  function getLegendProps() {
    return createLegendProps({
      seriesState,
      props: {
        ...props().legend,
        ...strict_equals(typeof legend(), "object") ? legend() : null
      }
    });
  }
  function getGridProps() {
    return {
      x: radial2(),
      y: true,
      ...strict_equals(typeof grid(), "object") ? grid() : null,
      ...props().grid
    };
  }
  if (profile()) {
    console.time("AreaChart render");
    onMount(() => {
      console.timeEnd("AreaChart render");
    });
  }
  setTooltipMetaContext({
    type: "area",
    get stackSeries() {
      return get(stackSeries2);
    },
    get visibleSeries() {
      return seriesState.visibleSeries;
    }
  });
  function resolveAccessor(acc) {
    if (get(stackSeries2)) {
      return (d) => isStackData(d) ? seriesState.visibleSeries.flatMap((s3, i) => d.stackData[i]) : void 0;
    }
    if (acc) return acc;
    return seriesState.visibleSeries.map((s3) => s3.value ?? s3.key);
  }
  function getAxisProps(axisDirection) {
    if (strict_equals(axisDirection, "y")) {
      return {
        placement: radial2() ? "radius" : "left",
        format: strict_equals(seriesLayout(), "stackExpand") ? "percentRound" : void 0,
        ...strict_equals(typeof axis(), "object") ? axis() : null,
        ...props().yAxis
      };
    }
    return {
      placement: radial2() ? "angle" : "bottom",
      ...strict_equals(typeof axis(), "object") ? axis() : null,
      ...props().xAxis
    };
  }
  function getRuleProps() {
    return {
      x: 0,
      y: 0,
      ...strict_equals(typeof rule(), "object") ? rule() : null,
      ...props().rule
    };
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(AreaChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          context: context2(),
          series: get(series),
          visibleSeries: seriesState.visibleSeries,
          getAreaProps,
          getLabelsProps,
          getPointsProps,
          getHighlightProps,
          getLegendProps,
          getGridProps,
          getAxisProps,
          getRuleProps,
          highlightKey: seriesState.highlightKey.current,
          setHighlightKey: seriesState.highlightKey.set
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", AreaChart, 483, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_10 = ($$anchor3) => {
          var fragment_3 = root_312();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", AreaChart, 485, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get center() {
                    return radial2();
                  },
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(AreaChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_46();
                    var node_5 = first_child(fragment_4);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_6 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_6, grid, () => get(snippetProps)), "render", AreaChart, 493, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_7 = first_child(fragment_6);
                        {
                          var consequent_2 = ($$anchor6) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            {
                              let $03 = user_derived(getGridProps);
                              add_svelte_meta(() => Grid_default(node_8, spread_props(() => get($03))), "component", AreaChart, 495, 10, { componentTag: "Grid" });
                            }
                            append($$anchor6, fragment_7);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_7,
                              ($$render) => {
                                if (grid()) $$render(consequent_2);
                              },
                              true
                            ),
                            "if",
                            AreaChart,
                            494,
                            8
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_5, ($$render) => {
                          if (strict_equals(typeof grid(), "function")) $$render(consequent_1);
                          else $$render(alternate, false);
                        }),
                        "if",
                        AreaChart,
                        492,
                        8
                      );
                    }
                    var node_9 = sibling(node_5, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_9, {
                          get disabled() {
                            return get($03);
                          },
                          children: wrap_snippet(AreaChart, ($$anchor5, $$slotProps2) => {
                            var fragment_8 = root_85();
                            var node_10 = first_child(fragment_8);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_10, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "below",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              AreaChart,
                              499,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            var node_11 = sibling(node_10, 2);
                            add_svelte_meta(() => snippet(node_11, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", AreaChart, 506, 10);
                            var node_12 = sibling(node_11, 2);
                            {
                              var consequent_3 = ($$anchor6) => {
                                var fragment_9 = comment();
                                var node_13 = first_child(fragment_9);
                                add_svelte_meta(() => snippet(node_13, () => $$props.marks, () => get(snippetProps)), "render", AreaChart, 509, 12);
                                append($$anchor6, fragment_9);
                              };
                              var alternate_1 = ($$anchor6) => {
                                var fragment_10 = comment();
                                var node_14 = first_child(fragment_10);
                                validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_14, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor7, s3, i) => {
                                    var fragment_11 = comment();
                                    var node_15 = first_child(fragment_11);
                                    {
                                      let $04 = user_derived(() => getAreaProps(get(s3), get(i)));
                                      add_svelte_meta(() => Area_default(node_15, spread_props(() => get($04))), "component", AreaChart, 512, 14, { componentTag: "Area" });
                                    }
                                    append($$anchor7, fragment_11);
                                  }),
                                  "each",
                                  AreaChart,
                                  511,
                                  12
                                );
                                append($$anchor6, fragment_10);
                              };
                              add_svelte_meta(
                                () => if_block(node_12, ($$render) => {
                                  if ($$props.marks) $$render(consequent_3);
                                  else $$render(alternate_1, false);
                                }),
                                "if",
                                AreaChart,
                                508,
                                10
                              );
                            }
                            append($$anchor5, fragment_8);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        AreaChart,
                        498,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    var node_16 = sibling(node_9, 2);
                    add_svelte_meta(() => snippet(node_16, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", AreaChart, 517, 8);
                    var node_17 = sibling(node_16, 2);
                    {
                      var consequent_6 = ($$anchor5) => {
                        var fragment_12 = root_124();
                        var node_18 = first_child(fragment_12);
                        add_svelte_meta(() => snippet(node_18, axis, () => get(snippetProps)), "render", AreaChart, 519, 10);
                        var node_19 = sibling(node_18, 2);
                        {
                          var consequent_4 = ($$anchor6) => {
                            var fragment_13 = comment();
                            var node_20 = first_child(fragment_13);
                            add_svelte_meta(() => snippet(node_20, rule, () => get(snippetProps)), "render", AreaChart, 521, 12);
                            append($$anchor6, fragment_13);
                          };
                          var alternate_2 = ($$anchor6) => {
                            var fragment_14 = comment();
                            var node_21 = first_child(fragment_14);
                            {
                              var consequent_5 = ($$anchor7) => {
                                var fragment_15 = comment();
                                var node_22 = first_child(fragment_15);
                                {
                                  let $03 = user_derived(getRuleProps);
                                  add_svelte_meta(() => Rule_default(node_22, spread_props(() => get($03))), "component", AreaChart, 523, 12, { componentTag: "Rule" });
                                }
                                append($$anchor7, fragment_15);
                              };
                              add_svelte_meta(
                                () => if_block(
                                  node_21,
                                  ($$render) => {
                                    if (rule()) $$render(consequent_5);
                                  },
                                  true
                                ),
                                "if",
                                AreaChart,
                                522,
                                10
                              );
                            }
                            append($$anchor6, fragment_14);
                          };
                          add_svelte_meta(
                            () => if_block(node_19, ($$render) => {
                              if (strict_equals(typeof rule(), "function")) $$render(consequent_4);
                              else $$render(alternate_2, false);
                            }),
                            "if",
                            AreaChart,
                            520,
                            10
                          );
                        }
                        append($$anchor5, fragment_12);
                      };
                      var alternate_4 = ($$anchor5) => {
                        var fragment_16 = comment();
                        var node_23 = first_child(fragment_16);
                        {
                          var consequent_11 = ($$anchor6) => {
                            var fragment_17 = root_172();
                            var node_24 = first_child(fragment_17);
                            {
                              var consequent_7 = ($$anchor7) => {
                                var fragment_18 = comment();
                                var node_25 = first_child(fragment_18);
                                {
                                  let $03 = user_derived(() => getAxisProps("y"));
                                  add_svelte_meta(() => Axis_default(node_25, spread_props(() => get($03))), "component", AreaChart, 527, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_18);
                              };
                              add_svelte_meta(
                                () => if_block(node_24, ($$render) => {
                                  if (strict_equals(axis(), "x", false)) $$render(consequent_7);
                                }),
                                "if",
                                AreaChart,
                                526,
                                10
                              );
                            }
                            var node_26 = sibling(node_24, 2);
                            {
                              var consequent_8 = ($$anchor7) => {
                                var fragment_19 = comment();
                                var node_27 = first_child(fragment_19);
                                {
                                  let $03 = user_derived(() => getAxisProps("x"));
                                  add_svelte_meta(() => Axis_default(node_27, spread_props(() => get($03))), "component", AreaChart, 531, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_19);
                              };
                              add_svelte_meta(
                                () => if_block(node_26, ($$render) => {
                                  if (strict_equals(axis(), "y", false)) $$render(consequent_8);
                                }),
                                "if",
                                AreaChart,
                                530,
                                10
                              );
                            }
                            var node_28 = sibling(node_26, 2);
                            {
                              var consequent_9 = ($$anchor7) => {
                                var fragment_20 = comment();
                                var node_29 = first_child(fragment_20);
                                add_svelte_meta(() => snippet(node_29, rule, () => get(snippetProps)), "render", AreaChart, 535, 12);
                                append($$anchor7, fragment_20);
                              };
                              var alternate_3 = ($$anchor7) => {
                                var fragment_21 = comment();
                                var node_30 = first_child(fragment_21);
                                {
                                  var consequent_10 = ($$anchor8) => {
                                    var fragment_22 = comment();
                                    var node_31 = first_child(fragment_22);
                                    {
                                      let $03 = user_derived(getRuleProps);
                                      add_svelte_meta(() => Rule_default(node_31, spread_props(() => get($03))), "component", AreaChart, 537, 12, { componentTag: "Rule" });
                                    }
                                    append($$anchor8, fragment_22);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_30,
                                      ($$render) => {
                                        if (rule()) $$render(consequent_10);
                                      },
                                      true
                                    ),
                                    "if",
                                    AreaChart,
                                    536,
                                    10
                                  );
                                }
                                append($$anchor7, fragment_21);
                              };
                              add_svelte_meta(
                                () => if_block(node_28, ($$render) => {
                                  if (strict_equals(typeof rule(), "function")) $$render(consequent_9);
                                  else $$render(alternate_3, false);
                                }),
                                "if",
                                AreaChart,
                                534,
                                10
                              );
                            }
                            append($$anchor6, fragment_17);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_23,
                              ($$render) => {
                                if (axis()) $$render(consequent_11);
                              },
                              true
                            ),
                            "if",
                            AreaChart,
                            525,
                            8
                          );
                        }
                        append($$anchor5, fragment_16);
                      };
                      add_svelte_meta(
                        () => if_block(node_17, ($$render) => {
                          if (strict_equals(typeof axis(), "function")) $$render(consequent_6);
                          else $$render(alternate_4, false);
                        }),
                        "if",
                        AreaChart,
                        518,
                        8
                      );
                    }
                    var node_32 = sibling(node_17, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_32, {
                          get disabled() {
                            return get($03);
                          },
                          full: true,
                          children: wrap_snippet(AreaChart, ($$anchor5, $$slotProps2) => {
                            var fragment_23 = root_232();
                            var node_33 = first_child(fragment_23);
                            {
                              var consequent_12 = ($$anchor6) => {
                                var fragment_24 = comment();
                                var node_34 = first_child(fragment_24);
                                add_svelte_meta(() => snippet(node_34, points, () => get(snippetProps)), "render", AreaChart, 544, 12);
                                append($$anchor6, fragment_24);
                              };
                              var alternate_5 = ($$anchor6) => {
                                var fragment_25 = comment();
                                var node_35 = first_child(fragment_25);
                                {
                                  var consequent_13 = ($$anchor7) => {
                                    var fragment_26 = comment();
                                    var node_36 = first_child(fragment_26);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_36, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_27 = comment();
                                        var node_37 = first_child(fragment_27);
                                        {
                                          let $04 = user_derived(() => getPointsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Points_default(node_37, spread_props(() => get($04))), "component", AreaChart, 547, 14, { componentTag: "Points" });
                                        }
                                        append($$anchor8, fragment_27);
                                      }),
                                      "each",
                                      AreaChart,
                                      546,
                                      12
                                    );
                                    append($$anchor7, fragment_26);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_35,
                                      ($$render) => {
                                        if (points()) $$render(consequent_13);
                                      },
                                      true
                                    ),
                                    "if",
                                    AreaChart,
                                    545,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_25);
                              };
                              add_svelte_meta(
                                () => if_block(node_33, ($$render) => {
                                  if (strict_equals(typeof points(), "function")) $$render(consequent_12);
                                  else $$render(alternate_5, false);
                                }),
                                "if",
                                AreaChart,
                                543,
                                10
                              );
                            }
                            var node_38 = sibling(node_33, 2);
                            {
                              var consequent_14 = ($$anchor6) => {
                                var fragment_28 = comment();
                                var node_39 = first_child(fragment_28);
                                add_svelte_meta(() => snippet(node_39, highlight, () => get(snippetProps)), "render", AreaChart, 552, 12);
                                append($$anchor6, fragment_28);
                              };
                              var alternate_6 = ($$anchor6) => {
                                var fragment_29 = comment();
                                var node_40 = first_child(fragment_29);
                                {
                                  var consequent_15 = ($$anchor7) => {
                                    var fragment_30 = comment();
                                    var node_41 = first_child(fragment_30);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_41, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_31 = comment();
                                        var node_42 = first_child(fragment_31);
                                        {
                                          let $04 = user_derived(() => getHighlightProps(get(s3), get(i)));
                                          add_svelte_meta(() => Highlight_default(node_42, spread_props(() => get($04))), "component", AreaChart, 555, 14, { componentTag: "Highlight" });
                                        }
                                        append($$anchor8, fragment_31);
                                      }),
                                      "each",
                                      AreaChart,
                                      554,
                                      12
                                    );
                                    append($$anchor7, fragment_30);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_40,
                                      ($$render) => {
                                        if (highlight()) $$render(consequent_15);
                                      },
                                      true
                                    ),
                                    "if",
                                    AreaChart,
                                    553,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_29);
                              };
                              add_svelte_meta(
                                () => if_block(node_38, ($$render) => {
                                  if (strict_equals(typeof highlight(), "function")) $$render(consequent_14);
                                  else $$render(alternate_6, false);
                                }),
                                "if",
                                AreaChart,
                                551,
                                10
                              );
                            }
                            var node_43 = sibling(node_38, 2);
                            {
                              var consequent_16 = ($$anchor6) => {
                                var fragment_32 = comment();
                                var node_44 = first_child(fragment_32);
                                add_svelte_meta(() => snippet(node_44, labels, () => get(snippetProps)), "render", AreaChart, 560, 12);
                                append($$anchor6, fragment_32);
                              };
                              var alternate_7 = ($$anchor6) => {
                                var fragment_33 = comment();
                                var node_45 = first_child(fragment_33);
                                {
                                  var consequent_17 = ($$anchor7) => {
                                    var fragment_34 = comment();
                                    var node_46 = first_child(fragment_34);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_46, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_35 = comment();
                                        var node_47 = first_child(fragment_35);
                                        {
                                          let $04 = user_derived(() => getLabelsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Labels_default(node_47, spread_props(() => get($04))), "component", AreaChart, 563, 14, { componentTag: "Labels" });
                                        }
                                        append($$anchor8, fragment_35);
                                      }),
                                      "each",
                                      AreaChart,
                                      562,
                                      12
                                    );
                                    append($$anchor7, fragment_34);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_45,
                                      ($$render) => {
                                        if (labels()) $$render(consequent_17);
                                      },
                                      true
                                    ),
                                    "if",
                                    AreaChart,
                                    561,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_33);
                              };
                              add_svelte_meta(
                                () => if_block(node_43, ($$render) => {
                                  if (strict_equals(typeof labels(), "function")) $$render(consequent_16);
                                  else $$render(alternate_7, false);
                                }),
                                "if",
                                AreaChart,
                                559,
                                10
                              );
                            }
                            var node_48 = sibling(node_43, 2);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_48, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "above",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              AreaChart,
                              567,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            append($$anchor5, fragment_23);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        AreaChart,
                        542,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              AreaChart,
              486,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_49 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_49, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", AreaChart, 576, 6);
          var node_50 = sibling(node_49, 2);
          {
            var consequent_18 = ($$anchor4) => {
              var fragment_36 = comment();
              var node_51 = first_child(fragment_36);
              add_svelte_meta(() => snippet(node_51, legend, () => get(snippetProps)), "render", AreaChart, 579, 8);
              append($$anchor4, fragment_36);
            };
            var alternate_8 = ($$anchor4) => {
              var fragment_37 = comment();
              var node_52 = first_child(fragment_37);
              {
                var consequent_19 = ($$anchor5) => {
                  var fragment_38 = comment();
                  var node_53 = first_child(fragment_38);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_53, spread_props(() => get($02))), "component", AreaChart, 581, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_38);
                };
                add_svelte_meta(
                  () => if_block(
                    node_52,
                    ($$render) => {
                      if (legend()) $$render(consequent_19);
                    },
                    true
                  ),
                  "if",
                  AreaChart,
                  580,
                  6
                );
              }
              append($$anchor4, fragment_37);
            };
            add_svelte_meta(
              () => if_block(node_50, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_18);
                else $$render(alternate_8, false);
              }),
              "if",
              AreaChart,
              578,
              6
            );
          }
          var node_54 = sibling(node_50, 2);
          {
            var consequent_20 = ($$anchor4) => {
              var fragment_39 = comment();
              var node_55 = first_child(fragment_39);
              add_svelte_meta(() => snippet(node_55, tooltip, () => get(snippetProps)), "render", AreaChart, 585, 8);
              append($$anchor4, fragment_39);
            };
            var alternate_9 = ($$anchor4) => {
              var fragment_40 = comment();
              var node_56 = first_child(fragment_40);
              {
                var consequent_21 = ($$anchor5) => {
                  var fragment_41 = comment();
                  var node_57 = first_child(fragment_41);
                  add_svelte_meta(
                    () => DefaultTooltip_default(node_57, {
                      get tooltipProps() {
                        return props().tooltip;
                      },
                      get seriesState() {
                        return seriesState;
                      },
                      get canHaveTotal() {
                        return get(stackSeries2);
                      }
                    }),
                    "component",
                    AreaChart,
                    587,
                    8,
                    { componentTag: "DefaultTooltip" }
                  );
                  append($$anchor5, fragment_41);
                };
                add_svelte_meta(
                  () => if_block(
                    node_56,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_21);
                    },
                    true
                  ),
                  "if",
                  AreaChart,
                  586,
                  6
                );
              }
              append($$anchor4, fragment_40);
            };
            add_svelte_meta(
              () => if_block(node_54, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_20);
                else $$render(alternate_9, false);
              }),
              "if",
              AreaChart,
              584,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_10, false);
          }),
          "if",
          AreaChart,
          482,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => resolveAccessor($$props.y));
    let $1 = user_derived(() => radial2() ? void 0 : defaultChartPadding(axis(), legend()));
    let $2 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      mode: "quadtree-x",
      onclick: onTooltipClick(),
      debug: debug(),
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    let $3 = user_derived(() => brush() && (strict_equals(brush(), true) || equals(brush().mode, void 0) || strict_equals(brush().mode, "integrated")) ? {
      axis: "x",
      resetOnEnd: true,
      xDomain: xDomain(),
      ...get(brushProps),
      onBrushEnd: (e) => {
        xDomain(e.xDomain);
        get(brushProps).onBrushEnd?.(e);
      }
    } : false);
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(chartData);
          },
          get x() {
            return $$props.x;
          },
          get xDomain() {
            return xDomain();
          },
          get xScale() {
            return get(xScale);
          },
          get y() {
            return get($0);
          },
          yBaseline: 0,
          yNice: true,
          get radial() {
            return radial2();
          },
          get padding() {
            return get($1);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($2);
          },
          get brush() {
            return get($3);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      AreaChart,
      431,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AreaChart = hmr(AreaChart, () => AreaChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = AreaChart[HMR].source;
    set(AreaChart[HMR].source, module2.default[HMR].original);
  });
}
var AreaChart_default = AreaChart;

// node_modules/layerchart/dist/components/Bars.svelte
Bars[FILENAME] = "node_modules/layerchart/dist/components/Bars.svelte";
function Bars($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Bars);
  let key2 = prop($$props, "key", 3, (_, i) => i), onBarClick = prop($$props, "onBarClick", 3, () => {
  }), radius = prop($$props, "radius", 3, 0), strokeWidth = prop($$props, "strokeWidth", 3, 0), stroke = prop($$props, "stroke", 3, "black"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "fill",
      "key",
      "data",
      "onBarClick",
      "children",
      "radius",
      "strokeWidth",
      "stroke"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const data = tag(user_derived(() => chartDataArray($$props.data ?? ctx.data)), "data");
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => layerClass("bars"));
    add_svelte_meta(
      () => Group_default(node, {
        get class() {
          return get($0);
        },
        children: wrap_snippet(Bars, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.children), "render", Bars, 57, 4);
              append($$anchor3, fragment_2);
            };
            var alternate = ($$anchor3) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              validate_each_keys(() => get(data), (d, i) => key2()(d, i));
              add_svelte_meta(
                () => each(node_3, 19, () => get(data), (d, i) => key2()(d, i), ($$anchor4, d) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  {
                    let $02 = user_derived(() => $$props.fill ?? (ctx.config.c ? ctx.cGet(get(d)) : null));
                    let $1 = user_derived(() => extractLayerProps(restProps, "bars-bar"));
                    add_svelte_meta(
                      () => Bar_default(node_4, spread_props(
                        {
                          get data() {
                            return get(d);
                          },
                          get radius() {
                            return radius();
                          },
                          get strokeWidth() {
                            return strokeWidth();
                          },
                          get stroke() {
                            return stroke();
                          },
                          get fill() {
                            return get($02);
                          },
                          onclick: (e) => onBarClick()(e, { data: get(d) })
                        },
                        () => get($1)
                      )),
                      "component",
                      Bars,
                      60,
                      6,
                      { componentTag: "Bar" }
                    );
                  }
                  append($$anchor4, fragment_4);
                }),
                "each",
                Bars,
                59,
                4
              );
              append($$anchor3, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.children) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Bars,
              56,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      Bars,
      55,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Bars = hmr(Bars, () => Bars[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Bars[HMR].source;
    set(Bars[HMR].source, module2.default[HMR].original);
  });
}
var Bars_default = Bars;

// node_modules/layerchart/dist/components/charts/BarChart.svelte
BarChart[FILENAME] = "node_modules/layerchart/dist/components/charts/BarChart.svelte";
var root_86 = add_locations(from_html(`<!> <!> <!>`, 1), BarChart[FILENAME], []);
var root_125 = add_locations(from_html(`<!> <!>`, 1), BarChart[FILENAME], []);
var root_173 = add_locations(from_html(`<!> <!> <!>`, 1), BarChart[FILENAME], []);
var root_233 = add_locations(from_html(`<!> <!> <!>`, 1), BarChart[FILENAME], []);
var root_47 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), BarChart[FILENAME], []);
var root_313 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), BarChart[FILENAME], []);
function BarChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BarChart);
  let data = prop($$props, "data", 19, () => []), xDomain = prop($$props, "xDomain", 7), radial2 = prop($$props, "radial", 3, false), orientation = prop($$props, "orientation", 3, "vertical"), seriesLayout = prop($$props, "seriesLayout", 3, "overlap"), axis = prop($$props, "axis", 3, true), brush = prop($$props, "brush", 3, false), grid = prop($$props, "grid", 3, true), labels = prop($$props, "labels", 3, false), legend = prop($$props, "legend", 3, false), points = prop($$props, "points", 3, false), rule = prop($$props, "rule", 3, true), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), onBarClick = prop($$props, "onBarClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), bandPadding = prop($$props, "bandPadding", 19, () => radial2() ? 0 : 0.4), groupPadding = prop($$props, "groupPadding", 3, 0), stackPadding = prop($$props, "stackPadding", 3, 0), tooltip = prop($$props, "tooltip", 3, true), highlight = prop($$props, "highlight", 3, true), annotations = prop($$props, "annotations", 19, () => []), context = prop($$props, "context", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "xDomain",
      "radial",
      "orientation",
      "series",
      "seriesLayout",
      "axis",
      "brush",
      "grid",
      "labels",
      "legend",
      "points",
      "rule",
      "onTooltipClick",
      "onBarClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "xScale",
      "yScale",
      "bandPadding",
      "groupPadding",
      "stackPadding",
      "tooltip",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "highlight",
      "annotations",
      "context"
    ],
    "restProps"
  );
  const series = tag(
    user_derived(() => strict_equals($$props.series, void 0) ? [
      {
        key: "default",
        label: strict_equals(orientation(), "vertical") ? strict_equals(typeof $$props.y, "string") ? $$props.y : "value" : strict_equals(typeof $$props.x, "string") ? $$props.x : "value",
        value: strict_equals(orientation(), "vertical") ? $$props.y : $$props.x
      }
    ] : $$props.series),
    "series"
  );
  const seriesState = new SeriesState(() => get(series));
  const isVertical = tag(user_derived(() => strict_equals(orientation(), "vertical")), "isVertical");
  const isStackSeries = tag(user_derived(() => seriesLayout().startsWith("stack")), "isStackSeries");
  const isGroupSeries = tag(user_derived(() => strict_equals(seriesLayout(), "group")), "isGroupSeries");
  const chartData = tag(
    user_derived(() => {
      let _chartData = seriesState.allSeriesData.length ? seriesState.allSeriesData : chartDataArray(data());
      if (get(isStackSeries)) {
        const seriesKeys = seriesState.visibleSeries.map((s3) => s3.key);
        const offset = strict_equals(seriesLayout(), "stackExpand") ? expand_default : strict_equals(seriesLayout(), "stackDiverging") ? diverging_default : none_default;
        const stackData = stack_default().keys(seriesKeys).value((d, key2) => {
          const s3 = get(series).find((d2) => strict_equals(d2.key, key2));
          return accessor(s3.value ?? s3.key)(d);
        }).offset(offset)(chartDataArray(data()));
        _chartData = _chartData.map((d, i) => {
          return { ...d, stackData: stackData.map((sd) => sd[i]) };
        });
      }
      return _chartData;
    }),
    "chartData"
  );
  const xScale = tag(
    user_derived(() => $$props.xScale ?? (get(isVertical) ? band().padding(bandPadding()) : accessor($$props.x)(get(
      chartData
      // TODO: also check for Array<Date> instances (ex. x={['start', 'end']})
    )[0]) instanceof Date ? time() : linear2())),
    "xScale"
  );
  const xBaseline = tag(user_derived(() => get(isVertical) || isScaleTime(get(xScale)) ? void 0 : 0), "xBaseline");
  const yScale = tag(
    user_derived(() => $$props.yScale ?? (get(isVertical) ? accessor($$props.y)(get(
      chartData
      // TODO: also check for Array<Date> instances (ex. y={['start', 'end']})
    )[0]) instanceof Date ? time() : linear2() : band().padding(bandPadding()))),
    "yScale"
  );
  const yBaseline = tag(user_derived(() => get(isVertical) || isScaleTime(get(yScale)) ? 0 : void 0), "yBaseline");
  const x1Scale = tag(user_derived(() => get(isGroupSeries) && get(isVertical) ? band().padding(groupPadding()) : void 0), "x1Scale");
  const x1Domain = tag(
    user_derived(() => get(isGroupSeries) && get(isVertical) ? seriesState.visibleSeries.map((s3) => s3.key) : void 0),
    "x1Domain"
  );
  const x1Range = tag(
    user_derived(() => get(isGroupSeries) && get(isVertical) ? (
      // TODO: can we do something better here where we don't need to cast this
      // feels fragile!
      ({ xScale: xScale2 }) => [0, xScale2.bandwidth()]
    ) : void 0),
    "x1Range"
  );
  const y1Scale = tag(user_derived(() => get(isGroupSeries) && !get(isVertical) ? band().padding(groupPadding()) : void 0), "y1Scale");
  const y1Domain = tag(
    user_derived(() => get(isGroupSeries) && !get(isVertical) ? seriesState.visibleSeries.map((s3) => s3.key) : void 0),
    "y1Domain"
  );
  const y1Range = tag(
    user_derived(() => get(isGroupSeries) && !get(isVertical) ? (
      // TODO: can we do something better here where we don't need to cast this
      // feels fragile!
      ({ yScale: yScale2 }) => [0, yScale2.bandwidth()]
    ) : void 0),
    "y1Range"
  );
  function isStackData(d) {
    return d && strict_equals(typeof d, "object") && "stackData" in d;
  }
  function getBarsProps(s3, i) {
    const isFirst = equals(i, 0);
    const isLast = equals(i, seriesState.visibleSeries.length - 1);
    const isStackLayout = seriesLayout().startsWith("stack");
    let stackInsets = void 0;
    if (isStackLayout) {
      const stackInset = stackPadding() / 2;
      if (get(isVertical)) {
        stackInsets = {
          bottom: isFirst ? void 0 : stackInset,
          top: isLast ? void 0 : stackInset
        };
      } else {
        stackInsets = {
          left: isFirst ? void 0 : stackInset,
          right: isLast ? void 0 : stackInset
        };
      }
    }
    const valueAccessor = get(isStackSeries) ? (d) => d.stackData[i] : s3.value ?? (s3.data ? void 0 : s3.key);
    return {
      data: s3.data,
      x: !get(isVertical) ? valueAccessor : void 0,
      y: get(isVertical) ? valueAccessor : void 0,
      x1: get(isVertical) && get(isGroupSeries) ? (d) => s3.value ?? s3.key : void 0,
      y1: !get(isVertical) && get(isGroupSeries) ? (d) => s3.value ?? s3.key : void 0,
      rounded: isStackLayout && strict_equals(i, seriesState.visibleSeries.length - 1, false) ? "none" : Array.isArray($$props.x) || Array.isArray($$props.y) ? "all" : "edge",
      radius: 4,
      strokeWidth: 1,
      insets: stackInsets,
      fill: s3.color,
      onBarClick: (e, detail) => onBarClick()(e, { ...detail, series: s3 }),
      ...props().bars,
      ...s3.props,
      class: cls("transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().bars?.class, s3.props?.class)
    };
  }
  function getLabelsProps(s3, i) {
    return {
      // TODO: Improve placement when using `seriesLayout="group"`
      // data: s.data,
      // y: s.value ?? (s.data ? undefined : s.key),
      ...props().labels,
      ...strict_equals(typeof labels(), "object") ? labels() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().labels?.class, strict_equals(typeof labels(), "object") && labels().class)
    };
  }
  const brushProps = tag(
    user_derived(() => ({
      ...strict_equals(typeof brush(), "object") ? brush() : null,
      ...props().brush
    })),
    "brushProps"
  );
  function getLegendProps() {
    return createLegendProps({
      seriesState,
      props: {
        ...props().legend,
        ...strict_equals(typeof legend(), "object") ? legend() : null
      }
    });
  }
  function getGridProps() {
    return {
      x: !get(isVertical) || radial2(),
      y: get(isVertical) || radial2(),
      ...strict_equals(typeof grid(), "object") ? grid() : null,
      ...props().grid
    };
  }
  function getHighlightProps() {
    return { area: true, ...props().highlight };
  }
  function getAxisProps(axisDirection) {
    if (strict_equals(axisDirection, "y")) {
      return {
        placement: radial2() ? "radius" : "left",
        format: get(isVertical) && strict_equals(seriesLayout(), "stackExpand") ? "percentRound" : void 0,
        ...strict_equals(typeof axis(), "object") ? axis() : null,
        ...props().yAxis
      };
    }
    return {
      placement: radial2() ? "angle" : "bottom",
      format: !get(isVertical) && strict_equals(seriesLayout(), "stackExpand") ? "percentRound" : void 0,
      ...strict_equals(typeof axis(), "object") ? axis() : null,
      ...props().xAxis
    };
  }
  function getRuleProps() {
    return {
      x: get(isVertical) ? false : 0,
      y: get(isVertical) ? 0 : false,
      ...strict_equals(typeof rule(), "object") ? rule() : null,
      ...props().rule
    };
  }
  if (profile()) {
    console.time("BarChart render");
    onMount(() => {
      console.timeEnd("BarChart render");
    });
  }
  setTooltipMetaContext({
    type: "bar",
    get orientation() {
      return orientation();
    },
    get stackSeries() {
      return get(isStackSeries);
    },
    get visibleSeries() {
      return seriesState.visibleSeries;
    }
  });
  function resolveAccessor(acc) {
    if (acc) return acc;
    if (get(isStackSeries)) {
      return (d) => isStackData(d) ? seriesState.visibleSeries.flatMap((s3, i) => d.stackData[i]) : void 0;
    }
    return seriesState.visibleSeries.map((s3) => s3.value ?? s3.key);
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(BarChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          context: context2(),
          series: get(series),
          visibleSeries: seriesState.visibleSeries,
          getBarsProps,
          getLabelsProps,
          getLegendProps,
          getGridProps,
          getHighlightProps,
          getAxisProps,
          getRuleProps,
          highlightKey: seriesState.highlightKey.current,
          setHighlightKey: seriesState.highlightKey.set
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", BarChart, 490, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_9 = ($$anchor3) => {
          var fragment_3 = root_313();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", BarChart, 492, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get center() {
                    return radial2();
                  },
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(BarChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_47();
                    var node_5 = first_child(fragment_4);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_6 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_6, grid, () => get(snippetProps)), "render", BarChart, 501, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_7 = first_child(fragment_6);
                        {
                          var consequent_2 = ($$anchor6) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            {
                              let $03 = user_derived(getGridProps);
                              add_svelte_meta(() => Grid_default(node_8, spread_props(() => get($03))), "component", BarChart, 503, 10, { componentTag: "Grid" });
                            }
                            append($$anchor6, fragment_7);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_7,
                              ($$render) => {
                                if (grid()) $$render(consequent_2);
                              },
                              true
                            ),
                            "if",
                            BarChart,
                            502,
                            8
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_5, ($$render) => {
                          if (strict_equals(typeof grid(), "function")) $$render(consequent_1);
                          else $$render(alternate, false);
                        }),
                        "if",
                        BarChart,
                        500,
                        8
                      );
                    }
                    var node_9 = sibling(node_5, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_9, {
                          get disabled() {
                            return get($03);
                          },
                          children: wrap_snippet(BarChart, ($$anchor5, $$slotProps2) => {
                            var fragment_8 = root_86();
                            var node_10 = first_child(fragment_8);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_10, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "below",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              BarChart,
                              507,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            var node_11 = sibling(node_10, 2);
                            add_svelte_meta(() => snippet(node_11, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", BarChart, 514, 10);
                            var node_12 = sibling(node_11, 2);
                            {
                              var consequent_3 = ($$anchor6) => {
                                var fragment_9 = comment();
                                var node_13 = first_child(fragment_9);
                                add_svelte_meta(() => snippet(node_13, () => $$props.marks, () => get(snippetProps)), "render", BarChart, 517, 12);
                                append($$anchor6, fragment_9);
                              };
                              var alternate_1 = ($$anchor6) => {
                                var fragment_10 = comment();
                                var node_14 = first_child(fragment_10);
                                validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_14, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor7, s3, i) => {
                                    var fragment_11 = comment();
                                    var node_15 = first_child(fragment_11);
                                    {
                                      let $04 = user_derived(() => getBarsProps(get(s3), get(i)));
                                      add_svelte_meta(() => Bars_default(node_15, spread_props(() => get($04))), "component", BarChart, 520, 14, { componentTag: "Bars" });
                                    }
                                    append($$anchor7, fragment_11);
                                  }),
                                  "each",
                                  BarChart,
                                  519,
                                  12
                                );
                                append($$anchor6, fragment_10);
                              };
                              add_svelte_meta(
                                () => if_block(node_12, ($$render) => {
                                  if (strict_equals(typeof $$props.marks, "function")) $$render(consequent_3);
                                  else $$render(alternate_1, false);
                                }),
                                "if",
                                BarChart,
                                516,
                                10
                              );
                            }
                            append($$anchor5, fragment_8);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        BarChart,
                        506,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    var node_16 = sibling(node_9, 2);
                    add_svelte_meta(() => snippet(node_16, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", BarChart, 525, 8);
                    var node_17 = sibling(node_16, 2);
                    {
                      var consequent_6 = ($$anchor5) => {
                        var fragment_12 = root_125();
                        var node_18 = first_child(fragment_12);
                        add_svelte_meta(() => snippet(node_18, axis, () => get(snippetProps)), "render", BarChart, 528, 10);
                        var node_19 = sibling(node_18, 2);
                        {
                          var consequent_4 = ($$anchor6) => {
                            var fragment_13 = comment();
                            var node_20 = first_child(fragment_13);
                            add_svelte_meta(() => snippet(node_20, rule, () => get(snippetProps)), "render", BarChart, 530, 12);
                            append($$anchor6, fragment_13);
                          };
                          var alternate_2 = ($$anchor6) => {
                            var fragment_14 = comment();
                            var node_21 = first_child(fragment_14);
                            {
                              var consequent_5 = ($$anchor7) => {
                                var fragment_15 = comment();
                                var node_22 = first_child(fragment_15);
                                {
                                  let $03 = user_derived(getRuleProps);
                                  add_svelte_meta(() => Rule_default(node_22, spread_props(() => get($03))), "component", BarChart, 532, 12, { componentTag: "Rule" });
                                }
                                append($$anchor7, fragment_15);
                              };
                              add_svelte_meta(
                                () => if_block(
                                  node_21,
                                  ($$render) => {
                                    if (rule()) $$render(consequent_5);
                                  },
                                  true
                                ),
                                "if",
                                BarChart,
                                531,
                                10
                              );
                            }
                            append($$anchor6, fragment_14);
                          };
                          add_svelte_meta(
                            () => if_block(node_19, ($$render) => {
                              if (strict_equals(typeof rule(), "function")) $$render(consequent_4);
                              else $$render(alternate_2, false);
                            }),
                            "if",
                            BarChart,
                            529,
                            10
                          );
                        }
                        append($$anchor5, fragment_12);
                      };
                      var alternate_4 = ($$anchor5) => {
                        var fragment_16 = comment();
                        var node_23 = first_child(fragment_16);
                        {
                          var consequent_11 = ($$anchor6) => {
                            var fragment_17 = root_173();
                            var node_24 = first_child(fragment_17);
                            {
                              var consequent_7 = ($$anchor7) => {
                                var fragment_18 = comment();
                                var node_25 = first_child(fragment_18);
                                {
                                  let $03 = user_derived(() => getAxisProps("y"));
                                  add_svelte_meta(() => Axis_default(node_25, spread_props(() => get($03))), "component", BarChart, 536, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_18);
                              };
                              add_svelte_meta(
                                () => if_block(node_24, ($$render) => {
                                  if (strict_equals(axis(), "x", false)) $$render(consequent_7);
                                }),
                                "if",
                                BarChart,
                                535,
                                10
                              );
                            }
                            var node_26 = sibling(node_24, 2);
                            {
                              var consequent_8 = ($$anchor7) => {
                                var fragment_19 = comment();
                                var node_27 = first_child(fragment_19);
                                {
                                  let $03 = user_derived(() => getAxisProps("x"));
                                  add_svelte_meta(() => Axis_default(node_27, spread_props(() => get($03))), "component", BarChart, 540, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_19);
                              };
                              add_svelte_meta(
                                () => if_block(node_26, ($$render) => {
                                  if (strict_equals(axis(), "y", false)) $$render(consequent_8);
                                }),
                                "if",
                                BarChart,
                                539,
                                10
                              );
                            }
                            var node_28 = sibling(node_26, 2);
                            {
                              var consequent_9 = ($$anchor7) => {
                                var fragment_20 = comment();
                                var node_29 = first_child(fragment_20);
                                add_svelte_meta(() => snippet(node_29, rule, () => get(snippetProps)), "render", BarChart, 544, 12);
                                append($$anchor7, fragment_20);
                              };
                              var alternate_3 = ($$anchor7) => {
                                var fragment_21 = comment();
                                var node_30 = first_child(fragment_21);
                                {
                                  var consequent_10 = ($$anchor8) => {
                                    var fragment_22 = comment();
                                    var node_31 = first_child(fragment_22);
                                    {
                                      let $03 = user_derived(getRuleProps);
                                      add_svelte_meta(() => Rule_default(node_31, spread_props(() => get($03))), "component", BarChart, 546, 12, { componentTag: "Rule" });
                                    }
                                    append($$anchor8, fragment_22);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_30,
                                      ($$render) => {
                                        if (rule()) $$render(consequent_10);
                                      },
                                      true
                                    ),
                                    "if",
                                    BarChart,
                                    545,
                                    10
                                  );
                                }
                                append($$anchor7, fragment_21);
                              };
                              add_svelte_meta(
                                () => if_block(node_28, ($$render) => {
                                  if (strict_equals(typeof rule(), "function")) $$render(consequent_9);
                                  else $$render(alternate_3, false);
                                }),
                                "if",
                                BarChart,
                                543,
                                10
                              );
                            }
                            append($$anchor6, fragment_17);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_23,
                              ($$render) => {
                                if (axis()) $$render(consequent_11);
                              },
                              true
                            ),
                            "if",
                            BarChart,
                            534,
                            8
                          );
                        }
                        append($$anchor5, fragment_16);
                      };
                      add_svelte_meta(
                        () => if_block(node_17, ($$render) => {
                          if (strict_equals(typeof axis(), "function")) $$render(consequent_6);
                          else $$render(alternate_4, false);
                        }),
                        "if",
                        BarChart,
                        527,
                        8
                      );
                    }
                    var node_32 = sibling(node_17, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_32, {
                          get disabled() {
                            return get($03);
                          },
                          full: true,
                          children: wrap_snippet(BarChart, ($$anchor5, $$slotProps2) => {
                            var fragment_23 = root_233();
                            var node_33 = first_child(fragment_23);
                            {
                              var consequent_12 = ($$anchor6) => {
                                var fragment_24 = comment();
                                var node_34 = first_child(fragment_24);
                                add_svelte_meta(() => snippet(node_34, highlight, () => get(snippetProps)), "render", BarChart, 553, 12);
                                append($$anchor6, fragment_24);
                              };
                              var alternate_5 = ($$anchor6) => {
                                var fragment_25 = comment();
                                var node_35 = first_child(fragment_25);
                                {
                                  var consequent_13 = ($$anchor7) => {
                                    var fragment_26 = comment();
                                    var node_36 = first_child(fragment_26);
                                    {
                                      let $04 = user_derived(getHighlightProps);
                                      add_svelte_meta(() => Highlight_default(node_36, spread_props(() => get($04))), "component", BarChart, 555, 12, { componentTag: "Highlight" });
                                    }
                                    append($$anchor7, fragment_26);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_35,
                                      ($$render) => {
                                        if (highlight()) $$render(consequent_13);
                                      },
                                      true
                                    ),
                                    "if",
                                    BarChart,
                                    554,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_25);
                              };
                              add_svelte_meta(
                                () => if_block(node_33, ($$render) => {
                                  if (strict_equals(typeof highlight(), "function")) $$render(consequent_12);
                                  else $$render(alternate_5, false);
                                }),
                                "if",
                                BarChart,
                                552,
                                10
                              );
                            }
                            var node_37 = sibling(node_33, 2);
                            {
                              var consequent_14 = ($$anchor6) => {
                                var fragment_27 = comment();
                                var node_38 = first_child(fragment_27);
                                add_svelte_meta(() => snippet(node_38, labels, () => get(snippetProps)), "render", BarChart, 559, 12);
                                append($$anchor6, fragment_27);
                              };
                              var alternate_6 = ($$anchor6) => {
                                var fragment_28 = comment();
                                var node_39 = first_child(fragment_28);
                                {
                                  var consequent_15 = ($$anchor7) => {
                                    var fragment_29 = comment();
                                    var node_40 = first_child(fragment_29);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_40, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_30 = comment();
                                        var node_41 = first_child(fragment_30);
                                        {
                                          let $04 = user_derived(() => getLabelsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Labels_default(node_41, spread_props(() => get($04))), "component", BarChart, 562, 14, { componentTag: "Labels" });
                                        }
                                        append($$anchor8, fragment_30);
                                      }),
                                      "each",
                                      BarChart,
                                      561,
                                      12
                                    );
                                    append($$anchor7, fragment_29);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_39,
                                      ($$render) => {
                                        if (labels()) $$render(consequent_15);
                                      },
                                      true
                                    ),
                                    "if",
                                    BarChart,
                                    560,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_28);
                              };
                              add_svelte_meta(
                                () => if_block(node_37, ($$render) => {
                                  if (strict_equals(typeof labels(), "function")) $$render(consequent_14);
                                  else $$render(alternate_6, false);
                                }),
                                "if",
                                BarChart,
                                558,
                                10
                              );
                            }
                            var node_42 = sibling(node_37, 2);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_42, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "above",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              BarChart,
                              566,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            append($$anchor5, fragment_23);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        BarChart,
                        551,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              BarChart,
              494,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_43 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_43, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", BarChart, 575, 6);
          var node_44 = sibling(node_43, 2);
          {
            var consequent_16 = ($$anchor4) => {
              var fragment_31 = comment();
              var node_45 = first_child(fragment_31);
              add_svelte_meta(() => snippet(node_45, legend, () => get(snippetProps)), "render", BarChart, 578, 8);
              append($$anchor4, fragment_31);
            };
            var alternate_7 = ($$anchor4) => {
              var fragment_32 = comment();
              var node_46 = first_child(fragment_32);
              {
                var consequent_17 = ($$anchor5) => {
                  var fragment_33 = comment();
                  var node_47 = first_child(fragment_33);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_47, spread_props(() => get($02))), "component", BarChart, 580, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_33);
                };
                add_svelte_meta(
                  () => if_block(
                    node_46,
                    ($$render) => {
                      if (legend()) $$render(consequent_17);
                    },
                    true
                  ),
                  "if",
                  BarChart,
                  579,
                  6
                );
              }
              append($$anchor4, fragment_32);
            };
            add_svelte_meta(
              () => if_block(node_44, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_16);
                else $$render(alternate_7, false);
              }),
              "if",
              BarChart,
              577,
              6
            );
          }
          var node_48 = sibling(node_44, 2);
          {
            var consequent_18 = ($$anchor4) => {
              var fragment_34 = comment();
              var node_49 = first_child(fragment_34);
              add_svelte_meta(() => snippet(node_49, tooltip, () => get(snippetProps)), "render", BarChart, 584, 8);
              append($$anchor4, fragment_34);
            };
            var alternate_8 = ($$anchor4) => {
              var fragment_35 = comment();
              var node_50 = first_child(fragment_35);
              {
                var consequent_19 = ($$anchor5) => {
                  var fragment_36 = comment();
                  var node_51 = first_child(fragment_36);
                  {
                    let $02 = user_derived(() => get(isStackSeries) || get(isGroupSeries));
                    add_svelte_meta(
                      () => DefaultTooltip_default(node_51, {
                        get tooltipProps() {
                          return props().tooltip;
                        },
                        get canHaveTotal() {
                          return get($02);
                        },
                        get seriesState() {
                          return seriesState;
                        }
                      }),
                      "component",
                      BarChart,
                      586,
                      8,
                      { componentTag: "DefaultTooltip" }
                    );
                  }
                  append($$anchor5, fragment_36);
                };
                add_svelte_meta(
                  () => if_block(
                    node_50,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_19);
                    },
                    true
                  ),
                  "if",
                  BarChart,
                  585,
                  6
                );
              }
              append($$anchor4, fragment_35);
            };
            add_svelte_meta(
              () => if_block(node_48, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_18);
                else $$render(alternate_8, false);
              }),
              "if",
              BarChart,
              583,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_9, false);
          }),
          "if",
          BarChart,
          489,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => resolveAccessor($$props.x));
    let $1 = user_derived(() => strict_equals(orientation(), "horizontal"));
    let $2 = user_derived(() => resolveAccessor($$props.y));
    let $3 = user_derived(() => strict_equals(orientation(), "vertical"));
    let $4 = user_derived(() => get(isVertical) ? $$props.y : $$props.x);
    let $5 = user_derived(() => radial2() ? void 0 : defaultChartPadding(axis(), legend()));
    let $6 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      mode: "band",
      onclick: onTooltipClick(),
      debug: debug(),
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    let $7 = user_derived(() => brush() && (strict_equals(brush(), true) || equals(brush().mode, void 0) || strict_equals(brush().mode, "integrated")) ? {
      axis: "x",
      resetOnEnd: true,
      xDomain: xDomain(),
      ...get(brushProps),
      onBrushEnd: (e) => {
        xDomain(e.xDomain);
        get(brushProps).onBrushEnd?.(e);
      }
    } : false);
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(chartData);
          },
          get x() {
            return get($0);
          },
          get xDomain() {
            return xDomain();
          },
          get xScale() {
            return get(xScale);
          },
          get xBaseline() {
            return get(xBaseline);
          },
          get xNice() {
            return get($1);
          },
          get x1Scale() {
            return get(x1Scale);
          },
          get x1Domain() {
            return get(x1Domain);
          },
          get x1Range() {
            return get(x1Range);
          },
          get y() {
            return get($2);
          },
          get yScale() {
            return get(yScale);
          },
          get yBaseline() {
            return get(yBaseline);
          },
          get yNice() {
            return get($3);
          },
          get y1Scale() {
            return get(y1Scale);
          },
          get y1Domain() {
            return get(y1Domain);
          },
          get y1Range() {
            return get(y1Range);
          },
          get c() {
            return get($4);
          },
          cRange: ["var(--color-primary)"],
          get radial() {
            return radial2();
          },
          get padding() {
            return get($5);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($6);
          },
          get brush() {
            return get($7);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      BarChart,
      428,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BarChart = hmr(BarChart, () => BarChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = BarChart[HMR].source;
    set(BarChart[HMR].source, module2.default[HMR].original);
  });
}
var BarChart_default = BarChart;

// node_modules/layerchart/dist/components/charts/LineChart.svelte
LineChart[FILENAME] = "node_modules/layerchart/dist/components/charts/LineChart.svelte";
var root_87 = add_locations(from_html(`<!> <!> <!> <!>`, 1), LineChart[FILENAME], []);
var root_142 = add_locations(from_html(`<!> <!>`, 1), LineChart[FILENAME], []);
var root_192 = add_locations(from_html(`<!> <!> <!>`, 1), LineChart[FILENAME], []);
var root_252 = add_locations(from_html(`<!> <!> <!> <!>`, 1), LineChart[FILENAME], []);
var root_48 = add_locations(from_html(`<!> <!> <!> <!>`, 1), LineChart[FILENAME], []);
var root_314 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), LineChart[FILENAME], []);
function LineChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LineChart);
  let data = prop($$props, "data", 19, () => []), xDomain = prop($$props, "xDomain", 7), radial2 = prop($$props, "radial", 3, false), seriesLayout = prop($$props, "seriesLayout", 3, "overlap"), axis = prop($$props, "axis", 3, true), brush = prop($$props, "brush", 3, false), grid = prop($$props, "grid", 3, true), labels = prop($$props, "labels", 3, false), legend = prop($$props, "legend", 3, false), points = prop($$props, "points", 3, false), rule = prop($$props, "rule", 3, true), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), tooltip = prop($$props, "tooltip", 3, true), highlight = prop($$props, "highlight", 3, true), annotations = prop($$props, "annotations", 19, () => []), context = prop($$props, "context", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "xDomain",
      "radial",
      "series",
      "seriesLayout",
      "axis",
      "brush",
      "grid",
      "labels",
      "legend",
      "points",
      "rule",
      "onTooltipClick",
      "onPointClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "xScale",
      "tooltip",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "spline",
      "highlight",
      "annotations",
      "context"
    ],
    "restProps"
  );
  const series = tag(
    user_derived(() => strict_equals($$props.series, void 0) ? [
      {
        key: "default",
        label: strict_equals(typeof $$props.y, "string") ? $$props.y : "value",
        value: $$props.y,
        color: "var(--color-primary)"
      }
    ] : $$props.series),
    "series"
  );
  const seriesState = new SeriesState(() => get(series));
  const chartData = tag(user_derived(() => seriesState.allSeriesData.length ? seriesState.allSeriesData : chartDataArray(data())), "chartData");
  const xScale = tag(user_derived(() => $$props.xScale ?? (accessor($$props.x)(get(chartData)[0]) instanceof Date ? time() : linear2())), "xScale");
  function getSplineProps(s3, i) {
    const splineProps = {
      data: s3.data,
      y: s3.value ?? (s3.data ? void 0 : s3.key),
      stroke: s3.color,
      ...props().spline,
      ...s3.props,
      class: cls(
        layerClass("line-chart-line"),
        "transition-opacity",
        // Checking `visibleSeries.length > 1` fixes re-animated tweened areas on hover
        seriesState.visibleSeries.length > 1 && seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10",
        props().spline?.class,
        s3.props?.class
      )
    };
    return splineProps;
  }
  function getPointsProps(s3, i) {
    const pointsProps = {
      data: s3.data,
      y: s3.value ?? (s3.data ? void 0 : s3.key),
      fill: s3.color,
      ...props().points,
      ...strict_equals(typeof points(), "object") ? points() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().points?.class, strict_equals(typeof points(), "object") && points().class)
    };
    return pointsProps;
  }
  function getLabelsProps(s3, i) {
    const labelsProps = {
      data: s3.data,
      y: s3.value ?? (s3.data ? void 0 : s3.key),
      ...props().labels,
      ...strict_equals(typeof labels(), "object") ? labels() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().labels?.class, strict_equals(typeof labels(), "object") && labels().class)
    };
    return labelsProps;
  }
  const highlightPointsProps = tag(user_derived(() => strict_equals(typeof props().highlight?.points, "object") ? props().highlight.points : null), "highlightPointsProps");
  function getHighlightProps(s3, i) {
    if (!context() || !context().tooltip.data) return {};
    const seriesTooltipData = s3.data && context().tooltip.data ? findRelatedData(s3.data, context().tooltip.data, context().x) : null;
    return {
      data: seriesTooltipData,
      y: s3.value ?? (s3.data ? void 0 : s3.key),
      lines: strict_equals(i, 0),
      onPointClick: $$props.onPointClick ? (e, detail) => $$props.onPointClick(e, { ...detail, series: s3 }) : void 0,
      onPointEnter: () => assign(seriesState.highlightKey, "current", s3.key, "node_modules/​layerchart/​dist/​components/​charts/​LineChart.svelte:250:27"),
      onPointLeave: () => assign(seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​LineChart.svelte:251:27"),
      ...props().highlight,
      points: equals(props().highlight?.points, false) ? false : {
        ...get(highlightPointsProps),
        fill: s3.color,
        class: cls("transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", get(highlightPointsProps)?.class)
      }
    };
  }
  function getLegendProps() {
    return createLegendProps({
      seriesState,
      props: {
        ...props().legend,
        ...strict_equals(typeof legend(), "object") ? legend() : null
      }
    });
  }
  function getGridProps() {
    return {
      x: radial2(),
      y: true,
      ...strict_equals(typeof grid(), "object") ? grid() : null,
      ...props().grid
    };
  }
  function getAxisProps(axisDirection) {
    if (strict_equals(axisDirection, "y")) {
      return {
        placement: radial2() ? "radius" : "left",
        ...strict_equals(typeof axis(), "object") ? axis() : null,
        ...props().yAxis
      };
    }
    return {
      placement: radial2() ? "angle" : "bottom",
      ...strict_equals(typeof axis(), "object") ? axis() : null,
      ...props().xAxis
    };
  }
  function getRuleProps() {
    return {
      x: 0,
      y: 0,
      ...strict_equals(typeof rule(), "object") ? rule() : null,
      ...props().rule
    };
  }
  const brushProps = tag(
    user_derived(() => ({
      ...strict_equals(typeof brush(), "object") ? brush() : null,
      ...props().brush
    })),
    "brushProps"
  );
  if (profile()) {
    console.time("LineChart render");
    onMount(() => {
      console.timeEnd("LineChart render");
    });
  }
  setTooltipMetaContext({
    type: "line",
    get visibleSeries() {
      return seriesState.visibleSeries;
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(LineChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          context: context2(),
          series: get(series),
          visibleSeries: seriesState.visibleSeries,
          getLabelsProps,
          getPointsProps,
          getSplineProps,
          getHighlightProps,
          getLegendProps,
          getGridProps,
          getAxisProps,
          getRuleProps,
          highlightKey: seriesState.highlightKey.current,
          setHighlightKey: seriesState.highlightKey.set
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", LineChart, 382, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_11 = ($$anchor3) => {
          var fragment_3 = root_314();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", LineChart, 384, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get center() {
                    return radial2();
                  },
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(LineChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_48();
                    var node_5 = first_child(fragment_4);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_6 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_6, grid, () => get(snippetProps)), "render", LineChart, 393, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_7 = first_child(fragment_6);
                        {
                          var consequent_2 = ($$anchor6) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            {
                              let $03 = user_derived(getGridProps);
                              add_svelte_meta(() => Grid_default(node_8, spread_props(() => get($03))), "component", LineChart, 395, 10, { componentTag: "Grid" });
                            }
                            append($$anchor6, fragment_7);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_7,
                              ($$render) => {
                                if (grid()) $$render(consequent_2);
                              },
                              true
                            ),
                            "if",
                            LineChart,
                            394,
                            8
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_5, ($$render) => {
                          if (strict_equals(typeof grid(), "function")) $$render(consequent_1);
                          else $$render(alternate, false);
                        }),
                        "if",
                        LineChart,
                        392,
                        8
                      );
                    }
                    var node_9 = sibling(node_5, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_9, {
                          get disabled() {
                            return get($03);
                          },
                          children: wrap_snippet(LineChart, ($$anchor5, $$slotProps2) => {
                            var fragment_8 = root_87();
                            var node_10 = first_child(fragment_8);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_10, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "below",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              LineChart,
                              399,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            var node_11 = sibling(node_10, 2);
                            add_svelte_meta(() => snippet(node_11, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", LineChart, 406, 10);
                            var node_12 = sibling(node_11, 2);
                            {
                              var consequent_3 = ($$anchor6) => {
                                var fragment_9 = comment();
                                var node_13 = first_child(fragment_9);
                                add_svelte_meta(() => snippet(node_13, () => $$props.marks, () => get(snippetProps)), "render", LineChart, 408, 12);
                                append($$anchor6, fragment_9);
                              };
                              var alternate_2 = ($$anchor6) => {
                                var fragment_10 = comment();
                                var node_14 = first_child(fragment_10);
                                validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_14, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor7, s3, i) => {
                                    var fragment_11 = comment();
                                    var node_15 = first_child(fragment_11);
                                    {
                                      var consequent_4 = ($$anchor8) => {
                                        var fragment_12 = comment();
                                        var node_16 = first_child(fragment_12);
                                        {
                                          let $04 = user_derived(() => ({
                                            ...get(snippetProps),
                                            props: getSplineProps(get(s3), get(i)),
                                            seriesIndex: get(i)
                                          }));
                                          add_svelte_meta(() => snippet(node_16, () => $$props.spline, () => get($04)), "render", LineChart, 412, 16);
                                        }
                                        append($$anchor8, fragment_12);
                                      };
                                      var alternate_1 = ($$anchor8) => {
                                        var fragment_13 = comment();
                                        var node_17 = first_child(fragment_13);
                                        {
                                          let $04 = user_derived(() => getSplineProps(get(s3), get(i)));
                                          add_svelte_meta(() => Spline_default(node_17, spread_props(() => get($04))), "component", LineChart, 414, 16, { componentTag: "Spline" });
                                        }
                                        append($$anchor8, fragment_13);
                                      };
                                      add_svelte_meta(
                                        () => if_block(node_15, ($$render) => {
                                          if (strict_equals(typeof $$props.spline, "function")) $$render(consequent_4);
                                          else $$render(alternate_1, false);
                                        }),
                                        "if",
                                        LineChart,
                                        411,
                                        14
                                      );
                                    }
                                    append($$anchor7, fragment_11);
                                  }),
                                  "each",
                                  LineChart,
                                  410,
                                  12
                                );
                                append($$anchor6, fragment_10);
                              };
                              add_svelte_meta(
                                () => if_block(node_12, ($$render) => {
                                  if ($$props.marks) $$render(consequent_3);
                                  else $$render(alternate_2, false);
                                }),
                                "if",
                                LineChart,
                                407,
                                10
                              );
                            }
                            var node_18 = sibling(node_12, 2);
                            add_svelte_meta(() => snippet(node_18, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", LineChart, 419, 10);
                            append($$anchor5, fragment_8);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        LineChart,
                        398,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    var node_19 = sibling(node_9, 2);
                    {
                      var consequent_7 = ($$anchor5) => {
                        var fragment_14 = root_142();
                        var node_20 = first_child(fragment_14);
                        add_svelte_meta(() => snippet(node_20, axis, () => get(snippetProps)), "render", LineChart, 423, 10);
                        var node_21 = sibling(node_20, 2);
                        {
                          var consequent_5 = ($$anchor6) => {
                            var fragment_15 = comment();
                            var node_22 = first_child(fragment_15);
                            add_svelte_meta(() => snippet(node_22, rule, () => get(snippetProps)), "render", LineChart, 426, 12);
                            append($$anchor6, fragment_15);
                          };
                          var alternate_3 = ($$anchor6) => {
                            var fragment_16 = comment();
                            var node_23 = first_child(fragment_16);
                            {
                              var consequent_6 = ($$anchor7) => {
                                var fragment_17 = comment();
                                var node_24 = first_child(fragment_17);
                                {
                                  let $03 = user_derived(getRuleProps);
                                  add_svelte_meta(() => Rule_default(node_24, spread_props(() => get($03))), "component", LineChart, 428, 12, { componentTag: "Rule" });
                                }
                                append($$anchor7, fragment_17);
                              };
                              add_svelte_meta(
                                () => if_block(
                                  node_23,
                                  ($$render) => {
                                    if (rule()) $$render(consequent_6);
                                  },
                                  true
                                ),
                                "if",
                                LineChart,
                                427,
                                10
                              );
                            }
                            append($$anchor6, fragment_16);
                          };
                          add_svelte_meta(
                            () => if_block(node_21, ($$render) => {
                              if (strict_equals(typeof rule(), "function")) $$render(consequent_5);
                              else $$render(alternate_3, false);
                            }),
                            "if",
                            LineChart,
                            425,
                            10
                          );
                        }
                        append($$anchor5, fragment_14);
                      };
                      var alternate_5 = ($$anchor5) => {
                        var fragment_18 = comment();
                        var node_25 = first_child(fragment_18);
                        {
                          var consequent_12 = ($$anchor6) => {
                            var fragment_19 = root_192();
                            var node_26 = first_child(fragment_19);
                            {
                              var consequent_8 = ($$anchor7) => {
                                var fragment_20 = comment();
                                var node_27 = first_child(fragment_20);
                                {
                                  let $03 = user_derived(() => getAxisProps("y"));
                                  add_svelte_meta(() => Axis_default(node_27, spread_props(() => get($03))), "component", LineChart, 432, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_20);
                              };
                              add_svelte_meta(
                                () => if_block(node_26, ($$render) => {
                                  if (strict_equals(axis(), "x", false)) $$render(consequent_8);
                                }),
                                "if",
                                LineChart,
                                431,
                                10
                              );
                            }
                            var node_28 = sibling(node_26, 2);
                            {
                              var consequent_9 = ($$anchor7) => {
                                var fragment_21 = comment();
                                var node_29 = first_child(fragment_21);
                                {
                                  let $03 = user_derived(() => getAxisProps("x"));
                                  add_svelte_meta(() => Axis_default(node_29, spread_props(() => get($03))), "component", LineChart, 436, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_21);
                              };
                              add_svelte_meta(
                                () => if_block(node_28, ($$render) => {
                                  if (strict_equals(axis(), "y", false)) $$render(consequent_9);
                                }),
                                "if",
                                LineChart,
                                435,
                                10
                              );
                            }
                            var node_30 = sibling(node_28, 2);
                            {
                              var consequent_10 = ($$anchor7) => {
                                var fragment_22 = comment();
                                var node_31 = first_child(fragment_22);
                                add_svelte_meta(() => snippet(node_31, rule, () => get(snippetProps)), "render", LineChart, 440, 12);
                                append($$anchor7, fragment_22);
                              };
                              var alternate_4 = ($$anchor7) => {
                                var fragment_23 = comment();
                                var node_32 = first_child(fragment_23);
                                {
                                  var consequent_11 = ($$anchor8) => {
                                    var fragment_24 = comment();
                                    var node_33 = first_child(fragment_24);
                                    {
                                      let $03 = user_derived(getRuleProps);
                                      add_svelte_meta(() => Rule_default(node_33, spread_props(() => get($03))), "component", LineChart, 442, 12, { componentTag: "Rule" });
                                    }
                                    append($$anchor8, fragment_24);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_32,
                                      ($$render) => {
                                        if (rule()) $$render(consequent_11);
                                      },
                                      true
                                    ),
                                    "if",
                                    LineChart,
                                    441,
                                    10
                                  );
                                }
                                append($$anchor7, fragment_23);
                              };
                              add_svelte_meta(
                                () => if_block(node_30, ($$render) => {
                                  if (strict_equals(typeof rule(), "function")) $$render(consequent_10);
                                  else $$render(alternate_4, false);
                                }),
                                "if",
                                LineChart,
                                439,
                                10
                              );
                            }
                            append($$anchor6, fragment_19);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_25,
                              ($$render) => {
                                if (axis()) $$render(consequent_12);
                              },
                              true
                            ),
                            "if",
                            LineChart,
                            430,
                            8
                          );
                        }
                        append($$anchor5, fragment_18);
                      };
                      add_svelte_meta(
                        () => if_block(node_19, ($$render) => {
                          if (strict_equals(typeof axis(), "function")) $$render(consequent_7);
                          else $$render(alternate_5, false);
                        }),
                        "if",
                        LineChart,
                        422,
                        8
                      );
                    }
                    var node_34 = sibling(node_19, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_34, {
                          get disabled() {
                            return get($03);
                          },
                          full: true,
                          children: wrap_snippet(LineChart, ($$anchor5, $$slotProps2) => {
                            var fragment_25 = root_252();
                            var node_35 = first_child(fragment_25);
                            {
                              var consequent_13 = ($$anchor6) => {
                                var fragment_26 = comment();
                                var node_36 = first_child(fragment_26);
                                add_svelte_meta(() => snippet(node_36, points, () => get(snippetProps)), "render", LineChart, 449, 12);
                                append($$anchor6, fragment_26);
                              };
                              var alternate_6 = ($$anchor6) => {
                                var fragment_27 = comment();
                                var node_37 = first_child(fragment_27);
                                {
                                  var consequent_14 = ($$anchor7) => {
                                    var fragment_28 = comment();
                                    var node_38 = first_child(fragment_28);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_38, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_29 = comment();
                                        var node_39 = first_child(fragment_29);
                                        {
                                          let $04 = user_derived(() => getPointsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Points_default(node_39, spread_props(() => get($04))), "component", LineChart, 452, 14, { componentTag: "Points" });
                                        }
                                        append($$anchor8, fragment_29);
                                      }),
                                      "each",
                                      LineChart,
                                      451,
                                      12
                                    );
                                    append($$anchor7, fragment_28);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_37,
                                      ($$render) => {
                                        if (points()) $$render(consequent_14);
                                      },
                                      true
                                    ),
                                    "if",
                                    LineChart,
                                    450,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_27);
                              };
                              add_svelte_meta(
                                () => if_block(node_35, ($$render) => {
                                  if (strict_equals(typeof points(), "function")) $$render(consequent_13);
                                  else $$render(alternate_6, false);
                                }),
                                "if",
                                LineChart,
                                448,
                                10
                              );
                            }
                            var node_40 = sibling(node_35, 2);
                            {
                              var consequent_15 = ($$anchor6) => {
                                var fragment_30 = comment();
                                var node_41 = first_child(fragment_30);
                                add_svelte_meta(() => snippet(node_41, labels, () => get(snippetProps)), "render", LineChart, 457, 12);
                                append($$anchor6, fragment_30);
                              };
                              var alternate_7 = ($$anchor6) => {
                                var fragment_31 = comment();
                                var node_42 = first_child(fragment_31);
                                {
                                  var consequent_16 = ($$anchor7) => {
                                    var fragment_32 = comment();
                                    var node_43 = first_child(fragment_32);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_43, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_33 = comment();
                                        var node_44 = first_child(fragment_33);
                                        {
                                          let $04 = user_derived(() => getLabelsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Labels_default(node_44, spread_props(() => get($04))), "component", LineChart, 460, 14, { componentTag: "Labels" });
                                        }
                                        append($$anchor8, fragment_33);
                                      }),
                                      "each",
                                      LineChart,
                                      459,
                                      12
                                    );
                                    append($$anchor7, fragment_32);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_42,
                                      ($$render) => {
                                        if (labels()) $$render(consequent_16);
                                      },
                                      true
                                    ),
                                    "if",
                                    LineChart,
                                    458,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_31);
                              };
                              add_svelte_meta(
                                () => if_block(node_40, ($$render) => {
                                  if (strict_equals(typeof labels(), "function")) $$render(consequent_15);
                                  else $$render(alternate_7, false);
                                }),
                                "if",
                                LineChart,
                                456,
                                10
                              );
                            }
                            var node_45 = sibling(node_40, 2);
                            {
                              var consequent_17 = ($$anchor6) => {
                                var fragment_34 = comment();
                                var node_46 = first_child(fragment_34);
                                add_svelte_meta(() => snippet(node_46, highlight, () => get(snippetProps)), "render", LineChart, 465, 12);
                                append($$anchor6, fragment_34);
                              };
                              var alternate_8 = ($$anchor6) => {
                                var fragment_35 = comment();
                                var node_47 = first_child(fragment_35);
                                {
                                  var consequent_18 = ($$anchor7) => {
                                    var fragment_36 = comment();
                                    var node_48 = first_child(fragment_36);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_48, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_37 = comment();
                                        var node_49 = first_child(fragment_37);
                                        {
                                          let $04 = user_derived(() => getHighlightProps(get(s3), get(i)));
                                          add_svelte_meta(() => Highlight_default(node_49, spread_props(() => get($04))), "component", LineChart, 468, 14, { componentTag: "Highlight" });
                                        }
                                        append($$anchor8, fragment_37);
                                      }),
                                      "each",
                                      LineChart,
                                      467,
                                      12
                                    );
                                    append($$anchor7, fragment_36);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_47,
                                      ($$render) => {
                                        if (highlight()) $$render(consequent_18);
                                      },
                                      true
                                    ),
                                    "if",
                                    LineChart,
                                    466,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_35);
                              };
                              add_svelte_meta(
                                () => if_block(node_45, ($$render) => {
                                  if (strict_equals(typeof highlight(), "function")) $$render(consequent_17);
                                  else $$render(alternate_8, false);
                                }),
                                "if",
                                LineChart,
                                464,
                                10
                              );
                            }
                            var node_50 = sibling(node_45, 2);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_50, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "above",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              LineChart,
                              472,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            append($$anchor5, fragment_25);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        LineChart,
                        447,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              LineChart,
              386,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_51 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_51, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", LineChart, 481, 6);
          var node_52 = sibling(node_51, 2);
          {
            var consequent_19 = ($$anchor4) => {
              var fragment_38 = comment();
              var node_53 = first_child(fragment_38);
              add_svelte_meta(() => snippet(node_53, legend, () => get(snippetProps)), "render", LineChart, 484, 8);
              append($$anchor4, fragment_38);
            };
            var alternate_9 = ($$anchor4) => {
              var fragment_39 = comment();
              var node_54 = first_child(fragment_39);
              {
                var consequent_20 = ($$anchor5) => {
                  var fragment_40 = comment();
                  var node_55 = first_child(fragment_40);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_55, spread_props(() => get($02))), "component", LineChart, 486, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_40);
                };
                add_svelte_meta(
                  () => if_block(
                    node_54,
                    ($$render) => {
                      if (legend()) $$render(consequent_20);
                    },
                    true
                  ),
                  "if",
                  LineChart,
                  485,
                  6
                );
              }
              append($$anchor4, fragment_39);
            };
            add_svelte_meta(
              () => if_block(node_52, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_19);
                else $$render(alternate_9, false);
              }),
              "if",
              LineChart,
              483,
              6
            );
          }
          var node_56 = sibling(node_52, 2);
          {
            var consequent_21 = ($$anchor4) => {
              var fragment_41 = comment();
              var node_57 = first_child(fragment_41);
              add_svelte_meta(() => snippet(node_57, tooltip, () => get(snippetProps)), "render", LineChart, 490, 8);
              append($$anchor4, fragment_41);
            };
            var alternate_10 = ($$anchor4) => {
              var fragment_42 = comment();
              var node_58 = first_child(fragment_42);
              {
                var consequent_22 = ($$anchor5) => {
                  var fragment_43 = comment();
                  var node_59 = first_child(fragment_43);
                  add_svelte_meta(
                    () => DefaultTooltip_default(node_59, {
                      get tooltipProps() {
                        return props().tooltip;
                      },
                      get seriesState() {
                        return seriesState;
                      },
                      canHaveTotal: true
                    }),
                    "component",
                    LineChart,
                    492,
                    8,
                    { componentTag: "DefaultTooltip" }
                  );
                  append($$anchor5, fragment_43);
                };
                add_svelte_meta(
                  () => if_block(
                    node_58,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_22);
                    },
                    true
                  ),
                  "if",
                  LineChart,
                  491,
                  6
                );
              }
              append($$anchor4, fragment_42);
            };
            add_svelte_meta(
              () => if_block(node_56, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_21);
                else $$render(alternate_10, false);
              }),
              "if",
              LineChart,
              489,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_11, false);
          }),
          "if",
          LineChart,
          381,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => $$props.y ?? get(series).map((s3) => s3.value ?? s3.key));
    let $1 = user_derived(() => radial2() ? void 0 : defaultChartPadding(axis(), legend()));
    let $2 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      mode: "quadtree-x",
      onclick: onTooltipClick(),
      debug: debug(),
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    let $3 = user_derived(() => brush() && (strict_equals(brush(), true) || equals(brush().mode, void 0) || strict_equals(brush().mode, "integrated")) ? {
      axis: "x",
      resetOnEnd: true,
      xDomain: xDomain(),
      ...get(brushProps),
      onBrushEnd: (e) => {
        xDomain(e.xDomain);
        get(brushProps).onBrushEnd?.(e);
      }
    } : false);
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(chartData);
          },
          get x() {
            return $$props.x;
          },
          get xDomain() {
            return xDomain();
          },
          get xScale() {
            return get(xScale);
          },
          get y() {
            return get($0);
          },
          yBaseline: 0,
          yNice: true,
          get radial() {
            return radial2();
          },
          get padding() {
            return get($1);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($2);
          },
          get brush() {
            return get($3);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      LineChart,
      331,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LineChart = hmr(LineChart, () => LineChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = LineChart[HMR].source;
    set(LineChart[HMR].source, module2.default[HMR].original);
  });
}
var LineChart_default = LineChart;

// node_modules/layerchart/dist/components/Pie.svelte
Pie[FILENAME] = "node_modules/layerchart/dist/components/Pie.svelte";
function Pie($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pie);
  let range4 = prop($$props, "range", 19, () => [0, 360]), cornerRadius = prop($$props, "cornerRadius", 3, 0), padAngle = prop($$props, "padAngle", 3, 0), offset = prop($$props, "offset", 3, 0);
  const ctx = getChartContext();
  const endAngle = tag(user_derived(() => $$props.endAngle ?? degreesToRadians(ctx.config.xRange ? max(ctx.xRange) : max(range4()))), "endAngle");
  const motionEndAngle = createMotion(0, () => get(endAngle), $$props.motion);
  const pie = tag(
    user_derived(() => {
      let _pie = pie_default().startAngle($$props.startAngle ?? degreesToRadians(ctx.config.xRange ? min(ctx.xRange) : min(range4()))).endAngle(motionEndAngle.current).padAngle(padAngle()).value(ctx.x);
      if (strict_equals($$props.sort, null)) {
        _pie = _pie.sort(null);
      } else if ($$props.sort) {
        _pie = _pie.sort($$props.sort);
      }
      return _pie;
    }),
    "pie"
  );
  const arcs = tag(user_derived(() => get(pie)($$props.data ?? (Array.isArray(ctx.data) ? ctx.data : []))), "arcs");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children, () => ({ arcs: get(arcs) })), "render", Pie, 139, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(
        () => each(node_2, 17, () => get(arcs), index, ($$anchor3, arc) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            let $0 = user_derived(() => layerClass("pie-arc"));
            let $1 = user_derived(() => ctx.config.c ? ctx.cScale?.(ctx.c(get(arc).data)) : null);
            add_svelte_meta(
              () => Arc_default(node_3, {
                get class() {
                  return get($0);
                },
                get startAngle() {
                  return get(arc).startAngle;
                },
                get endAngle() {
                  return get(arc).endAngle;
                },
                get padAngle() {
                  return get(arc).padAngle;
                },
                get innerRadius() {
                  return $$props.innerRadius;
                },
                get outerRadius() {
                  return $$props.outerRadius;
                },
                get cornerRadius() {
                  return cornerRadius();
                },
                get offset() {
                  return offset();
                },
                get fill() {
                  return get($1);
                },
                get data() {
                  return get(arc).data;
                },
                get tooltipContext() {
                  return $$props.tooltipContext;
                }
              }),
              "component",
              Pie,
              142,
              4,
              { componentTag: "Arc" }
            );
          }
          append($$anchor3, fragment_3);
        }),
        "each",
        Pie,
        141,
        2
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pie,
      138,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pie = hmr(Pie, () => Pie[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Pie[HMR].source;
    set(Pie[HMR].source, module2.default[HMR].original);
  });
}
var Pie_default = Pie;

// node_modules/layerchart/dist/components/charts/PieChart.svelte
PieChart[FILENAME] = "node_modules/layerchart/dist/components/charts/PieChart.svelte";
var root_49 = add_locations(from_html(`<!> <!> <!>`, 1), PieChart[FILENAME], []);
var root_315 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), PieChart[FILENAME], []);
function PieChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, PieChart);
  let data = prop($$props, "data", 19, () => []), key2 = prop($$props, "key", 3, "key"), label = prop($$props, "label", 3, "label"), value2 = prop($$props, "value", 3, "value"), range4 = prop($$props, "range", 19, () => [0, 360]), c3 = prop($$props, "c", 19, key2), cornerRadius = prop($$props, "cornerRadius", 3, 0), padAngle = prop($$props, "padAngle", 3, 0), placement = prop($$props, "placement", 3, "center"), center2 = prop($$props, "center", 19, () => strict_equals(placement(), "center")), legend = prop($$props, "legend", 3, false), onArcClick = prop($$props, "onArcClick", 3, () => {
  }), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), tooltip = prop($$props, "tooltip", 3, true), context = prop($$props, "context", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "key",
      "label",
      "value",
      "range",
      "c",
      "innerRadius",
      "outerRadius",
      "cornerRadius",
      "padAngle",
      "placement",
      "maxValue",
      "center",
      "series",
      "legend",
      "onArcClick",
      "onTooltipClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "tooltip",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "pie",
      "arc",
      "context"
    ],
    "restProps"
  );
  const series = tag(user_derived(() => strict_equals($$props.series, void 0) ? [{ key: "default", value: value2() }] : $$props.series), "series");
  const keyAccessor = tag(user_derived(() => accessor(key2())), "keyAccessor");
  const labelAccessor = tag(user_derived(() => accessor(label())), "labelAccessor");
  const valueAccessor = tag(user_derived(() => accessor(value2())), "valueAccessor");
  const cAccessor = tag(user_derived(() => accessor(c3())), "cAccessor");
  const allSeriesData = tag(user_derived(() => get(series).flatMap((s3) => s3.data?.map((d) => ({ seriesKey: s3.key, ...d }))).filter((d) => d)), "allSeriesData");
  const chartData = tag(user_derived(() => get(allSeriesData).length ? get(allSeriesData) : chartDataArray(data())), "chartData");
  const seriesColors = tag(user_derived(() => get(series).map((s3) => s3.color).filter((d) => equals(d, null, false))), "seriesColors");
  const highlightKey = new HighlightKey();
  const selectedKeys = new SelectionState();
  const selectedSeries = new SelectionState();
  const visibleData = tag(
    user_derived(() => get(chartData).filter((d) => {
      const dataKey = get(keyAccessor)(d);
      return selectedKeys.isEmpty() || selectedKeys.isSelected(dataKey);
    })),
    "visibleData"
  );
  const visibleSeries = tag(user_derived(() => get(series).filter((s3) => selectedSeries.isEmpty() || selectedSeries.isSelected(s3.key))), "visibleSeries");
  function getLegendProps() {
    return {
      tickFormat: (tick2) => {
        const item = get(chartData).find((d) => strict_equals(get(keyAccessor)(d), tick2));
        return item ? get(labelAccessor)(item) ?? tick2 : tick2;
      },
      placement: "bottom",
      variant: "swatches",
      onclick: (e, item) => {
        selectedKeys.toggle(item.value);
      },
      onpointerenter: (e, item) => assign(highlightKey, "current", item.value, "node_modules/​layerchart/​dist/​components/​charts/​PieChart.svelte:288:36"),
      onpointerleave: (e) => assign(highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​PieChart.svelte:289:30"),
      ...props().legend,
      ...strict_equals(typeof legend(), "object") ? legend() : null,
      classes: {
        item: (item) => get(visibleData).length && !get(visibleData).some((d) => strict_equals(get(keyAccessor)(d), item.value)) ? "opacity-50" : "",
        ...props().legend?.classes,
        ...strict_equals(typeof legend(), "object") ? legend().classes : null
      }
    };
  }
  function getGroupProps() {
    if (!context()) return {};
    return {
      x: strict_equals(placement(), "left") ? context().height / 2 : strict_equals(placement(), "right") ? context().width - context().height / 2 : void 0,
      center: ["left", "right"].includes(placement()) ? "y" : void 0,
      ...props().group
    };
  }
  function getPieProps(s3, i) {
    return {
      data: s3.data,
      range: range4(),
      innerRadius: $$props.innerRadius,
      outerRadius: $$props.outerRadius,
      cornerRadius: cornerRadius(),
      padAngle: padAngle(),
      ...props().pie
    };
  }
  function getArcProps(s3, seriesIndex, arc, arcIndex) {
    if (!context()) return {};
    const arcDataProps = "props" in arc.data && strict_equals(typeof arc.data.props, "object") ? arc.data.props : {};
    return {
      startAngle: arc.startAngle,
      endAngle: arc.endAngle,
      outerRadius: get(visibleSeries).length > 1 ? seriesIndex * ($$props.outerRadius ?? 0) : $$props.outerRadius,
      innerRadius: $$props.innerRadius,
      cornerRadius: cornerRadius(),
      padAngle: padAngle(),
      fill: context().cScale?.(context().c(arc.data)),
      data: arc.data,
      tooltipContext: context().tooltip,
      onclick: (e) => {
        onArcClick()(e, { data: arc.data, series: s3 });
        onTooltipClick()(e, { data: arc.data });
      },
      class: cls("transition-opacity", highlightKey.current && strict_equals(highlightKey.current, get(keyAccessor)(arc.data), false) && "opacity-50"),
      ...props().arc,
      ...s3.props,
      ...arcDataProps
    };
  }
  if (profile()) {
    console.time("PieChart render");
    onMount(() => {
      console.timeEnd("PieChart render");
    });
  }
  setTooltipMetaContext({
    type: "pie",
    get color() {
      return c3();
    },
    get value() {
      return value2();
    },
    get label() {
      return label();
    },
    get key() {
      return key2();
    },
    get visibleSeries() {
      return get(visibleSeries);
    }
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(PieChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          label: get(labelAccessor),
          key: get(keyAccessor),
          value: get(valueAccessor),
          color: get(cAccessor),
          context: context2(),
          series: get(series),
          visibleSeries: get(visibleSeries),
          visibleData: get(visibleData),
          highlightKey: highlightKey.current,
          setHighlightKey: highlightKey.set,
          getLegendProps,
          getGroupProps
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", PieChart, 432, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_5 = ($$anchor3) => {
          var fragment_3 = root_315();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", PieChart, 434, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get center() {
                    return center2();
                  },
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(PieChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_49();
                    var node_5 = first_child(fragment_4);
                    add_svelte_meta(() => snippet(node_5, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", PieChart, 442, 8);
                    var node_6 = sibling(node_5, 2);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_7 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_7, () => $$props.marks, () => get(snippetProps)), "render", PieChart, 445, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate_2 = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_8 = first_child(fragment_6);
                        {
                          let $03 = user_derived(getGroupProps);
                          add_svelte_meta(
                            () => Group_default(node_8, spread_props(() => get($03), {
                              children: wrap_snippet(PieChart, ($$anchor6, $$slotProps2) => {
                                var fragment_7 = comment();
                                var node_9 = first_child(fragment_7);
                                validate_each_keys(() => get(visibleSeries), (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_9, 19, () => get(visibleSeries), (s3) => s3.key, ($$anchor7, s3, seriesIdx) => {
                                    var fragment_8 = comment();
                                    var node_10 = first_child(fragment_8);
                                    {
                                      var consequent_2 = ($$anchor8) => {
                                        var fragment_9 = comment();
                                        var node_11 = first_child(fragment_9);
                                        {
                                          let $04 = user_derived(() => ({
                                            ...get(snippetProps),
                                            props: getPieProps(get(s3), get(seriesIdx)),
                                            index: get(seriesIdx)
                                          }));
                                          add_svelte_meta(() => snippet(node_11, () => $$props.pie, () => get($04)), "render", PieChart, 450, 16);
                                        }
                                        append($$anchor8, fragment_9);
                                      };
                                      var alternate_1 = ($$anchor8) => {
                                        var fragment_10 = comment();
                                        var node_12 = first_child(fragment_10);
                                        {
                                          const children2 = wrap_snippet(PieChart, function($$anchor9, $$arg02) {
                                            validate_snippet_args(...arguments);
                                            let arcs = () => $$arg02?.().arcs;
                                            arcs();
                                            var fragment_11 = comment();
                                            var node_13 = first_child(fragment_11);
                                            validate_each_keys(arcs, (arcData, arcIdx) => `${get(seriesIdx)}-${arcIdx}`);
                                            add_svelte_meta(
                                              () => each(node_13, 19, arcs, (arcData, arcIdx) => `${get(seriesIdx)}-${arcIdx}`, ($$anchor10, arcData, arcIdx) => {
                                                var fragment_12 = comment();
                                                const arcProps = tag(user_derived(() => getArcProps(get(s3), get(seriesIdx), get(arcData), get(arcIdx))), "arcProps");
                                                get(arcProps);
                                                var node_14 = first_child(fragment_12);
                                                {
                                                  var consequent_3 = ($$anchor11) => {
                                                    var fragment_13 = comment();
                                                    var node_15 = first_child(fragment_13);
                                                    {
                                                      let $05 = user_derived(() => ({
                                                        ...get(snippetProps),
                                                        props: get(arcProps),
                                                        index: get(arcIdx),
                                                        seriesIndex: get(seriesIdx)
                                                      }));
                                                      add_svelte_meta(() => snippet(node_15, () => $$props.arc, () => get($05)), "render", PieChart, 461, 24);
                                                    }
                                                    append($$anchor11, fragment_13);
                                                  };
                                                  var alternate = ($$anchor11) => {
                                                    var fragment_14 = comment();
                                                    var node_16 = first_child(fragment_14);
                                                    add_svelte_meta(() => Arc_default(node_16, spread_props(() => get(arcProps))), "component", PieChart, 468, 24, { componentTag: "Arc" });
                                                    append($$anchor11, fragment_14);
                                                  };
                                                  add_svelte_meta(
                                                    () => if_block(node_14, ($$render) => {
                                                      if (strict_equals(typeof $$props.arc, "function")) $$render(consequent_3);
                                                      else $$render(alternate, false);
                                                    }),
                                                    "if",
                                                    PieChart,
                                                    460,
                                                    22
                                                  );
                                                }
                                                append($$anchor10, fragment_12);
                                              }),
                                              "each",
                                              PieChart,
                                              458,
                                              20
                                            );
                                            append($$anchor9, fragment_11);
                                          });
                                          let $04 = user_derived(() => getPieProps(get(s3), get(seriesIdx)));
                                          add_svelte_meta(() => Pie_default(node_12, spread_props(() => get($04), { children: children2, $$slots: { default: true } })), "component", PieChart, 456, 16, { componentTag: "Pie" });
                                        }
                                        append($$anchor8, fragment_10);
                                      };
                                      add_svelte_meta(
                                        () => if_block(node_10, ($$render) => {
                                          if (strict_equals(typeof $$props.pie, "function")) $$render(consequent_2);
                                          else $$render(alternate_1, false);
                                        }),
                                        "if",
                                        PieChart,
                                        449,
                                        14
                                      );
                                    }
                                    append($$anchor7, fragment_8);
                                  }),
                                  "each",
                                  PieChart,
                                  448,
                                  12
                                );
                                append($$anchor6, fragment_7);
                              }),
                              $$slots: { default: true }
                            })),
                            "component",
                            PieChart,
                            447,
                            10,
                            { componentTag: "Group" }
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_6, ($$render) => {
                          if (strict_equals(typeof $$props.marks, "function")) $$render(consequent_1);
                          else $$render(alternate_2, false);
                        }),
                        "if",
                        PieChart,
                        444,
                        8
                      );
                    }
                    var node_17 = sibling(node_6, 2);
                    add_svelte_meta(() => snippet(node_17, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", PieChart, 478, 8);
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              PieChart,
              436,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_18 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_18, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", PieChart, 481, 6);
          var node_19 = sibling(node_18, 2);
          {
            var consequent_4 = ($$anchor4) => {
              var fragment_15 = comment();
              var node_20 = first_child(fragment_15);
              add_svelte_meta(() => snippet(node_20, legend, () => get(snippetProps)), "render", PieChart, 484, 8);
              append($$anchor4, fragment_15);
            };
            var alternate_3 = ($$anchor4) => {
              var fragment_16 = comment();
              var node_21 = first_child(fragment_16);
              {
                var consequent_5 = ($$anchor5) => {
                  var fragment_17 = comment();
                  var node_22 = first_child(fragment_17);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_22, spread_props(() => get($02))), "component", PieChart, 486, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_17);
                };
                add_svelte_meta(
                  () => if_block(
                    node_21,
                    ($$render) => {
                      if (legend()) $$render(consequent_5);
                    },
                    true
                  ),
                  "if",
                  PieChart,
                  485,
                  6
                );
              }
              append($$anchor4, fragment_16);
            };
            add_svelte_meta(
              () => if_block(node_19, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_4);
                else $$render(alternate_3, false);
              }),
              "if",
              PieChart,
              483,
              6
            );
          }
          var node_23 = sibling(node_19, 2);
          {
            var consequent_6 = ($$anchor4) => {
              var fragment_18 = comment();
              var node_24 = first_child(fragment_18);
              add_svelte_meta(() => snippet(node_24, tooltip, () => get(snippetProps)), "render", PieChart, 490, 8);
              append($$anchor4, fragment_18);
            };
            var alternate_4 = ($$anchor4) => {
              var fragment_19 = comment();
              var node_25 = first_child(fragment_19);
              {
                var consequent_7 = ($$anchor5) => {
                  var fragment_20 = comment();
                  var node_26 = first_child(fragment_20);
                  {
                    const children2 = wrap_snippet(PieChart, function($$anchor6, $$arg02) {
                      validate_snippet_args(...arguments);
                      let data2 = () => $$arg02?.().data;
                      data2();
                      var fragment_21 = comment();
                      var node_27 = first_child(fragment_21);
                      add_svelte_meta(
                        () => component(node_27, () => TooltipList_default, ($$anchor7, Tooltip_List) => {
                          Tooltip_List($$anchor7, spread_props(() => props().tooltip?.list, {
                            children: wrap_snippet(PieChart, ($$anchor8, $$slotProps) => {
                              var fragment_22 = comment();
                              var node_28 = first_child(fragment_22);
                              {
                                let $02 = user_derived(() => get(labelAccessor)(data2()) || get(keyAccessor)(data2()));
                                let $12 = user_derived(() => get(valueAccessor)(data2()));
                                let $22 = user_derived(() => context2().cScale?.(context2().c(data2())));
                                add_svelte_meta(
                                  () => component(node_28, () => TooltipItem_default, ($$anchor9, Tooltip_Item) => {
                                    Tooltip_Item($$anchor9, spread_props(
                                      {
                                        get label() {
                                          return get($02);
                                        },
                                        get value() {
                                          return get($12);
                                        },
                                        get color() {
                                          return get($22);
                                        },
                                        get format() {
                                          return format;
                                        },
                                        onpointerenter: () => assign(highlightKey, "current", get(keyAccessor)(data2()), "node_modules/​layerchart/​dist/​components/​charts/​PieChart.svelte:500:39"),
                                        onpointerleave: () => assign(highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​PieChart.svelte:501:39")
                                      },
                                      () => props().tooltip?.item
                                    ));
                                  }),
                                  "component",
                                  PieChart,
                                  495,
                                  14,
                                  { componentTag: "Tooltip.Item" }
                                );
                              }
                              append($$anchor8, fragment_22);
                            }),
                            $$slots: { default: true }
                          }));
                        }),
                        "component",
                        PieChart,
                        494,
                        12,
                        { componentTag: "Tooltip.List" }
                      );
                      append($$anchor6, fragment_21);
                    });
                    add_svelte_meta(
                      () => component(node_26, () => Tooltip_default, ($$anchor6, Tooltip_Root) => {
                        Tooltip_Root($$anchor6, spread_props(
                          {
                            get context() {
                              return context2();
                            }
                          },
                          () => props().tooltip?.root,
                          { children: children2, $$slots: { default: true } }
                        ));
                      }),
                      "component",
                      PieChart,
                      492,
                      8,
                      { componentTag: "Tooltip.Root" }
                    );
                  }
                  append($$anchor5, fragment_20);
                };
                add_svelte_meta(
                  () => if_block(
                    node_25,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_7);
                    },
                    true
                  ),
                  "if",
                  PieChart,
                  491,
                  6
                );
              }
              append($$anchor4, fragment_19);
            };
            add_svelte_meta(
              () => if_block(node_23, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_6);
                else $$render(alternate_4, false);
              }),
              "if",
              PieChart,
              489,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_5, false);
          }),
          "if",
          PieChart,
          431,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => get(chartData).map(get(keyAccessor)));
    let $1 = user_derived(() => get(seriesColors).length ? get(seriesColors) : strict_equals(c3(), key2(), false) ? get(chartData).map((d) => get(cAccessor)(d)) : [
      "var(--color-primary)",
      "var(--color-secondary)",
      "var(--color-info)",
      "var(--color-success)",
      "var(--color-warning)",
      "var(--color-danger)"
    ]);
    let $2 = user_derived(() => ({ bottom: strict_equals(legend(), true) ? 32 : 0 }));
    let $3 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(visibleData);
          },
          get x() {
            return value2();
          },
          get y() {
            return key2();
          },
          get c() {
            return key2();
          },
          get cDomain() {
            return get($0);
          },
          get cRange() {
            return get($1);
          },
          get padding() {
            return get($2);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($3);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      PieChart,
      391,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PieChart = hmr(PieChart, () => PieChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = PieChart[HMR].source;
    set(PieChart[HMR].source, module2.default[HMR].original);
  });
}
var PieChart_default = PieChart;

// node_modules/layerchart/dist/components/charts/ScatterChart.svelte
ScatterChart[FILENAME] = "node_modules/layerchart/dist/components/charts/ScatterChart.svelte";
var root_88 = add_locations(from_html(`<!> <!> <!> <!>`, 1), ScatterChart[FILENAME], []);
var root_126 = add_locations(from_html(`<!> <!>`, 1), ScatterChart[FILENAME], []);
var root_174 = add_locations(from_html(`<!> <!> <!>`, 1), ScatterChart[FILENAME], []);
var root_234 = add_locations(from_html(`<!> <!> <!>`, 1), ScatterChart[FILENAME], []);
var root_410 = add_locations(from_html(`<!> <!> <!> <!>`, 1), ScatterChart[FILENAME], []);
var root_392 = add_locations(from_html(`<!> <!> <!>`, 1), ScatterChart[FILENAME], []);
var root_372 = add_locations(from_html(`<!> <!>`, 1), ScatterChart[FILENAME], []);
var root_316 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), ScatterChart[FILENAME], []);
function ScatterChart($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ScatterChart);
  let data = prop($$props, "data", 19, () => []), xDomain = prop($$props, "xDomain", 7), yDomain = prop($$props, "yDomain", 7), seriesLayout = prop($$props, "seriesLayout", 3, "overlap"), axis = prop($$props, "axis", 3, true), brush = prop($$props, "brush", 3, false), grid = prop($$props, "grid", 3, true), labels = prop($$props, "labels", 3, false), legend = prop($$props, "legend", 3, false), points = prop($$props, "points", 3, false), rule = prop($$props, "rule", 3, true), tooltip = prop($$props, "tooltip", 3, true), context = prop($$props, "context", 15), onTooltipClick = prop($$props, "onTooltipClick", 3, () => {
  }), props = prop($$props, "props", 19, () => ({})), renderContext = prop($$props, "renderContext", 3, "svg"), profile = prop($$props, "profile", 3, false), debug = prop($$props, "debug", 3, false), highlight = prop($$props, "highlight", 3, true), annotations = prop($$props, "annotations", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "x",
      "y",
      "xDomain",
      "yDomain",
      "series",
      "seriesLayout",
      "axis",
      "brush",
      "grid",
      "labels",
      "legend",
      "points",
      "rule",
      "tooltip",
      "context",
      "onTooltipClick",
      "props",
      "renderContext",
      "profile",
      "debug",
      "xScale",
      "yScale",
      "children",
      "aboveContext",
      "belowContext",
      "belowMarks",
      "aboveMarks",
      "marks",
      "highlight",
      "annotations"
    ],
    "restProps"
  );
  const series = tag(
    user_derived(() => strict_equals($$props.series, void 0) ? [{ key: "default", data: chartDataArray(data()) }] : $$props.series),
    "series"
  );
  const seriesState = new SeriesState(() => get(series));
  const xScale = tag(user_derived(() => $$props.xScale ?? (accessor($$props.x)(chartDataArray(data())[0]) instanceof Date ? time() : linear2())), "xScale");
  const yScale = tag(user_derived(() => $$props.yScale ?? (accessor($$props.y)(chartDataArray(data())[0]) instanceof Date ? time() : linear2())), "yScale");
  const chartData = tag(user_derived(() => seriesState.visibleSeries.flatMap((s3) => s3.data?.map((d) => ({ seriesKey: s3.key, ...d }))).filter((d) => d)), "chartData");
  function getPointsProps(s3, i) {
    return {
      data: s3.data,
      fill: s3.color,
      ...props().points,
      ...s3.props,
      class: cls("transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().points?.class, s3.props?.class)
    };
  }
  function getLabelsProps(s3, i) {
    return {
      data: s3.data,
      ...props().labels,
      ...strict_equals(typeof labels(), "object") ? labels() : null,
      class: cls("stroke-surface-200 transition-opacity", seriesState.highlightKey.current && strict_equals(seriesState.highlightKey.current, s3.key, false) && "opacity-10", props().labels?.class, strict_equals(typeof labels(), "object") && labels().class)
    };
  }
  function getLegendProps() {
    return createLegendProps({
      seriesState,
      props: {
        ...props().legend,
        ...strict_equals(typeof legend(), "object") ? legend() : null
      }
    });
  }
  function getGridProps() {
    return {
      x: true,
      y: true,
      ...strict_equals(typeof grid(), "object") ? grid() : null,
      ...props().grid
    };
  }
  const activeSeries = tag(
    user_derived(() => {
      if (!context()?.tooltip?.data) return null;
      return get(series).find((s3) => strict_equals(s3.key, context()?.tooltip.data?.seriesKey)) ?? get(series)[0];
    }),
    "activeSeries"
  );
  function getHighlightProps() {
    return {
      lines: true,
      axis: "both",
      ...props().highlight,
      points: {
        ...get(activeSeries)?.color && { fill: get(activeSeries).color },
        ...strict_equals(typeof props().highlight?.points, "object") ? props().highlight.points : null
      }
    };
  }
  function getAxisProps(axisDirection) {
    if (strict_equals(axisDirection, "y")) {
      return {
        placement: "left",
        ...strict_equals(typeof axis(), "object") ? axis() : null,
        ...props().yAxis
      };
    }
    return {
      placement: "bottom",
      ...strict_equals(typeof axis(), "object") ? axis() : null,
      ...props().xAxis
    };
  }
  function getRuleProps() {
    return {
      x: 0,
      y: 0,
      ...strict_equals(typeof rule(), "object") ? rule() : null,
      ...props().rule
    };
  }
  const brushProps = tag(
    user_derived(() => ({
      ...strict_equals(typeof brush(), "object") ? brush() : null,
      ...props().brush
    })),
    "brushProps"
  );
  if (profile()) {
    console.time("ScatterChart render");
    onMount(() => {
      console.timeEnd("ScatterChart render");
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(ScatterChart, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let context2 = () => $$arg0?.().context;
      context2();
      var fragment_1 = comment();
      const snippetProps = tag(
        user_derived(() => ({
          context: context2(),
          series: get(series),
          visibleSeries: seriesState.visibleSeries,
          getLabelsProps,
          getPointsProps,
          getLegendProps,
          getHighlightProps,
          getAxisProps,
          getRuleProps,
          highlightKey: seriesState.highlightKey.current,
          setHighlightKey: seriesState.highlightKey.set
        })),
        "snippetProps"
      );
      get(snippetProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => get(snippetProps)), "render", ScatterChart, 293, 6);
          append($$anchor3, fragment_2);
        };
        var alternate_9 = ($$anchor3) => {
          var fragment_3 = root_316();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.belowContext ?? noop, () => get(snippetProps)), "render", ScatterChart, 295, 6);
          var node_4 = sibling(node_3, 2);
          {
            let $02 = user_derived(() => asAny(strict_equals(renderContext(), "canvas") ? props().canvas : props().svg));
            add_svelte_meta(
              () => Layer_default(node_4, spread_props(
                {
                  get type() {
                    return renderContext();
                  }
                },
                () => get($02),
                {
                  get debug() {
                    return debug();
                  },
                  children: wrap_snippet(ScatterChart, ($$anchor4, $$slotProps) => {
                    var fragment_4 = root_410();
                    var node_5 = first_child(fragment_4);
                    {
                      var consequent_1 = ($$anchor5) => {
                        var fragment_5 = comment();
                        var node_6 = first_child(fragment_5);
                        add_svelte_meta(() => snippet(node_6, grid, () => get(snippetProps)), "render", ScatterChart, 302, 10);
                        append($$anchor5, fragment_5);
                      };
                      var alternate = ($$anchor5) => {
                        var fragment_6 = comment();
                        var node_7 = first_child(fragment_6);
                        {
                          var consequent_2 = ($$anchor6) => {
                            var fragment_7 = comment();
                            var node_8 = first_child(fragment_7);
                            {
                              let $03 = user_derived(getGridProps);
                              add_svelte_meta(() => Grid_default(node_8, spread_props(() => get($03))), "component", ScatterChart, 304, 10, { componentTag: "Grid" });
                            }
                            append($$anchor6, fragment_7);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_7,
                              ($$render) => {
                                if (grid()) $$render(consequent_2);
                              },
                              true
                            ),
                            "if",
                            ScatterChart,
                            303,
                            8
                          );
                        }
                        append($$anchor5, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_5, ($$render) => {
                          if (strict_equals(typeof grid(), "function")) $$render(consequent_1);
                          else $$render(alternate, false);
                        }),
                        "if",
                        ScatterChart,
                        301,
                        8
                      );
                    }
                    var node_9 = sibling(node_5, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_9, {
                          get disabled() {
                            return get($03);
                          },
                          children: wrap_snippet(ScatterChart, ($$anchor5, $$slotProps2) => {
                            var fragment_8 = root_88();
                            var node_10 = first_child(fragment_8);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_10, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "below",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              ScatterChart,
                              308,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            var node_11 = sibling(node_10, 2);
                            add_svelte_meta(() => snippet(node_11, () => $$props.belowMarks ?? noop, () => get(snippetProps)), "render", ScatterChart, 315, 10);
                            var node_12 = sibling(node_11, 2);
                            {
                              var consequent_3 = ($$anchor6) => {
                                var fragment_9 = comment();
                                var node_13 = first_child(fragment_9);
                                add_svelte_meta(() => snippet(node_13, () => $$props.marks, () => get(snippetProps)), "render", ScatterChart, 318, 12);
                                append($$anchor6, fragment_9);
                              };
                              var alternate_1 = ($$anchor6) => {
                                var fragment_10 = comment();
                                var node_14 = first_child(fragment_10);
                                validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                add_svelte_meta(
                                  () => each(node_14, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor7, s3, i) => {
                                    var fragment_11 = comment();
                                    var node_15 = first_child(fragment_11);
                                    {
                                      let $04 = user_derived(() => getPointsProps(get(s3), get(i)));
                                      add_svelte_meta(() => Points_default(node_15, spread_props(() => get($04))), "component", ScatterChart, 321, 14, { componentTag: "Points" });
                                    }
                                    append($$anchor7, fragment_11);
                                  }),
                                  "each",
                                  ScatterChart,
                                  320,
                                  12
                                );
                                append($$anchor6, fragment_10);
                              };
                              add_svelte_meta(
                                () => if_block(node_12, ($$render) => {
                                  if (strict_equals(typeof $$props.marks, "function")) $$render(consequent_3);
                                  else $$render(alternate_1, false);
                                }),
                                "if",
                                ScatterChart,
                                317,
                                10
                              );
                            }
                            var node_16 = sibling(node_12, 2);
                            add_svelte_meta(() => snippet(node_16, () => $$props.aboveMarks ?? noop, () => get(snippetProps)), "render", ScatterChart, 325, 10);
                            append($$anchor5, fragment_8);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        ScatterChart,
                        307,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    var node_17 = sibling(node_9, 2);
                    {
                      var consequent_6 = ($$anchor5) => {
                        var fragment_12 = root_126();
                        var node_18 = first_child(fragment_12);
                        add_svelte_meta(() => snippet(node_18, axis, () => get(snippetProps)), "render", ScatterChart, 329, 10);
                        var node_19 = sibling(node_18, 2);
                        {
                          var consequent_4 = ($$anchor6) => {
                            var fragment_13 = comment();
                            var node_20 = first_child(fragment_13);
                            add_svelte_meta(() => snippet(node_20, rule, () => get(snippetProps)), "render", ScatterChart, 331, 12);
                            append($$anchor6, fragment_13);
                          };
                          var alternate_2 = ($$anchor6) => {
                            var fragment_14 = comment();
                            var node_21 = first_child(fragment_14);
                            {
                              var consequent_5 = ($$anchor7) => {
                                var fragment_15 = comment();
                                var node_22 = first_child(fragment_15);
                                {
                                  let $03 = user_derived(getRuleProps);
                                  add_svelte_meta(() => Rule_default(node_22, spread_props(() => get($03))), "component", ScatterChart, 333, 12, { componentTag: "Rule" });
                                }
                                append($$anchor7, fragment_15);
                              };
                              add_svelte_meta(
                                () => if_block(
                                  node_21,
                                  ($$render) => {
                                    if (rule()) $$render(consequent_5);
                                  },
                                  true
                                ),
                                "if",
                                ScatterChart,
                                332,
                                10
                              );
                            }
                            append($$anchor6, fragment_14);
                          };
                          add_svelte_meta(
                            () => if_block(node_19, ($$render) => {
                              if (strict_equals(typeof rule(), "function")) $$render(consequent_4);
                              else $$render(alternate_2, false);
                            }),
                            "if",
                            ScatterChart,
                            330,
                            10
                          );
                        }
                        append($$anchor5, fragment_12);
                      };
                      var alternate_4 = ($$anchor5) => {
                        var fragment_16 = comment();
                        var node_23 = first_child(fragment_16);
                        {
                          var consequent_11 = ($$anchor6) => {
                            var fragment_17 = root_174();
                            var node_24 = first_child(fragment_17);
                            {
                              var consequent_7 = ($$anchor7) => {
                                var fragment_18 = comment();
                                var node_25 = first_child(fragment_18);
                                {
                                  let $03 = user_derived(() => getAxisProps("y"));
                                  add_svelte_meta(() => Axis_default(node_25, spread_props(() => get($03))), "component", ScatterChart, 337, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_18);
                              };
                              add_svelte_meta(
                                () => if_block(node_24, ($$render) => {
                                  if (strict_equals(axis(), "x", false)) $$render(consequent_7);
                                }),
                                "if",
                                ScatterChart,
                                336,
                                10
                              );
                            }
                            var node_26 = sibling(node_24, 2);
                            {
                              var consequent_8 = ($$anchor7) => {
                                var fragment_19 = comment();
                                var node_27 = first_child(fragment_19);
                                {
                                  let $03 = user_derived(() => getAxisProps("x"));
                                  add_svelte_meta(() => Axis_default(node_27, spread_props(() => get($03))), "component", ScatterChart, 341, 12, { componentTag: "Axis" });
                                }
                                append($$anchor7, fragment_19);
                              };
                              add_svelte_meta(
                                () => if_block(node_26, ($$render) => {
                                  if (strict_equals(axis(), "y", false)) $$render(consequent_8);
                                }),
                                "if",
                                ScatterChart,
                                340,
                                10
                              );
                            }
                            var node_28 = sibling(node_26, 2);
                            {
                              var consequent_9 = ($$anchor7) => {
                                var fragment_20 = comment();
                                var node_29 = first_child(fragment_20);
                                add_svelte_meta(() => snippet(node_29, rule, () => get(snippetProps)), "render", ScatterChart, 345, 12);
                                append($$anchor7, fragment_20);
                              };
                              var alternate_3 = ($$anchor7) => {
                                var fragment_21 = comment();
                                var node_30 = first_child(fragment_21);
                                {
                                  var consequent_10 = ($$anchor8) => {
                                    var fragment_22 = comment();
                                    var node_31 = first_child(fragment_22);
                                    {
                                      let $03 = user_derived(getRuleProps);
                                      add_svelte_meta(() => Rule_default(node_31, spread_props(() => get($03))), "component", ScatterChart, 347, 12, { componentTag: "Rule" });
                                    }
                                    append($$anchor8, fragment_22);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_30,
                                      ($$render) => {
                                        if (rule()) $$render(consequent_10);
                                      },
                                      true
                                    ),
                                    "if",
                                    ScatterChart,
                                    346,
                                    10
                                  );
                                }
                                append($$anchor7, fragment_21);
                              };
                              add_svelte_meta(
                                () => if_block(node_28, ($$render) => {
                                  if (strict_equals(typeof rule(), "function")) $$render(consequent_9);
                                  else $$render(alternate_3, false);
                                }),
                                "if",
                                ScatterChart,
                                344,
                                10
                              );
                            }
                            append($$anchor6, fragment_17);
                          };
                          add_svelte_meta(
                            () => if_block(
                              node_23,
                              ($$render) => {
                                if (axis()) $$render(consequent_11);
                              },
                              true
                            ),
                            "if",
                            ScatterChart,
                            335,
                            8
                          );
                        }
                        append($$anchor5, fragment_16);
                      };
                      add_svelte_meta(
                        () => if_block(node_17, ($$render) => {
                          if (strict_equals(typeof axis(), "function")) $$render(consequent_6);
                          else $$render(alternate_4, false);
                        }),
                        "if",
                        ScatterChart,
                        328,
                        8
                      );
                    }
                    var node_32 = sibling(node_17, 2);
                    {
                      let $03 = user_derived(() => !brush());
                      add_svelte_meta(
                        () => ChartClipPath_default(node_32, {
                          get disabled() {
                            return get($03);
                          },
                          full: true,
                          children: wrap_snippet(ScatterChart, ($$anchor5, $$slotProps2) => {
                            var fragment_23 = root_234();
                            var node_33 = first_child(fragment_23);
                            {
                              var consequent_12 = ($$anchor6) => {
                                var fragment_24 = comment();
                                var node_34 = first_child(fragment_24);
                                add_svelte_meta(() => snippet(node_34, highlight, () => get(snippetProps)), "render", ScatterChart, 354, 12);
                                append($$anchor6, fragment_24);
                              };
                              var alternate_5 = ($$anchor6) => {
                                var fragment_25 = comment();
                                var node_35 = first_child(fragment_25);
                                {
                                  var consequent_13 = ($$anchor7) => {
                                    var fragment_26 = comment();
                                    var node_36 = first_child(fragment_26);
                                    {
                                      let $04 = user_derived(getHighlightProps);
                                      add_svelte_meta(() => Highlight_default(node_36, spread_props(() => get($04))), "component", ScatterChart, 356, 12, { componentTag: "Highlight" });
                                    }
                                    append($$anchor7, fragment_26);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_35,
                                      ($$render) => {
                                        if (highlight()) $$render(consequent_13);
                                      },
                                      true
                                    ),
                                    "if",
                                    ScatterChart,
                                    355,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_25);
                              };
                              add_svelte_meta(
                                () => if_block(node_33, ($$render) => {
                                  if (strict_equals(typeof highlight(), "function")) $$render(consequent_12);
                                  else $$render(alternate_5, false);
                                }),
                                "if",
                                ScatterChart,
                                353,
                                10
                              );
                            }
                            var node_37 = sibling(node_33, 2);
                            {
                              var consequent_14 = ($$anchor6) => {
                                var fragment_27 = comment();
                                var node_38 = first_child(fragment_27);
                                add_svelte_meta(() => snippet(node_38, labels, () => get(snippetProps)), "render", ScatterChart, 360, 12);
                                append($$anchor6, fragment_27);
                              };
                              var alternate_6 = ($$anchor6) => {
                                var fragment_28 = comment();
                                var node_39 = first_child(fragment_28);
                                {
                                  var consequent_15 = ($$anchor7) => {
                                    var fragment_29 = comment();
                                    var node_40 = first_child(fragment_29);
                                    validate_each_keys(() => seriesState.visibleSeries, (s3) => s3.key);
                                    add_svelte_meta(
                                      () => each(node_40, 19, () => seriesState.visibleSeries, (s3) => s3.key, ($$anchor8, s3, i) => {
                                        var fragment_30 = comment();
                                        var node_41 = first_child(fragment_30);
                                        {
                                          let $04 = user_derived(() => getLabelsProps(get(s3), get(i)));
                                          add_svelte_meta(() => Labels_default(node_41, spread_props(() => get($04))), "component", ScatterChart, 363, 14, { componentTag: "Labels" });
                                        }
                                        append($$anchor8, fragment_30);
                                      }),
                                      "each",
                                      ScatterChart,
                                      362,
                                      12
                                    );
                                    append($$anchor7, fragment_29);
                                  };
                                  add_svelte_meta(
                                    () => if_block(
                                      node_39,
                                      ($$render) => {
                                        if (labels()) $$render(consequent_15);
                                      },
                                      true
                                    ),
                                    "if",
                                    ScatterChart,
                                    361,
                                    10
                                  );
                                }
                                append($$anchor6, fragment_28);
                              };
                              add_svelte_meta(
                                () => if_block(node_37, ($$render) => {
                                  if (strict_equals(typeof labels(), "function")) $$render(consequent_14);
                                  else $$render(alternate_6, false);
                                }),
                                "if",
                                ScatterChart,
                                359,
                                10
                              );
                            }
                            var node_42 = sibling(node_37, 2);
                            add_svelte_meta(
                              () => ChartAnnotations_default(node_42, {
                                get annotations() {
                                  return annotations();
                                },
                                layer: "above",
                                get highlightKey() {
                                  return seriesState.highlightKey.current;
                                },
                                get visibleSeries() {
                                  return seriesState.visibleSeries;
                                }
                              }),
                              "component",
                              ScatterChart,
                              367,
                              10,
                              { componentTag: "ChartAnnotations" }
                            );
                            append($$anchor5, fragment_23);
                          }),
                          $$slots: { default: true }
                        }),
                        "component",
                        ScatterChart,
                        352,
                        8,
                        { componentTag: "ChartClipPath" }
                      );
                    }
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              ScatterChart,
              296,
              6,
              { componentTag: "Layer" }
            );
          }
          var node_43 = sibling(node_4, 2);
          add_svelte_meta(() => snippet(node_43, () => $$props.aboveContext ?? noop, () => get(snippetProps)), "render", ScatterChart, 376, 6);
          var node_44 = sibling(node_43, 2);
          {
            var consequent_16 = ($$anchor4) => {
              var fragment_31 = comment();
              var node_45 = first_child(fragment_31);
              add_svelte_meta(() => snippet(node_45, legend, () => get(snippetProps)), "render", ScatterChart, 379, 8);
              append($$anchor4, fragment_31);
            };
            var alternate_7 = ($$anchor4) => {
              var fragment_32 = comment();
              var node_46 = first_child(fragment_32);
              {
                var consequent_17 = ($$anchor5) => {
                  var fragment_33 = comment();
                  var node_47 = first_child(fragment_33);
                  {
                    let $02 = user_derived(getLegendProps);
                    add_svelte_meta(() => Legend_default(node_47, spread_props(() => get($02))), "component", ScatterChart, 381, 8, { componentTag: "Legend" });
                  }
                  append($$anchor5, fragment_33);
                };
                add_svelte_meta(
                  () => if_block(
                    node_46,
                    ($$render) => {
                      if (legend()) $$render(consequent_17);
                    },
                    true
                  ),
                  "if",
                  ScatterChart,
                  380,
                  6
                );
              }
              append($$anchor4, fragment_32);
            };
            add_svelte_meta(
              () => if_block(node_44, ($$render) => {
                if (strict_equals(typeof legend(), "function")) $$render(consequent_16);
                else $$render(alternate_7, false);
              }),
              "if",
              ScatterChart,
              378,
              6
            );
          }
          var node_48 = sibling(node_44, 2);
          {
            var consequent_18 = ($$anchor4) => {
              var fragment_34 = comment();
              var node_49 = first_child(fragment_34);
              add_svelte_meta(() => snippet(node_49, tooltip, () => get(snippetProps)), "render", ScatterChart, 385, 8);
              append($$anchor4, fragment_34);
            };
            var alternate_8 = ($$anchor4) => {
              var fragment_35 = comment();
              var node_50 = first_child(fragment_35);
              {
                var consequent_21 = ($$anchor5) => {
                  var fragment_36 = comment();
                  var node_51 = first_child(fragment_36);
                  {
                    const children2 = wrap_snippet(ScatterChart, function($$anchor6, $$arg02) {
                      validate_snippet_args(...arguments);
                      let data2 = () => $$arg02?.().data;
                      data2();
                      var fragment_37 = root_372();
                      var node_52 = first_child(fragment_37);
                      {
                        var consequent_19 = ($$anchor7) => {
                          var fragment_38 = comment();
                          var node_53 = first_child(fragment_38);
                          {
                            let $02 = user_derived(() => get(activeSeries)?.label ?? get(activeSeries)?.key);
                            let $12 = user_derived(() => get(activeSeries)?.color);
                            add_svelte_meta(
                              () => component(node_53, () => TooltipHeader_default, ($$anchor8, Tooltip_Header) => {
                                Tooltip_Header($$anchor8, spread_props(
                                  {
                                    get value() {
                                      return get($02);
                                    },
                                    get color() {
                                      return get($12);
                                    }
                                  },
                                  () => props().tooltip?.header
                                ));
                              }),
                              "component",
                              ScatterChart,
                              390,
                              14,
                              { componentTag: "Tooltip.Header" }
                            );
                          }
                          append($$anchor7, fragment_38);
                        };
                        add_svelte_meta(
                          () => if_block(node_52, ($$render) => {
                            if (strict_equals(get(activeSeries)?.key, "default", false)) $$render(consequent_19);
                          }),
                          "if",
                          ScatterChart,
                          389,
                          12
                        );
                      }
                      var node_54 = sibling(node_52, 2);
                      add_svelte_meta(
                        () => component(node_54, () => TooltipList_default, ($$anchor7, Tooltip_List) => {
                          Tooltip_List($$anchor7, spread_props(() => props().tooltip?.list, {
                            children: wrap_snippet(ScatterChart, ($$anchor8, $$slotProps) => {
                              var fragment_39 = root_392();
                              var node_55 = first_child(fragment_39);
                              {
                                let $02 = user_derived(() => strict_equals(typeof context2().config.x, "string") ? context2().config.x : "x");
                                let $12 = user_derived(() => context2().x(data2()));
                                add_svelte_meta(
                                  () => component(node_55, () => TooltipItem_default, ($$anchor9, Tooltip_Item) => {
                                    Tooltip_Item($$anchor9, spread_props(
                                      {
                                        get label() {
                                          return get($02);
                                        },
                                        get value() {
                                          return get($12);
                                        },
                                        get format() {
                                          return format;
                                        },
                                        onpointerenter: () => assign(seriesState.highlightKey, "current", get(activeSeries)?.key ?? null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:402:19"),
                                        onpointerleave: () => assign(seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:403:39")
                                      },
                                      () => props().tooltip?.item
                                    ));
                                  }),
                                  "component",
                                  ScatterChart,
                                  397,
                                  14,
                                  { componentTag: "Tooltip.Item" }
                                );
                              }
                              var node_56 = sibling(node_55, 2);
                              {
                                let $02 = user_derived(() => strict_equals(typeof context2().config.y, "string") ? context2().config.y : "y");
                                let $12 = user_derived(() => context2().y(data2()));
                                add_svelte_meta(
                                  () => component(node_56, () => TooltipItem_default, ($$anchor9, Tooltip_Item_1) => {
                                    Tooltip_Item_1($$anchor9, spread_props(
                                      {
                                        get label() {
                                          return get($02);
                                        },
                                        get value() {
                                          return get($12);
                                        },
                                        get format() {
                                          return format;
                                        },
                                        onpointerenter: () => assign(seriesState.highlightKey, "current", get(activeSeries)?.key ?? null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:411:19"),
                                        onpointerleave: () => assign(seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:412:39")
                                      },
                                      () => props().tooltip?.item
                                    ));
                                  }),
                                  "component",
                                  ScatterChart,
                                  406,
                                  14,
                                  { componentTag: "Tooltip.Item" }
                                );
                              }
                              var node_57 = sibling(node_56, 2);
                              {
                                var consequent_20 = ($$anchor9) => {
                                  var fragment_40 = comment();
                                  var node_58 = first_child(fragment_40);
                                  {
                                    let $02 = user_derived(() => strict_equals(typeof context2().config.r, "string") ? context2().config.r : "r");
                                    let $12 = user_derived(() => context2().r(data2()));
                                    add_svelte_meta(
                                      () => component(node_58, () => TooltipItem_default, ($$anchor10, Tooltip_Item_2) => {
                                        Tooltip_Item_2($$anchor10, spread_props(
                                          {
                                            get label() {
                                              return get($02);
                                            },
                                            get value() {
                                              return get($12);
                                            },
                                            get format() {
                                              return format;
                                            },
                                            onpointerenter: () => assign(seriesState.highlightKey, "current", get(activeSeries)?.key ?? null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:421:21"),
                                            onpointerleave: () => assign(seriesState.highlightKey, "current", null, "node_modules/​layerchart/​dist/​components/​charts/​ScatterChart.svelte:422:41")
                                          },
                                          () => props().tooltip?.item
                                        ));
                                      }),
                                      "component",
                                      ScatterChart,
                                      416,
                                      16,
                                      { componentTag: "Tooltip.Item" }
                                    );
                                  }
                                  append($$anchor9, fragment_40);
                                };
                                add_svelte_meta(
                                  () => if_block(node_57, ($$render) => {
                                    if (context2().config.r) $$render(consequent_20);
                                  }),
                                  "if",
                                  ScatterChart,
                                  415,
                                  14
                                );
                              }
                              append($$anchor8, fragment_39);
                            }),
                            $$slots: { default: true }
                          }));
                        }),
                        "component",
                        ScatterChart,
                        396,
                        12,
                        { componentTag: "Tooltip.List" }
                      );
                      append($$anchor6, fragment_37);
                    });
                    add_svelte_meta(
                      () => component(node_51, () => Tooltip_default, ($$anchor6, Tooltip_Root) => {
                        Tooltip_Root($$anchor6, spread_props(
                          {
                            get context() {
                              return context2();
                            }
                          },
                          () => props().tooltip?.root,
                          { children: children2, $$slots: { default: true } }
                        ));
                      }),
                      "component",
                      ScatterChart,
                      387,
                      8,
                      { componentTag: "Tooltip.Root" }
                    );
                  }
                  append($$anchor5, fragment_36);
                };
                add_svelte_meta(
                  () => if_block(
                    node_50,
                    ($$render) => {
                      if (tooltip()) $$render(consequent_21);
                    },
                    true
                  ),
                  "if",
                  ScatterChart,
                  386,
                  6
                );
              }
              append($$anchor4, fragment_35);
            };
            add_svelte_meta(
              () => if_block(node_48, ($$render) => {
                if (strict_equals(typeof tooltip(), "function")) $$render(consequent_18);
                else $$render(alternate_8, false);
              }),
              "if",
              ScatterChart,
              384,
              6
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate_9, false);
          }),
          "if",
          ScatterChart,
          292,
          4
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => defaultChartPadding(axis(), legend()));
    let $1 = user_derived(() => strict_equals(tooltip(), false) ? false : {
      mode: "quadtree",
      onclick: onTooltipClick(),
      debug: debug(),
      ...props().tooltip?.context,
      ...strict_equals(typeof tooltip(), "object") ? tooltip() : null
    });
    let $2 = user_derived(() => brush() && (strict_equals(brush(), true) || equals(brush().mode, void 0) || strict_equals(brush().mode, "integrated")) ? {
      axis: "both",
      resetOnEnd: true,
      xDomain: xDomain(),
      yDomain: yDomain(),
      ...get(brushProps),
      onBrushEnd: (e) => {
        xDomain(e.xDomain);
        yDomain(e.yDomain);
        get(brushProps).onBrushEnd?.(e);
      }
    } : false);
    add_svelte_meta(
      () => Chart_default(node, spread_props(
        {
          get data() {
            return get(chartData);
          },
          get x() {
            return $$props.x;
          },
          get xDomain() {
            return xDomain();
          },
          get xScale() {
            return get(xScale);
          },
          get y() {
            return $$props.y;
          },
          get yDomain() {
            return yDomain();
          },
          get yScale() {
            return get(yScale);
          },
          yNice: true,
          get c() {
            return $$props.y;
          },
          cRange: ["var(--color-primary)"],
          get padding() {
            return get($0);
          }
        },
        () => restProps,
        {
          get tooltip() {
            return get($1);
          },
          get brush() {
            return get($2);
          },
          get context() {
            return context();
          },
          set context($$value) {
            context($$value);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      ScatterChart,
      239,
      0,
      { componentTag: "Chart" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ScatterChart = hmr(ScatterChart, () => ScatterChart[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ScatterChart[HMR].source;
    set(ScatterChart[HMR].source, module2.default[HMR].original);
  });
}
var ScatterChart_default = ScatterChart;

// node_modules/layerchart/dist/components/Blur.svelte
Blur[FILENAME] = "node_modules/layerchart/dist/components/Blur.svelte";
var root_29 = add_locations(from_svg(`<g><!></g>`), Blur[FILENAME], [[44, 4]]);
var root_116 = add_locations(from_svg(`<defs><filter><feGaussianBlur in="SourceGraphic"></feGaussianBlur></filter></defs><!>`, 1), Blur[FILENAME], [[37, 2, [[38, 4, [[39, 6]]]]]]);
function Blur($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Blur);
  let id = prop($$props, "id", 19, () => createId("blur-", uid)), stdDeviation = prop($$props, "stdDeviation", 3, 5);
  const renderContext = getRenderContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_116();
      var defs = first_child(fragment_1);
      var filter4 = child(defs);
      var feGaussianBlur = child(filter4);
      reset(filter4);
      reset(defs);
      var node_1 = sibling(defs);
      {
        var consequent = ($$anchor3) => {
          var g = root_29();
          var node_2 = child(g);
          add_svelte_meta(() => snippet(node_2, () => $$props.children), "render", Blur, 45, 6);
          reset(g);
          template_effect(
            ($0) => {
              set_attribute(g, "filter", `url(#${id() ?? ""})`);
              set_class(g, 0, $0);
            },
            [() => clsx(layerClass("blur-g"))]
          );
          append($$anchor3, g);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
          }),
          "if",
          Blur,
          43,
          2
        );
      }
      template_effect(
        ($0) => {
          set_attribute(filter4, "id", id());
          set_class(filter4, 0, $0);
          set_attribute(feGaussianBlur, "stdDeviation", stdDeviation());
        },
        [() => clsx(layerClass("blur-filter"))]
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_4, () => $$props.children), "render", Blur, 49, 2);
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_3,
            ($$render) => {
              if ($$props.children) $$render(consequent_2);
            },
            true
          ),
          "if",
          Blur,
          48,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderContext, "svg")) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      Blur,
      36,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Blur = hmr(Blur, () => Blur[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Blur[HMR].source;
    set(Blur[HMR].source, module2.default[HMR].original);
  });
}
var Blur_default = Blur;

// node_modules/layerchart/dist/components/Bounds.svelte
Bounds[FILENAME] = "node_modules/layerchart/dist/components/Bounds.svelte";
function Bounds($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Bounds);
  const ctx = getChartContext();
  function getExtents(extents, axis, fallback) {
    const resolvedExtents = strict_equals(typeof extents, "function") ? extents({ width: ctx.width, height: ctx.height }) : extents;
    return [
      // @ts-expect-error
      resolvedExtents?.[axis + "0"] ?? 0,
      // x0 or y0
      // @ts-expect-error
      resolvedExtents?.[axis + "1"] ?? fallback
      // x1 or y1, fallback as $width or $height
    ];
  }
  const xScale = createMotionScale(linear2, $$props.motion, {
    defaultDomain: getExtents($$props.domain, "x", ctx.width),
    defaultRange: getExtents($$props.range, "x", ctx.width)
  });
  user_effect(() => {
    xScale.domain(getExtents($$props.domain, "x", ctx.width));
  });
  user_effect(() => {
    xScale.range(getExtents($$props.range, "x", ctx.width));
  });
  const yScale = createMotionScale(linear2, $$props.motion, {
    defaultDomain: getExtents($$props.domain, "y", ctx.height),
    defaultRange: getExtents($$props.range, "y", ctx.height)
  });
  user_effect(() => {
    yScale.domain(getExtents($$props.domain, "y", ctx.height));
  });
  user_effect(() => {
    yScale.range(getExtents($$props.range, "y", ctx.height));
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ xScale: xScale.current, yScale: yScale.current })), "render", Bounds, 72, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Bounds = hmr(Bounds, () => Bounds[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Bounds[HMR].source;
    set(Bounds[HMR].source, module2.default[HMR].original);
  });
}
var Bounds_default = Bounds;

// node_modules/layerchart/dist/components/MonthPath.svelte
MonthPath[FILENAME] = "node_modules/layerchart/dist/components/MonthPath.svelte";
function MonthPath($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MonthPath);
  let pathRefProp = prop($$props, "pathRef", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "date",
      "cellSize",
      "pathRef",
      "class"
    ],
    "restProps"
  );
  let pathRef = tag(state(void 0), "pathRef");
  user_pre_effect(() => {
    pathRefProp(get(pathRef));
  });
  const cellSize = tag(
    user_derived(() => Array.isArray($$props.cellSize) ? $$props.cellSize : [$$props.cellSize, $$props.cellSize]),
    "cellSize"
  );
  const startDayOfWeek = tag(user_derived(() => $$props.date.getDay()), "startDayOfWeek");
  const startWeek = tag(user_derived(() => timeSunday.count(timeYear($$props.date), $$props.date)), "startWeek");
  const monthEnd = tag(user_derived(() => endOfInterval("month", $$props.date)), "monthEnd");
  const endDayOfWeek = tag(user_derived(() => get(monthEnd).getDay()), "endDayOfWeek");
  const endWeek = tag(user_derived(() => timeSunday.count(timeYear(get(monthEnd)), get(monthEnd))), "endWeek");
  const pathData = tag(
    user_derived(() => `
    M${(get(startWeek) + 1) * get(cellSize)[0]},${get(startDayOfWeek) * get(cellSize)[1]}
    H${get(startWeek) * get(cellSize)[0]} V${get(cellSize)[1] * 7}
    H${get(endWeek) * get(cellSize)[0]} V${(get(endDayOfWeek) + 1) * get(cellSize)[1]}
    H${(get(endWeek) + 1) * get(cellSize)[0]} V0
    H${(get(startWeek) + 1) * get(cellSize)[0]}Z
  `),
    "pathData"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls(layerClass("month-path"), "stroke-surface-content/20", $$props.class));
    add_svelte_meta(
      () => Spline_default(node, spread_props(
        {
          get pathData() {
            return get(pathData);
          },
          fill: "none",
          get class() {
            return get($0);
          }
        },
        () => restProps,
        {
          get pathRef() {
            return get(pathRef);
          },
          set pathRef($$value) {
            set(pathRef, $$value, true);
          }
        }
      )),
      "component",
      MonthPath,
      74,
      0,
      { componentTag: "Spline" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MonthPath = hmr(MonthPath, () => MonthPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = MonthPath[HMR].source;
    set(MonthPath[HMR].source, module2.default[HMR].original);
  });
}
var MonthPath_default = MonthPath;

// node_modules/layerchart/dist/components/Calendar.svelte
Calendar[FILENAME] = "node_modules/layerchart/dist/components/Calendar.svelte";
var root21 = add_locations(from_html(`<!> <!> <!>`, 1), Calendar[FILENAME], []);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar);
  let monthPath = prop($$props, "monthPath", 3, false), monthLabel = prop($$props, "monthLabel", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "end",
      "start",
      "cellSize",
      "monthPath",
      "monthLabel",
      "tooltipContext",
      "children"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const yearDays = tag(user_derived(() => timeDays($$props.start, $$props.end)), "yearDays");
  const yearMonths = tag(user_derived(() => timeMonths($$props.start, $$props.end)), "yearMonths");
  const yearWeeks = tag(user_derived(() => timeSunday.count($$props.start, $$props.end)), "yearWeeks");
  const chartCellWidth = tag(user_derived(() => ctx.width / (get(yearWeeks) + 1)), "chartCellWidth");
  const chartCellHeight = tag(user_derived(() => ctx.height / 7), "chartCellHeight");
  const chartCellSize = tag(user_derived(() => Math.min(get(chartCellWidth), get(chartCellHeight))), "chartCellSize");
  const cellSize = tag(
    user_derived(() => Array.isArray($$props.cellSize) ? $$props.cellSize : strict_equals(typeof $$props.cellSize, "number") ? [$$props.cellSize, $$props.cellSize] : [get(chartCellSize), get(chartCellSize)]),
    "cellSize"
  );
  const dataByDate = tag(
    user_derived(() => ctx.data && ctx.config.x ? index2(chartDataArray(ctx.data), (d) => ctx.x(d)) : /* @__PURE__ */ new Map()),
    "dataByDate"
  );
  const cells = tag(
    user_derived(() => get(yearDays).map((date2) => {
      const cellData = get(dataByDate).get(date2) ?? { date: date2 };
      return {
        x: timeSunday.count(timeYear(date2), date2) * get(cellSize)[0],
        y: date2.getDay() * get(cellSize)[1],
        color: ctx.config.c ? ctx.cGet(cellData) : "transparent",
        data: cellData
      };
    })),
    "cells"
  );
  var fragment = root21();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children, () => ({ cells: get(cells), cellSize: get(cellSize) })), "render", Calendar, 120, 2);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(
        () => each(node_2, 17, () => get(cells), index, ($$anchor3, cell) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            let $0 = user_derived(() => extractLayerProps(restProps, "calendar-cell", "stroke-surface-content/5"));
            add_svelte_meta(
              () => Rect_default(node_3, spread_props(
                {
                  get x() {
                    return get(cell).x;
                  },
                  get y() {
                    return get(cell).y;
                  },
                  get width() {
                    return get(cellSize)[0];
                  },
                  get height() {
                    return get(cellSize)[1];
                  },
                  get fill() {
                    return get(cell).color;
                  },
                  onpointermove: (e) => $$props.tooltipContext?.show(e, get(cell).data),
                  onpointerleave: (e) => $$props.tooltipContext?.hide()
                },
                () => get($0)
              )),
              "component",
              Calendar,
              123,
              4,
              { componentTag: "Rect" }
            );
          }
          append($$anchor3, fragment_3);
        }),
        "each",
        Calendar,
        122,
        2
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.children) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar,
      119,
      0
    );
  }
  var node_4 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      add_svelte_meta(
        () => each(node_5, 17, () => get(yearMonths), index, ($$anchor3, date2) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            let $0 = user_derived(() => extractLayerProps(monthPath(), "calendar-month-path"));
            add_svelte_meta(
              () => MonthPath_default(node_6, spread_props(
                {
                  get date() {
                    return get(date2);
                  },
                  get cellSize() {
                    return get(cellSize);
                  }
                },
                () => get($0)
              )),
              "component",
              Calendar,
              138,
              4,
              { componentTag: "MonthPath" }
            );
          }
          append($$anchor3, fragment_5);
        }),
        "each",
        Calendar,
        137,
        2
      );
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node_4, ($$render) => {
        if (monthPath()) $$render(consequent_1);
      }),
      "if",
      Calendar,
      136,
      0
    );
  }
  var node_7 = sibling(node_4, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_6 = comment();
      var node_8 = first_child(fragment_6);
      add_svelte_meta(
        () => each(node_8, 17, () => get(yearMonths), index, ($$anchor3, date2) => {
          var fragment_7 = comment();
          var node_9 = first_child(fragment_7);
          {
            let $0 = user_derived(() => timeSunday.count(timeYear.floor(get(date2)), timeSunday.ceil(get(date2))) * get(cellSize)[0]);
            let $1 = user_derived(() => format(get(date2), "month", { variant: "short" }));
            let $2 = user_derived(() => extractLayerProps(monthLabel(), "calendar-month-label", "text-xs"));
            add_svelte_meta(
              () => Text_default(node_9, spread_props(
                {
                  get x() {
                    return get($0);
                  },
                  y: -4,
                  get value() {
                    return get($1);
                  }
                },
                () => get($2)
              )),
              "component",
              Calendar,
              144,
              4,
              { componentTag: "Text" }
            );
          }
          append($$anchor3, fragment_7);
        }),
        "each",
        Calendar,
        143,
        2
      );
      append($$anchor2, fragment_6);
    };
    add_svelte_meta(
      () => if_block(node_7, ($$render) => {
        if (monthLabel()) $$render(consequent_2);
      }),
      "if",
      Calendar,
      142,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module2.default[HMR].original);
  });
}
var Calendar_default = Calendar;

// node_modules/layerchart/dist/components/Dagre.svelte
var import_dagre2 = __toESM(require_dagre());

// node_modules/layerchart/dist/utils/graph/dagre.js
var import_dagre = __toESM(require_dagre(), 1);
function dagreGraph(data, { nodes = (d) => d.nodes, nodeId = (d) => d.id, edges = (d) => d.edges, directed = true, multigraph = false, compound = false, ranker = "network-simplex", direction = "top-bottom", align, rankSeparation = 50, nodeSeparation = 50, edgeSeparation = 10, nodeWidth = 100, nodeHeight = 50, edgeLabelWidth = 100, edgeLabelHeight = 20, edgeLabelPosition = "center", edgeLabelOffset = 10, filterNodes = () => true } = {}) {
  let g = new import_dagre.default.graphlib.Graph({ directed, multigraph, compound });
  g.setGraph({
    ranker,
    rankdir: RankDir[direction],
    align: align ? Align[align] : void 0,
    ranksep: rankSeparation,
    nodesep: nodeSeparation,
    edgesep: edgeSeparation
  });
  g.setDefaultEdgeLabel(() => ({}));
  const dataNodes = nodes(data);
  for (const n of dataNodes) {
    const id = nodeId(n);
    g.setNode(nodeId(n), {
      id,
      label: typeof n.label === "string" ? n.label : id,
      width: nodeWidth,
      height: nodeHeight,
      ...typeof n.label === "object" ? n.label : null
    });
    if (n.parent) {
      g.setParent(id, n.parent);
    }
  }
  const nodeEdges = edges(data);
  for (const e of nodeEdges) {
    const { source, target, label, ...rest2 } = e;
    g.setEdge(e.source, e.target, label ? {
      label,
      labelpos: EdgeLabelPosition[edgeLabelPosition],
      labeloffset: edgeLabelOffset,
      width: edgeLabelWidth,
      height: edgeLabelHeight,
      ...rest2
    } : {});
  }
  if (filterNodes) {
    g = g.filterNodes((nodeId2) => filterNodes(nodeId2, g));
  }
  import_dagre.default.layout(g);
  return g;
}
function dagreAncestors(graph, nodeId, maxDepth2 = Infinity, currentDepth = 0) {
  if (currentDepth === maxDepth2) {
    return [];
  }
  const predecessors = graph.predecessors(nodeId) ?? [];
  return [
    ...predecessors,
    // @ts-expect-error: Types from dagre appear incorrect
    ...predecessors.flatMap((pId) => dagreAncestors(graph, pId, maxDepth2, currentDepth + 1))
  ];
}
function dagreDescendants(graph, nodeId, maxDepth2 = Infinity, currentDepth = 0) {
  if (currentDepth === maxDepth2) {
    return [];
  }
  const predecessors = graph.successors(nodeId) ?? [];
  return [
    ...predecessors,
    // @ts-expect-error: Types from dagre appear incorrect
    ...predecessors.flatMap((pId) => dagreDescendants(graph, pId, maxDepth2, currentDepth + 1))
  ];
}

// node_modules/layerchart/dist/components/Dagre.svelte
Dagre[FILENAME] = "node_modules/layerchart/dist/components/Dagre.svelte";
var RankDir = {
  "top-bottom": "TB",
  "bottom-top": "BT",
  "left-right": "LR",
  "right-left": "RL"
};
var Align = {
  none: void 0,
  "up-left": "UL",
  "up-right": "UR",
  "down-left": "DL",
  "down-right": "DR"
};
var EdgeLabelPosition = { left: "l", center: "c", right: "r" };
function Dagre($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dagre);
  let nodes = prop($$props, "nodes", 3, (d) => d.nodes), nodeId = prop($$props, "nodeId", 3, (d) => d.id), edges = prop($$props, "edges", 3, (d) => d.edges), directed = prop($$props, "directed", 3, true), multigraph = prop($$props, "multigraph", 3, false), compound = prop($$props, "compound", 3, false), ranker = prop($$props, "ranker", 3, "network-simplex"), direction = prop($$props, "direction", 3, "top-bottom"), rankSeparation = prop($$props, "rankSeparation", 3, 50), nodeSeparation = prop($$props, "nodeSeparation", 3, 50), edgeSeparation = prop($$props, "edgeSeparation", 3, 10), nodeWidth = prop($$props, "nodeWidth", 3, 100), nodeHeight = prop($$props, "nodeHeight", 3, 50), edgeLabelWidth = prop($$props, "edgeLabelWidth", 3, 100), edgeLabelHeight = prop($$props, "edgeLabelHeight", 3, 20), edgeLabelPosition = prop($$props, "edgeLabelPosition", 3, "center"), edgeLabelOffset = prop($$props, "edgeLabelOffset", 3, 10), filterNodes = prop($$props, "filterNodes", 3, () => true), graphProp = prop($$props, "graph", 15);
  const graph = tag(
    user_derived(() => dagreGraph($$props.data, {
      nodes: nodes(),
      nodeId: nodeId(),
      edges: edges(),
      directed: directed(),
      multigraph: multigraph(),
      compound: compound(),
      ranker: ranker(),
      direction: direction(),
      align: $$props.align,
      rankSeparation: rankSeparation(),
      nodeSeparation: nodeSeparation(),
      edgeSeparation: edgeSeparation(),
      nodeWidth: nodeWidth(),
      nodeHeight: nodeHeight(),
      edgeLabelWidth: edgeLabelWidth(),
      edgeLabelHeight: edgeLabelHeight(),
      edgeLabelPosition: edgeLabelPosition(),
      edgeLabelOffset: edgeLabelOffset(),
      filterNodes: filterNodes()
    })),
    "graph"
  );
  user_pre_effect(() => {
    graphProp(get(graph));
  });
  const graphNodes = tag(
    user_derived(() => {
      if (strict_equals(typeof document, "undefined") || !get(graph)) return [];
      return get(graph).nodes().map((id) => get(graph).node(id));
    }),
    "graphNodes"
  );
  const graphEdges = tag(
    user_derived(() => {
      if (strict_equals(typeof document, "undefined") || !get(graph)) return [];
      return get(graph).edges().map((edge) => ({ ...edge, ...get(graph).edge(edge) }));
    }),
    "graphEdges"
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => snippet(node, () => $$props.children ?? noop, () => ({
      nodes: get(graphNodes),
      edges: get(graphEdges),
      graph: get(graph)
    })),
    "render",
    Dagre,
    241,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dagre = hmr(Dagre, () => Dagre[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Dagre[HMR].source;
    set(Dagre[HMR].source, module2.default[HMR].original);
  });
}
var Dagre_default = Dagre;

// node_modules/layerchart/dist/components/Ellipse.svelte
Ellipse[FILENAME] = "node_modules/layerchart/dist/components/Ellipse.svelte";
var root_117 = add_locations(from_svg(`<ellipse></ellipse>`), Ellipse[FILENAME], [[173, 2]]);
function Ellipse($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Ellipse);
  let cx = prop($$props, "cx", 3, 0), cy = prop($$props, "cy", 3, 0), rx = prop($$props, "rx", 3, 1), ry = prop($$props, "ry", 3, 1), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cx",
      "initialCx",
      "cy",
      "initialCy",
      "rx",
      "initialRx",
      "ry",
      "initialRy",
      "motion",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "class",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const initialCx = $$props.initialCx ?? cx();
  const initialCy = $$props.initialCy ?? cy();
  const initialRx = $$props.initialRx ?? rx();
  const initialRy = $$props.initialRy ?? ry();
  const renderCtx = getRenderContext();
  const motionCx = createMotion(initialCx, () => cx(), $$props.motion);
  const motionCy = createMotion(initialCy, () => cy(), $$props.motion);
  const motionRx = createMotion(initialRx, () => rx(), $$props.motion);
  const motionRy = createMotion(initialRy, () => ry(), $$props.motion);
  function render2(ctx, styleOverrides) {
    renderEllipse(
      ctx,
      {
        cx: motionCx.current,
        cy: motionCy.current,
        rx: motionRx.current,
        ry: motionRy.current
      },
      styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
        styles: {
          fill: $$props.fill,
          fillOpacity: $$props.fillOpacity,
          stroke: $$props.stroke,
          strokeWidth: $$props.strokeWidth,
          opacity: $$props.opacity
        },
        classes: $$props.class
      }
    );
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Ellipse",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerdown: $$props.onpointerdown,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave
      },
      deps: () => [
        motionCx.current,
        motionCy.current,
        motionRx.current,
        motionRy.current,
        fillKey.current,
        $$props.fillOpacity,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var ellipse = root_117();
      attribute_effect(
        ellipse,
        ($0) => ({
          cx: motionCx.current,
          cy: motionCy.current,
          rx: motionRx.current,
          ry: motionRy.current,
          fill: $$props.fill,
          "fill-opacity": $$props.fillOpacity,
          stroke: $$props.stroke,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          class: $0,
          ...restProps
        }),
        [
          () => cls(layerClass("ellipse"), equals($$props.fill, null) && "fill-surface-content", $$props.class)
        ]
      );
      bind_this(ellipse, ($$value) => set(ref, $$value), () => get(ref));
      append($$anchor2, ellipse);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent);
      }),
      "if",
      Ellipse,
      172,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Ellipse = hmr(Ellipse, () => Ellipse[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Ellipse[HMR].source;
    set(Ellipse[HMR].source, module2.default[HMR].original);
  });
}
var Ellipse_default = Ellipse;

// node_modules/layerchart/dist/components/Frame.svelte
Frame[FILENAME] = "node_modules/layerchart/dist/components/Frame.svelte";
function Frame($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Frame);
  let refProp = prop($$props, "ref", 15), full = prop($$props, "full", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "full"], "restProps");
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const ctx = getChartContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => full() && ctx.padding?.left ? -ctx.padding.left : 0);
    let $1 = user_derived(() => full() && ctx.padding?.top ? -ctx.padding.top : 0);
    let $2 = user_derived(() => ctx.width + (full() ? (ctx.padding?.left ?? 0) + (ctx.padding?.right ?? 0) : 0));
    let $3 = user_derived(() => ctx.height + (full() ? (ctx.padding?.top ?? 0) + (ctx.padding?.bottom ?? 0) : 0));
    let $4 = user_derived(() => extractLayerProps(restProps, "frame"));
    add_svelte_meta(
      () => Rect_default(node, spread_props(
        {
          get x() {
            return get($0);
          },
          get y() {
            return get($1);
          },
          get width() {
            return get($2);
          },
          get height() {
            return get($3);
          }
        },
        () => get($4),
        {
          get ref() {
            return get(ref);
          },
          set ref($$value) {
            set(ref, $$value, true);
          }
        }
      )),
      "component",
      Frame,
      34,
      0,
      { componentTag: "Rect" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Frame = hmr(Frame, () => Frame[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Frame[HMR].source;
    set(Frame[HMR].source, module2.default[HMR].original);
  });
}
var Frame_default = Frame;

// node_modules/d3-dispatch/src/dispatch.js
var noop5 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get4(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set3(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set3(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _ = this._;
    for (var t in _) copy3[t] = _[t].slice();
    return new Dispatch(copy3);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get4(type, name) {
  for (var i = 0, n = type.length, c3; i < n; ++i) {
    if ((c3 = type[i]).name === name) {
      return c3.value;
    }
  }
}
function set3(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop5, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now2() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now2() : +time2) + (delay2 == null ? 0 : +delay2);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep2();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep2();
    }
  }
};
function timer(callback, delay2, time2) {
  var t = new Timer();
  t.restart(callback, delay2, time2);
  return t;
}
function timerFlush() {
  now2();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay2 = now3 - clockLast;
  if (delay2 > pokeDelay) clockSkew -= delay2, clockLast = now3;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time) time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep2(time2);
}
function sleep2(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay2 = time2 - clockNow;
  if (delay2 > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s3 = 1;
  return () => (s3 = (a2 * s3 + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event2 = dispatch_default("tick", "end"), random2 = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick2();
    event2.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event2.call("end", simulation);
    }
  }
  function tick2(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0) iterations2 = 1;
    for (var k3 = 0; k3 < iterations2; ++k3) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random2);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation) : random2;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function(x4, y4, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x4 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event2.on(name, _), simulation) : event2.on(name);
    }
  };
}

// node_modules/layerchart/dist/components/ForceSimulation.svelte
ForceSimulation[FILENAME] = "node_modules/layerchart/dist/components/ForceSimulation.svelte";
var DEFAULT_ALPHA = 1;
var DEFAULT_ALPHA_TARGET = 0;
var DEFAULT_ALPHA_DECAY = 1 - Math.pow(1e-3, 1 / 300);
var DEFAULT_ALPHA_MIN = 0.01;
var DEFAULT_VELOCITY_DECAY = 0.4;
function ForceSimulation($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ForceSimulation);
  let alpha = prop($$props, "alpha", 15, DEFAULT_ALPHA), alphaTarget = prop($$props, "alphaTarget", 3, DEFAULT_ALPHA_TARGET), alphaDecay = prop($$props, "alphaDecay", 3, DEFAULT_ALPHA_DECAY), alphaMin = prop($$props, "alphaMin", 3, DEFAULT_ALPHA_MIN), velocityDecay = prop($$props, "velocityDecay", 3, DEFAULT_VELOCITY_DECAY), stopped = prop($$props, "stopped", 3, false), cloneNodes = prop($$props, "cloneNodes", 3, false);
  let linkPositions = tag(state(proxy([])), "linkPositions");
  let simulatedNodes = tag(state(proxy([])), "simulatedNodes");
  let simulatedLinks = tag(user_derived(() => $$props.data.links ?? []), "simulatedLinks");
  const simulation = simulation_default().stop();
  let previousForces = {};
  let paused = true;
  watch.pre(() => stopped(), () => {
    if (stopped()) {
      pauseDynamicSimulation();
    } else {
      runOrResumeSimulation();
    }
  });
  watch.pre(() => $$props.static, () => {
    if ($$props.static) {
      simulation.on("tick", null).on("end", null);
    } else {
      simulation.on("tick", onTick).on("end", onEnd);
    }
    runOrResumeSimulation();
  });
  watch.pre(() => $$props.data, () => {
    pushNodesToSimulation($$props.data.nodes);
    runOrResumeSimulation();
  });
  watch.pre(() => $$props.forces, () => {
    pushForcesToSimulation($$props.forces);
    runOrResumeSimulation();
  });
  watch.pre(() => alpha(), () => {
    pushAlphaToSimulation(alpha());
    runOrResumeSimulation();
  });
  watch.pre(
    [
      () => alphaTarget(),
      () => alphaMin(),
      () => alphaDecay(),
      () => velocityDecay()
    ],
    () => {
      let alphaValue = simulation.alpha();
      if (alphaTarget() > alphaValue && alphaValue < alphaMin()) {
        alphaValue = alphaMin();
      }
      simulation.alpha(alphaValue).alphaTarget(alphaTarget()).alphaMin(alphaMin()).alphaDecay(alphaDecay()).velocityDecay(velocityDecay());
      runOrResumeSimulation();
    }
  );
  function pushAlphaToSimulation(alpha2) {
    simulation.alpha(alpha2);
  }
  function pushNodesToSimulation(nodes) {
    simulation.nodes(nodes);
  }
  function pushForcesToSimulation(forces) {
    const names = Object.keys(previousForces);
    for (const name of names) {
      if (!(name in forces)) {
        simulation.force(name, null);
      }
    }
    const entries2 = Object.entries(forces);
    for (const [name, force] of entries2) {
      if (!(name in previousForces) || strict_equals(force, previousForces[name], false)) {
        simulation.force(name, force);
      }
    }
    previousForces = forces;
  }
  function updateLinkPositions() {
    set(
      linkPositions,
      get(simulatedLinks).map((link3) => ({
        x1: link3.source.x ?? 0,
        y1: link3.source.y ?? 0,
        x2: link3.target.x ?? 0,
        y2: link3.target.y ?? 0
      })),
      true
    );
  }
  function pullNodesFromSimulation() {
    const simulationNodes = simulation.nodes();
    set(simulatedNodes, cloneNodes() ? structuredClone(simulationNodes) : simulationNodes, true);
  }
  function pullAlphaFromSimulation() {
    alpha(simulation.alpha());
  }
  function runOrResumeSimulation() {
    if ($$props.static) {
      runStaticSimulationToCompletion();
    } else {
      resumeDynamicSimulation();
    }
  }
  function runStaticSimulationToCompletion() {
    if (stopped()) {
      return;
    }
    if (!$$props.static) {
      return;
    }
    if (!paused) {
      pauseDynamicSimulation();
    }
    const ticks2 = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
    pushAlphaToSimulation(1);
    onStart();
    for (let i = 0; i < ticks2; ++i) {
      simulation.tick();
    }
    pullNodesFromSimulation();
    pullAlphaFromSimulation();
    onEnd();
  }
  function resumeDynamicSimulation() {
    if (!paused) {
      return;
    }
    if (stopped()) {
      return;
    }
    if ($$props.static) {
      return;
    }
    if (simulation.alpha() < simulation.alphaMin()) {
      return;
    }
    onStart();
    simulation.restart();
  }
  function pauseDynamicSimulation() {
    if (paused) {
      return;
    }
    simulation.stop();
    onEnd();
  }
  function onStart() {
    if (!paused) {
      return;
    }
    paused = false;
    $$props.onStart?.({ alpha: alpha(), alphaTarget: alphaTarget(), simulation });
  }
  function onTick() {
    pullNodesFromSimulation();
    pullAlphaFromSimulation();
    updateLinkPositions();
    $$props.onTick?.({
      alpha: alpha(),
      alphaTarget: alphaTarget(),
      nodes: get(simulatedNodes),
      links: get(simulatedLinks),
      simulation
    });
  }
  function onEnd() {
    if (paused) {
      return;
    }
    paused = true;
    $$props.onEnd?.({ alpha: alpha(), alphaTarget: alphaTarget(), simulation });
  }
  user_effect(() => {
    return () => {
      simulation.stop();
      simulation.on("tick", null).on("end", null);
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => snippet(node, () => $$props.children ?? noop, () => ({
      nodes: get(simulatedNodes),
      links: get(simulatedLinks),
      simulation,
      linkPositions: get(linkPositions)
    })),
    "render",
    ForceSimulation,
    509,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ForceSimulation = hmr(ForceSimulation, () => ForceSimulation[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = ForceSimulation[HMR].source;
    set(ForceSimulation[HMR].source, module2.default[HMR].original);
  });
}
var ForceSimulation_default = ForceSimulation;

// node_modules/layerchart/dist/components/GeoCircle.svelte
GeoCircle[FILENAME] = "node_modules/layerchart/dist/components/GeoCircle.svelte";
function GeoCircle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoCircle);
  let radius = prop($$props, "radius", 3, 90), center2 = prop($$props, "center", 19, () => [0, 0]), precision = prop($$props, "precision", 3, 6), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "radius",
      "center",
      "precision"
    ],
    "restProps"
  );
  const geojson = tag(user_derived(() => circle_default2().radius(radius()).center(center2()).precision(precision())()), "geojson");
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => extractLayerProps(restProps, "geo-circle"));
    add_svelte_meta(
      () => GeoPath_default(node, spread_props(
        {
          get geojson() {
            return get(geojson);
          }
        },
        () => get($0)
      )),
      "component",
      GeoCircle,
      37,
      0,
      { componentTag: "GeoPath" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoCircle = hmr(GeoCircle, () => GeoCircle[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoCircle[HMR].source;
    set(GeoCircle[HMR].source, module2.default[HMR].original);
  });
}
var GeoCircle_default = GeoCircle;

// node_modules/layerchart/dist/components/GeoEdgeFade.svelte
GeoEdgeFade[FILENAME] = "node_modules/layerchart/dist/components/GeoEdgeFade.svelte";
function GeoEdgeFade($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoEdgeFade);
  let refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "link",
      "ref",
      "children",
      "opacity"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const geoCtx = getGeoContext();
  const fade2 = linear2().domain([-0.1, 0]).range([0, 0.1]);
  const clamper2 = linear2().domain([0, 1]).range([0, 1]).clamp(true);
  const center2 = tag(user_derived(() => geoCtx.projection?.invert?.(geoCtx.projection?.translate()) ?? [0, 0]), "center");
  const source = tag(user_derived(() => $$props.link.source), "source");
  const target = tag(user_derived(() => $$props.link.target), "target");
  const startDistance = tag(user_derived(() => 1.57 - distance_default(get(source), get(center2))), "startDistance");
  const endDistance = tag(user_derived(() => 1.57 - distance_default(get(target), get(center2))), "endDistance");
  const distance = tag(user_derived(() => get(startDistance) < get(endDistance) ? get(startDistance) : get(endDistance)), "distance");
  const opacity = tag(user_derived(() => $$props.opacity ?? clamper2(fade2(get(distance)))), "opacity");
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => extractLayerProps(restProps, "geo-edge-fade"));
    add_svelte_meta(
      () => Group_default(node, spread_props(
        {
          get opacity() {
            return get(opacity);
          }
        },
        () => get($0),
        {
          get ref() {
            return get(ref);
          },
          set ref($$value) {
            set(ref, $$value, true);
          },
          children: wrap_snippet(GeoEdgeFade, ($$anchor2, $$slotProps) => {
            var fragment_1 = comment();
            var node_1 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", GeoEdgeFade, 60, 2);
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      GeoEdgeFade,
      59,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoEdgeFade = hmr(GeoEdgeFade, () => GeoEdgeFade[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoEdgeFade[HMR].source;
    set(GeoEdgeFade[HMR].source, module2.default[HMR].original);
  });
}
var GeoEdgeFade_default = GeoEdgeFade;

// node_modules/layerchart/dist/components/GeoPoint.svelte
GeoPoint[FILENAME] = "node_modules/layerchart/dist/components/GeoPoint.svelte";
var root22 = add_locations(from_html(`<!> <!>`, 1), GeoPoint[FILENAME], []);
function GeoPoint($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoPoint);
  let refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "lat",
      "long",
      "ref",
      "children"
    ],
    "restProps"
  );
  let ref = void 0;
  user_pre_effect(() => {
    refProp(ref);
  });
  const geoCtx = getGeoContext();
  const points = tag(user_derived(() => geoCtx.projection?.([$$props.long, $$props.lat]) ?? [0, 0]), "points");
  const x4 = tag(user_derived(() => get(points)[0]), "x");
  const y4 = tag(user_derived(() => get(points)[1]), "y");
  const renderContext = getRenderContext();
  var fragment = root22();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $0 = user_derived(() => extractLayerProps(restProps, "geo-point-group"));
            add_svelte_meta(
              () => Group_default(node_2, spread_props(
                {
                  get x() {
                    return get(x4);
                  },
                  get y() {
                    return get(y4);
                  }
                },
                () => get($0),
                {
                  children: wrap_snippet(GeoPoint, ($$anchor4, $$slotProps) => {
                    var fragment_3 = comment();
                    var node_3 = first_child(fragment_3);
                    add_svelte_meta(() => snippet(node_3, () => $$props.children, () => ({ x: get(x4), y: get(y4) })), "render", GeoPoint, 57, 6);
                    append($$anchor4, fragment_3);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              GeoPoint,
              56,
              4,
              { componentTag: "Group" }
            );
          }
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          {
            let $0 = user_derived(() => extractLayerProps(restProps, "geo-point"));
            add_svelte_meta(
              () => Circle_default(node_4, spread_props(
                {
                  get cx() {
                    return get(x4);
                  },
                  get cy() {
                    return get(y4);
                  }
                },
                () => get($0)
              )),
              "component",
              GeoPoint,
              60,
              4,
              { componentTag: "Circle" }
            );
          }
          append($$anchor3, fragment_4);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          GeoPoint,
          55,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderContext, "svg")) $$render(consequent_1);
      }),
      "if",
      GeoPoint,
      54,
      0
    );
  }
  var node_5 = sibling(node, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_6 = comment();
          var node_7 = first_child(fragment_6);
          add_svelte_meta(() => snippet(node_7, () => $$props.children, () => ({ x: get(x4), y: get(y4) })), "render", GeoPoint, 68, 4);
          append($$anchor3, fragment_6);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_7 = comment();
          var node_8 = first_child(fragment_7);
          {
            let $0 = user_derived(() => extractLayerProps(restProps, "geo-point"));
            add_svelte_meta(
              () => Circle_default(node_8, spread_props(
                {
                  get cx() {
                    return get(x4);
                  },
                  get cy() {
                    return get(y4);
                  }
                },
                () => get($0)
              )),
              "component",
              GeoPoint,
              71,
              4,
              { componentTag: "Circle" }
            );
          }
          append($$anchor3, fragment_7);
        };
        add_svelte_meta(
          () => if_block(node_6, ($$render) => {
            if ($$props.children) $$render(consequent_2);
            else $$render(alternate_1, false);
          }),
          "if",
          GeoPoint,
          65,
          2
        );
      }
      append($$anchor2, fragment_5);
    };
    add_svelte_meta(
      () => if_block(node_5, ($$render) => {
        if (strict_equals(renderContext, "canvas")) $$render(consequent_3);
      }),
      "if",
      GeoPoint,
      64,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoPoint = hmr(GeoPoint, () => GeoPoint[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoPoint[HMR].source;
    set(GeoPoint[HMR].source, module2.default[HMR].original);
  });
}
var GeoPoint_default = GeoPoint;

// node_modules/layerchart/dist/components/GeoSpline.svelte
GeoSpline[FILENAME] = "node_modules/layerchart/dist/components/GeoSpline.svelte";
function GeoSpline($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoSpline);
  let loft = prop($$props, "loft", 3, 1), curve = prop($$props, "curve", 3, natural_default), pathRefProp = prop($$props, "pathRef", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "link",
      "loft",
      "curve",
      "pathRef"
    ],
    "restProps"
  );
  let pathRef = tag(state(void 0), "pathRef");
  user_pre_effect(() => {
    pathRefProp(get(pathRef));
  });
  const geoCtx = getGeoContext();
  const loftedProjection = tag(
    user_derived(() => geoCtx.projection ? orthographic_default().translate(geoCtx.projection.translate()).rotate(geoCtx.projection.rotate()).scale(geoCtx.projection.scale() * loft()) : void 0),
    "loftedProjection"
  );
  const source = tag(user_derived(() => geoCtx.projection ? geoCtx.projection($$props.link.source) : [0, 0]), "source");
  const target = tag(user_derived(() => geoCtx.projection ? geoCtx.projection($$props.link.target) : [0, 0]), "target");
  const middle = tag(
    user_derived(() => geoCtx.projection ? get(loftedProjection)(interpolate_default($$props.link.source, $$props.link.target)(0.5)) : [0, 0]),
    "middle"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => [get(source), get(middle), get(target)]);
    let $1 = user_derived(() => extractLayerProps(restProps, "geo-spline"));
    add_svelte_meta(
      () => Spline_default(node, spread_props(
        {
          get data() {
            return get($0);
          },
          x: (d) => d[0],
          y: (d) => d[1],
          get curve() {
            return curve();
          }
        },
        () => get($1),
        {
          get pathRef() {
            return get(pathRef);
          },
          set pathRef($$value) {
            set(pathRef, $$value, true);
          }
        }
      )),
      "component",
      GeoSpline,
      78,
      0,
      { componentTag: "Spline" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoSpline = hmr(GeoSpline, () => GeoSpline[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoSpline[HMR].source;
    set(GeoSpline[HMR].source, module2.default[HMR].original);
  });
}
var GeoSpline_default = GeoSpline;

// node_modules/d3-tile/src/tile.js
function defaultScale(t) {
  return t.k;
}
function defaultTranslate(t) {
  return [t.x, t.y];
}
function constant3(x4) {
  return function() {
    return x4;
  };
}
function tile_default() {
  let x06 = 0, y06 = 0, x12 = 960, y12 = 500;
  let clampX = true, clampY = true;
  let tileSize = 256;
  let scale2 = defaultScale;
  let translate = defaultTranslate;
  let zoomDelta = 0;
  function tile() {
    const scale_ = +scale2.apply(this, arguments);
    const translate_ = translate.apply(this, arguments);
    const z = Math.log2(scale_ / tileSize);
    const z02 = Math.round(Math.max(z + zoomDelta, 0));
    const k3 = Math.pow(2, z - z02) * tileSize;
    const x4 = +translate_[0] - scale_ / 2;
    const y4 = +translate_[1] - scale_ / 2;
    const xmin = Math.max(clampX ? 0 : -Infinity, Math.floor((x06 - x4) / k3));
    const xmax = Math.min(clampX ? 1 << z02 : Infinity, Math.ceil((x12 - x4) / k3));
    const ymin = Math.max(clampY ? 0 : -Infinity, Math.floor((y06 - y4) / k3));
    const ymax = Math.min(clampY ? 1 << z02 : Infinity, Math.ceil((y12 - y4) / k3));
    const tiles = [];
    for (let y5 = ymin; y5 < ymax; ++y5) {
      for (let x5 = xmin; x5 < xmax; ++x5) {
        tiles.push([x5, y5, z02]);
      }
    }
    tiles.translate = [x4 / k3, y4 / k3];
    tiles.scale = k3;
    return tiles;
  }
  tile.size = function(_) {
    return arguments.length ? (x06 = y06 = 0, x12 = +_[0], y12 = +_[1], tile) : [x12 - x06, y12 - y06];
  };
  tile.extent = function(_) {
    return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], tile) : [[x06, y06], [x12, y12]];
  };
  tile.scale = function(_) {
    return arguments.length ? (scale2 = typeof _ === "function" ? _ : constant3(+_), tile) : scale2;
  };
  tile.translate = function(_) {
    return arguments.length ? (translate = typeof _ === "function" ? _ : constant3([+_[0], +_[1]]), tile) : translate;
  };
  tile.zoomDelta = function(_) {
    return arguments.length ? (zoomDelta = +_, tile) : zoomDelta;
  };
  tile.tileSize = function(_) {
    return arguments.length ? (tileSize = +_, tile) : tileSize;
  };
  tile.clamp = function(_) {
    return arguments.length ? (clampX = clampY = !!_, tile) : clampX && clampY;
  };
  tile.clampX = function(_) {
    return arguments.length ? (clampX = !!_, tile) : clampX;
  };
  tile.clampY = function(_) {
    return arguments.length ? (clampY = !!_, tile) : clampY;
  };
  return tile;
}

// node_modules/layerchart/dist/components/TileImage.svelte
TileImage[FILENAME] = "node_modules/layerchart/dist/components/TileImage.svelte";
var tileCache = /* @__PURE__ */ new Map();
var root_118 = add_locations(from_svg(`<image></image><image></image>`, 1), TileImage[FILENAME], [[132, 2], [140, 2]]);
var root_210 = add_locations(from_svg(`<rect class="stroke-danger/50 fill-none"></rect><!>`, 1), TileImage[FILENAME], [[150, 2]]);
var root23 = add_locations(from_svg(`<!><!>`, 1), TileImage[FILENAME], []);
function TileImage($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TileImage);
  let disableCache = prop($$props, "disableCache", 3, false), debug = prop($$props, "debug", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "z",
      "tx",
      "ty",
      "scale",
      "disableCache",
      "debug",
      "url"
    ],
    "restProps"
  );
  let href = tag(state(proxy(disableCache() ? $$props.url($$props.x, $$props.y, $$props.z) : "")), "href");
  function loadImage(url) {
    const key2 = url;
    if (tileCache.has(key2)) {
      tileCache.get(key2)?.then((dataUri) => {
        set(href, dataUri, true);
      }).catch(() => {
      });
    } else {
      const promise = new Promise((resolve, reject2) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = function() {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          canvas.height = this.naturalHeight;
          canvas.width = this.naturalWidth;
          context.drawImage(this, 0, 0);
          var dataUri = canvas.toDataURL("image/jpeg");
          set(href, dataUri, true);
          resolve(dataUri);
        };
        img.onerror = (err) => {
          tileCache.delete(key2);
          reject2(err);
        };
        img.src = url;
      });
      tileCache.set(key2, promise);
    }
  }
  user_effect(() => {
    if (disableCache()) return;
    loadImage($$props.url($$props.x, $$props.y, $$props.z));
  });
  var fragment = root23();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => get(href), ($$anchor2) => {
      var fragment_1 = root_118();
      var image = first_child(fragment_1);
      attribute_effect(
        image,
        ($0) => ({
          href: get(href),
          x: ($$props.x + $$props.tx) * $$props.scale - 0.5,
          y: ($$props.y + $$props.ty) * $$props.scale - 0.5,
          width: $$props.scale + 1,
          height: $$props.scale + 1,
          ...$0
        }),
        [() => extractLayerProps(restProps, "tile-image-lower")]
      );
      var image_1 = sibling(image);
      attribute_effect(
        image_1,
        ($0) => ({
          href: get(href),
          x: ($$props.x + $$props.tx) * $$props.scale,
          y: ($$props.y + $$props.ty) * $$props.scale,
          width: $$props.scale,
          height: $$props.scale,
          ...$0
        }),
        [() => extractLayerProps(restProps, "tile-image")]
      );
      append($$anchor2, fragment_1);
    }),
    "key",
    TileImage,
    131,
    0
  );
  var node_1 = sibling(node);
  {
    var consequent = ($$anchor2) => {
      var fragment_2 = root_210();
      var rect = first_child(fragment_2);
      var node_2 = sibling(rect);
      {
        let $0 = user_derived(() => ($$props.x + $$props.tx) * $$props.scale);
        let $1 = user_derived(() => ($$props.y + $$props.ty) * $$props.scale);
        add_svelte_meta(
          () => Text_default(node_2, {
            get x() {
              return get($0);
            },
            get y() {
              return get($1);
            },
            verticalAnchor: "start",
            dx: 2,
            dy: -2,
            get value() {
              return `${$$props.x ?? ""}-${$$props.y ?? ""}-${$$props.z ?? ""}`;
            },
            class: "text-[8px] fill-black/50"
          }),
          "component",
          TileImage,
          157,
          2,
          { componentTag: "Text" }
        );
      }
      template_effect(() => {
        set_attribute(rect, "x", ($$props.x + $$props.tx) * $$props.scale);
        set_attribute(rect, "y", ($$props.y + $$props.ty) * $$props.scale);
        set_attribute(rect, "width", $$props.scale);
        set_attribute(rect, "height", $$props.scale);
      });
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (debug()) $$render(consequent);
      }),
      "if",
      TileImage,
      149,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TileImage = hmr(TileImage, () => TileImage[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = TileImage[HMR].source;
    set(TileImage[HMR].source, module2.default[HMR].original);
  });
}
var TileImage_default = TileImage;

// node_modules/layerchart/dist/components/GeoTile.svelte
GeoTile[FILENAME] = "node_modules/layerchart/dist/components/GeoTile.svelte";
function GeoTile($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoTile);
  let zoomDelta = prop($$props, "zoomDelta", 3, 0), tileSize = prop($$props, "tileSize", 3, 256), disableCache = prop($$props, "disableCache", 3, false), debug = prop($$props, "debug", 3, false);
  const ctx = getChartContext();
  const geoCtx = getGeoContext();
  const renderCtx = getRenderContext();
  const center2 = tag(user_derived(() => geoCtx.projection?.([0, 0]) ?? [0, 0]), "center");
  const tiles = tag(
    user_derived(() => tile_default().size([ctx.containerWidth, ctx.containerHeight]).translate([
      get(center2)[0] + ctx.padding.left,
      get(center2)[1] + ctx.padding.top
    ]).scale(geoCtx.projection ? geoCtx.projection.scale() * 2 * Math.PI : void 0).tileSize(tileSize()).zoomDelta(zoomDelta())()),
    "tiles"
  );
  const translate = tag(user_derived(() => get(tiles).translate), "translate");
  const scale2 = tag(user_derived(() => get(tiles).scale), "scale");
  function render2(ctx2) {
    for (const [x4, y4, z] of get(tiles)) {
      const image = new Image();
      image.onload = () => {
        ctx2.drawImage(image, (x4 + get(translate)[0]) * get(scale2), (y4 + get(translate)[1]) * get(scale2), get(scale2), get(scale2));
      };
      image.src = $$props.url(x4, y4, z);
    }
  }
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({ name: "GeoTile", render: render2, deps: () => [get(tiles)] });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.children, () => ({ tiles: get(tiles) })), "render", GeoTile, 104, 4);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            let $0 = user_derived(() => -ctx.padding.left);
            let $1 = user_derived(() => -ctx.padding.top);
            let $2 = user_derived(() => extractLayerProps($$props.group, "geo-tile-group"));
            add_svelte_meta(
              () => Group_default(node_3, spread_props(
                {
                  get x() {
                    return get($0);
                  },
                  get y() {
                    return get($1);
                  }
                },
                () => get($2),
                {
                  children: wrap_snippet(GeoTile, ($$anchor4, $$slotProps) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    validate_each_keys(() => get(tiles), ([x4, y4, z]) => $$props.url(x4, y4, z));
                    add_svelte_meta(
                      () => each(node_4, 17, () => get(tiles), ([x4, y4, z]) => $$props.url(x4, y4, z), ($$anchor5, $$item) => {
                        var $$array = user_derived(() => to_array(get($$item), 3));
                        let x4 = () => get($$array)[0];
                        x4();
                        let y4 = () => get($$array)[1];
                        y4();
                        let z = () => get($$array)[2];
                        z();
                        var fragment_5 = comment();
                        var node_5 = first_child(fragment_5);
                        add_svelte_meta(
                          () => TileImage_default(node_5, {
                            get url() {
                              return $$props.url;
                            },
                            get x() {
                              return x4();
                            },
                            get y() {
                              return y4();
                            },
                            get z() {
                              return z();
                            },
                            get tx() {
                              return get(translate)[0];
                            },
                            get ty() {
                              return get(translate)[1];
                            },
                            get scale() {
                              return get(scale2);
                            },
                            get disableCache() {
                              return disableCache();
                            },
                            get debug() {
                              return debug();
                            }
                          }),
                          "component",
                          GeoTile,
                          112,
                          8,
                          { componentTag: "TileImage" }
                        );
                        append($$anchor5, fragment_5);
                      }),
                      "each",
                      GeoTile,
                      111,
                      6
                    );
                    append($$anchor4, fragment_4);
                  }),
                  $$slots: { default: true }
                }
              )),
              "component",
              GeoTile,
              106,
              4,
              { componentTag: "Group" }
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.children) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          GeoTile,
          103,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg") && $$props.url) $$render(consequent_1);
      }),
      "if",
      GeoTile,
      102,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoTile = hmr(GeoTile, () => GeoTile[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoTile[HMR].source;
    set(GeoTile[HMR].source, module2.default[HMR].original);
  });
}
var GeoTile_default = GeoTile;

// node_modules/layerchart/dist/components/GeoVisible.svelte
GeoVisible[FILENAME] = "node_modules/layerchart/dist/components/GeoVisible.svelte";
function GeoVisible($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoVisible);
  const geoCtx = getGeoContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", GeoVisible, 22, 2);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (geoCtx.projection && isVisible(geoCtx.projection)([$$props.long, $$props.lat])) $$render(consequent);
      }),
      "if",
      GeoVisible,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GeoVisible = hmr(GeoVisible, () => GeoVisible[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = GeoVisible[HMR].source;
    set(GeoVisible[HMR].source, module2.default[HMR].original);
  });
}
var GeoVisible_default = GeoVisible;

// node_modules/layerchart/dist/components/Graticule.svelte
Graticule[FILENAME] = "node_modules/layerchart/dist/components/Graticule.svelte";
var root_119 = add_locations(from_html(`<!> <!> <!>`, 1), Graticule[FILENAME], []);
function Graticule($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Graticule);
  let step = prop($$props, "step", 19, () => [10, 10]), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "lines",
      "outline",
      "step"
    ],
    "restProps"
  );
  const graticule2 = graticule();
  user_effect(() => {
    graticule2.step(step());
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => layerClass("graticule-g"));
    add_svelte_meta(
      () => Group_default(node, {
        get class() {
          return get($0);
        },
        children: wrap_snippet(Graticule, ($$anchor2, $$slotProps) => {
          var fragment_1 = root_119();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                let $02 = user_derived(graticule2);
                let $1 = user_derived(() => extractLayerProps(restProps, "graticule-geo-path"));
                add_svelte_meta(
                  () => GeoPath_default(node_2, spread_props(
                    {
                      get geojson() {
                        return get($02);
                      }
                    },
                    () => get($1)
                  )),
                  "component",
                  Graticule,
                  33,
                  4,
                  { componentTag: "GeoPath" }
                );
              }
              append($$anchor3, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (!$$props.lines && !$$props.outline) $$render(consequent);
              }),
              "if",
              Graticule,
              32,
              2
            );
          }
          var node_3 = sibling(node_1, 2);
          {
            var consequent_1 = ($$anchor3) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              add_svelte_meta(
                () => each(node_4, 17, () => graticule2.lines(), index, ($$anchor4, line) => {
                  var fragment_4 = comment();
                  var node_5 = first_child(fragment_4);
                  {
                    let $02 = user_derived(() => extractLayerProps($$props.lines, "graticule-geo-line"));
                    add_svelte_meta(
                      () => GeoPath_default(node_5, spread_props(
                        {
                          get geojson() {
                            return get(line);
                          }
                        },
                        () => get($02)
                      )),
                      "component",
                      Graticule,
                      38,
                      6,
                      { componentTag: "GeoPath" }
                    );
                  }
                  append($$anchor4, fragment_4);
                }),
                "each",
                Graticule,
                37,
                4
              );
              append($$anchor3, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if ($$props.lines) $$render(consequent_1);
              }),
              "if",
              Graticule,
              36,
              2
            );
          }
          var node_6 = sibling(node_3, 2);
          {
            var consequent_2 = ($$anchor3) => {
              var fragment_5 = comment();
              var node_7 = first_child(fragment_5);
              {
                let $02 = user_derived(() => graticule2.outline());
                let $1 = user_derived(() => extractLayerProps($$props.outline, "graticule-geo-outline"));
                add_svelte_meta(
                  () => GeoPath_default(node_7, spread_props(
                    {
                      get geojson() {
                        return get($02);
                      }
                    },
                    () => get($1)
                  )),
                  "component",
                  Graticule,
                  43,
                  4,
                  { componentTag: "GeoPath" }
                );
              }
              append($$anchor3, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_6, ($$render) => {
                if ($$props.outline) $$render(consequent_2);
              }),
              "if",
              Graticule,
              42,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      Graticule,
      30,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Graticule = hmr(Graticule, () => Graticule[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Graticule[HMR].source;
    set(Graticule[HMR].source, module2.default[HMR].original);
  });
}
var Graticule_default = Graticule;

// node_modules/layerchart/dist/components/Hull.svelte
Hull[FILENAME] = "node_modules/layerchart/dist/components/Hull.svelte";
function Hull($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hull);
  let curve = prop($$props, "curve", 3, linearClosed_default), classes = prop($$props, "classes", 19, () => ({})), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "curve",
      "classes",
      "onpointermove",
      "onclick",
      "onpointerleave",
      "class",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const ctx = getChartContext();
  const geoCtx = getGeoContext();
  const points = tag(
    user_derived(() => ($$props.data ?? ctx.flatData).map((d) => {
      const xValue = ctx.x(d);
      const yValue = ctx.y(d);
      const x4 = Array.isArray(xValue) ? min(xValue) : xValue;
      const y4 = Array.isArray(yValue) ? min(yValue) : yValue;
      const point10 = [x4, y4];
      point10.data = d;
      return point10;
    })),
    "points"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => cls(layerClass("hull-g"), classes().root, $$props.class));
    add_svelte_meta(
      () => Group_default(node, spread_props(() => restProps, {
        get class() {
          return get($0);
        },
        get ref() {
          return get(ref);
        },
        set ref($$value) {
          set(ref, $$value, true);
        },
        children: wrap_snippet(Hull, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var fragment_2 = comment();
              const polygon2 = tag(user_derived(() => geoVoronoi().hull(get(points))), "polygon");
              get(polygon2);
              var node_2 = first_child(fragment_2);
              {
                let $02 = user_derived(() => cls(layerClass("hull-path"), "fill-transparent", classes().path));
                add_svelte_meta(
                  () => GeoPath_default(node_2, {
                    get geojson() {
                      return get(polygon2);
                    },
                    get curve() {
                      return curve();
                    },
                    get class() {
                      return get($02);
                    },
                    onclick: (e) => $$props.onclick?.(e, { points: get(points), polygon: get(polygon2) }),
                    onpointermove: (e) => $$props.onpointermove?.(e, { points: get(points), polygon: get(polygon2) }),
                    get onpointerleave() {
                      return $$props.onpointerleave;
                    }
                  }),
                  "component",
                  Hull,
                  110,
                  4,
                  { componentTag: "GeoPath" }
                );
              }
              append($$anchor3, fragment_2);
            };
            var alternate = ($$anchor3) => {
              var fragment_3 = comment();
              const delaunay = tag(user_derived(() => Delaunay.from(get(points))), "delaunay");
              get(delaunay);
              const polygon2 = tag(user_derived(() => get(delaunay).hullPolygon()), "polygon");
              get(polygon2);
              var node_3 = first_child(fragment_3);
              {
                let $02 = user_derived(() => cls(layerClass("hull-class"), "fill-transparent", classes().path));
                add_svelte_meta(
                  () => Spline_default(node_3, {
                    get data() {
                      return get(polygon2);
                    },
                    x: (d) => d[0],
                    y: (d) => d[1],
                    get curve() {
                      return curve();
                    },
                    get class() {
                      return get($02);
                    },
                    onclick: (e) => $$props.onclick?.(e, { points: get(points), polygon: get(polygon2) }),
                    onpointermove: (e) => $$props.onpointermove?.(e, { points: get(points), polygon: get(polygon2) }),
                    get onpointerleave() {
                      return $$props.onpointerleave;
                    }
                  }),
                  "component",
                  Hull,
                  121,
                  4,
                  { componentTag: "Spline" }
                );
              }
              append($$anchor3, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (geoCtx.projection) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Hull,
              108,
              2
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      })),
      "component",
      Hull,
      107,
      0,
      { componentTag: "Group" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Hull = hmr(Hull, () => Hull[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Hull[HMR].source;
    set(Hull[HMR].source, module2.default[HMR].original);
  });
}
var Hull_default = Hull;

// node_modules/layerchart/dist/components/MotionPath.svelte
MotionPath[FILENAME] = "node_modules/layerchart/dist/components/MotionPath.svelte";
var root24 = add_locations(from_svg(`<defs><animateMotion><mpath></mpath></animateMotion></defs><!>`, 1), MotionPath[FILENAME], [[95, 0, [[96, 2, [[105, 4]]]]]]);
function MotionPath($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, MotionPath);
  let pathId = prop($$props, "pathId", 19, () => createId("motionPathId-", uid)), objectId2 = prop($$props, "objectId", 19, () => createId("motionObjectId-", uid)), fill2 = prop($$props, "fill", 3, "freeze"), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "pathId",
      "objectId",
      "duration",
      "repeatCount",
      "fill",
      "rotate",
      "ref",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  user_effect(() => {
    if (!get(ref)) return;
    get(ref).beginElement();
  });
  var fragment = root24();
  var defs = first_child(fragment);
  var animateMotion = child(defs);
  attribute_effect(
    animateMotion,
    ($0) => ({
      href: `#${objectId2() ?? ""}`,
      dur: $$props.duration,
      repeatCount: $$props.repeatCount,
      fill: fill2(),
      rotate: $$props.rotate,
      ...$0
    }),
    [() => extractLayerProps(restProps, "motion-path")]
  );
  var mpath = child(animateMotion);
  reset(animateMotion);
  bind_this(animateMotion, ($$value) => set(ref, $$value), () => get(ref));
  reset(defs);
  var node = sibling(defs);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ pathId: pathId(), objectId: objectId2() })), "render", MotionPath, 109, 0);
  template_effect(() => set_attribute(mpath, "href", `#${pathId() ?? ""}`));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MotionPath = hmr(MotionPath, () => MotionPath[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = MotionPath[HMR].source;
    set(MotionPath[HMR].source, module2.default[HMR].original);
  });
}
var MotionPath_default = MotionPath;

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum7 = 0, children = node.children, i = children && children.length;
  if (!i) sum7 = 1;
  else while (--i >= 0) sum7 += children[i].value;
  node.value = sum7;
}
function count_default() {
  return this.eachAfter(count2);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index4 = -1;
  for (const node of this) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index4 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index4, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index4 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default3(callback, that) {
  let index4 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index4, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default2(value2) {
  return this.eachAfter(function(node) {
    var sum7 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0) sum7 += children[i].value;
    node.value = sum7;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k3 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k3, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a5, b) {
  if (a5 === b) return a5;
  var aNodes = a5.ancestors(), bNodes = b.ancestors(), c3 = null;
  a5 = aNodes.pop();
  b = bNodes.pop();
  while (a5 === b) {
    c3 = a5;
    a5 = aNodes.pop();
    b = bNodes.pop();
  }
  return c3;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root26 = this, links = [];
  root26.each(function(node) {
    if (node !== root26) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root26 = new Node(data), node, nodes = [root26], child2, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child2 = childs[i] = new Node(childs[i]));
        child2.parent = node;
        child2.depth = node.depth + 1;
      }
    }
  }
  return root26.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default3,
  sum: sum_default2,
  sort: sort_default,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function") throw new Error();
  return f2;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default6(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a3 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s3 = 1;
  return () => (s3 = (a3 * s3 + c2) % m2) / m2;
}

// node_modules/d3-hierarchy/src/array.js
function array_default3(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}
function shuffle2(array3, random2) {
  let m3 = array3.length, t, i;
  while (m3) {
    i = random2() * m3-- | 0;
    t = array3[m3];
    array3[m3] = array3[i];
    array3[i] = t;
  }
  return array3;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random2) {
  var i = 0, n = (circles = shuffle2(Array.from(circles), random2)).length, B3 = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;
  }
  return e;
}
function extendBasis(B3, p) {
  var i, j;
  if (enclosesWeakAll(p, B3)) return [p];
  for (i = 0; i < B3.length; ++i) {
    if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {
      return [B3[i], p];
    }
  }
  for (i = 0; i < B3.length - 1; ++i) {
    for (j = i + 1; j < B3.length; ++j) {
      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {
        return [B3[i], B3[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a5, b) {
  var dr = a5.r - b.r, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a5, b) {
  var dr = a5.r - b.r + Math.max(a5.r, b.r, 1) * 1e-9, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a5, B3) {
  for (var i = 0; i < B3.length; ++i) {
    if (!enclosesWeak(a5, B3[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B3) {
  switch (B3.length) {
    case 1:
      return encloseBasis1(B3[0]);
    case 2:
      return encloseBasis2(B3[0], B3[1]);
    case 3:
      return encloseBasis3(B3[0], B3[1], B3[2]);
  }
}
function encloseBasis1(a5) {
  return {
    x: a5.x,
    y: a5.y,
    r: a5.r
  };
}
function encloseBasis2(a5, b) {
  var x12 = a5.x, y12 = a5.y, r1 = a5.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a5, b, c3) {
  var x12 = a5.x, y12 = a5.y, r1 = a5.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c3.x, y32 = c3.y, r3 = c3.r, a22 = x12 - x22, a32 = x12 - x32, b2 = y12 - y22, b3 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (ab4 * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a5, c3) {
  var dx = b.x - a5.x, x4, a22, dy = b.y - a5.y, y4, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a5.r + c3.r, a22 *= a22;
    b2 = b.r + c3.r, b2 *= b2;
    if (a22 > b2) {
      x4 = (d2 + b2 - a22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, b2 / d2 - x4 * x4));
      c3.x = b.x - x4 * dx - y4 * dy;
      c3.y = b.y - x4 * dy + y4 * dx;
    } else {
      x4 = (d2 + a22 - b2) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));
      c3.x = a5.x + x4 * dx - y4 * dy;
      c3.y = a5.y + x4 * dy + y4 * dx;
    }
  } else {
    c3.x = a5.x + c3.r;
    c3.y = a5.y;
  }
}
function intersects(a5, b) {
  var dr = a5.r + b.r - 1e-6, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a5 = node._, b = node.next._, ab4 = a5.r + b.r, dx = (a5.x * b.r + b.x * a5.r) / ab4, dy = (a5.y * b.r + b.y * a5.r) / ab4;
  return dx * dx + dy * dy;
}
function Node2(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random2) {
  if (!(n = (circles = array_default3(circles)).length)) return 0;
  var a5, b, c3, n, aa2, ca3, i, j, k3, sj, sk;
  a5 = circles[0], a5.x = 0, a5.y = 0;
  if (!(n > 1)) return a5.r;
  b = circles[1], a5.x = -b.r, b.x = a5.r, b.y = 0;
  if (!(n > 2)) return a5.r + b.r;
  place(b, a5, c3 = circles[2]);
  a5 = new Node2(a5), b = new Node2(b), c3 = new Node2(c3);
  a5.next = c3.previous = b;
  b.next = a5.previous = c3;
  c3.next = b.previous = a5;
  pack: for (i = 3; i < n; ++i) {
    place(a5._, b._, c3 = circles[i]), c3 = new Node2(c3);
    j = b.next, k3 = a5.previous, sj = b._.r, sk = a5._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c3._)) {
          b = j, a5.next = b, b.previous = a5, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k3._, c3._)) {
          a5 = k3, a5.next = b, b.previous = a5, --i;
          continue pack;
        }
        sk += k3._.r, k3 = k3.previous;
      }
    } while (j !== k3.next);
    c3.previous = a5, c3.next = b, a5.next = b.previous = b = c3;
    aa2 = score(a5);
    while ((c3 = c3.next) !== b) {
      if ((ca3 = score(c3)) < aa2) {
        a5 = c3, aa2 = ca3;
      }
    }
    b = a5.next;
  }
  a5 = [b._], c3 = b;
  while ((c3 = c3.next) !== b) a5.push(c3._);
  c3 = packEncloseRandom(a5, random2);
  for (i = 0; i < n; ++i) a5 = circles[i], a5.x -= c3.x, a5.y -= c3.y;
  return c3.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root26) {
    const random2 = lcg_default2();
    root26.x = dx / 2, root26.y = dy / 2;
    if (radius) {
      root26.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random2)).eachBefore(translateChild(1));
    } else {
      root26.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random2)).eachAfter(packChildrenRandom(padding, root26.r / Math.min(dx, dy), random2)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root26.r)));
    }
    return root26;
  }
  pack.radius = function(x4) {
    return arguments.length ? (radius = optional(x4), pack) : radius;
  };
  pack.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];
  };
  pack.padding = function(x4) {
    return arguments.length ? (padding = typeof x4 === "function" ? x4 : constant_default6(+x4), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k3, random2) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding(node) * k3 || 0, e;
      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packSiblingsRandom(children, random2);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k3) {
  return function(node) {
    var parent2 = node.parent;
    node.r *= k3;
    if (parent2) {
      node.x = parent2.x + k3 * node.x;
      node.y = parent2.y + k3 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default3(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent2, x06, y06, x12, y12) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k3 = parent2.value && (x12 - x06) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y06, node.y1 = y12;
    node.x0 = x06, node.x1 = x06 += node.value * k3;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default2() {
  var dx = 1, dy = 1, padding = 0, round3 = false;
  function partition2(root26) {
    var n = root26.height + 1;
    root26.x0 = root26.y0 = padding;
    root26.x1 = dx;
    root26.y1 = dy / n;
    root26.eachBefore(positionNode(dy, n));
    if (round3) root26.eachBefore(round_default3);
    return root26;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition2.round = function(x4) {
    return arguments.length ? (round3 = !!x4, partition2) : round3;
  };
  partition2.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x4) {
    return arguments.length ? (padding = +x4, partition2) : padding;
  };
  return partition2;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation(a5, b) {
  return a5.parent === b.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children = v2.children;
  return children ? children[0] : v2.t;
}
function nextRight(v2) {
  var children = v2.children;
  return children ? children[children.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children = v2.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root26) {
  var tree = new TreeNode(root26, 0), node, nodes = [tree], child2, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child2 = node.children[i] = new TreeNode(children[i], i));
        child2.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root26) {
    var t = treeRoot(root26);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root26.eachBefore(sizeNode);
    else {
      var left2 = root26, right2 = root26, bottom = root26;
      root26.eachBefore(function(node) {
        if (node.x < left2.x) left2 = node;
        if (node.x > right2.x) right2 = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx3 = dx / (right2.x + s3 + tx), ky3 = dy / (bottom.depth || 1);
      root26.eachBefore(function(node) {
        node.x = (node.x + tx) * kx3;
        node.y = node.depth * ky3;
      });
    }
    return root26;
  }
  function firstWalk(v2) {
    var children = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;
    if (children) {
      executeShifts(v2);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v2.z = w.z + separation(v2._, w._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w) {
      v2.z = w.z + separation(v2._, w._);
    }
    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w, ancestor) {
    if (w) {
      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x4) {
    return arguments.length ? (separation = x4, tree) : separation;
  };
  tree.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default2(parent2, x06, y06, x12, y12) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k3 = parent2.value && (y12 - y06) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x06, node.x1 = x12;
    node.y0 = y06, node.y1 = y06 += node.value * k3;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent2, x06, y06, x12, y12) {
  var rows = [], nodes = parent2.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent2.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x06, dy = y12 - y06;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) dice_default(row, x06, y06, x12, value2 ? y06 += dy * sumValue / value2 : y12);
    else slice_default2(row, x06, y06, value2 ? x06 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent2, x06, y06, x12, y12) {
    squarifyRatio(ratio, parent2, x06, y06, x12, y12);
  }
  squarify.ratio = function(x4) {
    return custom8((x4 = +x4) > 1 ? x4 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round3 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root26) {
    root26.x0 = root26.y0 = 0;
    root26.x1 = dx;
    root26.y1 = dy;
    root26.eachBefore(positionNode);
    paddingStack = [0];
    if (round3) root26.eachBefore(round_default3);
    return root26;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
    if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
    if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
    node.x0 = x06;
    node.y0 = y06;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x06 += paddingLeft(node) - p;
      y06 += paddingTop(node) - p;
      x12 -= paddingRight(node) - p;
      y12 -= paddingBottom(node) - p;
      if (x12 < x06) x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06) y06 = y12 = (y06 + y12) / 2;
      tile(node, x06, y06, x12, y12);
    }
  }
  treemap.round = function(x4) {
    return arguments.length ? (round3 = !!x4, treemap) : round3;
  };
  treemap.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x4) {
    return arguments.length ? (tile = required(x4), treemap) : tile;
  };
  treemap.padding = function(x4) {
    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x4) {
    return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x4) {
    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x4) {
    return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x4) {
    return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x4) {
    return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x4) {
    return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent2, x06, y06, x12, y12) {
  var nodes = parent2.children, i, n = nodes.length, sum7, sums = new Array(n + 1);
  for (sums[0] = sum7 = i = 0; i < n; ++i) {
    sums[i + 1] = sum7 += nodes[i].value;
  }
  partition2(0, n, parent2.value, x06, y06, x12, y12);
  function partition2(i2, j, value2, x07, y07, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x07, node.y0 = y07;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k3 = i2 + 1, hi = j - 1;
    while (k3 < hi) {
      var mid = k3 + hi >>> 1;
      if (sums[mid] < valueTarget) k3 = mid + 1;
      else hi = mid;
    }
    if (valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3) --k3;
    var valueLeft = sums[k3] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x07 > y13 - y07) {
      var xk = value2 ? (x07 * valueRight + x13 * valueLeft) / value2 : x13;
      partition2(i2, k3, valueLeft, x07, y07, xk, y13);
      partition2(k3, j, valueRight, xk, y07, x13, y13);
    } else {
      var yk = value2 ? (y07 * valueRight + y13 * valueLeft) / value2 : y13;
      partition2(i2, k3, valueLeft, x07, y07, x13, yk);
      partition2(k3, j, valueRight, x07, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent2, x06, y06, x12, y12) {
  (parent2.depth & 1 ? slice_default2 : dice_default)(parent2, x06, y06, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent2, x06, y06, x12, y12) {
    if ((rows = parent2._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value2 = parent2.value;
      while (++j < m3) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) dice_default(row, x06, y06, x12, value2 ? y06 += (y12 - y06) * row.value / value2 : y12);
        else slice_default2(row, x06, y06, value2 ? x06 += (x12 - x06) * row.value / value2 : x12, y12);
        value2 -= row.value;
      }
    } else {
      parent2._squarify = rows = squarifyRatio(ratio, parent2, x06, y06, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x4) {
    return custom9((x4 = +x4) > 1 ? x4 : 1);
  };
  return resquarify;
}(phi);

// node_modules/layerchart/dist/components/Pack.svelte
Pack[FILENAME] = "node_modules/layerchart/dist/components/Pack.svelte";
function Pack($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pack);
  const ctx = getChartContext();
  let nodes = prop($$props, "nodes", 15);
  const packedData = tag(
    user_derived(() => {
      const h = $$props.hierarchy.copy();
      const _pack = pack_default().size($$props.size ?? [ctx.width, ctx.height]);
      if ($$props.padding) {
        _pack.padding($$props.padding);
      }
      return _pack(h).descendants();
    }),
    "packedData"
  );
  user_pre_effect(() => {
    nodes(get(packedData));
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ nodes: get(packedData) })), "render", Pack, 61, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pack = hmr(Pack, () => Pack[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Pack[HMR].source;
    set(Pack[HMR].source, module2.default[HMR].original);
  });
}
var Pack_default = Pack;

// node_modules/layerchart/dist/components/Partition.svelte
Partition[FILENAME] = "node_modules/layerchart/dist/components/Partition.svelte";
function Partition($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Partition);
  let orientation = prop($$props, "orientation", 3, "horizontal"), nodes = prop($$props, "nodes", 15);
  const ctx = getChartContext();
  const partitionData = tag(
    user_derived(() => {
      const h = $$props.hierarchy.copy();
      const _partition = partition_default2().size($$props.size ?? (strict_equals(orientation(), "horizontal") ? [ctx.height, ctx.width] : [ctx.width, ctx.height]));
      if ($$props.padding) {
        _partition.padding($$props.padding);
      }
      if ($$props.round) {
        _partition.round($$props.round);
      }
      return _partition(h).descendants();
    }),
    "partitionData"
  );
  user_pre_effect(() => {
    nodes(get(partitionData));
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ nodes: get(partitionData) })), "render", Partition, 84, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Partition = hmr(Partition, () => Partition[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Partition[HMR].source;
    set(Partition[HMR].source, module2.default[HMR].original);
  });
}
var Partition_default = Partition;

// node_modules/layerchart/dist/components/Point.svelte
Point[FILENAME] = "node_modules/layerchart/dist/components/Point.svelte";
function Point($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Point);
  const ctx = getChartContext();
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => ({ x: ctx.xGet($$props.d), y: ctx.yGet($$props.d) }));
    add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => get($0)), "render", Point, 25, 0);
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Point = hmr(Point, () => Point[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Point[HMR].source;
    set(Point[HMR].source, module2.default[HMR].original);
  });
}
var Point_default = Point;

// node_modules/layerchart/dist/utils/shape.js
function polygonPoints(count4, radius, rotate = 0) {
  const angle = 360 / count4;
  return range(count4).map((index4) => {
    return {
      angle: degreesToRadians(angle * index4) + degreesToRadians(rotate),
      radius
    };
  });
}
function polygon(options) {
  const { cx, cy, count: count4, radius, rotate = 0, inset = 1, scaleX = 1, scaleY = 1, skewX = 0, skewY = 0, tiltX = 0, tiltY = 0 } = options;
  const skewXRad = degreesToRadians(skewX);
  const skewYRad = degreesToRadians(skewY);
  return polygonPoints(count4, radius, rotate).map(({ angle, radius: radius2 }, i) => {
    const insetScale = i % 2 == 0 ? 1 : 1 - inset;
    let x4 = radius2 * insetScale * Math.cos(angle) * scaleX;
    let y4 = radius2 * insetScale * Math.sin(angle) * scaleY;
    const normalizedY = (y4 + radius2) / (2 * radius2);
    const normalizedX = (x4 + radius2) / (2 * radius2);
    const tiltScaleX = tiltX > 0 ? 1 + tiltX * (1 - normalizedY) : 1 - tiltX * normalizedY;
    const tiltScaleY = tiltY > 0 ? 1 + tiltY * (1 - normalizedX) : 1 - tiltY * normalizedX;
    x4 *= tiltScaleX;
    y4 *= tiltScaleY;
    const xSkewed = x4 + Math.tan(skewXRad) * y4;
    const ySkewed = y4 + Math.tan(skewYRad) * x4;
    return {
      x: cx + xSkewed,
      y: cy + ySkewed
    };
  });
}

// node_modules/layerchart/dist/components/Polygon.svelte
Polygon2[FILENAME] = "node_modules/layerchart/dist/components/Polygon.svelte";
var root_120 = add_locations(from_svg(`<path></path>`), Polygon2[FILENAME], [[274, 2]]);
function Polygon2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Polygon2);
  let cx = prop($$props, "cx", 3, 0), cy = prop($$props, "cy", 3, 0), r = prop($$props, "r", 3, 1), points = prop($$props, "points", 3, 4), cornerRadius = prop($$props, "cornerRadius", 3, 0), rotate = prop($$props, "rotate", 3, 0), inset = prop($$props, "inset", 3, 0), scaleX = prop($$props, "scaleX", 3, 1), scaleY = prop($$props, "scaleY", 3, 1), skewX = prop($$props, "skewX", 3, 0), skewY = prop($$props, "skewY", 3, 0), tiltX = prop($$props, "tiltX", 3, 0), tiltY = prop($$props, "tiltY", 3, 0), refProp = prop($$props, "ref", 15), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "cx",
      "initialCx",
      "cy",
      "initialCy",
      "r",
      "initialR",
      "points",
      "cornerRadius",
      "rotate",
      "inset",
      "scaleX",
      "scaleY",
      "skewX",
      "skewY",
      "tiltX",
      "tiltY",
      "motion",
      "fill",
      "fillOpacity",
      "stroke",
      "strokeWidth",
      "opacity",
      "class",
      "ref"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  const initialCx = $$props.initialCx ?? cx();
  const initialCy = $$props.initialCy ?? cy();
  const initialR = $$props.initialR ?? r();
  const motionCx = createMotion(initialCx, () => cx(), $$props.motion);
  const motionCy = createMotion(initialCy, () => cy(), $$props.motion);
  const motionR = createMotion(initialR, () => r(), $$props.motion);
  let polygonPoints2 = tag(
    user_derived(() => strict_equals(typeof points(), "number") ? polygon({
      cx: motionCx.current,
      cy: motionCy.current,
      count: points(),
      radius: motionR.current,
      rotate: rotate(),
      inset: inset(),
      scaleX: scaleX(),
      scaleY: scaleY(),
      skewX: skewX(),
      skewY: skewY(),
      tiltX: tiltX(),
      tiltY: tiltY()
    }) : points()),
    "polygonPoints"
  );
  let d = tag(user_derived(() => roundedPolygonPath(get(polygonPoints2), cornerRadius())), "d");
  const extractedTween = extractTweenConfig($$props.motion);
  const tweenedOptions = extractedTween ? {
    type: extractedTween.type,
    options: { interpolate: interpolatePath, ...extractedTween.options }
  } : void 0;
  const tweenedState = createMotion(null, () => get(d), tweenedOptions);
  const renderCtx = getRenderContext();
  function render2(ctx, styleOverrides) {
    renderPathData(ctx, tweenedState.current, styleOverrides ? merge_default({ styles: { strokeWidth: $$props.strokeWidth } }, styleOverrides) : {
      styles: {
        fill: $$props.fill,
        fillOpacity: $$props.fillOpacity,
        stroke: $$props.stroke,
        strokeWidth: $$props.strokeWidth,
        opacity: $$props.opacity
      },
      classes: cls(layerClass("polygon"), equals($$props.fill, null) && "fill-surface-content", $$props.class)
    });
  }
  const fillKey = createKey(() => $$props.fill);
  const strokeKey = createKey(() => $$props.stroke);
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Polygon",
      render: render2,
      events: {
        click: $$props.onclick,
        pointerenter: $$props.onpointerenter,
        pointermove: $$props.onpointermove,
        pointerleave: $$props.onpointerleave,
        pointerdown: $$props.onpointerdown,
        pointerover: $$props.onpointerover,
        pointerout: $$props.onpointerout,
        touchmove: $$props.ontouchmove
      },
      deps: () => [
        fillKey.current,
        $$props.fillOpacity,
        strokeKey.current,
        $$props.strokeWidth,
        $$props.opacity,
        $$props.class,
        tweenedState.current
      ]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var path3 = root_120();
      attribute_effect(
        path3,
        ($0) => ({
          d: tweenedState.current,
          fill: $$props.fill,
          "fill-opacity": $$props.fillOpacity,
          stroke: $$props.stroke,
          "stroke-width": $$props.strokeWidth,
          opacity: $$props.opacity,
          class: $0,
          ...restProps
        }),
        [
          () => cls(layerClass("polygon"), equals($$props.fill, null) && "fill-surface-content", $$props.class)
        ]
      );
      bind_this(path3, ($$value) => set(ref, $$value), () => get(ref));
      append($$anchor2, path3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "svg")) $$render(consequent);
      }),
      "if",
      Polygon2,
      273,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Polygon2 = hmr(Polygon2, () => Polygon2[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Polygon2[HMR].source;
    set(Polygon2[HMR].source, module2.default[HMR].original);
  });
}
var Polygon_default = Polygon2;

// node_modules/layerchart/dist/components/RadialGradient.svelte
RadialGradient[FILENAME] = "node_modules/layerchart/dist/components/RadialGradient.svelte";
var root_89 = add_locations(from_svg(`<stop></stop>`), RadialGradient[FILENAME], [[178, 12]]);
var root_95 = add_locations(from_svg(`<stop></stop>`), RadialGradient[FILENAME], [[180, 12]]);
var root_317 = add_locations(from_svg(`<defs><radialGradient><!></radialGradient></defs><!>`, 1), RadialGradient[FILENAME], [[159, 2, [[160, 4]]]]);
function RadialGradient($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, RadialGradient);
  let id = prop($$props, "id", 19, () => createId("radialGradient-", uid)), stops = prop($$props, "stops", 19, () => ["var(--tw-gradient-from)", "var(--tw-gradient-to)"]), cx = prop($$props, "cx", 3, "50%"), cy = prop($$props, "cy", 3, "50%"), fx = prop($$props, "fx", 19, cx), fy = prop($$props, "fy", 19, cy), r = prop($$props, "r", 3, "50%"), spreadMethod = prop($$props, "spreadMethod", 3, "pad"), transform2 = prop($$props, "transform", 3, void 0), units = prop($$props, "units", 3, "objectBoundingBox"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "stops",
      "cx",
      "cy",
      "fx",
      "fy",
      "r",
      "spreadMethod",
      "transform",
      "units",
      "children",
      "stopsContent",
      "class"
    ],
    "restProps"
  );
  const ctx = getChartContext();
  const renderCtx = getRenderContext();
  let canvasGradient = tag(state(void 0), "canvasGradient");
  function render2(_ctx) {
    const gradient = _ctx.createRadialGradient(0, 0, 0, 0, 0, 0);
    for (let i = 0; i < stops().length; i++) {
      const stop2 = stops()[i];
      if (Array.isArray(stop2)) {
        const { fill: fill2 } = getComputedStyles(_ctx.canvas, { styles: { fill: stop2[1] }, classes: $$props.class });
        gradient.addColorStop(parsePercent(stop2[0]), fill2);
      } else {
        const { fill: fill2 } = getComputedStyles(_ctx.canvas, { styles: { fill: stop2 }, classes: $$props.class });
        gradient.addColorStop(i / (stops().length - 1), fill2);
      }
    }
    set(canvasGradient, gradient, true);
  }
  if (strict_equals(renderCtx, "canvas")) {
    registerCanvasComponent({
      name: "Gradient",
      render: render2,
      deps: () => [stops(), cx(), cy(), fx(), fy(), ctx.width, ctx.height]
    });
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop, () => ({ id: id(), gradient: get(canvasGradient) })), "render", RadialGradient, 157, 2);
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_3 = root_317();
          var defs = first_child(fragment_3);
          var radialGradient = child(defs);
          attribute_effect(
            radialGradient,
            ($0) => ({
              id: id(),
              cx: cx(),
              cy: cy(),
              fx: fx(),
              fy: fy(),
              r: r(),
              spreadMethod: spreadMethod(),
              gradientTransform: transform2(),
              gradientUnits: units(),
              ...$0
            }),
            [
              () => extractLayerProps({ ...restProps, class: $$props.class }, "radial-gradient")
            ]
          );
          var node_3 = child(radialGradient);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              add_svelte_meta(() => snippet(node_4, () => $$props.stopsContent), "render", RadialGradient, 173, 8);
              append($$anchor4, fragment_4);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_5 = first_child(fragment_5);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_6 = comment();
                  const stopClass = tag(user_derived(() => cls(layerClass("radial-gradient-stop"), $$props.class)), "stopClass");
                  get(stopClass);
                  var node_6 = first_child(fragment_6);
                  add_svelte_meta(
                    () => each(node_6, 17, stops, index, ($$anchor6, stop2, i) => {
                      var fragment_7 = comment();
                      var node_7 = first_child(fragment_7);
                      {
                        var consequent_2 = ($$anchor7) => {
                          var stop_1 = root_89();
                          template_effect(() => {
                            set_attribute(stop_1, "offset", get(stop2)[0]);
                            set_attribute(stop_1, "stop-color", get(stop2)[1]);
                            set_class(stop_1, 0, clsx(get(stopClass)));
                          });
                          append($$anchor7, stop_1);
                        };
                        var alternate = ($$anchor7) => {
                          var stop_2 = root_95();
                          template_effect(() => {
                            set_attribute(stop_2, "offset", `${i * (100 / (stops().length - 1))}%`);
                            set_attribute(stop_2, "stop-color", get(stop2));
                            set_class(stop_2, 0, clsx(get(stopClass)));
                          });
                          append($$anchor7, stop_2);
                        };
                        add_svelte_meta(
                          () => if_block(node_7, ($$render) => {
                            if (Array.isArray(get(stop2))) $$render(consequent_2);
                            else $$render(alternate, false);
                          }),
                          "if",
                          RadialGradient,
                          177,
                          10
                        );
                      }
                      append($$anchor6, fragment_7);
                    }),
                    "each",
                    RadialGradient,
                    176,
                    8
                  );
                  append($$anchor5, fragment_6);
                };
                add_svelte_meta(
                  () => if_block(
                    node_5,
                    ($$render) => {
                      if (stops()) $$render(consequent_3);
                    },
                    true
                  ),
                  "if",
                  RadialGradient,
                  174,
                  6
                );
              }
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(node_3, ($$render) => {
                if ($$props.stopsContent) $$render(consequent_1);
                else $$render(alternate_1, false);
              }),
              "if",
              RadialGradient,
              172,
              6
            );
          }
          reset(radialGradient);
          reset(defs);
          var node_8 = sibling(defs);
          add_svelte_meta(() => snippet(node_8, () => $$props.children ?? noop, () => ({ id: id(), gradient: `url(#${id()})` })), "render", RadialGradient, 187, 2);
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(renderCtx, "svg")) $$render(consequent_4);
            },
            true
          ),
          "if",
          RadialGradient,
          158,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(renderCtx, "canvas")) $$render(consequent);
        else $$render(alternate_2, false);
      }),
      "if",
      RadialGradient,
      156,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RadialGradient = hmr(RadialGradient, () => RadialGradient[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = RadialGradient[HMR].source;
    set(RadialGradient[HMR].source, module2.default[HMR].original);
  });
}
var RadialGradient_default = RadialGradient;

// node_modules/d3-sankey/node_modules/d3-array/src/ascending.js
function ascending_default2(a5, b) {
  return a5 < b ? -1 : a5 > b ? 1 : a5 >= b ? 0 : NaN;
}

// node_modules/d3-sankey/node_modules/d3-array/src/bisector.js
function bisector_default(f2) {
  let delta = f2;
  let compare = f2;
  if (f2.length === 1) {
    delta = (d, x4) => f2(d) - x4;
    compare = ascendingComparator(f2);
  }
  function left2(a5, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a5.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a5[mid], x4) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right2(a5, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a5.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a5[mid], x4) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center2(a5, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a5.length;
    const i = left2(a5, x4, lo, hi - 1);
    return i > lo && delta(a5[i - 1], x4) > -delta(a5[i], x4) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function ascendingComparator(f2) {
  return (d, x4) => ascending_default2(f2(d), x4);
}

// node_modules/d3-sankey/node_modules/d3-array/src/number.js
function number_default2(x4) {
  return x4 === null ? NaN : +x4;
}

// node_modules/d3-sankey/node_modules/d3-array/src/bisect.js
var ascendingBisect2 = bisector_default(ascending_default2);
var bisectRight2 = ascendingBisect2.right;
var bisectLeft2 = ascendingBisect2.left;
var bisectCenter2 = bisector_default(number_default2).center;

// node_modules/d3-sankey/node_modules/d3-array/src/array.js
var array2 = Array.prototype;
var slice4 = array2.slice;
var map5 = array2.map;

// node_modules/d3-sankey/node_modules/d3-array/src/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);

// node_modules/d3-sankey/node_modules/d3-array/src/max.js
function max5(values2, valueof) {
  let max7;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  }
  return max7;
}

// node_modules/d3-sankey/node_modules/d3-array/src/min.js
function min5(values2, valueof) {
  let min7;
  if (valueof === void 0) {
    for (const value2 of values2) {
      if (value2 != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if ((value2 = valueof(value2, ++index4, values2)) != null && (min7 > value2 || min7 === void 0 && value2 >= value2)) {
        min7 = value2;
      }
    }
  }
  return min7;
}

// node_modules/d3-sankey/node_modules/d3-array/src/shuffle.js
var shuffle_default3 = shuffler2(Math.random);
function shuffler2(random2) {
  return function shuffle3(array3, i0 = 0, i1 = array3.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random2() * m3-- | 0, t = array3[m3 + i0];
      array3[m3 + i0] = array3[i + i0];
      array3[i + i0] = t;
    }
    return array3;
  };
}

// node_modules/d3-sankey/node_modules/d3-array/src/sum.js
function sum5(values2, valueof) {
  let sum7 = 0;
  if (valueof === void 0) {
    for (let value2 of values2) {
      if (value2 = +value2) {
        sum7 += value2;
      }
    }
  } else {
    let index4 = -1;
    for (let value2 of values2) {
      if (value2 = +valueof(value2, ++index4, values2)) {
        sum7 += value2;
      }
    }
  }
  return sum7;
}

// node_modules/d3-sankey/src/align.js
function targetDepth(d) {
  return d.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min5(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/d3-sankey/src/constant.js
function constant4(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a5, b) {
  return ascendingBreadth(a5.source, b.source) || a5.index - b.index;
}
function ascendingTargetBreadth(a5, b) {
  return ascendingBreadth(a5.target, b.target) || a5.index - b.index;
}
function ascendingBreadth(a5, b) {
  return a5.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find2(nodeById, id) {
  const node = nodeById.get(id);
  if (!node) throw new Error("missing: " + id);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y06 = node.y0;
    let y12 = y06;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y06 + link3.width / 2;
      y06 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x06 = 0, y06 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id = defaultId;
  let align = justify;
  let sort3;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey() {
    const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id = typeof _ === "function" ? _ : constant4(_), sankey) : id;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant4(_), sankey) : align;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort3 = _, sankey) : sort3;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant4(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant4(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x06 = y06 = 0, x12 = +_[0], y12 = +_[1], sankey) : [x12 - x06, y12 - y06];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x06 = +_[0][0], x12 = +_[1][0], y06 = +_[0][1], y12 = +_[1][1], sankey) : [[x06, y06], [x12, y12]];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    for (const [i, node] of nodes2.entries()) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i) => [id(d, i, nodes2), d]));
    for (const [i, link3] of links2.entries()) {
      link3.index = i;
      let { source, target } = link3;
      if (typeof source !== "object") source = link3.source = find2(nodeById, source);
      if (typeof target !== "object") target = link3.target = find2(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum5(node.sourceLinks, value), sum5(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x4 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x4;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x4 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x4 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x4;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x4 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x4 = max5(nodes2, (d) => d.depth) + 1;
    const kx3 = (x12 - x06 - dx) / (x4 - 1);
    const columns = new Array(x4);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x4 - 1, Math.floor(align.call(null, node, x4))));
      node.layer = i;
      node.x0 = x06 + i * kx3;
      node.x1 = node.x0 + dx;
      if (columns[i]) columns[i].push(node);
      else columns[i] = [node];
    }
    if (sort3) for (const column of columns) {
      column.sort(sort3);
    }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky3 = min5(columns, (c3) => (y12 - y06 - (c3.length - 1) * py) / sum5(c3, value));
    for (const nodes2 of columns) {
      let y4 = y06;
      for (const node of nodes2) {
        node.y0 = y4;
        node.y1 = y4 + node.value * ky3;
        y4 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky3;
        }
      }
      y4 = (y12 - y4 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y4 * (i + 1);
        node.y1 += y4 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y06) / (max5(columns, (c3) => c3.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations2; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (const target of column) {
        let y4 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v2 = value2 * (target.layer - source.layer);
          y4 += targetTop(source, target) * v2;
          w += v2;
        }
        if (!(w > 0)) continue;
        let dy2 = (y4 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort3 === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column = columns[i];
      for (const source of column) {
        let y4 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v2 = value2 * (target.layer - source.layer);
          y4 += sourceTop(source, target) * v2;
          w += v2;
        }
        if (!(w > 0)) continue;
        let dy2 = (y4 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort3 === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y06, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y4, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y4 - node.y0) * alpha;
      if (dy2 > 1e-6) node.y0 += dy2, node.y1 += dy2;
      y4 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y4, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y4) * alpha;
      if (dy2 > 1e-6) node.y0 -= dy2, node.y1 -= dy2;
      y4 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y4 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target) break;
      y4 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source) break;
      y4 -= width;
    }
    return y4;
  }
  function sourceTop(source, target) {
    let y4 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source) break;
      y4 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target) break;
      y4 -= width;
    }
    return y4;
  }
  return sankey;
}

// node_modules/d3-sankey/node_modules/d3-path/src/path.js
var pi5 = Math.PI;
var tau6 = 2 * pi5;
var epsilon6 = 1e-6;
var tauEpsilon2 = tau6 - epsilon6;
function Path3() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path2() {
  return new Path3();
}
Path3.prototype = path2.prototype = {
  constructor: Path3,
  moveTo: function(x4, y4) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x4, y4) {
    this._ += "L" + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  quadraticCurveTo: function(x12, y12, x4, y4) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  arcTo: function(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    var x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon6)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon6) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi5 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon6) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x06 + "," + y06;
    } else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6) {
      this._ += "L" + x06 + "," + y06;
    }
    if (!r) return;
    if (da2 < 0) da2 = da2 % tau6 + tau6;
    if (da2 > tauEpsilon2) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x4 - dx) + "," + (y4 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x06) + "," + (this._y1 = y06);
    } else if (da2 > epsilon6) {
      this._ += "A" + r + "," + r + ",0," + +(da2 >= pi5) + "," + cw + "," + (this._x1 = x4 + r * Math.cos(a1)) + "," + (this._y1 = y4 + r * Math.sin(a1));
    }
  },
  rect: function(x4, y4, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/math.js
var epsilon7 = 1e-12;
var pi6 = Math.PI;
var halfPi4 = pi6 / 2;
var tau7 = 2 * pi6;

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      // proceed
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default2(context) {
  return new Linear2(context);
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear2 = curveRadial2(linear_default2);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a5, r) {
    this._curve.point(r * Math.sin(a5), r * -Math.cos(a5));
  }
};
function curveRadial2(curve) {
  function radial2(context) {
    return new Radial2(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-sankey/node_modules/d3-shape/src/array.js
var slice5 = Array.prototype.slice;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/diamond.js
var tan302 = Math.sqrt(1 / 3);
var tan30_22 = tan302 * 2;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/star.js
var kr2 = Math.sin(pi6 / 10) / Math.sin(7 * pi6 / 10);
var kx2 = Math.sin(tau7 / 10) * kr2;
var ky2 = -Math.cos(tau7 / 10) * kr2;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/triangle.js
var sqrt34 = Math.sqrt(3);

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/wye.js
var s2 = Math.sqrt(3) / 2;
var k2 = 1 / Math.sqrt(12);
var a4 = (k2 / 2 + 1) * 3;

// node_modules/d3-sankey/node_modules/d3-shape/src/noop.js
function noop_default3() {
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basis.js
function point6(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis2(context) {
  this._context = context;
}
Basis2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point6(this, this._x1, this._y1);
      // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // proceed
      default:
        point6(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed2(context) {
  this._context = context;
}
BasisClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x4, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x4, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x4, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point6(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen2(context) {
  this._context = context;
}
BasisOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point6(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/bundle.js
function Bundle2(context, beta) {
  this._basis = new Basis2(context);
  this._beta = beta;
}
Bundle2.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j = x4.length - 1;
    if (j > 0) {
      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default2 = function custom10(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis2(context) : new Bundle2(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom10(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinal.js
function point7(that, x4, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x4),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point7(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point7(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default2 = function custom11(tension) {
  function cardinal(context) {
    return new Cardinal2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom11(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point7(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default2 = function custom12(tension) {
  function cardinal(context) {
    return new CardinalClosed2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom12(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point7(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default2 = function custom13(tension) {
  function cardinal(context) {
    return new CardinalOpen2(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom13(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRom.js
function point8(that, x4, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon7) {
    var a5 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a5 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a5 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon7) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point8(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default2 = function custom14(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom2(context, alpha) : new Cardinal2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom14(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point8(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default2 = function custom15(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed2(context, alpha) : new CardinalClosed2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom15(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point8(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default2 = function custom16(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen2(context, alpha) : new CardinalOpen2(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom16(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed2(context) {
  this._context = context;
}
LinearClosed2.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) this._context.lineTo(x4, y4);
    else this._point = 1, this._context.moveTo(x4, y4);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/monotone.js
function sign4(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope32(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign4(s0) + sign4(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope22(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point9(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX2(context) {
  this._context = context;
}
MonotoneX2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point9(this, this._t0, slope22(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    var t13 = NaN;
    x4 = +x4, y4 = +y4;
    if (x4 === this._x1 && y4 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point9(this, slope22(this, t13 = slope32(this, x4, y4)), t13);
        break;
      default:
        point9(this, this._t0, t13 = slope32(this, x4, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t13;
  }
};
function MonotoneY2(context) {
  this._context = new ReflectContext2(context);
}
(MonotoneY2.prototype = Object.create(MonotoneX2.prototype)).point = function(x4, y4) {
  MonotoneX2.prototype.point.call(this, y4, x4);
};
function ReflectContext2(context) {
  this._context = context;
}
ReflectContext2.prototype = {
  moveTo: function(x4, y4) {
    this._context.moveTo(y4, x4);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x4, y4) {
    this._context.lineTo(y4, x4);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/natural.js
function Natural2(context) {
  this._context = context;
}
Natural2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, n = x4.length;
    if (n) {
      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
      if (n === 2) {
        this._context.lineTo(x4[1], y4[1]);
      } else {
        var px = controlPoints2(x4), py = controlPoints2(y4);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
function controlPoints2(x4) {
  var i, n = x4.length - 1, m3, a5 = new Array(n), b = new Array(n), r = new Array(n);
  a5[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];
  for (i = 1; i < n - 1; ++i) a5[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
  a5[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
  for (i = 1; i < n; ++i) m3 = a5[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
  a5[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a5[i] = (r[i] - a5[i + 1]) / b[i];
  b[n - 1] = (x4[n] + a5[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x4[i + 1] - a5[i + 1];
  return [a5, b];
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/step.js
function Step2(context, t) {
  this._context = context;
  this._t = t;
}
Step2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x4, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x4 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x4, this._y = y4;
  }
};

// node_modules/layerchart/dist/components/Sankey.svelte
Sankey2[FILENAME] = "node_modules/layerchart/dist/components/Sankey.svelte";
function Sankey2($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Sankey2);
  let nodesProp = prop($$props, "nodes", 3, (d) => d.nodes), nodeId = prop($$props, "nodeId", 3, (d) => d.index), nodeAlign = prop($$props, "nodeAlign", 3, justify), nodeWidth = prop($$props, "nodeWidth", 3, 4), nodePadding = prop($$props, "nodePadding", 3, 10), linksProp = prop($$props, "links", 3, (d) => d.links);
  const ctx = getChartContext();
  const sankeyData = tag(
    user_derived(() => {
      if (strict_equals(typeof document, "undefined")) return { nodes: [], links: [] };
      return Sankey().size([ctx.width, ctx.height]).nodes(nodesProp()).nodeId(nodeId()).nodeAlign(strict_equals(nodeAlign(), "left") ? left : strict_equals(nodeAlign(), "center") ? center : strict_equals(nodeAlign(), "right") ? right : strict_equals(nodeAlign(), "justify") ? justify : nodeAlign()).nodeWidth(nodeWidth()).nodePadding(nodePadding()).nodeSort($$props.nodeSort).links(linksProp()).linkSort($$props.linkSort)(structuredClone(ctx.data));
    }),
    "sankeyData"
  );
  user_effect(() => {
    $$props.onUpdate?.(get(sankeyData));
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => snippet(node, () => $$props.children ?? noop, () => ({
      nodes: get(sankeyData).nodes,
      links: get(sankeyData).links
    })),
    "render",
    Sankey2,
    143,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Sankey2 = hmr(Sankey2, () => Sankey2[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Sankey2[HMR].source;
    set(Sankey2[HMR].source, module2.default[HMR].original);
  });
}
var Sankey_default = Sankey2;

// node_modules/layerchart/dist/components/Threshold.svelte
Threshold[FILENAME] = "node_modules/layerchart/dist/components/Threshold.svelte";
var root_121 = add_locations(from_html(`<!> <!> <!>`, 1), Threshold[FILENAME], []);
function Threshold($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Threshold);
  const ctx = getChartContext();
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => $$props.curve, ($$anchor2) => {
      var fragment_1 = root_121();
      var node_1 = first_child(fragment_1);
      {
        const clip = wrap_snippet(Threshold, function($$anchor3) {
          validate_snippet_args(...arguments);
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => Area_default(node_2, {
              y0: (d) => ctx.y(d)[0],
              y1: (d) => min(ctx.yDomain),
              get curve() {
                return $$props.curve;
              },
              get defined() {
                return $$props.defined;
              }
            }),
            "component",
            Threshold,
            58,
            6,
            { componentTag: "Area" }
          );
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => ClipPath_default(node_1, {
            clip,
            children: wrap_snippet(Threshold, ($$anchor3, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              add_svelte_meta(() => snippet(node_3, () => $$props.above ?? noop, () => ({ curve: $$props.curve, defined: $$props.defined })), "render", Threshold, 60, 4);
              append($$anchor3, fragment_3);
            }),
            $$slots: { clip: true, default: true }
          }),
          "component",
          Threshold,
          56,
          2,
          { componentTag: "ClipPath" }
        );
      }
      var node_4 = sibling(node_1, 2);
      {
        const clip = wrap_snippet(Threshold, function($$anchor3) {
          validate_snippet_args(...arguments);
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          add_svelte_meta(
            () => Area_default(node_5, {
              y0: (d) => min(ctx.yDomain),
              y1: (d) => ctx.y(d)[1],
              get curve() {
                return $$props.curve;
              },
              get defined() {
                return $$props.defined;
              }
            }),
            "component",
            Threshold,
            65,
            6,
            { componentTag: "Area" }
          );
          append($$anchor3, fragment_4);
        });
        add_svelte_meta(
          () => ClipPath_default(node_4, {
            clip,
            children: wrap_snippet(Threshold, ($$anchor3, $$slotProps) => {
              var fragment_5 = comment();
              var node_6 = first_child(fragment_5);
              add_svelte_meta(() => snippet(node_6, () => $$props.below ?? noop, () => ({ curve: $$props.curve, defined: $$props.defined })), "render", Threshold, 68, 4);
              append($$anchor3, fragment_5);
            }),
            $$slots: { clip: true, default: true }
          }),
          "component",
          Threshold,
          63,
          2,
          { componentTag: "ClipPath" }
        );
      }
      var node_7 = sibling(node_4, 2);
      add_svelte_meta(() => snippet(node_7, () => $$props.children ?? noop, () => ({ curve: $$props.curve, defined: $$props.defined })), "render", Threshold, 71, 2);
      append($$anchor2, fragment_1);
    }),
    "key",
    Threshold,
    55,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Threshold = hmr(Threshold, () => Threshold[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Threshold[HMR].source;
    set(Threshold[HMR].source, module2.default[HMR].original);
  });
}
var Threshold_default = Threshold;

// node_modules/layerchart/dist/components/Tree.svelte
Tree[FILENAME] = "node_modules/layerchart/dist/components/Tree.svelte";
function Tree($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tree);
  let orientation = prop($$props, "orientation", 3, "horizontal");
  const ctx = getChartContext();
  const treeData = tag(
    user_derived(() => {
      const _tree = tree_default().size(strict_equals(orientation(), "horizontal") ? [ctx.height, ctx.width] : [ctx.width, ctx.height]);
      if ($$props.nodeSize) {
        _tree.nodeSize($$props.nodeSize);
      }
      if ($$props.separation) {
        _tree.separation($$props.separation);
      }
      if ($$props.hierarchy) {
        const h = $$props.hierarchy.copy();
        const treeData2 = _tree(h);
        return { links: treeData2.links(), nodes: treeData2.descendants() };
      }
      return { links: [], nodes: [] };
    }),
    "treeData"
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ nodes: get(treeData).nodes, links: get(treeData).links })), "render", Tree, 79, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tree = hmr(Tree, () => Tree[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Tree[HMR].source;
    set(Tree[HMR].source, module2.default[HMR].original);
  });
}
var Tree_default = Tree;

// node_modules/layerchart/dist/utils/treemap.js
function aspectTile(tile, width, height) {
  return (node, x06, y06, x12, y12) => {
    tile(node, 0, 0, width, height);
    for (const child2 of node.children ?? []) {
      child2.x0 = x06 + child2.x0 / width * (x12 - x06);
      child2.x1 = x06 + child2.x1 / width * (x12 - x06);
      child2.y0 = y06 + child2.y0 / height * (y12 - y06);
      child2.y1 = y06 + child2.y1 / height * (y12 - y06);
    }
  };
}

// node_modules/layerchart/dist/components/Treemap.svelte
Treemap[FILENAME] = "node_modules/layerchart/dist/components/Treemap.svelte";
function Treemap($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Treemap);
  let tile = prop($$props, "tile", 3, squarify_default), padding = prop($$props, "padding", 3, 0), paddingInner = prop($$props, "paddingInner", 3, 0), paddingOuter = prop($$props, "paddingOuter", 3, 0), paddingTop = prop($$props, "paddingTop", 3, 0), paddingBottom = prop($$props, "paddingBottom", 3, 0), maintainAspectRatio = prop($$props, "maintainAspectRatio", 3, false);
  const ctx = getChartContext();
  const tileFunc = tag(
    user_derived(() => strict_equals(tile(), "squarify") ? squarify_default : strict_equals(tile(), "resquarify") ? resquarify_default : strict_equals(tile(), "binary") ? binary_default : strict_equals(tile(), "dice") ? dice_default : strict_equals(tile(), "slice") ? slice_default2 : strict_equals(tile(), "sliceDice") ? sliceDice_default : tile()),
    "tileFunc"
  );
  const treemapData = tag(
    user_derived(() => {
      const _treemap = treemap_default().size([ctx.width, ctx.height]).tile(maintainAspectRatio() ? aspectTile(get(tileFunc), ctx.width, ctx.height) : get(tileFunc));
      if (padding()) {
        if (strict_equals(typeof padding(), "number")) {
          _treemap.padding(padding());
        } else {
          _treemap.padding(padding());
        }
      }
      if (paddingInner()) {
        if (strict_equals(typeof paddingInner(), "number")) {
          _treemap.paddingInner(strict_equals(typeof paddingInner(), "number") ? paddingInner() : paddingInner());
        } else {
          _treemap.paddingInner(paddingInner());
        }
      }
      if (paddingOuter()) {
        if (strict_equals(typeof paddingOuter(), "number")) {
          _treemap.paddingOuter(paddingOuter());
        } else {
          _treemap.paddingOuter(paddingOuter());
        }
      }
      if (paddingTop()) {
        if (strict_equals(typeof paddingTop(), "number")) {
          _treemap.paddingTop(paddingTop());
        } else {
          _treemap.paddingTop(paddingTop());
        }
      }
      if (paddingBottom()) {
        if (strict_equals(typeof paddingBottom(), "number")) {
          _treemap.paddingBottom(paddingBottom());
        } else {
          _treemap.paddingBottom(paddingBottom());
        }
      }
      if ($$props.paddingLeft) {
        if (strict_equals(typeof $$props.paddingLeft, "number")) {
          _treemap.paddingLeft($$props.paddingLeft);
        } else {
          _treemap.paddingLeft($$props.paddingLeft);
        }
      }
      if ($$props.paddingRight) {
        if (strict_equals(typeof $$props.paddingRight, "number")) {
          _treemap.paddingRight($$props.paddingRight);
        } else {
          _treemap.paddingRight($$props.paddingRight);
        }
      }
      if ($$props.hierarchy) {
        const h = $$props.hierarchy.copy();
        const treemapData2 = _treemap(h);
        return { links: treemapData2.links(), nodes: treemapData2.descendants() };
      }
      return { links: [], nodes: [] };
    }),
    "treemapData"
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ nodes: get(treemapData).nodes })), "render", Treemap, 202, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Treemap = hmr(Treemap, () => Treemap[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = Treemap[HMR].source;
    set(Treemap[HMR].source, module2.default[HMR].original);
  });
}
var Treemap_default = Treemap;

// node_modules/layerchart/dist/components/layout/WebGL.svelte
WebGL[FILENAME] = "node_modules/layerchart/dist/components/layout/WebGL.svelte";
var _WebGLContext = new Context("WebGL");
function setWebGLContext(context) {
  return _WebGLContext.set(context);
}
function getWebGLContext() {
  const defaultContext2 = tag_proxy(proxy({ gl: null }), "defaultContext");
  return _WebGLContext.getOr(defaultContext2);
}
var root25 = add_locations(from_html(`<canvas><!></canvas> <!>`, 1), WebGL[FILENAME], [[117, 0]]);
function WebGL($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, WebGL);
  let context = prop($$props, "context", 15), refProp = prop($$props, "ref", 15), fallback = prop($$props, "fallback", 3, ""), pointerEvents = prop($$props, "pointerEvents", 3, true), zIndex = prop($$props, "zIndex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "context",
      "ref",
      "contextAttributes",
      "fallback",
      "pointerEvents",
      "zIndex",
      "children"
    ],
    "restProps"
  );
  let ref = tag(state(void 0), "ref");
  user_pre_effect(() => {
    refProp(get(ref));
  });
  let testGl;
  const ctx = getChartContext();
  onMount(() => {
    const contexts = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
    for (let j = 0; j < contexts.length; j++) {
      testGl = get(ref)?.getContext(contexts[j], $$props.contextAttributes);
      if (testGl) {
        context(testGl);
        break;
      }
    }
  });
  setWebGLContext({
    get gl() {
      return context() ?? null;
    },
    set gl(v2) {
      if (v2) {
        context(v2);
      }
      context(void 0);
    }
  });
  var fragment = root25();
  var canvas = first_child(fragment);
  attribute_effect(
    canvas,
    ($0, $1) => ({
      style: "width:100%;height:100%;position:absolute;",
      ...$0,
      [STYLE]: $1
    }),
    [
      () => extractLayerProps(restProps, "layout-webgl"),
      () => ({
        "z-index": zIndex(),
        "pointer-events": strict_equals(pointerEvents(), false) ? "none" : null,
        top: ctx.padding.top + "px",
        right: ctx.padding.right + "px",
        bottom: ctx.padding.bottom + "px",
        left: ctx.padding.left + "px"
      })
    ]
  );
  var node = child(canvas);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, fallback), "render", WebGL, 129, 4);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, fallback()));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (fallback()) $$render(consequent_1);
            },
            true
          ),
          "if",
          WebGL,
          130,
          2
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(typeof fallback(), "function")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      WebGL,
      128,
      2
    );
  }
  reset(canvas);
  bind_this(canvas, ($$value) => set(ref, $$value), () => get(ref));
  var node_3 = sibling(canvas, 2);
  add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ ref: get(ref), webGLContext: context() })), "render", WebGL, 135, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WebGL = hmr(WebGL, () => WebGL[HMR].source);
  import.meta.hot.accept((module2) => {
    module2.default[HMR].source = WebGL[HMR].source;
    set(WebGL[HMR].source, module2.default[HMR].original);
  });
}
var WebGL_default = WebGL;

// node_modules/layerchart/dist/utils/hierarchy.js
function findAncestor(node, filter4) {
  while (node) {
    if (filter4(node)) {
      return node;
    }
    node = node.parent;
  }
  return null;
}

// node_modules/layerchart/dist/utils/pivot.js
function pivotLonger(data, columns, name, value2) {
  const keep = Object.keys(data[0]).filter((c3) => !columns.includes(c3));
  return data.flatMap((d) => {
    const base = keep.map((k3) => [k3, d[k3]]);
    return columns.map((column) => {
      return Object.fromEntries([...base, [name, column], [value2, d[column]]]);
    });
  });
}
function pivotWider(data, column, name, value2) {
  return Array.from(group(data, (d) => d[column]), ([columnVal, items]) => Object.fromEntries([[column, columnVal]].concat(items.map((d) => [d[name], d[value2]]))));
}

// node_modules/layerchart/dist/utils/stack.js
function groupStackData(data, options) {
  const dataByKey = group(data, (d) => d[options.xKey]);
  if (options.groupBy) {
    const groupedData = flatGroup(data, (d) => d[options.xKey], (d) => d[options.groupBy ?? ""]);
    const result2 = groupedData.flatMap((d, i) => {
      const groupKeys = d.slice(0, -1);
      const groupData = d.slice(-1)[0];
      const pivotData = pivotWider(groupData, options.xKey, options.stackBy ?? "", "value");
      const stackKeys = [
        ...new Set(groupData.map((d2) => d2[options.stackBy ?? ""]))
      ];
      const stackData = stack_default().keys(stackKeys).order(options.order).offset(options.offset)(pivotData);
      return stackData.flatMap((series) => {
        return series.flatMap((s3) => {
          const keys3 = {
            [options.xKey]: groupKeys[0],
            [options.groupBy ?? ""]: groupKeys[1]
          };
          if (options.stackBy) {
            keys3[options.stackBy] = series.key;
          }
          const value2 = sum(groupData, (d2) => d2.value);
          return {
            ...keys3,
            keys: keys3,
            value: value2,
            values: options.stackBy ? [s3[0], s3[1]] : [0, value2],
            data: dataByKey.get(keys3[options.xKey])
          };
        });
      });
    });
    return result2;
  } else if (options.stackBy) {
    const pivotData = pivotWider(data, options.xKey, options.stackBy, "value");
    const stackKeys = [...new Set(data.map((d) => d[options.stackBy ?? ""]))];
    const stackData = stack_default().keys(stackKeys).order(options.order).offset(options.offset)(pivotData);
    const result2 = stackData.flatMap((series) => {
      return series.flatMap((s3) => {
        const keys3 = {
          [options.xKey]: s3.data[options.xKey],
          [options.stackBy ?? ""]: series.key
        };
        return {
          ...keys3,
          keys: keys3,
          value: s3[1] - s3[0],
          values: [s3[0], s3[1]],
          data: dataByKey.get(keys3[options.xKey])
        };
      });
    });
    return result2;
  } else {
    return Array.from(rollup(
      data,
      (items) => {
        const keys3 = { [options.xKey]: items[0][options.xKey] };
        const value2 = sum(items, (d) => d.value);
        return {
          ...keys3,
          keys: keys3,
          value: value2,
          values: [0, value2],
          data: dataByKey.get(keys3[options.xKey])
        };
      },
      // @ts-expect-error
      (d) => d[options.xKey]
    ).values());
  }
}
function stackOffsetSeparated(series, order) {
  const gap = 200;
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    let base = max(s0, (d) => d[1]) + gap;
    for (var j = 0; j < m3; ++j) {
      let diff = s1[j][1] - s1[j][0];
      s1[j][0] = base;
      s1[j][1] = base + diff;
    }
  }
}

// node_modules/layerchart/dist/utils/threshold.js
function thresholdTime(n) {
  return (data, min7, max7) => {
    return time().domain([min7, max7]).ticks(n);
  };
}
function thresholdChunks(chunks) {
  return (data, min7, max7) => range(chunks).map((t) => min7 + t / chunks * (max7 - min7));
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f2(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad3(value2, width) {
  var s3 = value2 + "", length = s3.length;
  return length < width ? new Array(width - length + 1).join(0) + s3 : s3;
}
function formatYear2(year) {
  return year < 0 ? "-" + pad3(-year, 6) : year > 9999 ? "+" + pad3(year, 6) : pad3(year, 4);
}
function formatDate2(date2) {
  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear2(date2.getUTCFullYear(), 4) + "-" + pad3(date2.getUTCMonth() + 1, 2) + "-" + pad3(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad3(hours, 2) + ":" + pad3(minutes, 2) + ":" + pad3(seconds2, 2) + "." + pad3(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad3(hours, 2) + ":" + pad3(minutes, 2) + ":" + pad3(seconds2, 2) + "Z" : minutes || hours ? "T" + pad3(hours, 2) + ":" + pad3(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse2(text2, f2) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f2 ? customConverter(row, f2) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f2) {
    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE) --N;
    if (text2.charCodeAt(N - 1) === RETURN) --N;
    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i, j = I, c3;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE) ;
        if ((i = I) >= N) eof = true;
        else if ((c3 = text2.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE) ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c3 = text2.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE) ++I;
        } else if (c3 !== DELIMITER) continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f2 && (row = f2(row, n++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate2(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse: parse2,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/layerchart/dist/utils/graph/sankey.js
function sankeyGraphFromCsv(csv2) {
  const links = csvParseRows(csv2, ([
    source,
    target,
    value2
    /*, linkColor = color*/
  ]) => source && target ? {
    source,
    target,
    // @ts-expect-error
    value: !value2 || isNaN(value2 = +value2) ? 1 : +value2
    // color: linkColor,
  } : null);
  return { nodes: sankeyNodesFromLinks(links), links };
}
function sankeyGraphFromHierarchy(hierarchy2) {
  return {
    nodes: hierarchy2.descendants(),
    links: hierarchy2.links().map((link3) => ({ ...link3, value: link3.target.value }))
  };
}
function sankeyGraphFromNode(node) {
  const nodes = [node];
  const links = [];
  for (const link3 of node.sourceLinks ?? []) {
    nodes.push(link3.target);
    links.push(link3);
    if (link3.target.sourceLinks.length) {
      const targetData = sankeyGraphFromNode(link3.target);
      for (const node2 of targetData.nodes) {
        if (!nodes.includes(node2)) {
          nodes.push(node2);
        }
      }
      for (const link4 of targetData.links) {
        if (!links.includes(link4)) {
          links.push(link4);
        }
      }
    }
  }
  return { nodes, links };
}
function sankeyNodesFromLinks(links) {
  const nodesByName = /* @__PURE__ */ new Map();
  for (const link3 of links) {
    if (!nodesByName.has(link3.source)) {
      nodesByName.set(link3.source, { name: link3.source });
    }
    if (!nodesByName.has(link3.target)) {
      nodesByName.set(link3.target, { name: link3.target });
    }
  }
  return Array.from(nodesByName.values());
}
export {
  Align,
  AnnotationLine_default as AnnotationLine,
  AnnotationPoint_default as AnnotationPoint,
  AnnotationRange_default as AnnotationRange,
  Arc_default as Arc,
  ArcChart_default as ArcChart,
  Area_default as Area,
  AreaChart_default as AreaChart,
  Axis_default as Axis,
  Bar_default as Bar,
  BarChart_default as BarChart,
  Bars_default as Bars,
  Blur_default as Blur,
  Bounds_default as Bounds,
  BrushContext_default as BrushContext,
  Calendar_default as Calendar,
  Canvas_default as Canvas,
  Chart_default as Chart,
  ChartClipPath_default as ChartClipPath,
  Circle_default as Circle,
  CircleClipPath_default as CircleClipPath,
  ClipPath_default as ClipPath,
  ColorRamp_default as ColorRamp,
  Connector_default as Connector,
  DEFAULT_ALPHA,
  DEFAULT_ALPHA_DECAY,
  DEFAULT_ALPHA_MIN,
  DEFAULT_ALPHA_TARGET,
  DEFAULT_FILL,
  DEFAULT_VELOCITY_DECAY,
  Dagre_default as Dagre,
  EdgeLabelPosition,
  Ellipse_default as Ellipse,
  ForceSimulation_default as ForceSimulation,
  Frame_default as Frame,
  GeoCircle_default as GeoCircle,
  GeoContext_default as GeoContext,
  GeoEdgeFade_default as GeoEdgeFade,
  GeoPath_default as GeoPath,
  GeoPoint_default as GeoPoint,
  GeoSpline_default as GeoSpline,
  GeoTile_default as GeoTile,
  GeoVisible_default as GeoVisible,
  Graticule_default as Graticule,
  Grid_default as Grid,
  Group_default as Group,
  Highlight_default as Highlight,
  Html_default as Html,
  Hull_default as Hull,
  Labels_default as Labels,
  Layer_default as Layer,
  Legend_default as Legend,
  Line_default as Line,
  LineChart_default as LineChart,
  LinearGradient_default as LinearGradient,
  Link_default as Link,
  MotionPath_default as MotionPath,
  Pack_default as Pack,
  Partition_default as Partition,
  Pattern_default as Pattern,
  Pie_default as Pie,
  PieChart_default as PieChart,
  Point_default as Point,
  Points_default as Points,
  Polygon_default as Polygon,
  RadialGradient_default as RadialGradient,
  RankDir,
  Rect_default as Rect,
  RectClipPath_default as RectClipPath,
  Rule_default as Rule,
  Sankey_default as Sankey,
  ScatterChart_default as ScatterChart,
  Spline_default as Spline,
  Svg_default as Svg,
  Text_default as Text,
  Threshold_default as Threshold,
  TileImage_default as TileImage,
  tooltip_exports as Tooltip,
  TransformContext_default as TransformContext,
  Tree_default as Tree,
  Treemap_default as Treemap,
  Voronoi_default as Voronoi,
  WebGL_default as WebGL,
  _createLinearGradient,
  _createPattern,
  _getComputedStyles,
  accessor,
  add3 as add,
  antipode,
  applyLanes,
  asAny,
  cartesianToPolar,
  celsiusToFahrenheit,
  chartDataArray,
  circlePath,
  clearCanvasContext,
  createLinearGradient,
  createPattern,
  dagreAncestors,
  dagreDescendants,
  dagreGraph,
  defaultChartPadding,
  degreesToRadians,
  fahrenheitToCelsius,
  findAncestor,
  findRelatedData,
  flattenPathData,
  geoCurvePath,
  geoFitObjectTransform,
  getBrushContext,
  getCanvasContext,
  getChartContext,
  getComputedStyles,
  getDurationFormat,
  getEasingPath,
  getGeoContext,
  getPixelColor,
  getRenderContext,
  getTooltipContext,
  getTransformContext,
  getWebGLContext,
  groupStackData,
  isVisible,
  parsePercent,
  pivotLonger,
  pivotWider,
  polarToCartesian,
  radiansToDegrees,
  registerCanvasComponent,
  renderCircle,
  renderEllipse,
  renderPathData,
  renderRect,
  renderText,
  resolveTickFormat,
  resolveTickVals,
  roundedPolygonPath,
  sankeyGraphFromCsv,
  sankeyGraphFromHierarchy,
  sankeyGraphFromNode,
  sankeyNodesFromLinks,
  scaleCanvas,
  setBrushContext,
  setChartContext,
  setGeoContext,
  setRenderContext,
  setTransformContext,
  setWebGLContext,
  spikePath,
  stackOffsetSeparated,
  thresholdChunks,
  thresholdTime
};
/*! Bundled license information:

lodash-es/lodash.default.js:
lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=layerchart.js.map
