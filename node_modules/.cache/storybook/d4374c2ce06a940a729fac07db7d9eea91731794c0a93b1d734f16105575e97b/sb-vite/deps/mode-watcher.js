import "./chunk-NRMMMDUL.js";
import {
  MediaQuery
} from "./chunk-WL7JBLBF.js";
import "./chunk-OEZDBU4I.js";
import "./chunk-7RQDXF5S.js";
import "./chunk-6LD3WD6G.js";
import {
  add_locations,
  check_target,
  hmr,
  html,
  if_block,
  legacy_api,
  log_if_contains_state,
  onMount,
  prop,
  set_attribute
} from "./chunk-FRZCO2ZW.js";
import "./chunk-ZYTAZ2LT.js";
import {
  append,
  comment,
  from_html,
  head
} from "./chunk-OIZRCF3F.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  createSubscriber,
  effect_root,
  equals,
  first_child,
  get,
  on,
  pop,
  proxy,
  push,
  set,
  sibling,
  state,
  strict_equals,
  tag,
  template_effect,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-ITKELFPS.js";
import "./chunk-HXIGQYEZ.js";
import {
  true_default
} from "./chunk-E62QTSXI.js";
import "./chunk-P6TGDP3C.js";
import "./chunk-PR4QN5HX.js";

// node_modules/mode-watcher/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/mode-watcher/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement3 = document2.activeElement;
  while (activeElement3?.shadowRoot) {
    const node = activeElement3.shadowRoot.activeElement;
    if (node === activeElement3)
      break;
    else
      activeElement3 = node;
  }
  return activeElement3;
}

// node_modules/mode-watcher/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/mode-watcher/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/mode-watcher/node_modules/runed/dist/utilities/persisted-state/persisted-state.svelte.js
function getStorage(storageType, window2) {
  switch (storageType) {
    case "local":
      return window2.localStorage;
    case "session":
      return window2.sessionStorage;
  }
}
var PersistedState = class {
  #current;
  #key;
  #serializer;
  #storage;
  #subscribe;
  #version = tag(state(0), "PersistedState.#version");
  constructor(key, initialValue, options = {}) {
    const {
      storage: storageType = "local",
      serializer = { serialize: JSON.stringify, deserialize: JSON.parse },
      syncTabs = true,
      window: window2 = defaultWindow
    } = options;
    this.#current = initialValue;
    this.#key = key;
    this.#serializer = serializer;
    if (strict_equals(window2, void 0)) return;
    const storage = getStorage(storageType, window2);
    this.#storage = storage;
    const existingValue = storage.getItem(key);
    if (strict_equals(existingValue, null, false)) {
      this.#current = this.#deserialize(existingValue);
    } else {
      this.#serialize(initialValue);
    }
    if (syncTabs && strict_equals(storageType, "local")) {
      this.#subscribe = createSubscriber(() => {
        return on(window2, "storage", this.#handleStorageEvent);
      });
    }
  }
  get current() {
    this.#subscribe?.();
    get(this.#version);
    const root = this.#deserialize(this.#storage?.getItem(this.#key)) ?? this.#current;
    const proxies = /* @__PURE__ */ new WeakMap();
    const proxy2 = (value) => {
      if (strict_equals(value, null) || strict_equals(value?.constructor.name, "Date") || strict_equals(typeof value, "object", false)) {
        return value;
      }
      let p = proxies.get(value);
      if (!p) {
        p = new Proxy(value, {
          get: (target, property) => {
            get(this.#version);
            return proxy2(Reflect.get(target, property));
          },
          set: (target, property, value2) => {
            set(this.#version, get(this.#version) + 1);
            Reflect.set(target, property, value2);
            this.#serialize(root);
            return true;
          }
        });
        proxies.set(value, p);
      }
      return p;
    };
    return proxy2(root);
  }
  set current(newValue) {
    this.#serialize(newValue);
    set(this.#version, get(this.#version) + 1);
  }
  #handleStorageEvent = (event) => {
    if (strict_equals(event.key, this.#key, false) || strict_equals(event.newValue, null)) return;
    this.#current = this.#deserialize(event.newValue);
    set(this.#version, get(this.#version) + 1);
  };
  #deserialize(value) {
    try {
      return this.#serializer.deserialize(value);
    } catch (error) {
      console.error(...log_if_contains_state("error", `Error when parsing "${value}" from persisted store "${this.#key}"`, error));
      return;
    }
  }
  #serialize(value) {
    try {
      if (equals(value, void 0, false)) {
        this.#storage?.setItem(this.#key, this.#serializer.serialize(value));
      }
    } catch (error) {
      console.error(...log_if_contains_state("error", `Error when writing value from persisted store "${this.#key}" to ${this.#storage}`, error));
    }
  }
};

// node_modules/mode-watcher/node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = (await track_reactivity_loss(fn(...args)))();
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup(() => controller.abort());
      const result = (await track_reactivity_loss(fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup,
        signal: controller.signal
      })))();
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      if (prevValues && strict_equals(JSON.stringify(values), JSON.stringify(prevValues))) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/mode-watcher/dist/utils.js
function sanitizeClassNames(classNames) {
  return classNames.filter((className) => className.length > 0);
}
var noopStorage = {
  getItem: (_key) => null,
  setItem: (_key, _value) => {
  }
};
var isBrowser = typeof document !== "undefined";

// node_modules/mode-watcher/node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}

// node_modules/mode-watcher/node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction2(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/mode-watcher/node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/mode-watcher/node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/mode-watcher/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow2 = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument2 = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator2 = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation2 = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/mode-watcher/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement2(document2) {
  let activeElement3 = document2.activeElement;
  while (activeElement3?.shadowRoot) {
    const node = activeElement3.shadowRoot.activeElement;
    if (node === activeElement3)
      break;
    else
      activeElement3 = node;
  }
  return activeElement3;
}

// node_modules/mode-watcher/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement2 = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow2, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement2(this.#document);
  }
};
var activeElement2 = new ActiveElement2();

// node_modules/mode-watcher/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect2(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher2(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect2(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce2(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher2(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch2(sources, effect, options) {
  runWatcher2(sources, "post", effect, options);
}
function watchPre2(sources, effect, options) {
  runWatcher2(sources, "pre", effect, options);
}
watch2.pre = watchPre2;
function watchOnce2(source, effect) {
  runWatcherOnce2(source, "post", effect);
}
function watchOncePre2(source, effect) {
  runWatcherOnce2(source, "pre", effect);
}
watchOnce2.pre = watchOncePre2;

// node_modules/mode-watcher/dist/storage-keys.svelte.js
var modeStorageKey = box("mode-watcher-mode");
var themeStorageKey = box("mode-watcher-theme");

// node_modules/mode-watcher/dist/modes.js
var modes = ["dark", "light", "system"];
function isValidMode(value) {
  if (typeof value !== "string")
    return false;
  return modes.includes(value);
}

// node_modules/mode-watcher/dist/mode-states.svelte.js
var UserPrefersMode = class {
  #defaultValue = "system";
  #storage = isBrowser ? localStorage : noopStorage;
  #initialValue = this.#storage.getItem(modeStorageKey.current);
  #value = isValidMode(this.#initialValue) ? this.#initialValue : this.#defaultValue;
  #persisted = tag(state(proxy(this.#makePersisted())), "UserPrefersMode.#persisted");
  #makePersisted(value = this.#value) {
    return new PersistedState(modeStorageKey.current, value, {
      serializer: {
        serialize: (v) => v,
        deserialize: (v) => {
          if (isValidMode(v)) return v;
          return this.#defaultValue;
        }
      }
    });
  }
  constructor() {
    effect_root(() => {
      return watch.pre(() => modeStorageKey.current, (_, prevStorageKey) => {
        const currModeValue = get(this.#persisted).current;
        set(this.#persisted, this.#makePersisted(currModeValue), true);
        if (prevStorageKey) {
          localStorage.removeItem(prevStorageKey);
        }
      });
    });
  }
  get current() {
    return get(this.#persisted).current;
  }
  set current(newValue) {
    get(this.#persisted).current = newValue;
  }
};
var SystemPrefersMode = class {
  #defaultValue = void 0;
  #track = true;
  #current = tag(state(proxy(this.#defaultValue)), "SystemPrefersMode.#current");
  #mediaQueryState = strict_equals(typeof window, "undefined", false) && strict_equals(typeof window.matchMedia, "function") ? new MediaQuery("prefers-color-scheme: light") : { current: false };
  query() {
    if (!isBrowser) return;
    set(this.#current, this.#mediaQueryState.current ? "light" : "dark", true);
  }
  tracking(active) {
    this.#track = active;
  }
  constructor() {
    effect_root(() => {
      user_pre_effect(() => {
        if (!this.#track) return;
        this.query();
      });
    });
    this.query = this.query.bind(this);
    this.tracking = this.tracking.bind(this);
  }
  get current() {
    return get(this.#current);
  }
};
var userPrefersMode = new UserPrefersMode();
var systemPrefersMode = new SystemPrefersMode();

// node_modules/mode-watcher/dist/theme-state.svelte.js
var CustomTheme = class {
  #storage = isBrowser ? localStorage : noopStorage;
  #initialValue = this.#storage.getItem(themeStorageKey.current);
  #value = strict_equals(this.#initialValue, null) || strict_equals(this.#initialValue, void 0) ? "" : this.#initialValue;
  #persisted = tag(state(proxy(this.#makePersisted())), "CustomTheme.#persisted");
  #makePersisted(value = this.#value) {
    return new PersistedState(themeStorageKey.current, value, {
      serializer: {
        serialize: (v) => {
          if (strict_equals(typeof v, "string", false)) return "";
          return v;
        },
        deserialize: (v) => v
      }
    });
  }
  constructor() {
    effect_root(() => {
      return watch.pre(() => themeStorageKey.current, (_, prevStorageKey) => {
        const currModeValue = get(this.#persisted).current;
        set(this.#persisted, this.#makePersisted(currModeValue), true);
        if (prevStorageKey) {
          localStorage.removeItem(prevStorageKey);
        }
      });
    });
  }
  /**
   * The current theme.
   * @returns The current theme.
   */
  get current() {
    return get(this.#persisted).current;
  }
  /**
   * Set the current theme.
   * @param newValue The new theme to set.
   */
  set current(newValue) {
    get(this.#persisted).current = newValue;
  }
};
var customTheme = new CustomTheme();

// node_modules/mode-watcher/dist/without-transition.js
var timeoutAction;
var timeoutEnable;
var hasLoaded = false;
var styleElement = null;
function getStyleElement() {
  if (styleElement)
    return styleElement;
  styleElement = document.createElement("style");
  styleElement.appendChild(document.createTextNode(`* {
		-webkit-transition: none !important;
		-moz-transition: none !important;
		-o-transition: none !important;
		-ms-transition: none !important;
		transition: none !important;
	}`));
  return styleElement;
}
function withoutTransition(action, synchronous = false) {
  if (typeof document === "undefined")
    return;
  if (!hasLoaded) {
    hasLoaded = true;
    action();
    return;
  }
  const isTest = typeof process !== "undefined" && false || typeof window !== "undefined" && window.__vitest_worker__;
  if (isTest) {
    action();
    return;
  }
  clearTimeout(timeoutAction);
  clearTimeout(timeoutEnable);
  const style = getStyleElement();
  const disable = () => document.head.appendChild(style);
  const enable = () => {
    if (style.parentNode) {
      document.head.removeChild(style);
    }
  };
  function executeAction() {
    action();
    window.requestAnimationFrame(enable);
  }
  if (typeof window.requestAnimationFrame !== "undefined") {
    disable();
    if (synchronous) {
      executeAction();
    } else {
      window.requestAnimationFrame(() => {
        executeAction();
      });
    }
    return;
  }
  disable();
  timeoutAction = window.setTimeout(() => {
    action();
    timeoutEnable = window.setTimeout(enable, 16);
  }, 16);
}

// node_modules/mode-watcher/dist/states.svelte.js
var themeColors = box(void 0);
var disableTransitions = box(true);
var synchronousModeChanges = box(false);
var darkClassNames = box([]);
var lightClassNames = box([]);
function createDerivedMode() {
  const current = tag(
    user_derived(() => {
      if (!isBrowser) return void 0;
      const derivedMode2 = strict_equals(userPrefersMode.current, "system") ? systemPrefersMode.current : userPrefersMode.current;
      const sanitizedDarkClassNames = sanitizeClassNames(darkClassNames.current);
      const sanitizedLightClassNames = sanitizeClassNames(lightClassNames.current);
      function update() {
        const htmlEl = document.documentElement;
        const themeColorEl = document.querySelector('meta[name="theme-color"]');
        if (strict_equals(derivedMode2, "light")) {
          if (sanitizedDarkClassNames.length) htmlEl.classList.remove(...sanitizedDarkClassNames);
          if (sanitizedLightClassNames.length) htmlEl.classList.add(...sanitizedLightClassNames);
          htmlEl.style.colorScheme = "light";
          if (themeColorEl && themeColors.current) {
            themeColorEl.setAttribute("content", themeColors.current.light);
          }
        } else {
          if (sanitizedLightClassNames.length) htmlEl.classList.remove(...sanitizedLightClassNames);
          if (sanitizedDarkClassNames.length) htmlEl.classList.add(...sanitizedDarkClassNames);
          htmlEl.style.colorScheme = "dark";
          if (themeColorEl && themeColors.current) {
            themeColorEl.setAttribute("content", themeColors.current.dark);
          }
        }
      }
      if (disableTransitions.current) {
        withoutTransition(update, synchronousModeChanges.current);
      } else {
        update();
      }
      return derivedMode2;
    }),
    "current"
  );
  return {
    get current() {
      return get(current);
    }
  };
}
function createDerivedTheme() {
  const current = tag(
    user_derived(() => {
      customTheme.current;
      if (!isBrowser) return void 0;
      function update() {
        const htmlEl = document.documentElement;
        htmlEl.setAttribute("data-theme", customTheme.current);
      }
      if (disableTransitions.current) {
        withoutTransition(update, untrack(() => synchronousModeChanges.current));
      } else {
        update();
      }
      return customTheme.current;
    }),
    "current"
  );
  return {
    get current() {
      return get(current);
    }
  };
}
var derivedMode = createDerivedMode();
var derivedTheme = createDerivedTheme();

// node_modules/mode-watcher/dist/mode.js
function toggleMode() {
  userPrefersMode.current = derivedMode.current === "dark" ? "light" : "dark";
}
function setMode(mode) {
  userPrefersMode.current = mode;
}
function resetMode() {
  userPrefersMode.current = "system";
}
function setTheme(newTheme) {
  customTheme.current = newTheme;
}
function defineConfig(config) {
  return config;
}
function setInitialMode({ defaultMode = "system", themeColors: themeColors2, darkClassNames: darkClassNames2 = ["dark"], lightClassNames: lightClassNames2 = [], defaultTheme = "", modeStorageKey: modeStorageKey2 = "mode-watcher-mode", themeStorageKey: themeStorageKey2 = "mode-watcher-theme" }) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem(modeStorageKey2) ?? defaultMode;
  const theme = localStorage.getItem(themeStorageKey2) ?? defaultTheme;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  if (light) {
    if (darkClassNames2.length)
      rootEl.classList.remove(...darkClassNames2.filter(Boolean));
    if (lightClassNames2.length)
      rootEl.classList.add(...lightClassNames2.filter(Boolean));
  } else {
    if (lightClassNames2.length)
      rootEl.classList.remove(...lightClassNames2.filter(Boolean));
    if (darkClassNames2.length)
      rootEl.classList.add(...darkClassNames2.filter(Boolean));
  }
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  if (theme) {
    rootEl.setAttribute("data-theme", theme);
    localStorage.setItem(themeStorageKey2, theme);
  }
  localStorage.setItem(modeStorageKey2, mode);
}
function createInitialModeExpression(config = {}) {
  return `(${setInitialMode.toString()})(${JSON.stringify(config)});`;
}
var generateSetInitialModeExpression = createInitialModeExpression;

// node_modules/mode-watcher/dist/components/mode-watcher-lite.svelte
Mode_watcher_lite[FILENAME] = "node_modules/mode-watcher/dist/components/mode-watcher-lite.svelte";
var root_1 = add_locations(from_html(`<meta name="theme-color"/>`), Mode_watcher_lite[FILENAME], [[11, 1]]);
function Mode_watcher_lite($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mode_watcher_lite);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var meta = root_1();
      template_effect(() => set_attribute(meta, "content", $$props.themeColors.dark));
      append($$anchor2, meta);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.themeColors) $$render(consequent);
      }),
      "if",
      Mode_watcher_lite,
      7,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mode_watcher_lite = hmr(Mode_watcher_lite, () => Mode_watcher_lite[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mode_watcher_lite[HMR].source;
    set(Mode_watcher_lite[HMR].source, module.default[HMR].original);
  });
}
var mode_watcher_lite_default = Mode_watcher_lite;

// node_modules/mode-watcher/dist/components/mode-watcher-full.svelte
Mode_watcher_full[FILENAME] = "node_modules/mode-watcher/dist/components/mode-watcher-full.svelte";
var root_2 = add_locations(from_html(`<meta name="theme-color"/>`), Mode_watcher_full[FILENAME], [[21, 2]]);
var root_12 = add_locations(from_html(`<!> <!>`, 1), Mode_watcher_full[FILENAME], []);
function Mode_watcher_full($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mode_watcher_full);
  let trueNonce = prop($$props, "trueNonce", 3, "");
  head(($$anchor2) => {
    var fragment = root_12();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor3) => {
        var meta = root_2();
        template_effect(() => set_attribute(meta, "content", $$props.themeColors.dark));
        append($$anchor3, meta);
      };
      add_svelte_meta(
        () => if_block(node, ($$render) => {
          if ($$props.themeColors) $$render(consequent);
        }),
        "if",
        Mode_watcher_full,
        17,
        1
      );
    }
    var node_1 = sibling(node, 2);
    html(node_1, () => `<script${trueNonce() ? ` nonce=${trueNonce()}` : ""}>(` + setInitialMode.toString() + `)(` + JSON.stringify($$props.initConfig) + `);<\/script>`, void 0, void 0, true);
    append($$anchor2, fragment);
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mode_watcher_full = hmr(Mode_watcher_full, () => Mode_watcher_full[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mode_watcher_full[HMR].source;
    set(Mode_watcher_full[HMR].source, module.default[HMR].original);
  });
}
var mode_watcher_full_default = Mode_watcher_full;

// node_modules/mode-watcher/dist/components/mode-watcher.svelte
Mode_watcher[FILENAME] = "node_modules/mode-watcher/dist/components/mode-watcher.svelte";
function Mode_watcher($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mode_watcher);
  let track = prop($$props, "track", 3, true), defaultMode = prop($$props, "defaultMode", 3, "system"), disableTransitionsProp = prop($$props, "disableTransitions", 3, true), darkClassNamesProp = prop($$props, "darkClassNames", 19, () => ["dark"]), lightClassNamesProp = prop($$props, "lightClassNames", 19, () => []), defaultTheme = prop($$props, "defaultTheme", 3, ""), nonce = prop($$props, "nonce", 3, ""), themeStorageKeyProp = prop($$props, "themeStorageKey", 3, "mode-watcher-theme"), modeStorageKeyProp = prop($$props, "modeStorageKey", 3, "mode-watcher-mode"), disableHeadScriptInjection = prop($$props, "disableHeadScriptInjection", 3, false), synchronousModeChangesProp = prop($$props, "synchronousModeChanges", 3, false);
  modeStorageKey.current = modeStorageKeyProp();
  themeStorageKey.current = themeStorageKeyProp();
  darkClassNames.current = darkClassNamesProp();
  lightClassNames.current = lightClassNamesProp();
  disableTransitions.current = disableTransitionsProp();
  themeColors.current = $$props.themeColors;
  synchronousModeChanges.current = synchronousModeChangesProp();
  user_pre_effect(() => {
    synchronousModeChanges.current = synchronousModeChangesProp();
  });
  user_pre_effect(() => {
    disableTransitions.current = disableTransitionsProp();
  });
  user_pre_effect(() => {
    themeColors.current = $$props.themeColors;
  });
  user_pre_effect(() => {
    darkClassNames.current = darkClassNamesProp();
  });
  user_pre_effect(() => {
    lightClassNames.current = lightClassNamesProp();
  });
  user_pre_effect(() => {
    modeStorageKey.current = modeStorageKeyProp();
  });
  user_pre_effect(() => {
    themeStorageKey.current = themeStorageKeyProp();
  });
  user_pre_effect(() => {
    derivedMode.current;
    modeStorageKey.current;
    themeStorageKey.current;
    derivedTheme.current;
  });
  onMount(() => {
    systemPrefersMode.tracking(track());
    systemPrefersMode.query();
    const localStorageMode = localStorage.getItem(modeStorageKey.current);
    setMode(isValidMode(localStorageMode) ? localStorageMode : defaultMode());
    const localStorageTheme = localStorage.getItem(themeStorageKey.current);
    setTheme(localStorageTheme || defaultTheme());
  });
  const initConfig = defineConfig({
    defaultMode: defaultMode(),
    themeColors: $$props.themeColors,
    darkClassNames: darkClassNamesProp(),
    lightClassNames: lightClassNamesProp(),
    defaultTheme: defaultTheme(),
    modeStorageKey: modeStorageKeyProp(),
    themeStorageKey: themeStorageKeyProp()
  });
  const trueNonce = tag(user_derived(() => strict_equals(typeof window, "undefined") ? nonce() : ""), "trueNonce");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => mode_watcher_lite_default(node_1, {
          get themeColors() {
            return themeColors.current;
          }
        }),
        "component",
        Mode_watcher,
        101,
        1,
        { componentTag: "ModeWatcherLite" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(
        () => mode_watcher_full_default(node_2, {
          get trueNonce() {
            return get(trueNonce);
          },
          get initConfig() {
            return initConfig;
          },
          get themeColors() {
            return themeColors.current;
          }
        }),
        "component",
        Mode_watcher,
        103,
        1,
        { componentTag: "ModeWatcherFull" }
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (disableHeadScriptInjection()) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Mode_watcher,
      100,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mode_watcher = hmr(Mode_watcher, () => Mode_watcher[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mode_watcher[HMR].source;
    set(Mode_watcher[HMR].source, module.default[HMR].original);
  });
}
var mode_watcher_default = Mode_watcher;
export {
  mode_watcher_default as ModeWatcher,
  createInitialModeExpression,
  generateSetInitialModeExpression,
  derivedMode as mode,
  modeStorageKey,
  resetMode,
  setMode,
  setTheme,
  systemPrefersMode,
  derivedTheme as theme,
  themeStorageKey,
  toggleMode,
  userPrefersMode
};
//# sourceMappingURL=mode-watcher.js.map
