{
  "version": 3,
  "sources": ["../../../../../paneforge/dist/internal/utils/aria.js", "../../../../../paneforge/dist/internal/utils/assert.js", "../../../../../paneforge/dist/internal/constants.js", "../../../../../paneforge/dist/internal/utils/compare.js", "../../../../../paneforge/dist/internal/utils/is.js", "../../../../../paneforge/dist/internal/utils/resize.js", "../../../../../paneforge/dist/internal/helpers.js", "../../../../../paneforge/node_modules/runed/dist/internal/configurable-globals.js", "../../../../../paneforge/node_modules/runed/dist/internal/utils/dom.js", "../../../../../paneforge/node_modules/runed/dist/utilities/active-element/active-element.svelte.js", "../../../../../paneforge/node_modules/runed/dist/utilities/watch/watch.svelte.js", "../../../../../paneforge/node_modules/runed/dist/utilities/context/context.js", "../../../../../paneforge/dist/internal/utils/adjust-layout.js", "../../../../../paneforge/dist/internal/utils/style.js", "../../../../../paneforge/dist/internal/utils/storage.js", "../../../../../paneforge/dist/paneforge.svelte.js", "../../../../../paneforge/dist/components/pane-group.svelte", "../../../../../paneforge/dist/components/pane.svelte", "../../../../../paneforge/dist/components/pane-resizer.svelte"],
  "sourcesContent": ["/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({ layout, panesArray, pivotIndices, }) {\n    let currentMinSize = 0;\n    let currentMaxSize = 100;\n    let totalMinSize = 0;\n    let totalMaxSize = 0;\n    const firstIndex = pivotIndices[0];\n    // A pane's effective min/max sizes also need to account for other pane's sizes.\n    for (let i = 0; i < panesArray.length; i++) {\n        const constraints = panesArray[i].constraints;\n        const { maxSize = 100, minSize = 0 } = constraints;\n        if (i === firstIndex) {\n            currentMinSize = minSize;\n            currentMaxSize = maxSize;\n        }\n        else {\n            totalMinSize += minSize;\n            totalMaxSize += maxSize;\n        }\n    }\n    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n    const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n    const valueNow = layout[firstIndex];\n    return {\n        valueMax,\n        valueMin,\n        valueNow,\n    };\n}\n", "export function assert(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexpectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        console.error(message);\n        throw new Error(message);\n    }\n}\n", "export const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n", "import { PRECISION } from \"../constants.js\";\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {\n    return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {\n    const roundedActual = roundTo(actual, fractionDigits);\n    const roundedExpected = roundTo(expected, fractionDigits);\n    return Math.sign(roundedActual - roundedExpected);\n}\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual(arrA, arrB) {\n    if (arrA.length !== arrB.length)\n        return false;\n    for (let index = 0; index < arrA.length; index++) {\n        if (arrA[index] !== arrB[index])\n            return false;\n    }\n    return true;\n}\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value, decimals) {\n    return Number.parseFloat(value.toFixed(decimals));\n}\n", "export const isBrowser = typeof document !== \"undefined\";\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nexport function isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nexport function isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\n", "import { PRECISION } from \"../constants.js\";\nimport { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance } from \"./compare.js\";\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize, }) {\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    assert(paneConstraints != null, \"Pane constraints should not be null.\");\n    const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;\n    let newSize = initialSize;\n    if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n        newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);\n    }\n    newSize = Math.min(maxSize, newSize);\n    return Number.parseFloat(newSize.toFixed(PRECISION));\n}\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {\n    if (!collapsible)\n        return minSize;\n    // Snap collapsible panes closed or open based on the halfway point.\n    const halfwayPoint = (collapsedSize + minSize) / 2;\n    return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;\n}\n", "import { calculateAriaValues } from \"./utils/aria.js\";\nimport { assert } from \"./utils/assert.js\";\nimport { areNumbersAlmostEqual } from \"./utils/compare.js\";\nimport { isBrowser, isHTMLElement, isKeyDown, isMouseEvent, isTouchEvent } from \"./utils/is.js\";\nimport { resizePane } from \"./utils/resize.js\";\nexport function noop() { }\nexport function updateResizeHandleAriaValues({ groupId, layout, panesArray, domContext, }) {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, domContext);\n    for (let index = 0; index < panesArray.length - 1; index++) {\n        const { valueMax, valueMin, valueNow } = calculateAriaValues({\n            layout,\n            panesArray: panesArray,\n            pivotIndices: [index, index + 1],\n        });\n        const resizeHandleEl = resizeHandleElements[index];\n        if (isHTMLElement(resizeHandleEl)) {\n            const paneData = panesArray[index];\n            resizeHandleEl.setAttribute(\"aria-controls\", paneData.opts.id.current);\n            resizeHandleEl.setAttribute(\"aria-valuemax\", `${Math.round(valueMax)}`);\n            resizeHandleEl.setAttribute(\"aria-valuemin\", `${Math.round(valueMin)}`);\n            resizeHandleEl.setAttribute(\"aria-valuenow\", valueNow != null ? `${Math.round(valueNow)}` : \"\");\n        }\n    }\n    return () => {\n        for (const el of resizeHandleElements) {\n            el.removeAttribute(\"aria-controls\");\n            el.removeAttribute(\"aria-valuemax\");\n            el.removeAttribute(\"aria-valuemin\");\n            el.removeAttribute(\"aria-valuenow\");\n        }\n    };\n}\nexport function getResizeHandleElementsForGroup(groupId, domContext) {\n    if (!isBrowser)\n        return [];\n    return Array.from(domContext.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`));\n}\nexport function getResizeHandleElementIndex({ groupId, id, domContext, }) {\n    if (!isBrowser)\n        return null;\n    const handles = getResizeHandleElementsForGroup(groupId, domContext);\n    const index = handles.findIndex((handle) => handle.getAttribute(\"data-pane-resizer-id\") === id);\n    return index ?? null;\n}\nexport function getPivotIndices({ groupId, dragHandleId, domContext, }) {\n    const index = getResizeHandleElementIndex({\n        groupId,\n        id: dragHandleId,\n        domContext: domContext,\n    });\n    return index != null ? [index, index + 1] : [-1, -1];\n}\nexport function paneDataHelper(panesArray, pane, layout) {\n    const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);\n    const paneIndex = findPaneDataIndex(panesArray, pane);\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    const isLastPane = paneIndex === panesArray.length - 1;\n    const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];\n    const paneSize = layout[paneIndex];\n    return {\n        ...paneConstraints,\n        paneSize,\n        pivotIndices,\n    };\n}\nexport function findPaneDataIndex(panesArray, pane) {\n    return panesArray.findIndex((prevPaneData) => prevPaneData.opts.id.current === pane.opts.id.current);\n}\n// Layout should be pre-converted into percentages\nexport function callPaneCallbacks(panesArray, layout, paneIdToLastNotifiedSizeMap) {\n    for (let index = 0; index < layout.length; index++) {\n        const size = layout[index];\n        const paneData = panesArray[index];\n        assert(paneData);\n        const { collapsedSize = 0, collapsible } = paneData.constraints;\n        const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneData.opts.id.current];\n        // invert the logic from below\n        if (!(lastNotifiedSize == null || size !== lastNotifiedSize))\n            continue;\n        paneIdToLastNotifiedSizeMap[paneData.opts.id.current] = size;\n        const { onCollapse, onExpand, onResize } = paneData.callbacks;\n        onResize?.(size, lastNotifiedSize);\n        if (collapsible && (onCollapse || onExpand)) {\n            if (onExpand &&\n                (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n                size !== collapsedSize) {\n                onExpand();\n            }\n            if (onCollapse &&\n                (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) &&\n                size === collapsedSize) {\n                onCollapse();\n            }\n        }\n    }\n}\nexport function getUnsafeDefaultLayout({ panesArray }) {\n    const layout = Array(panesArray.length);\n    const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);\n    let numPanesWithSizes = 0;\n    let remainingSize = 100;\n    // Distribute default sizes first\n    for (let index = 0; index < panesArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            numPanesWithSizes++;\n            layout[index] = defaultSize;\n            remainingSize -= defaultSize;\n        }\n    }\n    // Remaining size should be distributed evenly between panes without default sizes\n    for (let index = 0; index < panesArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            continue;\n        }\n        const numRemainingPanes = panesArray.length - numPanesWithSizes;\n        const size = remainingSize / numRemainingPanes;\n        numPanesWithSizes++;\n        layout[index] = size;\n        remainingSize -= size;\n    }\n    return layout;\n}\n// All units must be in percentages\nexport function validatePaneGroupLayout({ layout: prevLayout, paneConstraints, }) {\n    const nextLayout = [...prevLayout];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== paneConstraints.length) {\n        throw new Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout\n            .map((size) => `${size}%`)\n            .join(\", \")}`);\n    }\n    else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each pane's constraints\n    for (let index = 0; index < paneConstraints.length; index++) {\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePane({\n            paneConstraints,\n            paneIndex: index,\n            initialSize: unsafeSize,\n        });\n        if (unsafeSize !== safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any pane(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!areNumbersAlmostEqual(remainingSize, 0)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePane({\n                paneConstraints,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (areNumbersAlmostEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nexport function getPaneGroupElement(id, domContext) {\n    if (!isBrowser)\n        return null;\n    const element = domContext.querySelector(`[data-pane-group][data-pane-group-id=\"${id}\"]`);\n    if (element)\n        return element;\n    return null;\n}\nexport function getResizeHandleElement(id, domContext) {\n    if (!isBrowser)\n        return null;\n    const element = domContext.querySelector(`[data-pane-resizer-id=\"${id}\"]`);\n    if (element)\n        return element;\n    return null;\n}\nexport function getDragOffsetPercentage({ event, dragHandleId, dir, initialDragState, domContext, }) {\n    const isHorizontal = dir === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId, domContext);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-pane-group-id\");\n    assert(groupId);\n    const { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(dir, event);\n    const groupElement = getPaneGroupElement(groupId, domContext);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function getDeltaPercentage({ event, dragHandleId, dir, initialDragState, keyboardResizeBy, domContext, }) {\n    if (isKeyDown(event)) {\n        const isHorizontal = dir === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        }\n        else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        }\n        else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch (event.key) {\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    }\n    else {\n        if (initialDragState == null)\n            return 0;\n        return getDragOffsetPercentage({\n            event,\n            dragHandleId,\n            dir,\n            initialDragState,\n            domContext: domContext,\n        });\n    }\n}\nexport function getResizeEventCursorPosition(dir, e) {\n    const isHorizontal = dir === \"horizontal\";\n    if (isMouseEvent(e)) {\n        return isHorizontal ? e.clientX : e.clientY;\n    }\n    else if (isTouchEvent(e)) {\n        const firstTouch = e.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    }\n    else {\n        throw new Error(`Unsupported event type \"${e.type}\"`);\n    }\n}\nexport function getResizeHandlePaneIds({ groupId, handleId, panesArray, domContext, }) {\n    const handle = getResizeHandleElement(handleId, domContext);\n    const handles = getResizeHandleElementsForGroup(groupId, domContext);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panesArray[index]?.opts.id.current ?? null;\n    const idAfter = panesArray[index + 1]?.opts.id.current ?? null;\n    return [idBefore, idAfter];\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { getContext, hasContext, setContext } from \"svelte\";\nexport class Context {\n    #name;\n    #key;\n    /**\n     * @param name The name of the context.\n     * This is used for generating the context key and error messages.\n     */\n    constructor(name) {\n        this.#name = name;\n        this.#key = Symbol(name);\n    }\n    /**\n     * The key used to get and set the context.\n     *\n     * It is not recommended to use this value directly.\n     * Instead, use the methods provided by this class.\n     */\n    get key() {\n        return this.#key;\n    }\n    /**\n     * Checks whether this has been set in the context of a parent component.\n     *\n     * Must be called during component initialisation.\n     */\n    exists() {\n        return hasContext(this.#key);\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component.\n     *\n     * Must be called during component initialisation.\n     *\n     * @throws An error if the context does not exist.\n     */\n    get() {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            throw new Error(`Context \"${this.#name}\" not found`);\n        }\n        return context;\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component,\n     * or the given fallback value if the context does not exist.\n     *\n     * Must be called during component initialisation.\n     */\n    getOr(fallback) {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            return fallback;\n        }\n        return context;\n    }\n    /**\n     * Associates the given value with the current component and returns it.\n     *\n     * Must be called during component initialisation.\n     */\n    set(context) {\n        return setContext(this.#key, context);\n    }\n}\n", "import { assert } from \"./assert.js\";\nimport { areNumbersAlmostEqual, compareNumbersWithTolerance } from \"./compare.js\";\nimport { resizePane } from \"./resize.js\";\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger, }) {\n    if (areNumbersAlmostEqual(delta, 0))\n        return prevLayout;\n    const nextLayout = [...prevLayout];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    let deltaApplied = 0;\n    // A resizing pane affects the panes before or after it.\n    //\n    // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed pane\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                if (paneConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                            //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a pane at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                const { collapsible } = paneConstraints;\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding pane might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        while (true) {\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: 100,\n            });\n            const delta = maxSafeSize - prevSize;\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= paneConstraintsArray.length) {\n                break;\n            }\n        }\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    }\n    {\n        // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while (index >= 0 && index < paneConstraintsArray.length) {\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied\n                    .toPrecision(3)\n                    .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true,\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n        }\n    }\n    // If we were unable to resize any of the panes, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n    if (areNumbersAlmostEqual(deltaApplied, 0)) {\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panes in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePane({\n            paneConstraints: paneConstraintsArray,\n            paneIndex: pivotIndex,\n            initialSize: unsafeSize,\n        });\n        // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one pane caused another one to change collapsed state\n        if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while (index >= 0 && index < paneConstraintsArray.length) {\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePane({\n                    paneConstraints: paneConstraintsArray,\n                    paneIndex: index,\n                    initialSize: unsafeSize,\n                });\n                if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (areNumbersAlmostEqual(deltaRemaining, 0))\n                    break;\n                delta > 0 ? index-- : index++;\n            }\n        }\n    }\n    const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n    if (!areNumbersAlmostEqual(totalSize, 100))\n        return prevLayout;\n    return nextLayout;\n}\n", "/* Global cursor state */\nlet currentState = null;\n/* Global cursor element */\nlet element = null;\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state) {\n    switch (state) {\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n    if (element === null)\n        return;\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n}\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state, doc) {\n    if (currentState === state)\n        return;\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = doc.createElement(\"style\");\n        doc.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({ defaultSize, dragState, layout, panesArray, paneIndex, precision = 3, }) {\n    const size = layout[paneIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panes have registered themselves)\n        // To support server rendering, fallback to default size\n        flexGrow = defaultSize ?? \"1\";\n    }\n    else if (panesArray.length === 1) {\n        //  Single pane group should always fill full width/height\n        flexGrow = \"1\";\n    }\n    else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, pane sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a pane during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined,\n    };\n}\n", "import { LOCAL_STORAGE_DEBOUNCE_INTERVAL } from \"../constants.js\";\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject) {\n    try {\n        if (typeof localStorage === \"undefined\") {\n            throw new TypeError(\"localStorage is not supported in this environment\");\n        }\n        storageObject.getItem = (name) => localStorage.getItem(name);\n        storageObject.setItem = (name, value) => localStorage.setItem(name, value);\n    }\n    catch (err) {\n        console.error(err);\n        storageObject.getItem = () => null;\n        storageObject.setItem = () => { };\n    }\n}\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(autoSaveId) {\n    return `paneforge:${autoSaveId}`;\n}\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes) {\n    const sortedPaneIds = panes\n        .map((pane) => {\n        return pane.opts.order.current\n            ? `${pane.opts.order.current}:${JSON.stringify(pane.constraints)}`\n            : JSON.stringify(pane.constraints);\n    })\n        .sort()\n        .join(\",\");\n    return sortedPaneIds;\n}\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(autoSaveId, storage) {\n    try {\n        const paneGroupKey = getPaneGroupKey(autoSaveId);\n        const serialized = storage.getItem(paneGroupKey);\n        const parsed = JSON.parse(serialized || \"\");\n        if (typeof parsed === \"object\" && parsed !== null) {\n            return parsed;\n        }\n    }\n    catch {\n        // noop\n    }\n    return null;\n}\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(autoSaveId, panesArray, storage) {\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    const paneKey = getPaneKey(panesArray);\n    return state[paneKey] || null;\n}\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(autoSaveId, panesArray, paneSizesBeforeCollapse, sizes, storage) {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const paneKey = getPaneKey(panesArray);\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    state[paneKey] = {\n        expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n        layout: sizes,\n    };\n    try {\n        storage.setItem(paneGroupKey, JSON.stringify(state));\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const callable = (...args) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({ autoSaveId, layout, storage, panesArray, paneSizeBeforeCollapse, }) {\n    // If this pane has been configured to persist sizing\n    // information, save sizes to local storage.\n    if (layout.length === 0 || layout.length !== panesArray.length)\n        return;\n    let debouncedSave = debounceMap[autoSaveId];\n    // Limit frequency of local storage writes.\n    if (debouncedSave == null) {\n        debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n    }\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPanesArray = [...panesArray];\n    const clonedPaneSizesBeforeCollapse = new Map(paneSizeBeforeCollapse);\n    debouncedSave(autoSaveId, clonedPanesArray, clonedPaneSizesBeforeCollapse, layout, storage);\n}\n", "import { addEventListener, executeCallbacks, afterTick, attachRef, DOMContext, } from \"svelte-toolbelt\";\nimport { onMount, untrack } from \"svelte\";\nimport { Context, watch } from \"runed\";\nimport { callPaneCallbacks, findPaneDataIndex, getDeltaPercentage, getPivotIndices, getResizeEventCursorPosition, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePaneIds, getUnsafeDefaultLayout, noop, paneDataHelper, updateResizeHandleAriaValues, validatePaneGroupLayout, } from \"./internal/helpers.js\";\nimport { isKeyDown, isMouseEvent, isTouchEvent } from \"./internal/utils/is.js\";\nimport { adjustLayoutByDelta } from \"./internal/utils/adjust-layout.js\";\nimport { areArraysEqual, areNumbersAlmostEqual } from \"./internal/utils/compare.js\";\nimport { computePaneFlexBoxStyle, getCursorStyle, resetGlobalCursorStyle, setGlobalCursorStyle, } from \"./internal/utils/style.js\";\nimport { assert } from \"./internal/utils/assert.js\";\nimport { initializeStorage, loadPaneGroupState, updateStorageValues, } from \"./internal/utils/storage.js\";\nimport { on } from \"svelte/events\";\nexport const defaultStorage = {\n    getItem: (name) => {\n        initializeStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value) => {\n        initializeStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    },\n};\nconst PaneGroupContext = new Context(\"PaneGroup\");\nexport class PaneGroupState {\n    static create(opts) {\n        return PaneGroupContext.set(new PaneGroupState(opts));\n    }\n    opts;\n    attachment;\n    domContext;\n    dragState = $state.raw(null);\n    layout = $state.raw([]);\n    panesArray = $state.raw([]);\n    panesArrayChanged = $state(false);\n    paneIdToLastNotifiedSizeMap = $state({});\n    paneSizeBeforeCollapseMap = new Map();\n    prevDelta = 0;\n    constructor(opts) {\n        this.opts = opts;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        watch([() => this.opts.id.current, () => this.layout, () => this.panesArray], () => {\n            return updateResizeHandleAriaValues({\n                groupId: this.opts.id.current,\n                layout: this.layout,\n                panesArray: this.panesArray,\n                domContext: this.domContext,\n            });\n        });\n        $effect(() => {\n            return untrack(() => {\n                return this.#setResizeHandlerEventListeners();\n            });\n        });\n        watch([\n            () => this.opts.autoSaveId.current,\n            () => this.layout,\n            () => this.opts.storage.current,\n        ], () => {\n            if (!this.opts.autoSaveId.current)\n                return;\n            updateStorageValues({\n                autoSaveId: this.opts.autoSaveId.current,\n                layout: this.layout,\n                storage: this.opts.storage.current,\n                panesArray: this.panesArray,\n                paneSizeBeforeCollapse: this.paneSizeBeforeCollapseMap,\n            });\n        });\n        watch(() => this.panesArrayChanged, () => {\n            if (!this.panesArrayChanged)\n                return;\n            this.panesArrayChanged = false;\n            // const autoSaveId = this.opts.autoSaveId.current;\n            // const storage = this.opts.storage.current;\n            const prevLayout = this.layout;\n            // const paneDataArray = this.panesArray;\n            let unsafeLayout = null;\n            if (this.opts.autoSaveId.current) {\n                const state = loadPaneGroupState(this.opts.autoSaveId.current, this.panesArray, this.opts.storage.current);\n                if (state) {\n                    this.paneSizeBeforeCollapseMap = new Map(Object.entries(state.expandToSizes));\n                    unsafeLayout = state.layout;\n                }\n            }\n            if (unsafeLayout == null) {\n                unsafeLayout = getUnsafeDefaultLayout({\n                    panesArray: this.panesArray,\n                });\n            }\n            const nextLayout = validatePaneGroupLayout({\n                layout: unsafeLayout,\n                paneConstraints: this.panesArray.map((paneData) => paneData.constraints),\n            });\n            if (areArraysEqual(prevLayout, nextLayout))\n                return;\n            this.layout = nextLayout;\n            this.opts.onLayout.current?.(nextLayout);\n            callPaneCallbacks(this.panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n        });\n    }\n    setLayout = (newLayout) => {\n        this.layout = newLayout;\n    };\n    registerResizeHandle = (dragHandleId) => {\n        return (event) => {\n            event.preventDefault();\n            const direction = this.opts.direction.current;\n            const dragState = this.dragState;\n            const groupId = this.opts.id.current;\n            const keyboardResizeBy = this.opts.keyboardResizeBy.current;\n            const prevLayout = this.layout;\n            const paneDataArray = this.panesArray;\n            const { initialLayout } = dragState ?? {};\n            const doc = this.domContext.getDocument();\n            const pivotIndices = getPivotIndices({\n                groupId,\n                dragHandleId,\n                domContext: this.domContext,\n            });\n            let delta = getDeltaPercentage({\n                event: event,\n                dragHandleId,\n                dir: direction,\n                initialDragState: dragState,\n                keyboardResizeBy,\n                domContext: this.domContext,\n            });\n            if (delta === 0)\n                return;\n            // support RTL\n            const isHorizontal = direction === \"horizontal\";\n            if (doc.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const paneConstraints = paneDataArray.map((paneData) => paneData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout ?? prevLayout,\n                paneConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n            });\n            const layoutChanged = !areArraysEqual(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Pane sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                const prevDelta = this.prevDelta;\n                if (prevDelta !== delta) {\n                    this.prevDelta = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the pane any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\", doc);\n                        }\n                        else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\", doc);\n                        }\n                    }\n                    else {\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\", doc);\n                    }\n                }\n            }\n            if (layoutChanged) {\n                this.setLayout(nextLayout);\n                this.opts.onLayout.current?.(nextLayout);\n                callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n            }\n        };\n    };\n    resizePane = (paneState, unsafePaneSize) => {\n        const prevLayout = this.layout;\n        const panesArray = this.panesArray;\n        const paneConstraintsArr = panesArray.map((paneData) => paneData.constraints);\n        const { paneSize, pivotIndices } = paneDataHelper(panesArray, paneState, prevLayout);\n        assert(paneSize != null);\n        const isLastPane = findPaneDataIndex(panesArray, paneState) === panesArray.length - 1;\n        const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArr,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.setLayout(nextLayout);\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    startDragging = (dragHandleId, e) => {\n        const direction = this.opts.direction.current;\n        const layout = this.layout;\n        const handleElement = getResizeHandleElement(dragHandleId, this.domContext);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, e);\n        this.dragState = {\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout,\n        };\n    };\n    stopDragging = () => {\n        resetGlobalCursorStyle();\n        this.dragState = null;\n    };\n    isPaneCollapsed = (pane) => {\n        const paneDataArray = this.panesArray;\n        const layout = this.layout;\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper(paneDataArray, pane, layout);\n        // On init the value may be undefined, so we need to check for that\n        if (typeof paneSize !== \"number\" || typeof collapsedSize !== \"number\")\n            return false;\n        return collapsible === true && areNumbersAlmostEqual(paneSize, collapsedSize);\n    };\n    expandPane = (pane) => {\n        const prevLayout = this.layout;\n        const paneDataArray = this.panesArray;\n        if (!pane.constraints.collapsible)\n            return;\n        const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices, } = paneDataHelper(paneDataArray, pane, prevLayout);\n        if (paneSize !== collapsedSize)\n            return;\n        // restore this pane to the size it was before it was collapsed, if possible.\n        const prevPaneSize = this.paneSizeBeforeCollapseMap.get(pane.opts.id.current);\n        const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n        const isLastPane = findPaneDataIndex(paneDataArray, pane) === paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.setLayout(nextLayout);\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    collapsePane = (pane) => {\n        const prevLayout = this.layout;\n        const paneDataArray = this.panesArray;\n        if (!pane.constraints.collapsible)\n            return;\n        const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, pivotIndices, } = paneDataHelper(paneDataArray, pane, prevLayout);\n        assert(paneSize != null);\n        if (paneSize === collapsedSize)\n            return;\n        // Store the size before collapse, which is returned when `expand()` is called\n        this.paneSizeBeforeCollapseMap.set(pane.opts.id.current, paneSize);\n        const isLastPane = findPaneDataIndex(paneDataArray, pane) === paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.layout = nextLayout;\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    getPaneSize = (pane) => {\n        return paneDataHelper(this.panesArray, pane, this.layout).paneSize;\n    };\n    getPaneStyle = (pane, defaultSize) => {\n        const paneDataArray = this.panesArray;\n        const layout = this.layout;\n        const dragState = this.dragState;\n        const paneIndex = findPaneDataIndex(paneDataArray, pane);\n        return computePaneFlexBoxStyle({\n            defaultSize,\n            dragState,\n            layout,\n            panesArray: paneDataArray,\n            paneIndex,\n        });\n    };\n    isPaneExpanded = (pane) => {\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper(this.panesArray, pane, this.layout);\n        return !collapsible || paneSize > collapsedSize;\n    };\n    registerPane = (pane) => {\n        const newPaneDataArray = [...this.panesArray, pane];\n        newPaneDataArray.sort((paneA, paneB) => {\n            const orderA = paneA.opts.order.current;\n            const orderB = paneB.opts.order.current;\n            if (orderA == null && orderB == null) {\n                return 0;\n            }\n            else if (orderA == null) {\n                return -1;\n            }\n            else if (orderB == null) {\n                return 1;\n            }\n            else {\n                return orderA - orderB;\n            }\n        });\n        this.panesArray = newPaneDataArray;\n        this.panesArrayChanged = true;\n        return () => {\n            const paneDataArray = [...this.panesArray];\n            const index = findPaneDataIndex(this.panesArray, pane);\n            if (index < 0)\n                return;\n            paneDataArray.splice(index, 1);\n            this.panesArray = paneDataArray;\n            delete this.paneIdToLastNotifiedSizeMap[pane.opts.id.current];\n            this.panesArrayChanged = true;\n        };\n    };\n    #setResizeHandlerEventListeners = () => {\n        const groupId = this.opts.id.current;\n        const handles = getResizeHandleElementsForGroup(groupId, this.domContext);\n        const paneDataArray = this.panesArray;\n        const unsubHandlers = handles.map((handle) => {\n            const handleId = handle.getAttribute(\"data-pane-resizer-id\");\n            if (!handleId)\n                return noop;\n            const [idBefore, idAfter] = getResizeHandlePaneIds({\n                groupId,\n                handleId,\n                panesArray: paneDataArray,\n                domContext: this.domContext,\n            });\n            if (idBefore == null || idAfter == null)\n                return noop;\n            const onKeydown = (e) => {\n                if (e.defaultPrevented || e.key !== \"Enter\")\n                    return;\n                e.preventDefault();\n                const paneDataArray = this.panesArray;\n                const index = paneDataArray.findIndex((paneData) => paneData.opts.id.current === idBefore);\n                if (index < 0)\n                    return;\n                const paneData = paneDataArray[index];\n                assert(paneData);\n                const layout = this.layout;\n                const size = layout[index];\n                const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;\n                if (!(size != null && collapsible))\n                    return;\n                const nextLayout = adjustLayoutByDelta({\n                    delta: areNumbersAlmostEqual(size, collapsedSize)\n                        ? minSize - size\n                        : collapsedSize - size,\n                    layout,\n                    paneConstraints: paneDataArray.map((paneData) => paneData.constraints),\n                    pivotIndices: getPivotIndices({\n                        groupId,\n                        dragHandleId: handleId,\n                        domContext: this.domContext,\n                    }),\n                    trigger: \"keyboard\",\n                });\n                if (layout !== nextLayout) {\n                    this.layout = nextLayout;\n                }\n            };\n            const unsubListener = addEventListener(handle, \"keydown\", onKeydown);\n            return () => {\n                unsubListener();\n            };\n        });\n        return () => {\n            for (const unsub of unsubHandlers) {\n                unsub();\n            }\n        };\n    };\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        \"data-pane-group\": \"\",\n        \"data-direction\": this.opts.direction.current,\n        \"data-pane-group-id\": this.opts.id.current,\n        style: {\n            display: \"flex\",\n            flexDirection: this.opts.direction.current === \"horizontal\" ? \"row\" : \"column\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            width: \"100%\",\n        },\n        ...this.attachment,\n    }));\n}\nconst resizeKeys = [\"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"End\", \"Home\"];\nexport class PaneResizerState {\n    static create(opts) {\n        return new PaneResizerState(opts, PaneGroupContext.get());\n    }\n    opts;\n    #group;\n    attachment;\n    domContext;\n    #isDragging = $derived.by(() => this.#group.dragState?.dragHandleId === this.opts.id.current);\n    #isFocused = $state(false);\n    resizeHandler = null;\n    constructor(opts, group) {\n        this.opts = opts;\n        this.#group = group;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        $effect(() => {\n            if (this.opts.disabled.current) {\n                this.resizeHandler = null;\n            }\n            else {\n                this.resizeHandler = this.#group.registerResizeHandle(this.opts.id.current);\n            }\n        });\n        $effect(() => {\n            const node = this.opts.ref.current;\n            if (!node)\n                return;\n            const disabled = this.opts.disabled.current;\n            const resizeHandler = this.resizeHandler;\n            const isDragging = this.#isDragging;\n            if (disabled || resizeHandler === null || !isDragging)\n                return;\n            const onMove = (e) => {\n                resizeHandler(e);\n            };\n            const onMouseLeave = (e) => {\n                resizeHandler(e);\n            };\n            const stopDraggingAndBlur = () => {\n                node.blur();\n                this.#group.stopDragging();\n                this.opts.onDraggingChange.current(false);\n            };\n            const domBody = this.domContext.getDocument().body;\n            const domWindow = this.domContext.getWindow();\n            return executeCallbacks(on(domBody, \"contextmenu\", stopDraggingAndBlur), on(domBody, \"mousemove\", onMove), on(domBody, \"touchmove\", onMove, { passive: false }), on(domBody, \"mouseleave\", onMouseLeave), on(domWindow, \"mouseup\", stopDraggingAndBlur), on(domWindow, \"touchend\", stopDraggingAndBlur));\n        });\n    }\n    #startDragging = (e) => {\n        e.preventDefault();\n        if (this.opts.disabled.current)\n            return;\n        this.#group.startDragging(this.opts.id.current, e);\n        this.opts.onDraggingChange.current(true);\n    };\n    #stopDraggingAndBlur = () => {\n        const node = this.opts.ref.current;\n        if (!node)\n            return;\n        node.blur();\n        this.#group.stopDragging();\n        this.opts.onDraggingChange.current(false);\n    };\n    #onkeydown = (e) => {\n        if (this.opts.disabled.current || !this.resizeHandler || e.defaultPrevented)\n            return;\n        if (resizeKeys.includes(e.key)) {\n            e.preventDefault();\n            this.resizeHandler(e);\n            return;\n        }\n        if (e.key !== \"F6\")\n            return;\n        e.preventDefault();\n        const handles = getResizeHandleElementsForGroup(this.#group.opts.id.current, this.domContext);\n        const index = getResizeHandleElementIndex({\n            groupId: this.#group.opts.id.current,\n            id: this.opts.id.current,\n            domContext: this.domContext,\n        });\n        if (index === null)\n            return;\n        let nextIndex = 0;\n        if (e.shiftKey) {\n            // Moving backwards\n            if (index > 0) {\n                nextIndex = index - 1;\n            }\n            else {\n                nextIndex = handles.length - 1;\n            }\n        }\n        else {\n            // Moving forwards\n            if (index + 1 < handles.length) {\n                nextIndex = index + 1;\n            }\n            else {\n                nextIndex = 0;\n            }\n        }\n        const nextHandle = handles[nextIndex];\n        nextHandle.focus();\n    };\n    #onblur = () => {\n        this.#isFocused = false;\n    };\n    #onfocus = () => {\n        this.#isFocused = true;\n    };\n    #onmousedown = (e) => {\n        this.#startDragging(e);\n    };\n    #onmouseup = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchcancel = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchend = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchstart = (e) => {\n        this.#startDragging(e);\n    };\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        role: \"separator\",\n        \"data-direction\": this.#group.opts.direction.current,\n        \"data-pane-group-id\": this.#group.opts.id.current,\n        \"data-active\": this.#isDragging\n            ? \"pointer\"\n            : this.#isFocused\n                ? \"keyboard\"\n                : undefined,\n        \"data-enabled\": !this.opts.disabled.current,\n        \"data-pane-resizer-id\": this.opts.id.current,\n        \"data-pane-resizer\": \"\",\n        tabIndex: this.opts.tabIndex.current,\n        style: {\n            cursor: getCursorStyle(this.#group.opts.direction.current),\n            touchAction: \"none\",\n            userSelect: \"none\",\n            \"-webkit-user-select\": \"none\",\n            \"-webkit-touch-callout\": \"none\",\n        },\n        onkeydown: this.#onkeydown,\n        onblur: this.#onblur,\n        onfocus: this.#onfocus,\n        onmousedown: this.#onmousedown,\n        onmouseup: this.#onmouseup,\n        ontouchcancel: this.#ontouchcancel,\n        ontouchend: this.#ontouchend,\n        ontouchstart: this.#ontouchstart,\n        ...this.attachment,\n    }));\n}\nexport class PaneState {\n    static create(opts) {\n        return new PaneState(opts, PaneGroupContext.get());\n    }\n    opts;\n    group;\n    attachment;\n    domContext;\n    #paneTransitionState = $state(\"\");\n    callbacks = $derived.by(() => ({\n        onCollapse: this.opts.onCollapse.current,\n        onExpand: this.opts.onExpand.current,\n        onResize: this.opts.onResize.current,\n    }));\n    constraints = $derived.by(() => ({\n        collapsedSize: this.opts.collapsedSize.current,\n        collapsible: this.opts.collapsible.current,\n        defaultSize: this.opts.defaultSize.current,\n        maxSize: this.opts.maxSize.current,\n        minSize: this.opts.minSize.current,\n    }));\n    #handleTransition = (state) => {\n        this.#paneTransitionState = state;\n        afterTick(() => {\n            if (this.opts.ref.current) {\n                const element = this.opts.ref.current;\n                const computedStyle = getComputedStyle(element);\n                const hasTransition = computedStyle.transitionDuration !== \"0s\";\n                if (!hasTransition) {\n                    this.#paneTransitionState = \"\";\n                    return;\n                }\n                const handleTransitionEnd = (event) => {\n                    // Only handle width/flex transitions\n                    if (event.propertyName === \"flex-grow\") {\n                        this.#paneTransitionState = \"\";\n                        element.removeEventListener(\"transitionend\", handleTransitionEnd);\n                    }\n                };\n                // Always add the listener - if there's no transition, it won't fire\n                element.addEventListener(\"transitionend\", handleTransitionEnd);\n            }\n            else {\n                this.#paneTransitionState = \"\";\n            }\n        });\n    };\n    pane = {\n        collapse: () => {\n            this.#handleTransition(\"collapsing\");\n            this.group.collapsePane(this);\n        },\n        expand: () => {\n            this.#handleTransition(\"expanding\");\n            this.group.expandPane(this);\n        },\n        getSize: () => this.group.getPaneSize(this),\n        isCollapsed: () => this.group.isPaneCollapsed(this),\n        isExpanded: () => this.group.isPaneExpanded(this),\n        resize: (size) => this.group.resizePane(this, size),\n        getId: () => this.opts.id.current,\n    };\n    constructor(opts, group) {\n        this.opts = opts;\n        this.group = group;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        onMount(() => {\n            return this.group.registerPane(this);\n        });\n        watch(() => $state.snapshot(this.constraints), () => {\n            this.group.panesArrayChanged = true;\n        });\n    }\n    #isCollapsed = $derived.by(() => this.group.isPaneCollapsed(this));\n    #paneState = $derived.by(() => this.#paneTransitionState !== \"\"\n        ? this.#paneTransitionState\n        : this.#isCollapsed\n            ? \"collapsed\"\n            : \"expanded\");\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        style: this.group.getPaneStyle(this, this.opts.defaultSize.current),\n        \"data-pane\": \"\",\n        \"data-pane-id\": this.opts.id.current,\n        \"data-pane-group-id\": this.group.opts.id.current,\n        \"data-collapsed\": this.#isCollapsed ? \"\" : undefined,\n        \"data-expanded\": this.#isCollapsed ? undefined : \"\",\n        \"data-pane-state\": this.#paneState,\n        ...this.attachment,\n    }));\n}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneGroupProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { defaultStorage, PaneGroupState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tautoSaveId = null,\n\t\tdirection,\n\t\tid = uid,\n\t\tkeyboardResizeBy = null,\n\t\tonLayoutChange = noop,\n\t\tstorage = defaultStorage,\n\t\tref = $bindable(null),\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneGroupProps = $props();\n\n\tconst paneGroupState = PaneGroupState.create({\n\t\tid: box.with(() => id ?? uid),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tautoSaveId: box.with(() => autoSaveId),\n\t\tdirection: box.with(() => direction),\n\t\tkeyboardResizeBy: box.with(() => keyboardResizeBy),\n\t\tonLayout: box.with(() => onLayoutChange),\n\t\tstorage: box.with(() => storage),\n\t});\n\n\texport const getLayout = () => paneGroupState.layout;\n\texport const setLayout = paneGroupState.setLayout;\n\texport const getId = () => paneGroupState.opts.id.current;\n\n\tconst mergedProps = $derived(mergeProps(restProps, paneGroupState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { PaneState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tid = uid,\n\t\tref = $bindable(null),\n\t\tcollapsedSize,\n\t\tcollapsible,\n\t\tdefaultSize,\n\t\tmaxSize,\n\t\tminSize,\n\t\tonCollapse = noop,\n\t\tonExpand = noop,\n\t\tonResize = noop,\n\t\torder,\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneProps = $props();\n\n\tconst paneState = PaneState.create({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tcollapsedSize: box.with(() => collapsedSize),\n\t\tcollapsible: box.with(() => collapsible),\n\t\tdefaultSize: box.with(() => defaultSize),\n\t\tmaxSize: box.with(() => maxSize),\n\t\tminSize: box.with(() => minSize),\n\t\tonCollapse: box.with(() => onCollapse),\n\t\tonExpand: box.with(() => onExpand),\n\t\tonResize: box.with(() => onResize),\n\t\torder: box.with(() => order),\n\t});\n\n\texport const collapse = paneState.pane.collapse;\n\texport const expand = paneState.pane.expand;\n\texport const getSize = paneState.pane.getSize;\n\texport const isCollapsed = paneState.pane.isCollapsed;\n\texport const isExpanded = paneState.pane.isExpanded;\n\texport const resize = paneState.pane.resize;\n\texport const getId = paneState.pane.getId;\n\n\tconst mergedProps = $derived(mergeProps(restProps, paneState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneResizerProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { PaneResizerState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tid = uid,\n\t\tref = $bindable(null),\n\t\tdisabled = false,\n\t\tonDraggingChange = noop,\n\t\ttabindex = 0,\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneResizerProps = $props();\n\n\tconst resizerState = PaneResizerState.create({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tdisabled: box.with(() => disabled),\n\t\tonDraggingChange: box.with(() => onDraggingChange),\n\t\ttabIndex: box.with(() => tabindex),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, resizerState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n"],
  "mappings": "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",
  "names": ["element", "noop", "element", "document", "activeElement", "window", "document", "paneConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "state", "state", "state", "noop", "paneDataArray", "paneData", "element", "noop", "noop", "noop"]
}
