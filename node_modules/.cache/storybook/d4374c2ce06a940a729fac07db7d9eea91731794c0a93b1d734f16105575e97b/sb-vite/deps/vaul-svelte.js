import {
  exports_exports16 as exports_exports
} from "./chunk-T57FFCWY.js";
import "./chunk-XJ3IM2VA.js";
import {
  esm_default
} from "./chunk-NRMMMDUL.js";
import "./chunk-SIGXRIP3.js";
import "./chunk-WL7JBLBF.js";
import "./chunk-OEZDBU4I.js";
import "./chunk-7RQDXF5S.js";
import "./chunk-UTM3QVDF.js";
import "./chunk-6LD3WD6G.js";
import {
  add_locations,
  append_styles,
  attribute_effect,
  check_target,
  cleanup_styles,
  component,
  create_ownership_validator,
  hmr,
  if_block,
  legacy_api,
  onMount,
  prop,
  rest_props,
  snippet,
  spread_props,
  wrap_snippet
} from "./chunk-FRZCO2ZW.js";
import {
  clsx
} from "./chunk-ZYTAZ2LT.js";
import {
  append,
  comment,
  from_html
} from "./chunk-OIZRCF3F.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  createSubscriber,
  effect_root,
  first_child,
  get,
  getContext,
  hasContext,
  noop,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tick,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-ITKELFPS.js";
import "./chunk-HXIGQYEZ.js";
import {
  true_default
} from "./chunk-E62QTSXI.js";
import "./chunk-P6TGDP3C.js";
import {
  __export
} from "./chunk-PR4QN5HX.js";

// node_modules/vaul-svelte/dist/components/drawer/index.js
var drawer_exports = {};
__export(drawer_exports, {
  Close: () => Close,
  Content: () => drawer_content_default,
  Description: () => Description,
  Handle: () => drawer_handle_default,
  NestedRoot: () => drawer_nested_default,
  Overlay: () => drawer_overlay_default,
  Portal: () => drawer_portal_default,
  Root: () => drawer_default,
  Title: () => Title,
  Trigger: () => Trigger
});

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        handler.current?.call(this, e);
      }
    }
  };
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p) => upperFirst(p)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  esm_default(css, iterator);
  return styleObj;
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  return key.length > 2 && key.startsWith("on") && key[2] === key[2]?.toLowerCase();
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    for (const key in props) {
      const a = result[key];
      const b = props[key];
      const aIsFunction = typeof a === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a, b);
      } else if (key === "class") {
        const aIsClassValue = isClassValue(a);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key] = clsx(a, b);
        } else if (aIsClassValue) {
          result[key] = clsx(a);
        } else if (bIsClassValue) {
          result[key] = clsx(b);
        }
      } else if (key === "style") {
        const aIsObject = typeof a === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a;
        } else if (bIsObject) {
          result[key] = b;
        } else if (aIsString) {
          result[key] = a;
        } else if (bIsString) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a;
      }
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/vaul-svelte/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/vaul-svelte/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2?.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/vaul-svelte/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/vaul-svelte/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/vaul-svelte/node_modules/runed/dist/utilities/context/context.js
var Context = class {
  #name;
  #key;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    this.#name = name;
    this.#key = Symbol(name);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#key;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(this.#key);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(this.#key);
    if (context === void 0) {
      throw new Error(`Context "${this.#name}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(this.#key);
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(this.#key, context);
  }
};

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js
function onDestroyEffect(fn) {
  user_effect(() => {
    return () => {
      fn();
    };
  });
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/use-ref-by-id.svelte.js
function useRefById({ id, ref, deps = () => true, onRefChange, getRootNode }) {
  watch([() => id.current, deps], ([_id]) => {
    const rootNode = getRootNode?.() ?? document;
    const node = rootNode?.getElementById(_id);
    if (node) ref.current = node;
    else ref.current = null;
    onRefChange?.(ref.current);
  });
  onDestroyEffect(() => {
    ref.current = null;
    onRefChange?.(null);
  });
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/after-sleep.js
function afterSleep(ms, cb) {
  return setTimeout(cb, ms);
}

// node_modules/vaul-svelte/node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/vaul-svelte/dist/internal/noop.js
function noop3() {
}

// node_modules/vaul-svelte/dist/internal/constants.js
var TRANSITIONS = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
};
var VELOCITY_THRESHOLD = 0.4;
var CLOSE_THRESHOLD = 0.25;
var SCROLL_LOCK_TIMEOUT = 100;
var BORDER_RADIUS = 8;
var NESTED_DISPLACEMENT = 16;
var WINDOW_TOP_OFFSET = 26;
var DRAG_CLASS = "vaul-dragging";

// node_modules/vaul-svelte/dist/helpers.js
var cache = /* @__PURE__ */ new WeakMap();
function set2(el, styles, ignoreCache = false) {
  if (!el || !(el instanceof HTMLElement))
    return;
  let originalStyles = {};
  Object.entries(styles).forEach(([key, value]) => {
    if (key.startsWith("--")) {
      el.style.setProperty(key, value);
      return;
    }
    originalStyles[key] = el.style[key];
    el.style[key] = value;
  });
  if (ignoreCache)
    return;
  cache.set(el, originalStyles);
}
function reset2(el, prop2) {
  if (!el || !(el instanceof HTMLElement))
    return;
  let originalStyles = cache.get(el);
  if (!originalStyles)
    return;
  if (prop2) {
    el.style[prop2] = originalStyles[prop2];
  } else {
    Object.entries(originalStyles).forEach(([key, value]) => {
      el.style[key] = value;
    });
  }
}
var isVertical = (direction) => {
  switch (direction) {
    case "top":
    case "bottom":
      return true;
    case "left":
    case "right":
      return false;
    default:
      return direction;
  }
};
function getTranslate(element, direction) {
  if (!element) {
    return null;
  }
  const style = window.getComputedStyle(element);
  const transform = (
    // @ts-expect-error - shh
    style.transform || style.webkitTransform || style.mozTransform
  );
  let mat = transform.match(/^matrix3d\((.+)\)$/);
  if (mat) {
    return parseFloat(mat[1].split(", ")[isVertical(direction) ? 13 : 12]);
  }
  mat = transform.match(/^matrix\((.+)\)$/);
  return mat ? parseFloat(mat[1].split(", ")[isVertical(direction) ? 5 : 4]) : null;
}
function dampenValue(v) {
  return 8 * (Math.log(v + 1) - 2);
}
function assignStyle(element, style) {
  if (!element)
    return () => {
    };
  const prevStyle = element.style.cssText;
  Object.assign(element.style, style);
  return () => {
    element.style.cssText = prevStyle;
  };
}
function chain(...fns) {
  return (...args) => {
    for (const fn of fns) {
      if (typeof fn === "function") {
        fn(...args);
      }
    }
  };
}

// node_modules/vaul-svelte/dist/use-snap-points.svelte.js
function useSnapPoints({
  snapPoints,
  drawerNode,
  overlayNode,
  fadeFromIndex,
  setOpenTime,
  direction,
  container,
  snapToSequentialPoint,
  activeSnapPoint,
  open,
  isReleasing
}) {
  let windowDimensions = tag(
    state(proxy(strict_equals(typeof window, "undefined", false) ? {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    } : void 0)),
    "windowDimensions"
  );
  onMount(() => {
    function onResize() {
      set(
        windowDimensions,
        {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight
        },
        true
      );
    }
    return on(window, "resize", onResize);
  });
  const isLastSnapPoint = tag(user_derived(() => strict_equals(activeSnapPoint.current, snapPoints.current?.[snapPoints.current.length - 1]) || null), "isLastSnapPoint");
  const activeSnapPointIndex = tag(user_derived(() => snapPoints.current?.findIndex((snapPoint) => strict_equals(snapPoint, activeSnapPoint.current))), "activeSnapPointIndex");
  const shouldFade = tag(user_derived(() => snapPoints.current && snapPoints.current.length > 0 && (fadeFromIndex.current || strict_equals(fadeFromIndex.current, 0)) && !Number.isNaN(fadeFromIndex.current) && strict_equals(snapPoints.current[fadeFromIndex.current], activeSnapPoint.current) || !snapPoints.current), "shouldFade");
  const snapPointsOffset = tag(
    user_derived(() => {
      open.current;
      const containerSize = container.current ? {
        width: container.current.getBoundingClientRect().width,
        height: container.current.getBoundingClientRect().height
      } : strict_equals(typeof window, "undefined", false) ? { width: window.innerWidth, height: window.innerHeight } : { width: 0, height: 0 };
      return snapPoints.current?.map((snapPoint) => {
        const isPx = strict_equals(typeof snapPoint, "string");
        let snapPointAsNumber = 0;
        if (isPx) {
          snapPointAsNumber = parseInt(snapPoint, 10);
        }
        if (isVertical(direction.current)) {
          const height = isPx ? snapPointAsNumber : get(windowDimensions) ? snapPoint * containerSize.height : 0;
          if (get(windowDimensions)) {
            return strict_equals(direction.current, "bottom") ? containerSize.height - height : -containerSize.height + height;
          }
          return height;
        }
        const width = isPx ? snapPointAsNumber : get(windowDimensions) ? snapPoint * containerSize.width : 0;
        if (get(windowDimensions)) {
          return strict_equals(direction.current, "right") ? containerSize.width - width : -containerSize.width + width;
        }
        return width;
      }) ?? [];
    }),
    "snapPointsOffset"
  );
  const activeSnapPointOffset = tag(
    user_derived(() => {
      if (strict_equals(get(activeSnapPointIndex), null, false)) {
        if (strict_equals(get(activeSnapPointIndex), void 0, false)) {
          return get(snapPointsOffset)[get(activeSnapPointIndex)];
        }
      }
      return null;
    }),
    "activeSnapPointOffset"
  );
  function onSnapPointChange(activeSnapPointIndex2) {
    if (snapPoints.current && strict_equals(activeSnapPointIndex2, get(snapPointsOffset).length - 1)) {
      setOpenTime(/* @__PURE__ */ new Date());
    }
  }
  function snapToPoint(dimension) {
    const newSnapPointIndex = get(snapPointsOffset)?.findIndex((snapPointDim) => strict_equals(snapPointDim, dimension)) ?? null;
    onSnapPointChange(newSnapPointIndex);
    set2(drawerNode(), {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: isVertical(direction.current) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`
    });
    if (get(snapPointsOffset) && strict_equals(newSnapPointIndex, get(snapPointsOffset).length - 1, false) && strict_equals(fadeFromIndex.current, void 0, false) && strict_equals(newSnapPointIndex, fadeFromIndex.current, false) && newSnapPointIndex < fadeFromIndex.current) {
      set2(overlayNode(), {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "0"
      });
    } else {
      set2(overlayNode(), {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        opacity: "1"
      });
    }
    activeSnapPoint.current = snapPoints.current?.[Math.max(newSnapPointIndex, 0)];
  }
  watch([() => activeSnapPoint.current, () => open.current], () => {
    const releasing = isReleasing();
    if (!activeSnapPoint.current || releasing) return;
    const newIndex = snapPoints.current?.findIndex((snapPoint) => strict_equals(snapPoint, activeSnapPoint.current)) ?? -1;
    if (get(snapPointsOffset) && strict_equals(newIndex, -1, false) && strict_equals(typeof get(snapPointsOffset)[newIndex], "number")) {
      if (strict_equals(get(snapPointsOffset)[newIndex], activeSnapPoint.current)) return;
      snapToPoint(get(snapPointsOffset)[newIndex]);
    }
  });
  function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {
    if (strict_equals(fadeFromIndex.current, void 0)) return;
    const dir = direction.current;
    const currentPosition = strict_equals(dir, "bottom") || strict_equals(dir, "right") ? (get(activeSnapPointOffset) ?? 0) - draggedDistance : (get(activeSnapPointOffset) ?? 0) + draggedDistance;
    const isOverlaySnapPoint = strict_equals(get(activeSnapPointIndex), fadeFromIndex.current - 1);
    const isFirst = strict_equals(get(activeSnapPointIndex), 0);
    const hasDraggedUp = draggedDistance > 0;
    if (isOverlaySnapPoint) {
      set2(overlayNode(), {
        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
      });
    }
    if (!snapToSequentialPoint.current && velocity > 2 && !hasDraggedUp) {
      if (dismissible) {
        closeDrawer();
      } else {
        snapToPoint(get(snapPointsOffset)[0]);
      }
      return;
    }
    if (!snapToSequentialPoint.current && velocity > 2 && hasDraggedUp && get(snapPointsOffset) && snapPoints.current) {
      snapToPoint(get(snapPointsOffset)[snapPoints.current.length - 1]);
      return;
    }
    const closestSnapPoint = get(snapPointsOffset)?.reduce((prev, curr) => {
      if (strict_equals(typeof prev, "number", false) || strict_equals(typeof curr, "number", false)) return prev;
      return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;
    });
    const dim = isVertical(dir) ? window.innerHeight : window.innerWidth;
    if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {
      const dragDirection = hasDraggedUp ? 1 : -1;
      if (dragDirection > 0 && get(isLastSnapPoint) && snapPoints.current) {
        snapToPoint(get(snapPointsOffset)[snapPoints.current.length - 1]);
        return;
      }
      if (isFirst && dragDirection < 0 && dismissible) {
        closeDrawer();
      }
      if (strict_equals(get(activeSnapPointIndex), null)) return;
      snapToPoint(get(snapPointsOffset)[get(activeSnapPointIndex) + dragDirection]);
      return;
    }
    snapToPoint(closestSnapPoint);
  }
  function onDrag({ draggedDistance }) {
    if (strict_equals(get(activeSnapPointOffset), null)) return;
    const dir = direction.current;
    const newValue = isBottomOrRight(dir) ? get(activeSnapPointOffset) - draggedDistance : get(activeSnapPointOffset) + draggedDistance;
    const lastSnapPoint = get(snapPointsOffset)[get(snapPointsOffset).length - 1];
    if (isBottomOrRight(dir) && newValue < lastSnapPoint) return;
    if (!isBottomOrRight(dir) && newValue > lastSnapPoint) return;
    set2(drawerNode(), {
      transform: isVertical(dir) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`
    });
  }
  function getPercentageDragged(absDraggedDistance, isDraggingDown) {
    if (!snapPoints.current || strict_equals(typeof get(activeSnapPointIndex), "number", false) || !get(snapPointsOffset) || strict_equals(fadeFromIndex.current, void 0)) {
      return null;
    }
    const isOverlaySnapPoint = strict_equals(get(activeSnapPointIndex), fadeFromIndex.current - 1);
    const isOverlaySnapPointOrHigher = get(activeSnapPointIndex) >= fadeFromIndex.current;
    if (isOverlaySnapPointOrHigher && isDraggingDown) {
      return 0;
    }
    if (isOverlaySnapPoint && !isDraggingDown) {
      return 1;
    }
    if (!get(shouldFade) && !isOverlaySnapPoint) {
      return null;
    }
    const targetSnapPointIndex = isOverlaySnapPoint ? get(activeSnapPointIndex) + 1 : get(activeSnapPointIndex) - 1;
    const snapPointDistance = isOverlaySnapPoint ? get(snapPointsOffset)[targetSnapPointIndex] - get(snapPointsOffset)[targetSnapPointIndex - 1] : get(snapPointsOffset)[targetSnapPointIndex + 1] - get(snapPointsOffset)[targetSnapPointIndex];
    const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);
    if (isOverlaySnapPoint) {
      return 1 - percentageDragged;
    } else {
      return percentageDragged;
    }
  }
  return {
    get isLastSnapPoint() {
      return get(isLastSnapPoint);
    },
    get shouldFade() {
      return get(shouldFade);
    },
    get activeSnapPointIndex() {
      return get(activeSnapPointIndex);
    },
    get snapPointsOffset() {
      return snapshot(get(snapPointsOffset));
    },
    getPercentageDragged,
    onRelease,
    onDrag
  };
}
function isBottomOrRight(direction) {
  if (strict_equals(direction, "bottom") || strict_equals(direction, "right")) return true;
  return false;
}

// node_modules/vaul-svelte/dist/internal/browser.js
var isBrowser = typeof document !== "undefined";
function isMobileFirefox() {
  const userAgent = navigator.userAgent;
  return typeof window !== "undefined" && (/Firefox/.test(userAgent) && /Mobile/.test(userAgent) || // Android Firefox
  /FxiOS/.test(userAgent));
}
function isMac() {
  return testPlatform(/^Mac/);
}
function isIPhone() {
  return testPlatform(/^iPhone/);
}
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isIPad() {
  return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function testPlatform(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(window.navigator.platform) : void 0;
}

// node_modules/vaul-svelte/dist/use-prevent-scroll.svelte.js
var KEYBOARD_BUFFER = 24;
function chain2(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) {
      if (strict_equals(typeof callback, "function")) {
        callback(...args);
      }
    }
  };
}
var visualViewport = isBrowser && window.visualViewport;
function isScrollable(node) {
  let style = window.getComputedStyle(node);
  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}
function getScrollParent(node) {
  if (isScrollable(node)) {
    node = node.parentElement;
  }
  while (node && !isScrollable(node)) {
    node = node.parentElement;
  }
  return node || document.scrollingElement || document.documentElement;
}
var nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var preventScrollCount = 0;
var restore;
function usePreventScroll(opts) {
  watch(opts.isDisabled, () => {
    if (opts.isDisabled()) {
      return;
    }
    preventScrollCount++;
    if (strict_equals(preventScrollCount, 1)) {
      if (isIOS()) {
        restore = preventScrollMobileSafari();
      }
    }
    return () => {
      preventScrollCount--;
      if (strict_equals(preventScrollCount, 0)) {
        restore?.();
      }
    };
  });
}
function preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  const onTouchStart = (e) => {
    scrollable = getScrollParent(e.target);
    if (strict_equals(scrollable, document.documentElement) && strict_equals(scrollable, document.body)) {
      return;
    }
    lastY = e.changedTouches[0].pageY;
  };
  let onTouchMove = (e) => {
    if (!scrollable || strict_equals(scrollable, document.documentElement) || strict_equals(scrollable, document.body)) {
      e.preventDefault();
      return;
    }
    let y = e.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (strict_equals(bottom, 0)) {
      return;
    }
    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }
    lastY = y;
  };
  let onTouchEnd = (e) => {
    let target = e.target;
    if (isInput(target) && strict_equals(target, document.activeElement, false)) {
      e.preventDefault();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
  };
  const onFocus = (e) => {
    let target = e.target;
    if (isInput(target)) {
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if (visualViewport) {
          if (visualViewport.height < window.innerHeight) {
            requestAnimationFrame(() => {
              scrollIntoView(target);
            });
          } else {
            visualViewport.addEventListener("resize", () => scrollIntoView(target), { once: true });
          }
        }
      });
    }
  };
  let onWindowScroll = () => {
    window.scrollTo(0, 0);
  };
  let scrollX = window.pageXOffset;
  let scrollY = window.pageYOffset;
  let restoreStyles = chain2(setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let removeEvents = chain2(on(document, "touchstart", onTouchStart, { passive: false, capture: true }), on(document, "touchmove", onTouchMove, { passive: false, capture: true }), on(document, "touchend", onTouchEnd, { passive: false, capture: true }), on(document, "focus", onFocus, { capture: true }), on(window, "scroll", onWindowScroll));
  return () => {
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
}
function setStyle(element, style, value) {
  let cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
}
function scrollIntoView(target) {
  let root2 = document.scrollingElement || document.documentElement;
  while (target && strict_equals(target, root2, false)) {
    let scrollable = getScrollParent(target);
    if (strict_equals(scrollable, document.documentElement, false) && strict_equals(scrollable, document.body, false) && strict_equals(scrollable, target, false)) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      let targetBottom = target.getBoundingClientRect().bottom;
      const keyboardHeight = scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;
      if (targetBottom > keyboardHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    target = scrollable.parentElement;
  }
}
function isInput(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}

// node_modules/vaul-svelte/dist/use-position-fixed.svelte.js
var previousBodyPosition = null;
function usePositionFixed({
  open,
  modal,
  nested,
  hasBeenOpened,
  preventScrollRestoration,
  noBodyStyles
}) {
  let activeUrl = tag(state(proxy(strict_equals(typeof window, "undefined", false) ? window.location.href : "")), "activeUrl");
  let scrollPos = 0;
  function setPositionFixed() {
    if (!isSafari()) return;
    if (strict_equals(previousBodyPosition, null) && open.current && !noBodyStyles.current) {
      previousBodyPosition = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX, innerHeight } = window;
      document.body.style.setProperty("position", "fixed", "important");
      Object.assign(document.body.style, {
        top: `${-scrollPos}px`,
        left: `${-scrollX}px`,
        right: "0px",
        height: "auto"
      });
      window.setTimeout(
        () => window.requestAnimationFrame(() => {
          const bottomBarHeight = innerHeight - window.innerHeight;
          if (bottomBarHeight && scrollPos >= innerHeight) {
            document.body.style.top = `${-(scrollPos + bottomBarHeight)}px`;
          }
        }),
        300
      );
    }
  }
  function restorePositionSetting() {
    if (!isSafari()) return;
    if (strict_equals(previousBodyPosition, null, false) && !noBodyStyles.current) {
      const y = -parseInt(document.body.style.top, 10);
      const x = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, previousBodyPosition);
      window.requestAnimationFrame(() => {
        if (preventScrollRestoration.current && strict_equals(get(activeUrl), window.location.href, false)) {
          set(activeUrl, window.location.href, true);
          return;
        }
        window.scrollTo(x, y);
      });
      previousBodyPosition = null;
    }
  }
  onMount(() => {
    function onScroll() {
      scrollPos = window.scrollY;
    }
    onScroll();
    return on(window, "scroll", onScroll);
  });
  watch([() => modal.current, () => get(activeUrl)], () => {
    if (!modal.current) return;
    return () => {
      if (strict_equals(typeof document, "undefined")) return;
      const hasDrawerOpened = !!document.querySelector("[data-vaul-drawer]");
      if (hasDrawerOpened) return;
      restorePositionSetting();
    };
  });
  watch(
    [
      () => open.current,
      () => hasBeenOpened(),
      () => get(activeUrl),
      () => modal.current,
      () => nested.current
    ],
    () => {
      if (nested.current || !hasBeenOpened()) return;
      if (open.current) {
        const isStandalone = window.matchMedia("(display-mode: standalone)").matches;
        !isStandalone && setPositionFixed();
        if (!modal.current) {
          window.setTimeout(
            () => {
              restorePositionSetting();
            },
            500
          );
        }
      } else {
        restorePositionSetting();
      }
    }
  );
  return { restorePositionSetting };
}

// node_modules/vaul-svelte/dist/context.js
var DrawerContext = new Context("Drawer.Root");

// node_modules/vaul-svelte/dist/use-drawer-root.svelte.js
function useDrawerRoot(opts) {
  let hasBeenOpened = tag(state(false), "hasBeenOpened");
  let isDragging = tag(state(false), "isDragging");
  let justReleased = tag(state(false), "justReleased");
  let overlayNode = tag(state(null), "overlayNode");
  let drawerNode = tag(state(null), "drawerNode");
  let openTime = null;
  let dragStartTime = null;
  let dragEndTime = null;
  let lastTimeDragPrevented = null;
  let isAllowedToDrag = false;
  let nestedOpenChangeTimer = null;
  let pointerStart = 0;
  let keyboardIsOpen = box(false);
  let shouldAnimate = tag(state(!opts.open.current), "shouldAnimate");
  let previousDiffFromInitial = 0;
  let drawerHeight = 0;
  let drawerWidth = 0;
  let initialDrawerHeight = 0;
  let isReleasing = false;
  const snapPointsState = useSnapPoints({
    snapPoints: opts.snapPoints,
    drawerNode: () => get(drawerNode),
    activeSnapPoint: opts.activeSnapPoint,
    container: opts.container,
    direction: opts.direction,
    fadeFromIndex: opts.fadeFromIndex,
    overlayNode: () => get(overlayNode),
    setOpenTime: (time) => {
      openTime = time;
    },
    snapToSequentialPoint: opts.snapToSequentialPoint,
    open: opts.open,
    isReleasing: () => isReleasing
  });
  usePreventScroll({
    isDisabled: () => !opts.open.current || get(isDragging) || !opts.modal.current || get(justReleased) || !get(hasBeenOpened) || !opts.repositionInputs.current || !opts.disablePreventScroll.current
  });
  const { restorePositionSetting } = usePositionFixed({ ...opts, hasBeenOpened: () => get(hasBeenOpened) });
  function getScale() {
    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
  }
  function onPress(event) {
    if (!opts.dismissible.current && !opts.snapPoints.current) return;
    if (get(drawerNode) && !get(drawerNode).contains(event.target)) return;
    drawerHeight = get(drawerNode)?.getBoundingClientRect().height || 0;
    drawerWidth = get(drawerNode)?.getBoundingClientRect().width || 0;
    set(isDragging, true);
    dragStartTime = /* @__PURE__ */ new Date();
    if (isIOS()) {
      on(window, "touchend", () => isAllowedToDrag = false, { once: true });
    }
    event.target.setPointerCapture(event.pointerId);
    pointerStart = isVertical(opts.direction.current) ? event.pageY : event.pageX;
  }
  function shouldDrag(el, isDraggingInDirection) {
    let element = el;
    const highlightedText = window.getSelection()?.toString();
    const swipeAmount = get(drawerNode) ? getTranslate(get(drawerNode), opts.direction.current) : null;
    const date = /* @__PURE__ */ new Date();
    if (strict_equals(element.tagName, "SELECT")) return false;
    if (element.hasAttribute("data-vaul-no-drag") || element.closest("[data-vaul-no-drag]")) {
      return false;
    }
    if (strict_equals(opts.direction.current, "right") || strict_equals(opts.direction.current, "left")) {
      return true;
    }
    if (openTime && date.getTime() - openTime.getTime() < 500) {
      return false;
    }
    if (strict_equals(swipeAmount, null, false)) {
      if (strict_equals(opts.direction.current, "bottom") ? swipeAmount > 0 : swipeAmount < 0) {
        return true;
      }
    }
    if (highlightedText && highlightedText.length > 0) {
      return false;
    }
    if (lastTimeDragPrevented && date.getTime() - lastTimeDragPrevented.getTime() < opts.scrollLockTimeout.current && strict_equals(swipeAmount, 0)) {
      lastTimeDragPrevented = date;
      return false;
    }
    if (isDraggingInDirection) {
      lastTimeDragPrevented = date;
      return false;
    }
    while (element) {
      if (element.scrollHeight > element.clientHeight) {
        if (strict_equals(element.scrollTop, 0, false)) {
          lastTimeDragPrevented = /* @__PURE__ */ new Date();
          return false;
        }
        if (strict_equals(element.getAttribute("role"), "dialog")) {
          return true;
        }
      }
      element = element.parentNode;
    }
    return true;
  }
  function onDrag(event) {
    if (!get(drawerNode) || !get(isDragging)) return;
    const directionMultiplier = strict_equals(opts.direction.current, "bottom") || strict_equals(opts.direction.current, "right") ? 1 : -1;
    const draggedDistance = (pointerStart - (isVertical(opts.direction.current) ? event.pageY : event.pageX)) * directionMultiplier;
    const isDraggingInDirection = draggedDistance > 0;
    const noCloseSnapPointsPreCondition = opts.snapPoints.current && !opts.dismissible.current && !isDraggingInDirection;
    if (noCloseSnapPointsPreCondition && strict_equals(snapPointsState.activeSnapPointIndex, 0)) return;
    const absDraggedDistance = Math.abs(draggedDistance);
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    const drawerDimension = strict_equals(opts.direction.current, "bottom") || strict_equals(opts.direction.current, "top") ? drawerHeight : drawerWidth;
    let percentageDragged = absDraggedDistance / drawerDimension;
    const snapPointPercentageDragged = snapPointsState.getPercentageDragged(absDraggedDistance, isDraggingInDirection);
    if (strict_equals(snapPointPercentageDragged, null, false)) {
      percentageDragged = snapPointPercentageDragged;
    }
    if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {
      return;
    }
    if (!isAllowedToDrag && !shouldDrag(event.target, isDraggingInDirection)) return;
    get(drawerNode).classList.add(DRAG_CLASS);
    isAllowedToDrag = true;
    set2(get(drawerNode), { transition: "none" });
    set2(get(overlayNode), { transition: "none" });
    if (opts.snapPoints.current) {
      snapPointsState.onDrag({ draggedDistance });
    }
    if (isDraggingInDirection && !opts.snapPoints.current) {
      const dampenedDraggedDistance = dampenValue(draggedDistance);
      const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;
      set2(get(drawerNode), {
        transform: isVertical(opts.direction.current) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
      });
      return;
    }
    const opacityValue = 1 - percentageDragged;
    if (snapPointsState.shouldFade || opts.fadeFromIndex.current && strict_equals(snapPointsState.activeSnapPointIndex, opts.fadeFromIndex.current - 1)) {
      opts.onDrag.current?.(event, percentageDragged);
      set2(get(overlayNode), { opacity: `${opacityValue}`, transition: "none" }, true);
    }
    if (wrapper && get(overlayNode) && opts.shouldScaleBackground.current) {
      const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);
      const borderRadiusValue = 8 - percentageDragged * 8;
      const translateValue = Math.max(0, 14 - percentageDragged * 14);
      set2(
        wrapper,
        {
          borderRadius: `${borderRadiusValue}px`,
          transform: isVertical(opts.direction.current) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,
          transition: "none"
        },
        true
      );
    }
    if (!opts.snapPoints.current) {
      const translateValue = absDraggedDistance * directionMultiplier;
      set2(get(drawerNode), {
        transform: isVertical(opts.direction.current) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
      });
    }
  }
  user_effect(() => {
    window.requestAnimationFrame(() => {
      set(shouldAnimate, true);
    });
  });
  function onDialogOpenChange(o) {
    if (!opts.dismissible.current && !o) return;
    if (o) {
      set(hasBeenOpened, true);
    } else {
      closeDrawer(true);
    }
    opts.open.current = o;
  }
  function onVisualViewportChange() {
    if (!get(drawerNode) || !opts.repositionInputs.current) return;
    const focusedElement = document.activeElement;
    if (isInput(focusedElement) || keyboardIsOpen.current) {
      const visualViewportHeight = window.visualViewport?.height || 0;
      const totalHeight = window.innerHeight;
      let diffFromInitial = totalHeight - visualViewportHeight;
      const drawerHeight2 = get(drawerNode).getBoundingClientRect().height || 0;
      const isTallEnough = drawerHeight2 > totalHeight * 0.8;
      if (!initialDrawerHeight) {
        initialDrawerHeight = drawerHeight2;
      }
      const offsetFromTop = get(drawerNode).getBoundingClientRect().top;
      if (Math.abs(previousDiffFromInitial - diffFromInitial) > 60) {
        keyboardIsOpen.current = !keyboardIsOpen.current;
      }
      if (opts.snapPoints.current && opts.snapPoints.current.length > 0 && snapPointsState.snapPointsOffset && snapPointsState.activeSnapPointIndex) {
        const activeSnapPointHeight = snapPointsState.snapPointsOffset[snapPointsState.activeSnapPointIndex] || 0;
        diffFromInitial += activeSnapPointHeight;
      }
      previousDiffFromInitial = diffFromInitial;
      if (drawerHeight2 > visualViewportHeight || keyboardIsOpen.current) {
        const height = get(drawerNode).getBoundingClientRect().height;
        let newDrawerHeight = height;
        if (height > visualViewportHeight) {
          newDrawerHeight = visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);
        }
        if (opts.fixed.current) {
          get(drawerNode).style.height = `${height - Math.max(diffFromInitial, 0)}px`;
        } else {
          get(drawerNode).style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
        }
      } else if (!isMobileFirefox()) {
        get(drawerNode).style.height = `${initialDrawerHeight}px`;
      }
      if (opts.snapPoints.current && opts.snapPoints.current.length > 0 && !keyboardIsOpen.current) {
        get(drawerNode).style.bottom = `0px`;
      } else {
        get(drawerNode).style.bottom = `${Math.max(diffFromInitial, 0)}px`;
      }
    }
  }
  watch(
    [
      () => snapPointsState.activeSnapPointIndex,
      () => opts.snapPoints.current,
      () => snapPointsState.snapPointsOffset,
      () => get(drawerNode)
    ],
    () => {
      if (!window.visualViewport) return;
      return on(window.visualViewport, "resize", onVisualViewportChange);
    }
  );
  function cancelDrag() {
    if (!get(isDragging) || !get(drawerNode)) return;
    get(drawerNode).classList.remove(DRAG_CLASS);
    isAllowedToDrag = false;
    set(isDragging, false);
    dragEndTime = /* @__PURE__ */ new Date();
  }
  function closeDrawer(fromWithin) {
    cancelDrag();
    opts.onClose?.current();
    if (!fromWithin) {
      handleOpenChange(false);
      opts.open.current = false;
    }
    window.setTimeout(
      () => {
        if (opts.snapPoints.current && opts.snapPoints.current.length > 0) {
          opts.activeSnapPoint.current = opts.snapPoints.current[0];
        }
      },
      TRANSITIONS.DURATION * 1e3
    );
  }
  function resetDrawer() {
    if (!get(drawerNode)) return;
    const wrapper = document.querySelector("[data-vaul-drawer-wrapper]");
    const currentSwipeAmount = getTranslate(get(drawerNode), opts.direction.current);
    set2(get(drawerNode), {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`
    });
    set2(get(overlayNode), {
      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      opacity: "1"
    });
    if (opts.shouldScaleBackground.current && currentSwipeAmount && currentSwipeAmount > 0 && opts.open.current) {
      set2(
        wrapper,
        {
          borderRadius: `${BORDER_RADIUS}px`,
          overflow: "hidden",
          ...isVertical(opts.direction.current) ? {
            transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
            transformOrigin: "top"
          } : {
            transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
            transformOrigin: "left"
          },
          transitionProperty: "transform, border-radius",
          transitionDuration: `${TRANSITIONS.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
        },
        true
      );
    }
  }
  function onRelease(event) {
    isReleasing = true;
    handleRelease(event);
    afterTick(() => {
      isReleasing = false;
    });
  }
  function handleRelease(event) {
    if (!get(isDragging) || !get(drawerNode)) return;
    get(drawerNode).classList.remove(DRAG_CLASS);
    isAllowedToDrag = false;
    set(isDragging, false);
    dragEndTime = /* @__PURE__ */ new Date();
    const swipeAmount = getTranslate(get(drawerNode), opts.direction.current);
    if (!event || event.target && !shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) {
      return;
    }
    if (strict_equals(dragStartTime, null)) return;
    const timeTaken = dragEndTime.getTime() - dragStartTime.getTime();
    const distMoved = pointerStart - (isVertical(opts.direction.current) ? event.pageY : event.pageX);
    const velocity = Math.abs(distMoved) / timeTaken;
    if (velocity > 0.05) {
      set(justReleased, true);
      setTimeout(
        () => {
          set(justReleased, false);
        },
        200
      );
    }
    if (opts.snapPoints.current) {
      const directionMultiplier = strict_equals(opts.direction.current, "bottom") || strict_equals(opts.direction.current, "right") ? 1 : -1;
      snapPointsState.onRelease({
        draggedDistance: distMoved * directionMultiplier,
        closeDrawer,
        velocity,
        dismissible: opts.dismissible.current
      });
      opts.onRelease.current?.(event, true);
      return;
    }
    if (strict_equals(opts.direction.current, "bottom") || strict_equals(opts.direction.current, "right") ? distMoved > 0 : distMoved < 0) {
      resetDrawer();
      opts.onRelease.current?.(event, true);
      return;
    }
    if (velocity > VELOCITY_THRESHOLD) {
      closeDrawer();
      opts.onRelease.current?.(event, false);
      return;
    }
    const visibleDrawerHeight = Math.min(get(drawerNode).getBoundingClientRect().height ?? 0, window.innerHeight);
    const visibleDrawerWidth = Math.min(get(drawerNode).getBoundingClientRect().width ?? 0, window.innerWidth);
    const isHorizontalSwipe = strict_equals(opts.direction.current, "left") || strict_equals(opts.direction.current, "right");
    if (Math.abs(swipeAmount) >= (isHorizontalSwipe ? visibleDrawerWidth : visibleDrawerHeight) * opts.closeThreshold.current) {
      closeDrawer();
      opts.onRelease.current?.(event, false);
      return;
    }
    opts.onRelease.current?.(event, true);
    resetDrawer();
  }
  watch(() => opts.open.current, () => {
    if (opts.open.current) {
      set2(document.documentElement, { scrollBehavior: "auto" });
      openTime = /* @__PURE__ */ new Date();
    }
    return () => {
      reset2(document.documentElement, "scrollBehavior");
    };
  });
  function onNestedOpenChange(o) {
    const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;
    const initialTranslate = o ? -NESTED_DISPLACEMENT : 0;
    if (nestedOpenChangeTimer) {
      window.clearTimeout(nestedOpenChangeTimer);
    }
    set2(get(drawerNode), {
      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
      transform: isVertical(opts.direction.current) ? `scale(${scale}) translate3d(0, ${initialTranslate}px, 0)` : `scale(${scale}) translate3d(${initialTranslate}px, 0, 0)`
    });
    if (!o && get(drawerNode)) {
      nestedOpenChangeTimer = window.setTimeout(
        () => {
          const translateValue = getTranslate(get(drawerNode), opts.direction.current);
          set2(get(drawerNode), {
            transition: "none",
            transform: isVertical(opts.direction.current) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`
          });
        },
        500
      );
    }
  }
  function onNestedDrag(_event, percentageDragged) {
    if (percentageDragged < 0) return;
    const initialScale = (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth;
    const newScale = initialScale + percentageDragged * (1 - initialScale);
    const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;
    set2(get(drawerNode), {
      transform: isVertical(opts.direction.current) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,
      transition: "none"
    });
  }
  function onNestedRelease(_event, o) {
    const dim = isVertical(opts.direction.current) ? window.innerHeight : window.innerWidth;
    const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;
    const translate = o ? -NESTED_DISPLACEMENT : 0;
    if (o) {
      set2(get(drawerNode), {
        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(",")})`,
        transform: isVertical(opts.direction.current) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`
      });
    }
  }
  let bodyStyles;
  function handleOpenChange(o) {
    opts.onOpenChange.current?.(o);
    if (o && !opts.nested.current) {
      bodyStyles = document.body.style.cssText;
    } else if (!o && !opts.nested.current) {
      afterSleep(TRANSITIONS.DURATION * 1e3, () => {
        document.body.style.cssText = bodyStyles;
      });
    }
    if (!o && !opts.nested.current) {
      restorePositionSetting();
    }
    setTimeout(
      () => {
        opts.onAnimationEnd.current?.(o);
      },
      TRANSITIONS.DURATION * 1e3
    );
    if (o && !opts.modal.current) {
      if (strict_equals(typeof window, "undefined", false)) {
        window.requestAnimationFrame(() => {
          document.body.style.pointerEvents = "auto";
        });
      }
    }
    if (!o) {
      document.body.style.pointerEvents = "auto";
    }
  }
  watch(() => opts.modal.current, () => {
    if (!opts.modal.current) {
      window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      });
    }
  });
  function setOverlayNode(node) {
    set(overlayNode, node, true);
  }
  function setDrawerNode(node) {
    set(drawerNode, node, true);
  }
  return DrawerContext.set({
    ...opts,
    keyboardIsOpen,
    closeDrawer,
    setDrawerNode,
    setOverlayNode,
    onDrag,
    onNestedDrag,
    onNestedOpenChange,
    onNestedRelease,
    onRelease,
    onPress,
    onDialogOpenChange,
    get shouldAnimate() {
      return get(shouldAnimate);
    },
    get isDragging() {
      return get(isDragging);
    },
    get overlayNode() {
      return get(overlayNode);
    },
    get drawerNode() {
      return get(drawerNode);
    },
    get snapPointsOffset() {
      return snapPointsState.snapPointsOffset;
    },
    get shouldFade() {
      return snapPointsState.shouldFade;
    },
    restorePositionSetting,
    handleOpenChange
  });
}

// node_modules/vaul-svelte/dist/components/drawer/drawer.svelte
Drawer[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer.svelte";
var $$css = {
  hash: "s-SAGRHVcWzuKe",
  code: '\n	[data-vaul-drawer] {\n		touch-action: none;\n		will-change: transform;\n		transition: transform 0.5s cubic-bezier(0.32, 0.72, 0, 1);\n		animation-duration: 0.5s;\n		animation-timing-function: cubic-bezier(0.32, 0.72, 0, 1);\n	}\n\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="bottom"][data-state="open"]\n		 {\n		animation-name: slideFromBottom;\n	}\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="bottom"][data-state="closed"]\n		 {\n		animation-name: slideToBottom;\n	}\n\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="top"][data-state="open"]\n		 {\n		animation-name: slideFromTop;\n	}\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="top"][data-state="closed"]\n		 {\n		animation-name: slideToTop;\n	}\n\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="left"][data-state="open"]\n		 {\n		animation-name: slideFromLeft;\n	}\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="left"][data-state="closed"]\n		 {\n		animation-name: slideToLeft;\n	}\n\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="right"][data-state="open"]\n		 {\n		animation-name: slideFromRight;\n	}\n	\n			[data-vaul-drawer][data-vaul-snap-points="false"][data-vaul-drawer-direction="right"][data-state="closed"]\n		 {\n		animation-name: slideToRight;\n	}\n\n	[data-vaul-drawer][data-vaul-snap-points="true"][data-vaul-drawer-direction="bottom"] {\n		transform: translate3d(0, var(--initial-transform, 100%), 0);\n	}\n\n	[data-vaul-drawer][data-vaul-snap-points="true"][data-vaul-drawer-direction="top"] {\n		transform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n	}\n\n	[data-vaul-drawer][data-vaul-snap-points="true"][data-vaul-drawer-direction="left"] {\n		transform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n	}\n\n	[data-vaul-drawer][data-vaul-snap-points="true"][data-vaul-drawer-direction="right"] {\n		transform: translate3d(var(--initial-transform, 100%), 0, 0);\n	}\n\n	\n			[data-vaul-drawer][data-vaul-delayed-snap-points="true"][data-vaul-drawer-direction="top"]\n		 {\n		transform: translate3d(0, var(--snap-point-height, 0), 0);\n	}\n\n	\n			[data-vaul-drawer][data-vaul-delayed-snap-points="true"][data-vaul-drawer-direction="bottom"]\n		 {\n		transform: translate3d(0, var(--snap-point-height, 0), 0);\n	}\n\n	\n			[data-vaul-drawer][data-vaul-delayed-snap-points="true"][data-vaul-drawer-direction="left"]\n		 {\n		transform: translate3d(var(--snap-point-height, 0), 0, 0);\n	}\n\n	\n			[data-vaul-drawer][data-vaul-delayed-snap-points="true"][data-vaul-drawer-direction="right"]\n		 {\n		transform: translate3d(var(--snap-point-height, 0), 0, 0);\n	}\n\n	[data-vaul-overlay][data-vaul-snap-points="false"] {\n		animation-duration: 0.5s;\n		animation-timing-function: cubic-bezier(0.32, 0.72, 0, 1);\n	}\n	[data-vaul-overlay][data-vaul-snap-points="false"][data-state="open"] {\n		animation-name: fadeIn;\n	}\n	[data-vaul-overlay][data-state="closed"] {\n		animation-name: fadeOut;\n	}\n\n	[data-vaul-animate="false"] {\n		animation: none !important;\n	}\n\n	[data-vaul-overlay][data-vaul-snap-points="true"] {\n		opacity: 0;\n		transition: opacity 0.5s cubic-bezier(0.32, 0.72, 0, 1);\n	}\n\n	[data-vaul-overlay][data-vaul-snap-points="true"] {\n		opacity: 1;\n	}\n\n	[data-vaul-drawer]:not([data-vaul-custom-container="true"])::after {\n		content: "";\n		position: absolute;\n		background: inherit;\n		background-color: inherit;\n	}\n\n	[data-vaul-drawer][data-vaul-drawer-direction="top"]::after {\n		top: initial;\n		bottom: 100%;\n		left: 0;\n		right: 0;\n		height: 200%;\n	}\n\n	[data-vaul-drawer][data-vaul-drawer-direction="bottom"]::after {\n		top: 100%;\n		bottom: initial;\n		left: 0;\n		right: 0;\n		height: 200%;\n	}\n\n	[data-vaul-drawer][data-vaul-drawer-direction="left"]::after {\n		left: initial;\n		right: 100%;\n		top: 0;\n		bottom: 0;\n		width: 200%;\n	}\n\n	[data-vaul-drawer][data-vaul-drawer-direction="right"]::after {\n		left: 100%;\n		right: initial;\n		top: 0;\n		bottom: 0;\n		width: 200%;\n	}\n\n	\n			[data-vaul-overlay][data-vaul-snap-points="true"]:not(\n					[data-vaul-snap-points-overlay="true"]\n				):not([data-state="closed"])\n		 {\n		opacity: 0;\n	}\n\n	[data-vaul-overlay][data-vaul-snap-points-overlay="true"] {\n		opacity: 1;\n	}\n\n	[data-vaul-handle] {\n		display: block;\n		position: relative;\n		opacity: 0.7;\n		background: #e2e2e4;\n		margin-left: auto;\n		margin-right: auto;\n		height: 5px;\n		width: 32px;\n		border-radius: 1rem;\n		touch-action: pan-y;\n	}\n\n	[data-vaul-handle]:hover, [data-vaul-handle]:active {\n		opacity: 1;\n	}\n\n	[data-vaul-handle-hitarea] {\n		position: absolute;\n		left: 50%;\n		top: 50%;\n		transform: translate(-50%, -50%);\n		width: max(100%, 2.75rem); /* 44px */\n		height: max(100%, 2.75rem); /* 44px */\n		touch-action: inherit;\n	}\n\n	/* This will allow us to not animate via animation, but still benefit from delaying unmount via Radix. */\n\n	@keyframes fake-animation {\n		from {\n		}\n		to {\n		}\n	}\n\n	@keyframes fadeIn {\n		from {\n			opacity: 0;\n		}\n		to {\n			opacity: 1;\n		}\n	}\n\n	@keyframes fadeOut {\n		to {\n			opacity: 0;\n		}\n	}\n\n	@keyframes slideFromBottom {\n		from {\n			transform: translate3d(0, var(--initial-transform, 100%), 0);\n		}\n		to {\n			transform: translate3d(0, 0, 0);\n		}\n	}\n\n	@keyframes slideToBottom {\n		to {\n			transform: translate3d(0, var(--initial-transform, 100%), 0);\n		}\n	}\n\n	@keyframes slideFromTop {\n		from {\n			transform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n		}\n		to {\n			transform: translate3d(0, 0, 0);\n		}\n	}\n\n	@keyframes slideToTop {\n		to {\n			transform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n		}\n	}\n\n	@keyframes slideFromLeft {\n		from {\n			transform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n		}\n		to {\n			transform: translate3d(0, 0, 0);\n		}\n	}\n\n	@keyframes slideToLeft {\n		to {\n			transform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n		}\n	}\n\n	@keyframes slideFromRight {\n		from {\n			transform: translate3d(var(--initial-transform, 100%), 0, 0);\n		}\n		to {\n			transform: translate3d(0, 0, 0);\n		}\n	}\n\n	@keyframes slideToRight {\n		to {\n			transform: translate3d(var(--initial-transform, 100%), 0, 0);\n		}\n	}\n\n	@media (hover: hover) and (pointer: fine) {\n		[data-vaul-drawer] {\n			user-select: none !important;\n		}\n	}\n\n	@media (pointer: fine) {\n		[data-vaul-handle-hitarea] {\n			width: 100%;\n			height: 100%;\n		}\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiZHJhd2VyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBEaWFsb2cgYXMgRGlhbG9nUHJpbWl0aXZlIH0gZnJvbSBcImJpdHMtdWlcIjtcblx0aW1wb3J0IHsgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFJvb3RQcm9wcyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cdGltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvbm9vcC5qc1wiO1xuXHRpbXBvcnQgeyBDTE9TRV9USFJFU0hPTEQsIFNDUk9MTF9MT0NLX1RJTUVPVVQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvY29uc3RhbnRzLmpzXCI7XG5cdGltcG9ydCB7IHVzZURyYXdlclJvb3QgfSBmcm9tIFwiLi4vLi4vdXNlLWRyYXdlci1yb290LnN2ZWx0ZS5qc1wiO1xuXG5cdGxldCB7XG5cdFx0b3BlbiA9ICRiaW5kYWJsZShmYWxzZSksXG5cdFx0b25PcGVuQ2hhbmdlID0gbm9vcCxcblx0XHRvbkRyYWcgPSBub29wLFxuXHRcdG9uUmVsZWFzZSA9IG5vb3AsXG5cdFx0c25hcFBvaW50cyxcblx0XHRzaG91bGRTY2FsZUJhY2tncm91bmQgPSBmYWxzZSxcblx0XHRzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlID0gdHJ1ZSxcblx0XHRjbG9zZVRocmVzaG9sZCA9IENMT1NFX1RIUkVTSE9MRCxcblx0XHRzY3JvbGxMb2NrVGltZW91dCA9IFNDUk9MTF9MT0NLX1RJTUVPVVQsXG5cdFx0ZGlzbWlzc2libGUgPSB0cnVlLFxuXHRcdGhhbmRsZU9ubHkgPSBmYWxzZSxcblx0XHRmYWRlRnJvbUluZGV4ID0gc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCAtIDEsXG5cdFx0YWN0aXZlU25hcFBvaW50ID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdG9uQWN0aXZlU25hcFBvaW50Q2hhbmdlID0gbm9vcCxcblx0XHRmaXhlZCA9IGZhbHNlLFxuXHRcdG1vZGFsID0gdHJ1ZSxcblx0XHRvbkNsb3NlID0gbm9vcCxcblx0XHRuZXN0ZWQgPSBmYWxzZSxcblx0XHRub0JvZHlTdHlsZXMgPSBmYWxzZSxcblx0XHRkaXJlY3Rpb24gPSBcImJvdHRvbVwiLFxuXHRcdHNuYXBUb1NlcXVlbnRpYWxQb2ludCA9IGZhbHNlLFxuXHRcdHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbiA9IGZhbHNlLFxuXHRcdHJlcG9zaXRpb25JbnB1dHMgPSB0cnVlLFxuXHRcdG9uQW5pbWF0aW9uRW5kID0gbm9vcCxcblx0XHRjb250YWluZXIgPSBudWxsLFxuXHRcdGF1dG9Gb2N1cyA9IGZhbHNlLFxuXHRcdGRpc2FibGVQcmV2ZW50U2Nyb2xsID0gdHJ1ZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogUm9vdFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3Qgcm9vdFN0YXRlID0gdXNlRHJhd2VyUm9vdCh7XG5cdFx0b3BlbjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiBvcGVuLFxuXHRcdFx0KG8pID0+IHtcblx0XHRcdFx0b3BlbiA9IG87XG5cdFx0XHRcdHJvb3RTdGF0ZS5oYW5kbGVPcGVuQ2hhbmdlKG8pO1xuXHRcdFx0fVxuXHRcdCksXG5cdFx0Y2xvc2VUaHJlc2hvbGQ6IGJveC53aXRoKCgpID0+IGNsb3NlVGhyZXNob2xkKSxcblx0XHRzY3JvbGxMb2NrVGltZW91dDogYm94LndpdGgoKCkgPT4gc2Nyb2xsTG9ja1RpbWVvdXQpLFxuXHRcdHNuYXBQb2ludHM6IGJveC53aXRoKCgpID0+IHNuYXBQb2ludHMpLFxuXHRcdGZhZGVGcm9tSW5kZXg6IGJveC53aXRoKCgpID0+IGZhZGVGcm9tSW5kZXgpLFxuXHRcdG5lc3RlZDogYm94LndpdGgoKCkgPT4gbmVzdGVkKSxcblx0XHRzaG91bGRTY2FsZUJhY2tncm91bmQ6IGJveC53aXRoKCgpID0+IHNob3VsZFNjYWxlQmFja2dyb3VuZCksXG5cdFx0YWN0aXZlU25hcFBvaW50OiBib3gud2l0aChcblx0XHRcdCgpID0+IGFjdGl2ZVNuYXBQb2ludCxcblx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdGFjdGl2ZVNuYXBQb2ludCA9IHY7XG5cdFx0XHRcdG9uQWN0aXZlU25hcFBvaW50Q2hhbmdlKHYpO1xuXHRcdFx0fVxuXHRcdCksXG5cdFx0b25SZWxlYXNlOiBib3gud2l0aCgoKSA9PiBvblJlbGVhc2UpLFxuXHRcdG9uRHJhZzogYm94LndpdGgoKCkgPT4gb25EcmFnKSxcblx0XHRvbkNsb3NlOiBib3gud2l0aCgoKSA9PiBvbkNsb3NlKSxcblx0XHRkaXNtaXNzaWJsZTogYm94LndpdGgoKCkgPT4gZGlzbWlzc2libGUpLFxuXHRcdGRpcmVjdGlvbjogYm94LndpdGgoKCkgPT4gZGlyZWN0aW9uKSxcblx0XHRmaXhlZDogYm94LndpdGgoKCkgPT4gZml4ZWQpLFxuXHRcdG1vZGFsOiBib3gud2l0aCgoKSA9PiBtb2RhbCksXG5cdFx0aGFuZGxlT25seTogYm94LndpdGgoKCkgPT4gaGFuZGxlT25seSksXG5cdFx0bm9Cb2R5U3R5bGVzOiBib3gud2l0aCgoKSA9PiBub0JvZHlTdHlsZXMpLFxuXHRcdHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbjogYm94LndpdGgoKCkgPT4gcHJldmVudFNjcm9sbFJlc3RvcmF0aW9uKSxcblx0XHRzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlOiBib3gud2l0aCgoKSA9PiBzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlKSxcblx0XHRyZXBvc2l0aW9uSW5wdXRzOiBib3gud2l0aCgoKSA9PiByZXBvc2l0aW9uSW5wdXRzKSxcblx0XHRhdXRvRm9jdXM6IGJveC53aXRoKCgpID0+IGF1dG9Gb2N1cyksXG5cdFx0c25hcFRvU2VxdWVudGlhbFBvaW50OiBib3gud2l0aCgoKSA9PiBzbmFwVG9TZXF1ZW50aWFsUG9pbnQpLFxuXHRcdGNvbnRhaW5lcjogYm94LndpdGgoKCkgPT4gY29udGFpbmVyKSxcblx0XHRkaXNhYmxlUHJldmVudFNjcm9sbDogYm94LndpdGgoKCkgPT4gZGlzYWJsZVByZXZlbnRTY3JvbGwpLFxuXHRcdG9uT3BlbkNoYW5nZTogYm94LndpdGgoKCkgPT4gb25PcGVuQ2hhbmdlKSxcblx0XHRvbkFuaW1hdGlvbkVuZDogYm94LndpdGgoKCkgPT4gb25BbmltYXRpb25FbmQpLFxuXHR9KTtcbjwvc2NyaXB0PlxuXG48RGlhbG9nUHJpbWl0aXZlLlJvb3Rcblx0YmluZDpvcGVuPXtcblx0XHQoKSA9PiByb290U3RhdGUub3Blbi5jdXJyZW50LFxuXHRcdChvKSA9PiB7XG5cdFx0XHRyb290U3RhdGUub25EaWFsb2dPcGVuQ2hhbmdlKG8pO1xuXHRcdH1cblx0fVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cblxuPHN0eWxlIGdsb2JhbD5cblx0Omdsb2JhbChbZGF0YS12YXVsLWRyYXdlcl0pIHtcblx0XHR0b3VjaC1hY3Rpb246IG5vbmU7XG5cdFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcblx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyBjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSk7XG5cdFx0YW5pbWF0aW9uLWR1cmF0aW9uOiAwLjVzO1xuXHRcdGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjMyLCAwLjcyLCAwLCAxKTtcblx0fVxuXG5cdDpnbG9iYWwoXG5cdFx0XHRbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPVwiZmFsc2VcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJib3R0b21cIl1bZGF0YS1zdGF0ZT1cIm9wZW5cIl1cblx0XHQpIHtcblx0XHRhbmltYXRpb24tbmFtZTogc2xpZGVGcm9tQm90dG9tO1xuXHR9XG5cdDpnbG9iYWwoXG5cdFx0XHRbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPVwiZmFsc2VcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJib3R0b21cIl1bZGF0YS1zdGF0ZT1cImNsb3NlZFwiXVxuXHRcdCkge1xuXHRcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZVRvQm90dG9tO1xuXHR9XG5cblx0Omdsb2JhbChcblx0XHRcdFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJmYWxzZVwiXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cInRvcFwiXVtkYXRhLXN0YXRlPVwib3BlblwiXVxuXHRcdCkge1xuXHRcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZUZyb21Ub3A7XG5cdH1cblx0Omdsb2JhbChcblx0XHRcdFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJmYWxzZVwiXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cInRvcFwiXVtkYXRhLXN0YXRlPVwiY2xvc2VkXCJdXG5cdFx0KSB7XG5cdFx0YW5pbWF0aW9uLW5hbWU6IHNsaWRlVG9Ub3A7XG5cdH1cblxuXHQ6Z2xvYmFsKFxuXHRcdFx0W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cImZhbHNlXCJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPVwibGVmdFwiXVtkYXRhLXN0YXRlPVwib3BlblwiXVxuXHRcdCkge1xuXHRcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZUZyb21MZWZ0O1xuXHR9XG5cdDpnbG9iYWwoXG5cdFx0XHRbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPVwiZmFsc2VcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJsZWZ0XCJdW2RhdGEtc3RhdGU9XCJjbG9zZWRcIl1cblx0XHQpIHtcblx0XHRhbmltYXRpb24tbmFtZTogc2xpZGVUb0xlZnQ7XG5cdH1cblxuXHQ6Z2xvYmFsKFxuXHRcdFx0W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cImZhbHNlXCJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPVwicmlnaHRcIl1bZGF0YS1zdGF0ZT1cIm9wZW5cIl1cblx0XHQpIHtcblx0XHRhbmltYXRpb24tbmFtZTogc2xpZGVGcm9tUmlnaHQ7XG5cdH1cblx0Omdsb2JhbChcblx0XHRcdFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJmYWxzZVwiXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cInJpZ2h0XCJdW2RhdGEtc3RhdGU9XCJjbG9zZWRcIl1cblx0XHQpIHtcblx0XHRhbmltYXRpb24tbmFtZTogc2xpZGVUb1JpZ2h0O1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPVwidHJ1ZVwiXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cImJvdHRvbVwiXSkge1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sIDEwMCUpLCAwKTtcblx0fVxuXG5cdDpnbG9iYWwoW2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cInRydWVcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJ0b3BcIl0pIHtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sIDEwMCUpICogLTEpLCAwKTtcblx0fVxuXG5cdDpnbG9iYWwoW2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cInRydWVcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJsZWZ0XCJdKSB7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZChjYWxjKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLCAxMDAlKSAqIC0xKSwgMCwgMCk7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJ0cnVlXCJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPVwicmlnaHRcIl0pIHtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLCAxMDAlKSwgMCwgMCk7XG5cdH1cblxuXHQ6Z2xvYmFsKFxuXHRcdFx0W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1kZWxheWVkLXNuYXAtcG9pbnRzPVwidHJ1ZVwiXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cInRvcFwiXVxuXHRcdCkge1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0tc25hcC1wb2ludC1oZWlnaHQsIDApLCAwKTtcblx0fVxuXG5cdDpnbG9iYWwoXG5cdFx0XHRbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRlbGF5ZWQtc25hcC1wb2ludHM9XCJ0cnVlXCJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPVwiYm90dG9tXCJdXG5cdFx0KSB7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwgMCksIDApO1xuXHR9XG5cblx0Omdsb2JhbChcblx0XHRcdFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtZGVsYXllZC1zbmFwLXBvaW50cz1cInRydWVcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJsZWZ0XCJdXG5cdFx0KSB7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCh2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwgMCksIDAsIDApO1xuXHR9XG5cblx0Omdsb2JhbChcblx0XHRcdFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtZGVsYXllZC1zbmFwLXBvaW50cz1cInRydWVcIl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJyaWdodFwiXVxuXHRcdCkge1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QodmFyKC0tc25hcC1wb2ludC1oZWlnaHQsIDApLCAwLCAwKTtcblx0fVxuXG5cdDpnbG9iYWwoW2RhdGEtdmF1bC1vdmVybGF5XVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJmYWxzZVwiXSkge1xuXHRcdGFuaW1hdGlvbi1kdXJhdGlvbjogMC41cztcblx0XHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSk7XG5cdH1cblx0Omdsb2JhbChbZGF0YS12YXVsLW92ZXJsYXldW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cImZhbHNlXCJdW2RhdGEtc3RhdGU9XCJvcGVuXCJdKSB7XG5cdFx0YW5pbWF0aW9uLW5hbWU6IGZhZGVJbjtcblx0fVxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtb3ZlcmxheV1bZGF0YS1zdGF0ZT1cImNsb3NlZFwiXSkge1xuXHRcdGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0O1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS12YXVsLWFuaW1hdGU9XCJmYWxzZVwiXSkge1xuXHRcdGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS12YXVsLW92ZXJsYXldW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1cInRydWVcIl0pIHtcblx0XHRvcGFjaXR5OiAwO1xuXHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMC41cyBjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSk7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtb3ZlcmxheV1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPVwidHJ1ZVwiXSkge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtZHJhd2VyXTpub3QoW2RhdGEtdmF1bC1jdXN0b20tY29udGFpbmVyPVwidHJ1ZVwiXSk6OmFmdGVyKSB7XG5cdFx0Y29udGVudDogXCJcIjtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0YmFja2dyb3VuZDogaW5oZXJpdDtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJ0b3BcIl06OmFmdGVyKSB7XG5cdFx0dG9wOiBpbml0aWFsO1xuXHRcdGJvdHRvbTogMTAwJTtcblx0XHRsZWZ0OiAwO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdGhlaWdodDogMjAwJTtcblx0fVxuXG5cdDpnbG9iYWwoW2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPVwiYm90dG9tXCJdOjphZnRlcikge1xuXHRcdHRvcDogMTAwJTtcblx0XHRib3R0b206IGluaXRpYWw7XG5cdFx0bGVmdDogMDtcblx0XHRyaWdodDogMDtcblx0XHRoZWlnaHQ6IDIwMCU7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1cImxlZnRcIl06OmFmdGVyKSB7XG5cdFx0bGVmdDogaW5pdGlhbDtcblx0XHRyaWdodDogMTAwJTtcblx0XHR0b3A6IDA7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdHdpZHRoOiAyMDAlO1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249XCJyaWdodFwiXTo6YWZ0ZXIpIHtcblx0XHRsZWZ0OiAxMDAlO1xuXHRcdHJpZ2h0OiBpbml0aWFsO1xuXHRcdHRvcDogMDtcblx0XHRib3R0b206IDA7XG5cdFx0d2lkdGg6IDIwMCU7XG5cdH1cblxuXHQ6Z2xvYmFsKFxuXHRcdFx0W2RhdGEtdmF1bC1vdmVybGF5XVtkYXRhLXZhdWwtc25hcC1wb2ludHM9XCJ0cnVlXCJdOm5vdChcblx0XHRcdFx0XHRbZGF0YS12YXVsLXNuYXAtcG9pbnRzLW92ZXJsYXk9XCJ0cnVlXCJdXG5cdFx0XHRcdCk6bm90KFtkYXRhLXN0YXRlPVwiY2xvc2VkXCJdKVxuXHRcdCkge1xuXHRcdG9wYWNpdHk6IDA7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtb3ZlcmxheV1bZGF0YS12YXVsLXNuYXAtcG9pbnRzLW92ZXJsYXk9XCJ0cnVlXCJdKSB7XG5cdFx0b3BhY2l0eTogMTtcblx0fVxuXG5cdDpnbG9iYWwoW2RhdGEtdmF1bC1oYW5kbGVdKSB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG9wYWNpdHk6IDAuNztcblx0XHRiYWNrZ3JvdW5kOiAjZTJlMmU0O1xuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xuXHRcdG1hcmdpbi1yaWdodDogYXV0bztcblx0XHRoZWlnaHQ6IDVweDtcblx0XHR3aWR0aDogMzJweDtcblx0XHRib3JkZXItcmFkaXVzOiAxcmVtO1xuXHRcdHRvdWNoLWFjdGlvbjogcGFuLXk7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtaGFuZGxlXTpob3ZlciwgW2RhdGEtdmF1bC1oYW5kbGVdOmFjdGl2ZSkge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLXZhdWwtaGFuZGxlLWhpdGFyZWFdKSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGxlZnQ6IDUwJTtcblx0XHR0b3A6IDUwJTtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcblx0XHR3aWR0aDogbWF4KDEwMCUsIDIuNzVyZW0pOyAvKiA0NHB4ICovXG5cdFx0aGVpZ2h0OiBtYXgoMTAwJSwgMi43NXJlbSk7IC8qIDQ0cHggKi9cblx0XHR0b3VjaC1hY3Rpb246IGluaGVyaXQ7XG5cdH1cblxuXHQvKiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gbm90IGFuaW1hdGUgdmlhIGFuaW1hdGlvbiwgYnV0IHN0aWxsIGJlbmVmaXQgZnJvbSBkZWxheWluZyB1bm1vdW50IHZpYSBSYWRpeC4gKi9cblxuXHRAa2V5ZnJhbWVzIC1nbG9iYWwtZmFrZS1hbmltYXRpb24ge1xuXHRcdGZyb20ge1xuXHRcdH1cblx0XHR0byB7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyAtZ2xvYmFsLWZhZGVJbiB7XG5cdFx0ZnJvbSB7XG5cdFx0XHRvcGFjaXR5OiAwO1xuXHRcdH1cblx0XHR0byB7XG5cdFx0XHRvcGFjaXR5OiAxO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgLWdsb2JhbC1mYWRlT3V0IHtcblx0XHR0byB7XG5cdFx0XHRvcGFjaXR5OiAwO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgLWdsb2JhbC1zbGlkZUZyb21Cb3R0b20ge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS1pbml0aWFsLXRyYW5zZm9ybSwgMTAwJSksIDApO1xuXHRcdH1cblx0XHR0byB7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgLWdsb2JhbC1zbGlkZVRvQm90dG9tIHtcblx0XHR0byB7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLCAxMDAlKSwgMCk7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyAtZ2xvYmFsLXNsaWRlRnJvbVRvcCB7XG5cdFx0ZnJvbSB7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sIDEwMCUpICogLTEpLCAwKTtcblx0XHR9XG5cdFx0dG8ge1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRAa2V5ZnJhbWVzIC1nbG9iYWwtc2xpZGVUb1RvcCB7XG5cdFx0dG8ge1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCBjYWxjKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLCAxMDAlKSAqIC0xKSwgMCk7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyAtZ2xvYmFsLXNsaWRlRnJvbUxlZnQge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZChjYWxjKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLCAxMDAlKSAqIC0xKSwgMCwgMCk7XG5cdFx0fVxuXHRcdHRvIHtcblx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyAtZ2xvYmFsLXNsaWRlVG9MZWZ0IHtcblx0XHR0byB7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sIDEwMCUpICogLTEpLCAwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRAa2V5ZnJhbWVzIC1nbG9iYWwtc2xpZGVGcm9tUmlnaHQge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCh2YXIoLS1pbml0aWFsLXRyYW5zZm9ybSwgMTAwJSksIDAsIDApO1xuXHRcdH1cblx0XHR0byB7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgLWdsb2JhbC1zbGlkZVRvUmlnaHQge1xuXHRcdHRvIHtcblx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QodmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sIDEwMCUpLCAwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRAbWVkaWEgKGhvdmVyOiBob3ZlcikgYW5kIChwb2ludGVyOiBmaW5lKSB7XG5cdFx0Omdsb2JhbChbZGF0YS12YXVsLWRyYXdlcl0pIHtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lICFpbXBvcnRhbnQ7XG5cdFx0fVxuXHR9XG5cblx0QG1lZGlhIChwb2ludGVyOiBmaW5lKSB7XG5cdFx0Omdsb2JhbChbZGF0YS12YXVsLWhhbmRsZS1oaXRhcmVhXSkge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0= */'
};
function Drawer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer);
  append_styles($$anchor, $$css);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onDrag = prop($$props, "onDrag", 3, noop3), onRelease = prop($$props, "onRelease", 3, noop3), shouldScaleBackground = prop($$props, "shouldScaleBackground", 3, false), setBackgroundColorOnScale = prop($$props, "setBackgroundColorOnScale", 3, true), closeThreshold = prop($$props, "closeThreshold", 3, CLOSE_THRESHOLD), scrollLockTimeout = prop($$props, "scrollLockTimeout", 3, SCROLL_LOCK_TIMEOUT), dismissible = prop($$props, "dismissible", 3, true), handleOnly = prop($$props, "handleOnly", 3, false), fadeFromIndex = prop($$props, "fadeFromIndex", 19, () => $$props.snapPoints && $$props.snapPoints.length - 1), activeSnapPoint = prop($$props, "activeSnapPoint", 15, null), onActiveSnapPointChange = prop($$props, "onActiveSnapPointChange", 3, noop3), fixed = prop($$props, "fixed", 3, false), modal = prop($$props, "modal", 3, true), onClose = prop($$props, "onClose", 3, noop3), nested = prop($$props, "nested", 3, false), noBodyStyles = prop($$props, "noBodyStyles", 3, false), direction = prop($$props, "direction", 3, "bottom"), snapToSequentialPoint = prop($$props, "snapToSequentialPoint", 3, false), preventScrollRestoration = prop($$props, "preventScrollRestoration", 3, false), repositionInputs = prop($$props, "repositionInputs", 3, true), onAnimationEnd = prop($$props, "onAnimationEnd", 3, noop3), container = prop($$props, "container", 3, null), autoFocus = prop($$props, "autoFocus", 3, false), disablePreventScroll = prop($$props, "disablePreventScroll", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "open",
      "onOpenChange",
      "onDrag",
      "onRelease",
      "snapPoints",
      "shouldScaleBackground",
      "setBackgroundColorOnScale",
      "closeThreshold",
      "scrollLockTimeout",
      "dismissible",
      "handleOnly",
      "fadeFromIndex",
      "activeSnapPoint",
      "onActiveSnapPointChange",
      "fixed",
      "modal",
      "onClose",
      "nested",
      "noBodyStyles",
      "direction",
      "snapToSequentialPoint",
      "preventScrollRestoration",
      "repositionInputs",
      "onAnimationEnd",
      "container",
      "autoFocus",
      "disablePreventScroll"
    ],
    "restProps"
  );
  const rootState = useDrawerRoot({
    open: box.with(() => open(), (o) => {
      open(o);
      rootState.handleOpenChange(o);
    }),
    closeThreshold: box.with(() => closeThreshold()),
    scrollLockTimeout: box.with(() => scrollLockTimeout()),
    snapPoints: box.with(() => $$props.snapPoints),
    fadeFromIndex: box.with(() => fadeFromIndex()),
    nested: box.with(() => nested()),
    shouldScaleBackground: box.with(() => shouldScaleBackground()),
    activeSnapPoint: box.with(() => activeSnapPoint(), (v) => {
      activeSnapPoint(v);
      onActiveSnapPointChange()(v);
    }),
    onRelease: box.with(() => onRelease()),
    onDrag: box.with(() => onDrag()),
    onClose: box.with(() => onClose()),
    dismissible: box.with(() => dismissible()),
    direction: box.with(() => direction()),
    fixed: box.with(() => fixed()),
    modal: box.with(() => modal()),
    handleOnly: box.with(() => handleOnly()),
    noBodyStyles: box.with(() => noBodyStyles()),
    preventScrollRestoration: box.with(() => preventScrollRestoration()),
    setBackgroundColorOnScale: box.with(() => setBackgroundColorOnScale()),
    repositionInputs: box.with(() => repositionInputs()),
    autoFocus: box.with(() => autoFocus()),
    snapToSequentialPoint: box.with(() => snapToSequentialPoint()),
    container: box.with(() => container()),
    disablePreventScroll: box.with(() => disablePreventScroll()),
    onOpenChange: box.with(() => onOpenChange()),
    onAnimationEnd: box.with(() => onAnimationEnd())
  });
  var fragment = comment();
  var node = first_child(fragment);
  var bind_get = () => rootState.open.current;
  var bind_set = (o) => {
    rootState.onDialogOpenChange(o);
  };
  add_svelte_meta(
    () => component(node, () => exports_exports.Root, ($$anchor2, DialogPrimitive_Root) => {
      DialogPrimitive_Root($$anchor2, spread_props(
        {
          get open() {
            return bind_get();
          },
          set open($$value) {
            bind_set($$value);
          }
        },
        () => restProps
      ));
    }),
    "component",
    Drawer,
    82,
    0,
    { componentTag: "DialogPrimitive.Root" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer = hmr(Drawer, () => Drawer[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-SAGRHVcWzuKe");
    module.default[HMR].source = Drawer[HMR].source;
    set(Drawer[HMR].source, module.default[HMR].original);
  });
}
var drawer_default = Drawer;

// node_modules/vaul-svelte/dist/internal/use-id.js
globalThis.vaulIdCounter ??= { current: 0 };
function useId(prefix = "vaul-svelte") {
  globalThis.vaulIdCounter.current++;
  return `${prefix}-${globalThis.vaulIdCounter.current}`;
}

// node_modules/vaul-svelte/dist/use-scale-background.svelte.js
function useScaleBackground() {
  const ctx = DrawerContext.get();
  let timeoutId = null;
  const initialBackgroundColor = strict_equals(typeof document, "undefined", false) ? document.body.style.backgroundColor : "";
  function getScale() {
    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
  }
  watch(
    [
      () => ctx.open.current,
      () => ctx.shouldScaleBackground.current,
      () => ctx.setBackgroundColorOnScale.current
    ],
    () => {
      if (ctx.open.current && ctx.shouldScaleBackground.current) {
        if (timeoutId) clearTimeout(timeoutId);
        const wrapper = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[data-vaul-drawer-wrapper]");
        if (!wrapper) return;
        chain(
          ctx.setBackgroundColorOnScale.current && !ctx.noBodyStyles.current ? assignStyle(document.body, { background: "black" }) : noop3,
          assignStyle(wrapper, {
            transformOrigin: isVertical(ctx.direction.current) ? "top" : "left",
            transitionProperty: "transform, border-radius",
            transitionDuration: `${TRANSITIONS.DURATION}s`,
            transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(",")})`
          })
        );
        const wrapperStylesCleanup = assignStyle(wrapper, {
          borderRadius: `${BORDER_RADIUS}px`,
          overflow: "hidden",
          ...isVertical(ctx.direction.current) ? {
            transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
          } : {
            transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
          }
        });
        return () => {
          wrapperStylesCleanup();
          timeoutId = window.setTimeout(
            () => {
              if (initialBackgroundColor) {
                document.body.style.background = initialBackgroundColor;
              } else {
                document.body.style.removeProperty("background");
              }
            },
            TRANSITIONS.DURATION * 1e3
          );
        };
      }
    }
  );
}

// node_modules/vaul-svelte/dist/use-drawer-content.svelte.js
function useDrawerContent(opts) {
  const ctx = DrawerContext.get();
  let mounted = tag(state(false), "mounted");
  useRefById({
    id: opts.id,
    ref: opts.ref,
    deps: () => [get(mounted), ctx.open.current],
    onRefChange: (node) => {
      if (!get(mounted)) {
        ctx.setDrawerNode(null);
      } else {
        ctx.setDrawerNode(node);
      }
    }
  });
  let delayedSnapPoints = tag(state(false), "delayedSnapPoints");
  let pointerStart = null;
  let lastKnownPointerEvent = null;
  let wasBeyondThePoint = false;
  const hasSnapPoints = tag(user_derived(() => ctx.snapPoints.current && ctx.snapPoints.current.length > 0), "hasSnapPoints");
  useScaleBackground();
  function isDeltaInDirection(delta, direction, threshold = 0) {
    if (wasBeyondThePoint) return true;
    const deltaY = Math.abs(delta.y);
    const deltaX = Math.abs(delta.x);
    const isDeltaX = deltaX > deltaY;
    const dFactor = ["bottom", "right"].includes(direction) ? 1 : -1;
    if (strict_equals(direction, "left") || strict_equals(direction, "right")) {
      const isReverseDirection = delta.x * dFactor < 0;
      if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {
        return isDeltaX;
      }
    } else {
      const isReverseDirection = delta.y * dFactor < 0;
      if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {
        return !isDeltaX;
      }
    }
    wasBeyondThePoint = true;
    return true;
  }
  watch([() => get(hasSnapPoints), () => ctx.open.current], () => {
    if (get(hasSnapPoints) && ctx.open.current) {
      window.requestAnimationFrame(() => {
        set(delayedSnapPoints, true);
      });
    } else {
      set(delayedSnapPoints, false);
    }
  });
  function handleOnPointerUp(e) {
    pointerStart = null;
    wasBeyondThePoint = false;
    ctx.onRelease(e);
  }
  function onpointerdown(e) {
    if (ctx.handleOnly.current) return;
    opts.onpointerdown.current?.(e);
    pointerStart = { x: e.pageX, y: e.pageY };
    ctx.onPress(e);
  }
  function onOpenAutoFocus(e) {
    opts.onOpenAutoFocus.current?.(e);
    if (!ctx.autoFocus.current) {
      e.preventDefault();
    }
  }
  function onInteractOutside(e) {
    opts.onInteractOutside.current?.(e);
    if (!ctx.modal.current || e.defaultPrevented) {
      e.preventDefault();
      return;
    }
    if (ctx.keyboardIsOpen.current) {
      ctx.keyboardIsOpen.current = false;
    }
  }
  function onFocusOutside(e) {
    if (!ctx.modal.current) {
      e.preventDefault();
      return;
    }
  }
  function onpointermove(e) {
    lastKnownPointerEvent = e;
    if (ctx.handleOnly.current) return;
    opts.onpointermove.current?.(e);
    if (!pointerStart) return;
    const yPosition = e.pageY - pointerStart.y;
    const xPosition = e.pageX - pointerStart.x;
    const swipeStartThreshold = strict_equals(e.pointerType, "touch") ? 10 : 2;
    const delta = { x: xPosition, y: yPosition };
    const isAllowedToSwipe = isDeltaInDirection(delta, ctx.direction.current, swipeStartThreshold);
    if (isAllowedToSwipe) {
      ctx.onDrag(e);
    } else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {
      pointerStart = null;
    }
  }
  function onpointerup(e) {
    opts.onpointerup.current?.(e);
    pointerStart = null;
    wasBeyondThePoint = false;
    ctx.onRelease(e);
  }
  function onpointerout(e) {
    opts.onpointerout.current?.(e);
    handleOnPointerUp(lastKnownPointerEvent);
  }
  function oncontextmenu(e) {
    opts.oncontextmenu.current?.(e);
    if (lastKnownPointerEvent) {
      handleOnPointerUp(lastKnownPointerEvent);
    }
  }
  const props = tag(
    user_derived(() => ({
      id: opts.id.current,
      "data-vaul-drawer-direction": ctx.direction.current,
      "data-vaul-drawer": "",
      "data-vaul-delayed-snap-points": get(delayedSnapPoints) ? "true" : "false",
      "data-vaul-snap-points": ctx.open.current && get(hasSnapPoints) ? "true" : "false",
      "data-vaul-custom-container": ctx.container.current ? "true" : "false",
      "data-vaul-animate": ctx.shouldAnimate ? "true" : "false",
      onpointerdown,
      onOpenAutoFocus,
      onInteractOutside,
      onFocusOutside,
      onpointerup,
      onpointermove,
      onpointerout,
      oncontextmenu,
      preventScroll: ctx.modal.current
    })),
    "props"
  );
  return {
    get props() {
      return get(props);
    },
    ctx,
    setMounted: (value) => {
      set(mounted, value, true);
    }
  };
}

// node_modules/vaul-svelte/dist/components/utils/mounted.svelte
Mounted[FILENAME] = "node_modules/vaul-svelte/dist/components/utils/mounted.svelte";
function Mounted($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mounted);
  onMount(() => {
    $$props.onMounted(true);
    return () => {
      $$props.onMounted(false);
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mounted = hmr(Mounted, () => Mounted[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mounted[HMR].source;
    set(Mounted[HMR].source, module.default[HMR].original);
  });
}
var mounted_default = Mounted;

// node_modules/vaul-svelte/dist/components/drawer/drawer-content.svelte
Drawer_content[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer-content.svelte";
var root_1 = add_locations(from_html(`<!> <!>`, 1), Drawer_content[FILENAME], []);
function Drawer_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), oncontextmenu = prop($$props, "oncontextmenu", 3, noop3), onpointerdown = prop($$props, "onpointerdown", 3, noop3), onpointerup = prop($$props, "onpointerup", 3, noop3), onpointerout = prop($$props, "onpointerout", 3, noop3), onpointermove = prop($$props, "onpointermove", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "onOpenAutoFocus",
      "onInteractOutside",
      "onFocusOutside",
      "oncontextmenu",
      "onpointerdown",
      "onpointerup",
      "onpointerout",
      "onpointermove",
      "children"
    ],
    "restProps"
  );
  const contentState = useDrawerContent({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    oncontextmenu: box.with(() => oncontextmenu() ?? noop3),
    onInteractOutside: box.with(() => onInteractOutside()),
    onpointerdown: box.with(() => onpointerdown() ?? noop3),
    onpointermove: box.with(() => onpointermove() ?? noop3),
    onpointerout: box.with(() => onpointerout() ?? noop3),
    onpointerup: box.with(() => onpointerup() ?? noop3),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus()),
    onFocusOutside: box.with(() => onFocusOutside())
  });
  const snapPointsOffset = snapshot(contentState.ctx.snapPointsOffset);
  const styleProp = tag(
    user_derived(() => snapPointsOffset && snapPointsOffset.length > 0 ? {
      "--snap-point-height": `${snapPointsOffset[contentState.ctx.activeSnapPointIndex ?? 0]}px`
    } : {}),
    "styleProp"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { style: get(styleProp) })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => exports_exports.Content, ($$anchor2, DialogPrimitive_Content) => {
      DialogPrimitive_Content($$anchor2, spread_props(() => get(mergedProps), {
        children: wrap_snippet(Drawer_content, ($$anchor3, $$slotProps) => {
          var fragment_1 = root_1();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Drawer_content, 58, 1);
          var node_2 = sibling(node_1, 2);
          add_svelte_meta(
            () => mounted_default(node_2, {
              get onMounted() {
                return contentState.setMounted;
              }
            }),
            "component",
            Drawer_content,
            59,
            1,
            { componentTag: "Mounted" }
          );
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    }),
    "component",
    Drawer_content,
    57,
    0,
    { componentTag: "DialogPrimitive.Content" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer_content = hmr(Drawer_content, () => Drawer_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Drawer_content[HMR].source;
    set(Drawer_content[HMR].source, module.default[HMR].original);
  });
}
var drawer_content_default = Drawer_content;

// node_modules/vaul-svelte/dist/use-drawer-overlay.svelte.js
function useDrawerOverlay(opts) {
  const ctx = DrawerContext.get();
  let mounted = tag(state(false), "mounted");
  useRefById({
    id: opts.id,
    ref: opts.ref,
    deps: () => get(mounted),
    onRefChange: (node) => {
      if (!get(mounted)) {
        ctx.setOverlayNode(null);
      } else {
        ctx.setOverlayNode(node);
      }
    }
  });
  const hasSnapPoints = tag(user_derived(() => ctx.snapPoints.current && ctx.snapPoints.current.length > 0), "hasSnapPoints");
  const shouldRender = tag(user_derived(() => ctx.modal.current), "shouldRender");
  const props = tag(
    user_derived(() => ({
      id: opts.id.current,
      onmouseup: ctx.onRelease,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": ctx.open.current && get(hasSnapPoints) ? "true" : "false",
      "data-vaul-snap-points-overlay": ctx.open.current && ctx.shouldFade ? "true" : "false",
      "data-vaul-animate": ctx.shouldAnimate ? "true" : "false"
    })),
    "props"
  );
  return {
    get props() {
      return get(props);
    },
    get shouldRender() {
      return get(shouldRender);
    },
    setMounted: (value) => {
      set(mounted, value, true);
    }
  };
}

// node_modules/vaul-svelte/dist/components/drawer/drawer-overlay.svelte
Drawer_overlay[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer-overlay.svelte";
var root_2 = add_locations(from_html(`<!> <!>`, 1), Drawer_overlay[FILENAME], []);
function Drawer_overlay($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer_overlay);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"], "restProps");
  const overlayState = useDrawerOverlay({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, overlayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => component(node_1, () => exports_exports.Overlay, ($$anchor3, DialogPrimitive_Overlay) => {
          DialogPrimitive_Overlay($$anchor3, spread_props(() => get(mergedProps), {
            children: wrap_snippet(Drawer_overlay, ($$anchor4, $$slotProps) => {
              var fragment_2 = root_2();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => mounted_default(node_2, {
                  get onMounted() {
                    return overlayState.setMounted;
                  }
                }),
                "component",
                Drawer_overlay,
                29,
                2,
                { componentTag: "Mounted" }
              );
              var node_3 = sibling(node_2, 2);
              add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Drawer_overlay, 30, 2);
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          }));
        }),
        "component",
        Drawer_overlay,
        28,
        1,
        { componentTag: "DialogPrimitive.Overlay" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (overlayState.shouldRender) $$render(consequent);
      }),
      "if",
      Drawer_overlay,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer_overlay = hmr(Drawer_overlay, () => Drawer_overlay[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Drawer_overlay[HMR].source;
    set(Drawer_overlay[HMR].source, module.default[HMR].original);
  });
}
var drawer_overlay_default = Drawer_overlay;

// node_modules/vaul-svelte/dist/components/drawer/drawer-nested.svelte
Drawer_nested[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer-nested.svelte";
function Drawer_nested($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer_nested);
  var $$ownership_validator = create_ownership_validator($$props);
  let open = prop($$props, "open", 15, false), activeSnapPoint = prop($$props, "activeSnapPoint", 15, null), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onDrag = prop($$props, "onDrag", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "open",
      "activeSnapPoint",
      "onOpenChange",
      "onDrag"
    ],
    "restProps"
  );
  const rootState = DrawerContext.get();
  const rest = tag(user_derived(() => restProps), "rest");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("activeSnapPoint", drawer_default, activeSnapPoint);
    $$ownership_validator.binding("open", drawer_default, open);
    add_svelte_meta(
      () => drawer_default(node, spread_props(
        {
          nested: true,
          onClose: () => rootState.onNestedOpenChange(false),
          onDrag: (e, p) => {
            rootState.onNestedDrag(e, p);
            onDrag()(e, p);
          },
          onOpenChange: (o) => {
            if (o) {
              rootState.onNestedOpenChange(o);
            }
            onOpenChange()(o);
          },
          get onRelease() {
            return rootState.onNestedRelease;
          }
        },
        () => get(rest),
        {
          get activeSnapPoint() {
            return activeSnapPoint();
          },
          set activeSnapPoint($$value) {
            activeSnapPoint($$value);
          },
          get open() {
            return open();
          },
          set open($$value) {
            open($$value);
          }
        }
      )),
      "component",
      Drawer_nested,
      20,
      0,
      { componentTag: "DrawerRoot" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer_nested = hmr(Drawer_nested, () => Drawer_nested[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Drawer_nested[HMR].source;
    set(Drawer_nested[HMR].source, module.default[HMR].original);
  });
}
var drawer_nested_default = Drawer_nested;

// node_modules/vaul-svelte/dist/use-drawer-handle.svelte.js
var LONG_HANDLE_PRESS_TIMEOUT = 250;
var DOUBLE_TAP_TIMEOUT = 120;
function useDrawerHandle(opts) {
  const ctx = DrawerContext.get();
  useRefById({ id: opts.id, ref: opts.ref, deps: () => ctx.open.current });
  let closeTimeoutId = null;
  let shouldCancelInteraction = false;
  function handleStartInteraction() {
    closeTimeoutId = window.setTimeout(
      () => {
        shouldCancelInteraction = true;
      },
      LONG_HANDLE_PRESS_TIMEOUT
    );
  }
  function handleCancelInteraction() {
    if (closeTimeoutId) {
      window.clearTimeout(closeTimeoutId);
    }
    shouldCancelInteraction = false;
  }
  function handleCycleSnapPoints() {
    if (ctx.isDragging || opts.preventCycle.current || shouldCancelInteraction) {
      handleCancelInteraction();
      return;
    }
    handleCancelInteraction();
    if (!ctx.snapPoints.current || strict_equals(ctx.snapPoints.current.length, 0)) {
      if (!ctx.dismissible.current) {
        ctx.closeDrawer();
      }
      return;
    }
    const isLastSnapPoint = strict_equals(ctx.activeSnapPoint.current, ctx.snapPoints.current[ctx.snapPoints.current.length - 1]);
    if (isLastSnapPoint && ctx.dismissible.current) {
      ctx.closeDrawer();
      return;
    }
    const currentSnapIndex = ctx.snapPoints.current.findIndex((point) => strict_equals(point, ctx.activeSnapPoint.current));
    if (strict_equals(currentSnapIndex, -1) || strict_equals(currentSnapIndex, void 0)) return;
    const nextSnapPoint = ctx.snapPoints.current[currentSnapIndex + 1];
    ctx.activeSnapPoint.current = nextSnapPoint;
  }
  function handleStartCycle() {
    if (shouldCancelInteraction) {
      handleCancelInteraction();
      return;
    }
    window.setTimeout(
      () => {
        handleCycleSnapPoints();
      },
      DOUBLE_TAP_TIMEOUT
    );
  }
  const props = tag(
    user_derived(() => ({
      id: opts.id.current,
      "data-vaul-drawer-visible": ctx.open.current ? "true" : "false",
      "data-vaul-handle": "",
      "aria-hidden": "true",
      onclick: handleStartCycle,
      onpointercancel: handleCancelInteraction,
      onpointerdown: (e) => {
        if (ctx.handleOnly.current) ctx.onPress(e);
        handleStartInteraction();
      },
      onpointermove: (e) => {
        if (ctx.handleOnly.current) ctx.onDrag(e);
      }
    })),
    "props"
  );
  return {
    get props() {
      return get(props);
    }
  };
}

// node_modules/vaul-svelte/dist/components/drawer/drawer-handle.svelte
Drawer_handle[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer-handle.svelte";
var root = add_locations(from_html(`<div><span data-vaul-handle-hitarea="" aria-hidden="true"><!></span></div>`), Drawer_handle[FILENAME], [[27, 0, [[28, 1]]]]);
function Drawer_handle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer_handle);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), preventCycle = prop($$props, "preventCycle", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "preventCycle",
      "children"
    ],
    "restProps"
  );
  const handleState = useDrawerHandle({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    preventCycle: box.with(() => preventCycle())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, handleState.props)), "mergedProps");
  var div = root();
  attribute_effect(div, () => ({ ...get(mergedProps) }));
  var span = child(div);
  var node = child(span);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Drawer_handle, 29, 2);
  reset(span);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer_handle = hmr(Drawer_handle, () => Drawer_handle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Drawer_handle[HMR].source;
    set(Drawer_handle[HMR].source, module.default[HMR].original);
  });
}
var drawer_handle_default = Drawer_handle;

// node_modules/vaul-svelte/dist/components/drawer/drawer-portal.svelte
Drawer_portal[FILENAME] = "node_modules/vaul-svelte/dist/components/drawer/drawer-portal.svelte";
function Drawer_portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Drawer_portal);
  const ctx = DrawerContext.get();
  let to = prop($$props, "to", 19, () => ctx.container.current ?? void 0), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "to"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => exports_exports.Portal, ($$anchor2, Dialog_Portal) => {
      Dialog_Portal($$anchor2, spread_props(
        {
          get to() {
            return to();
          }
        },
        () => restProps
      ));
    }),
    "component",
    Drawer_portal,
    10,
    0,
    { componentTag: "Dialog.Portal" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Drawer_portal = hmr(Drawer_portal, () => Drawer_portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Drawer_portal[HMR].source;
    set(Drawer_portal[HMR].source, module.default[HMR].original);
  });
}
var drawer_portal_default = Drawer_portal;

// node_modules/vaul-svelte/dist/components/drawer/index.js
var Trigger = exports_exports.Trigger;
var Title = exports_exports.Title;
var Description = exports_exports.Description;
var Close = exports_exports.Close;
export {
  drawer_exports as Drawer
};
//# sourceMappingURL=vaul-svelte.js.map
