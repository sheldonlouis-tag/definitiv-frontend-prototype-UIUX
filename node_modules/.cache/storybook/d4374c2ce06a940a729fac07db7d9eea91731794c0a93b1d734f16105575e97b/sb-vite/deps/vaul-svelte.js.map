{
  "version": 3,
  "sources": ["../../../../../vaul-svelte/dist/components/drawer/index.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/is.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/box/box.svelte.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/compose-handlers.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/strings.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/style-to-css.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/style.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/merge-props.js", "../../../../../vaul-svelte/node_modules/runed/dist/internal/configurable-globals.js", "../../../../../vaul-svelte/node_modules/runed/dist/internal/utils/dom.js", "../../../../../vaul-svelte/node_modules/runed/dist/utilities/active-element/active-element.svelte.js", "../../../../../vaul-svelte/node_modules/runed/dist/utilities/watch/watch.svelte.js", "../../../../../vaul-svelte/node_modules/runed/dist/utilities/context/context.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/use-ref-by-id.svelte.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/after-sleep.js", "../../../../../vaul-svelte/node_modules/svelte-toolbelt/dist/utils/after-tick.js", "../../../../../vaul-svelte/dist/internal/noop.js", "../../../../../vaul-svelte/dist/internal/constants.js", "../../../../../vaul-svelte/dist/helpers.js", "../../../../../vaul-svelte/dist/use-snap-points.svelte.js", "../../../../../vaul-svelte/dist/internal/browser.js", "../../../../../vaul-svelte/dist/use-prevent-scroll.svelte.js", "../../../../../vaul-svelte/dist/use-position-fixed.svelte.js", "../../../../../vaul-svelte/dist/context.js", "../../../../../vaul-svelte/dist/use-drawer-root.svelte.js", "../../../../../vaul-svelte/dist/components/drawer/drawer.svelte", "../../../../../vaul-svelte/dist/internal/use-id.js", "../../../../../vaul-svelte/dist/use-scale-background.svelte.js", "../../../../../vaul-svelte/dist/use-drawer-content.svelte.js", "../../../../../vaul-svelte/dist/components/utils/mounted.svelte", "../../../../../vaul-svelte/dist/components/drawer/drawer-content.svelte", "../../../../../vaul-svelte/dist/use-drawer-overlay.svelte.js", "../../../../../vaul-svelte/dist/components/drawer/drawer-overlay.svelte", "../../../../../vaul-svelte/dist/components/drawer/drawer-nested.svelte", "../../../../../vaul-svelte/dist/use-drawer-handle.svelte.js", "../../../../../vaul-svelte/dist/components/drawer/drawer-handle.svelte", "../../../../../vaul-svelte/dist/components/drawer/drawer-portal.svelte"],
  "sourcesContent": ["import { Dialog as DrawerPrimitive } from \"bits-ui\";\nexport { default as Root } from \"./drawer.svelte\";\nexport { default as Content } from \"./drawer-content.svelte\";\nexport { default as Overlay } from \"./drawer-overlay.svelte\";\nexport { default as NestedRoot } from \"./drawer-nested.svelte\";\nexport { default as Handle } from \"./drawer-handle.svelte\";\nexport { default as Portal } from \"./drawer-portal.svelte\";\nexport const Trigger = DrawerPrimitive.Trigger;\nexport const Title = DrawerPrimitive.Title;\nexport const Description = DrawerPrimitive.Description;\nexport const Close = DrawerPrimitive.Close;\n", "export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nconst CLASS_VALUE_PRIMITIVE_TYPES = [\"string\", \"number\", \"bigint\", \"boolean\"];\nexport function isClassValue(value) {\n    // handle primitive types\n    if (value === null || value === undefined)\n        return true;\n    if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))\n        return true;\n    // handle arrays (ClassArray)\n    if (Array.isArray(value))\n        return value.every((item) => isClassValue(item));\n    // handle objects (ClassDictionary)\n    if (typeof value === \"object\") {\n        // ensure it's a plain object and not some other object type\n        if (Object.getPrototypeOf(value) !== Object.prototype)\n            return false;\n        return true;\n    }\n    return false;\n}\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_NODE = 9;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nexport function isHTMLElement(v) {\n    return isObject(v) && v.nodeType === ELEMENT_NODE && typeof v.nodeName === \"string\";\n}\nexport function isDocument(v) {\n    return isObject(v) && v.nodeType === DOCUMENT_NODE;\n}\nexport function isWindow(v) {\n    return isObject(v) && v === v.window;\n}\nexport function getNodeName(node) {\n    if (isHTMLElement(node))\n        return node.localName || \"\";\n    return \"#document\";\n}\nexport function isRootElement(node) {\n    return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nexport function isNode(v) {\n    return isObject(v) && v.nodeType !== undefined;\n}\nexport function isShadowRoot(v) {\n    return isNode(v) && v.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in v;\n}\n", "import { isFunction, isObject } from \"../utils/is.js\";\nconst BoxSymbol = Symbol(\"box\");\nconst isWritableSymbol = Symbol(\"is-writable\");\n/**\n * @returns Whether the value is a Box\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isBox(value) {\n    return isObject(value) && BoxSymbol in value;\n}\n/**\n * @returns Whether the value is a WritableBox\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isWritableBox(value) {\n    return box.isBox(value) && isWritableSymbol in value;\n}\nexport function box(initialValue) {\n    let current = $state(initialValue);\n    return {\n        [BoxSymbol]: true,\n        [isWritableSymbol]: true,\n        get current() {\n            return current;\n        },\n        set current(v) {\n            current = v;\n        }\n    };\n}\nfunction boxWith(getter, setter) {\n    const derived = $derived.by(getter);\n    if (setter) {\n        return {\n            [BoxSymbol]: true,\n            [isWritableSymbol]: true,\n            get current() {\n                return derived;\n            },\n            set current(v) {\n                setter(v);\n            }\n        };\n    }\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return getter();\n        }\n    };\n}\nfunction boxFrom(value) {\n    if (box.isBox(value))\n        return value;\n    if (isFunction(value))\n        return box.with(value);\n    return box(value);\n}\n/**\n * Function that gets an object of boxes, and returns an object of reactive values\n *\n * @example\n * const count = box(0)\n * const flat = box.flatten({ count, double: box.with(() => count.current) })\n * // type of flat is { count: number, readonly double: number }\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction boxFlatten(boxes) {\n    return Object.entries(boxes).reduce((acc, [key, b]) => {\n        if (!box.isBox(b)) {\n            return Object.assign(acc, { [key]: b });\n        }\n        if (box.isWritableBox(b)) {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                },\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                set(v) {\n                    b.current = v;\n                }\n            });\n        }\n        else {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                }\n            });\n        }\n        return acc;\n    }, {});\n}\n/**\n * Function that converts a box to a readonly box.\n *\n * @example\n * const count = box(0) // WritableBox<number>\n * const countReadonly = box.readonly(count) // ReadableBox<number>\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction toReadonlyBox(b) {\n    if (!box.isWritableBox(b))\n        return b;\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return b.current;\n        }\n    };\n}\nbox.from = boxFrom;\nbox.with = boxWith;\nbox.flatten = boxFlatten;\nbox.readonly = toReadonlyBox;\nbox.isBox = isBox;\nbox.isWritableBox = isWritableBox;\n", "/**\n * Composes event handlers into a single function that can be called with an event.\n * If the previous handler cancels the event using `event.preventDefault()`, the handlers\n * that follow will not be called.\n */\nexport function composeHandlers(...handlers) {\n    return function (e) {\n        for (const handler of handlers) {\n            if (!handler)\n                continue;\n            if (e.defaultPrevented)\n                return;\n            if (typeof handler === \"function\") {\n                handler.call(this, e);\n            }\n            else {\n                handler.current?.call(this, e);\n            }\n        }\n    };\n}\n", "const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n    if (NUMBER_CHAR_RE.test(char))\n        return undefined;\n    return char !== char.toLowerCase();\n}\nfunction splitByCase(str) {\n    const parts = [];\n    let buff = \"\";\n    let previousUpper;\n    let previousSplitter;\n    for (const char of str) {\n        // Splitter\n        const isSplitter = STR_SPLITTERS.includes(char);\n        if (isSplitter === true) {\n            parts.push(buff);\n            buff = \"\";\n            previousUpper = undefined;\n            continue;\n        }\n        const isUpper = isUppercase(char);\n        if (previousSplitter === false) {\n            // Case rising edge\n            if (previousUpper === false && isUpper === true) {\n                parts.push(buff);\n                buff = char;\n                previousUpper = isUpper;\n                continue;\n            }\n            // Case falling edge\n            if (previousUpper === true && isUpper === false && buff.length > 1) {\n                const lastChar = buff.at(-1);\n                parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n                buff = lastChar + char;\n                previousUpper = isUpper;\n                continue;\n            }\n        }\n        // Normal char\n        buff += char;\n        previousUpper = isUpper;\n        previousSplitter = isSplitter;\n    }\n    parts.push(buff);\n    return parts;\n}\nexport function pascalCase(str) {\n    if (!str)\n        return \"\";\n    return splitByCase(str)\n        .map((p) => upperFirst(p))\n        .join(\"\");\n}\nexport function camelCase(str) {\n    return lowerFirst(pascalCase(str || \"\"));\n}\nexport function kebabCase(str) {\n    return str\n        ? splitByCase(str)\n            .map((p) => p.toLowerCase())\n            .join(\"-\")\n        : \"\";\n}\nfunction upperFirst(str) {\n    return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n    return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\n", "import parse from \"style-to-object\";\nimport { camelCase, pascalCase } from \"./strings.js\";\nexport function cssToStyleObj(css) {\n    if (!css)\n        return {};\n    const styleObj = {};\n    function iterator(name, value) {\n        if (name.startsWith(\"-moz-\") ||\n            name.startsWith(\"-webkit-\") ||\n            name.startsWith(\"-ms-\") ||\n            name.startsWith(\"-o-\")) {\n            styleObj[pascalCase(name)] = value;\n            return;\n        }\n        if (name.startsWith(\"--\")) {\n            styleObj[name] = value;\n            return;\n        }\n        styleObj[camelCase(name)] = value;\n    }\n    parse(css, iterator);\n    return styleObj;\n}\n", "/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param callbacks array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n", "function createParser(matcher, replacer) {\n    const regex = RegExp(matcher, \"g\");\n    return (str) => {\n        // throw an error if not a string\n        if (typeof str !== \"string\") {\n            throw new TypeError(`expected an argument of type string, but got ${typeof str}`);\n        }\n        // if no match between string and matcher\n        if (!str.match(regex))\n            return str;\n        // executes the replacer function for each match\n        return str.replace(regex, replacer);\n    };\n}\nconst camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);\nexport function styleToCSS(styleObj) {\n    if (!styleObj || typeof styleObj !== \"object\" || Array.isArray(styleObj)) {\n        throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);\n    }\n    return Object.keys(styleObj)\n        .map((property) => `${camelToKebab(property)}: ${styleObj[property]};`)\n        .join(\"\\n\");\n}\n", "import { styleToCSS } from \"./style-to-css.js\";\nexport function styleToString(style = {}) {\n    return styleToCSS(style).replace(\"\\n\", \" \");\n}\nexport const srOnlyStyles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    padding: \"0\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    borderWidth: \"0\",\n    transform: \"translateX(-100%)\"\n};\nexport const srOnlyStylesString = styleToString(srOnlyStyles);\n", "/**\n * Modified from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts (see NOTICE.txt for source)\n */\nimport { clsx } from \"clsx\";\nimport { composeHandlers } from \"./compose-handlers.js\";\nimport { cssToStyleObj } from \"./css-to-style-obj.js\";\nimport { isClassValue } from \"./is.js\";\nimport { executeCallbacks } from \"./execute-callbacks.js\";\nimport { styleToString } from \"./style.js\";\nfunction isEventHandler(key) {\n    // we check if the 3rd character is uppercase to avoid merging our own\n    // custom callbacks like `onValueChange` and strictly merge native event handlers\n    return key.length > 2 && key.startsWith(\"on\") && key[2] === key[2]?.toLowerCase();\n}\n/**\n * Given a list of prop objects, merges them into a single object.\n * - Automatically composes event handlers (e.g. `onclick`, `oninput`, etc.)\n * - Chains regular functions with the same name so they are called in order\n * - Merges class strings with `clsx`\n * - Merges style objects and converts them to strings\n * - Handles a bug with Svelte where setting the `hidden` attribute to `false` doesn't remove it\n * - Overrides other values with the last one\n */\nexport function mergeProps(...args) {\n    const result = { ...args[0] };\n    for (let i = 1; i < args.length; i++) {\n        const props = args[i];\n        for (const key in props) {\n            const a = result[key];\n            const b = props[key];\n            const aIsFunction = typeof a === \"function\";\n            const bIsFunction = typeof b === \"function\";\n            // compose event handlers\n            if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {\n                // handle merging of event handlers\n                const aHandler = a;\n                const bHandler = b;\n                result[key] = composeHandlers(aHandler, bHandler);\n            }\n            else if (aIsFunction && bIsFunction) {\n                // chain non-event handler functions\n                result[key] = executeCallbacks(a, b);\n            }\n            else if (key === \"class\") {\n                // handle merging acceptable class values from clsx\n                const aIsClassValue = isClassValue(a);\n                const bIsClassValue = isClassValue(b);\n                if (aIsClassValue && bIsClassValue) {\n                    result[key] = clsx(a, b);\n                }\n                else if (aIsClassValue) {\n                    result[key] = clsx(a);\n                }\n                else if (bIsClassValue) {\n                    result[key] = clsx(b);\n                }\n            }\n            else if (key === \"style\") {\n                const aIsObject = typeof a === \"object\";\n                const bIsObject = typeof b === \"object\";\n                const aIsString = typeof a === \"string\";\n                const bIsString = typeof b === \"string\";\n                if (aIsObject && bIsObject) {\n                    // both are style objects, merge them\n                    result[key] = { ...a, ...b };\n                }\n                else if (aIsObject && bIsString) {\n                    // a is style object, b is string, convert b to style object and merge\n                    const parsedStyle = cssToStyleObj(b);\n                    result[key] = { ...a, ...parsedStyle };\n                }\n                else if (aIsString && bIsObject) {\n                    // a is string, b is style object, convert a to style object and merge\n                    const parsedStyle = cssToStyleObj(a);\n                    result[key] = { ...parsedStyle, ...b };\n                }\n                else if (aIsString && bIsString) {\n                    // both are strings, convert both to objects and merge\n                    const parsedStyleA = cssToStyleObj(a);\n                    const parsedStyleB = cssToStyleObj(b);\n                    result[key] = { ...parsedStyleA, ...parsedStyleB };\n                }\n                else if (aIsObject) {\n                    result[key] = a;\n                }\n                else if (bIsObject) {\n                    result[key] = b;\n                }\n                else if (aIsString) {\n                    result[key] = a;\n                }\n                else if (bIsString) {\n                    result[key] = b;\n                }\n            }\n            else {\n                // override other values\n                result[key] = b !== undefined ? b : a;\n            }\n        }\n    }\n    // convert style object to string\n    if (typeof result.style === \"object\") {\n        result.style = styleToString(result.style).replaceAll(\"\\n\", \" \");\n    }\n    // handle weird svelte bug where `hidden` is not removed when set to `false`\n    if (result.hidden !== true) {\n        result.hidden = undefined;\n        delete result.hidden;\n    }\n    // handle weird svelte bug where `disabled` is not removed when set to `false`\n    if (result.disabled !== true) {\n        result.disabled = undefined;\n        delete result.disabled;\n    }\n    return result;\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { getContext, hasContext, setContext } from \"svelte\";\nexport class Context {\n    #name;\n    #key;\n    /**\n     * @param name The name of the context.\n     * This is used for generating the context key and error messages.\n     */\n    constructor(name) {\n        this.#name = name;\n        this.#key = Symbol(name);\n    }\n    /**\n     * The key used to get and set the context.\n     *\n     * It is not recommended to use this value directly.\n     * Instead, use the methods provided by this class.\n     */\n    get key() {\n        return this.#key;\n    }\n    /**\n     * Checks whether this has been set in the context of a parent component.\n     *\n     * Must be called during component initialisation.\n     */\n    exists() {\n        return hasContext(this.#key);\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component.\n     *\n     * Must be called during component initialisation.\n     *\n     * @throws An error if the context does not exist.\n     */\n    get() {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            throw new Error(`Context \"${this.#name}\" not found`);\n        }\n        return context;\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component,\n     * or the given fallback value if the context does not exist.\n     *\n     * Must be called during component initialisation.\n     */\n    getOr(fallback) {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            return fallback;\n        }\n        return context;\n    }\n    /**\n     * Associates the given value with the current component and returns it.\n     *\n     * Must be called during component initialisation.\n     */\n    set(context) {\n        return setContext(this.#key, context);\n    }\n}\n", "export function onDestroyEffect(fn) {\n    $effect(() => {\n        return () => {\n            fn();\n        };\n    });\n}\n", "import { watch } from \"runed\";\nimport { onDestroyEffect } from \"./on-destroy-effect.svelte.js\";\n/**\n * Finds the node with that ID and sets it to the boxed node.\n * Reactive using `$effect` to ensure when the ID or deps change,\n * an update is triggered and new node is found.\n */\nexport function useRefById({ id, ref, deps = () => true, onRefChange, getRootNode }) {\n    watch([() => id.current, deps], ([_id]) => {\n        const rootNode = getRootNode?.() ?? document;\n        const node = rootNode?.getElementById(_id);\n        if (node)\n            ref.current = node;\n        else\n            ref.current = null;\n        onRefChange?.(ref.current);\n    });\n    onDestroyEffect(() => {\n        ref.current = null;\n        onRefChange?.(null);\n    });\n}\n", "/**\n * A utility function that executes a callback after a specified number of milliseconds.\n */\nexport function afterSleep(ms, cb) {\n    return setTimeout(cb, ms);\n}\n", "import { tick } from \"svelte\";\nexport function afterTick(fn) {\n    tick().then(fn);\n}\n", "export function noop() {\n    // do nothing;\n}\n", "export const TRANSITIONS = {\n    DURATION: 0.5,\n    EASE: [0.32, 0.72, 0, 1],\n};\nexport const VELOCITY_THRESHOLD = 0.4;\nexport const CLOSE_THRESHOLD = 0.25;\nexport const SCROLL_LOCK_TIMEOUT = 100;\nexport const BORDER_RADIUS = 8;\nexport const NESTED_DISPLACEMENT = 16;\nexport const WINDOW_TOP_OFFSET = 26;\nexport const DRAG_CLASS = \"vaul-dragging\";\n", "const cache = new WeakMap();\nexport function isInView(el) {\n    const rect = el.getBoundingClientRect();\n    if (!window.visualViewport)\n        return false;\n    return (rect.top >= 0 &&\n        rect.left >= 0 &&\n        // Need + 40 for safari detection\n        rect.bottom <= window.visualViewport.height - 40 &&\n        rect.right <= window.visualViewport.width);\n}\nexport function set(el, styles, ignoreCache = false) {\n    if (!el || !(el instanceof HTMLElement))\n        return;\n    let originalStyles = {};\n    Object.entries(styles).forEach(([key, value]) => {\n        if (key.startsWith(\"--\")) {\n            el.style.setProperty(key, value);\n            return;\n        }\n        originalStyles[key] = el.style[key];\n        el.style[key] = value;\n    });\n    if (ignoreCache)\n        return;\n    cache.set(el, originalStyles);\n}\nexport function reset(el, prop) {\n    if (!el || !(el instanceof HTMLElement))\n        return;\n    let originalStyles = cache.get(el);\n    if (!originalStyles)\n        return;\n    if (prop) {\n        el.style[prop] = originalStyles[prop];\n    }\n    else {\n        Object.entries(originalStyles).forEach(([key, value]) => {\n            el.style[key] = value;\n        });\n    }\n}\nexport const isVertical = (direction) => {\n    switch (direction) {\n        case \"top\":\n        case \"bottom\":\n            return true;\n        case \"left\":\n        case \"right\":\n            return false;\n        default:\n            return direction;\n    }\n};\nexport function getTranslate(element, direction) {\n    if (!element) {\n        return null;\n    }\n    const style = window.getComputedStyle(element);\n    const transform = \n    // @ts-expect-error - shh\n    style.transform || style.webkitTransform || style.mozTransform;\n    let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n        return parseFloat(mat[1].split(\", \")[isVertical(direction) ? 13 : 12]);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    mat = transform.match(/^matrix\\((.+)\\)$/);\n    return mat ? parseFloat(mat[1].split(\", \")[isVertical(direction) ? 5 : 4]) : null;\n}\nexport function dampenValue(v) {\n    return 8 * (Math.log(v + 1) - 2);\n}\nexport function assignStyle(element, style) {\n    if (!element)\n        return () => { };\n    const prevStyle = element.style.cssText;\n    Object.assign(element.style, style);\n    return () => {\n        element.style.cssText = prevStyle;\n    };\n}\n/**\n * Receives functions as arguments and returns a new function that calls all.\n */\nexport function chain(...fns) {\n    return (...args) => {\n        for (const fn of fns) {\n            if (typeof fn === \"function\") {\n                fn(...args);\n            }\n        }\n    };\n}\n", "import { onMount } from \"svelte\";\nimport { on } from \"svelte/events\";\nimport { isVertical, set } from \"./helpers.js\";\nimport { TRANSITIONS, VELOCITY_THRESHOLD } from \"./internal/constants.js\";\nimport { watch } from \"runed\";\nexport function useSnapPoints({ snapPoints, drawerNode: drawerNode, overlayNode: overlayNode, fadeFromIndex, setOpenTime, direction, container, snapToSequentialPoint, activeSnapPoint, open, isReleasing, }) {\n    let windowDimensions = $state(typeof window !== \"undefined\"\n        ? { innerWidth: window.innerWidth, innerHeight: window.innerHeight }\n        : undefined);\n    onMount(() => {\n        function onResize() {\n            windowDimensions = {\n                innerWidth: window.innerWidth,\n                innerHeight: window.innerHeight,\n            };\n        }\n        return on(window, \"resize\", onResize);\n    });\n    const isLastSnapPoint = $derived(activeSnapPoint.current === snapPoints.current?.[snapPoints.current.length - 1] || null);\n    const activeSnapPointIndex = $derived(snapPoints.current?.findIndex((snapPoint) => snapPoint === activeSnapPoint.current));\n    const shouldFade = $derived((snapPoints.current &&\n        snapPoints.current.length > 0 &&\n        (fadeFromIndex.current || fadeFromIndex.current === 0) &&\n        !Number.isNaN(fadeFromIndex.current) &&\n        snapPoints.current[fadeFromIndex.current] === activeSnapPoint.current) ||\n        !snapPoints.current);\n    const snapPointsOffset = $derived.by(() => {\n        open.current;\n        const containerSize = container.current\n            ? {\n                width: container.current.getBoundingClientRect().width,\n                height: container.current.getBoundingClientRect().height,\n            }\n            : typeof window !== \"undefined\"\n                ? { width: window.innerWidth, height: window.innerHeight }\n                : { width: 0, height: 0 };\n        return (snapPoints.current?.map((snapPoint) => {\n            const isPx = typeof snapPoint === \"string\";\n            let snapPointAsNumber = 0;\n            if (isPx) {\n                snapPointAsNumber = parseInt(snapPoint, 10);\n            }\n            if (isVertical(direction.current)) {\n                const height = isPx\n                    ? snapPointAsNumber\n                    : windowDimensions\n                        ? snapPoint * containerSize.height\n                        : 0;\n                if (windowDimensions) {\n                    return direction.current === \"bottom\"\n                        ? containerSize.height - height\n                        : -containerSize.height + height;\n                }\n                return height;\n            }\n            const width = isPx\n                ? snapPointAsNumber\n                : windowDimensions\n                    ? snapPoint * containerSize.width\n                    : 0;\n            if (windowDimensions) {\n                return direction.current === \"right\"\n                    ? containerSize.width - width\n                    : -containerSize.width + width;\n            }\n            return width;\n        }) ?? []);\n    });\n    const activeSnapPointOffset = $derived.by(() => {\n        if (activeSnapPointIndex !== null) {\n            if (activeSnapPointIndex !== undefined) {\n                return snapPointsOffset[activeSnapPointIndex];\n            }\n        }\n        return null;\n    });\n    function onSnapPointChange(activeSnapPointIndex) {\n        if (snapPoints.current && activeSnapPointIndex === snapPointsOffset.length - 1) {\n            setOpenTime(new Date());\n        }\n    }\n    function snapToPoint(dimension) {\n        const newSnapPointIndex = snapPointsOffset?.findIndex((snapPointDim) => snapPointDim === dimension) ?? null;\n        onSnapPointChange(newSnapPointIndex);\n        set(drawerNode(), {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: isVertical(direction.current)\n                ? `translate3d(0, ${dimension}px, 0)`\n                : `translate3d(${dimension}px, 0, 0)`,\n        });\n        if (snapPointsOffset &&\n            newSnapPointIndex !== snapPointsOffset.length - 1 &&\n            fadeFromIndex.current !== undefined &&\n            newSnapPointIndex !== fadeFromIndex.current &&\n            newSnapPointIndex < fadeFromIndex.current) {\n            set(overlayNode(), {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"0\",\n            });\n        }\n        else {\n            set(overlayNode(), {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"1\",\n            });\n        }\n        activeSnapPoint.current = snapPoints.current?.[Math.max(newSnapPointIndex, 0)];\n    }\n    watch([() => activeSnapPoint.current, () => open.current], () => {\n        // we only want to snap to the next point if we are closing via a\n        // means other than release, otherwise a race condition can occur\n        // where the drawer snaps to the previous point and then closes,\n        // rather than continuing to close from the current point\n        const releasing = isReleasing();\n        if (!activeSnapPoint.current || releasing)\n            return;\n        const newIndex = snapPoints.current?.findIndex((snapPoint) => snapPoint === activeSnapPoint.current) ??\n            -1;\n        if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === \"number\") {\n            if (snapPointsOffset[newIndex] === activeSnapPoint.current)\n                return;\n            snapToPoint(snapPointsOffset[newIndex]);\n        }\n    });\n    function onRelease({ draggedDistance, closeDrawer, velocity, dismissible, }) {\n        if (fadeFromIndex.current === undefined)\n            return;\n        const dir = direction.current;\n        const currentPosition = dir === \"bottom\" || dir === \"right\"\n            ? (activeSnapPointOffset ?? 0) - draggedDistance\n            : (activeSnapPointOffset ?? 0) + draggedDistance;\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex.current - 1;\n        const isFirst = activeSnapPointIndex === 0;\n        const hasDraggedUp = draggedDistance > 0;\n        if (isOverlaySnapPoint) {\n            set(overlayNode(), {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            });\n        }\n        if (!snapToSequentialPoint.current && velocity > 2 && !hasDraggedUp) {\n            if (dismissible) {\n                closeDrawer();\n            }\n            else {\n                snapToPoint(snapPointsOffset[0]);\n            }\n            return;\n        }\n        if (!snapToSequentialPoint.current &&\n            velocity > 2 &&\n            hasDraggedUp &&\n            snapPointsOffset &&\n            snapPoints.current) {\n            snapToPoint(snapPointsOffset[snapPoints.current.length - 1]);\n            return;\n        }\n        // Find the closest snap point to the current position\n        const closestSnapPoint = snapPointsOffset?.reduce((prev, curr) => {\n            if (typeof prev !== \"number\" || typeof curr !== \"number\")\n                return prev;\n            return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition)\n                ? curr\n                : prev;\n        });\n        const dim = isVertical(dir) ? window.innerHeight : window.innerWidth;\n        if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n            const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n            // Don't do anything if we swipe upwards while being on the last snap point\n            if (dragDirection > 0 && isLastSnapPoint && snapPoints.current) {\n                snapToPoint(snapPointsOffset[snapPoints.current.length - 1]);\n                return;\n            }\n            if (isFirst && dragDirection < 0 && dismissible) {\n                closeDrawer();\n            }\n            if (activeSnapPointIndex === null)\n                return;\n            snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n            return;\n        }\n        snapToPoint(closestSnapPoint);\n    }\n    function onDrag({ draggedDistance }) {\n        if (activeSnapPointOffset === null)\n            return;\n        const dir = direction.current;\n        const newValue = isBottomOrRight(dir)\n            ? activeSnapPointOffset - draggedDistance\n            : activeSnapPointOffset + draggedDistance;\n        const lastSnapPoint = snapPointsOffset[snapPointsOffset.length - 1];\n        // Don't do anything if we exceed the last(biggest) snap point\n        if (isBottomOrRight(dir) && newValue < lastSnapPoint)\n            return;\n        if (!isBottomOrRight(dir) && newValue > lastSnapPoint)\n            return;\n        set(drawerNode(), {\n            transform: isVertical(dir)\n                ? `translate3d(0, ${newValue}px, 0)`\n                : `translate3d(${newValue}px, 0, 0)`,\n        });\n    }\n    function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n        if (!snapPoints.current ||\n            typeof activeSnapPointIndex !== \"number\" ||\n            !snapPointsOffset ||\n            fadeFromIndex.current === undefined) {\n            return null;\n        }\n        // If this is true we are dragging to a snap point that is supposed to have an overlay\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex.current - 1;\n        const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex.current;\n        if (isOverlaySnapPointOrHigher && isDraggingDown) {\n            return 0;\n        }\n        // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n        if (isOverlaySnapPoint && !isDraggingDown) {\n            return 1;\n        }\n        if (!shouldFade && !isOverlaySnapPoint) {\n            return null;\n        }\n        // Either fadeFrom index or the one before\n        const targetSnapPointIndex = isOverlaySnapPoint\n            ? activeSnapPointIndex + 1\n            : activeSnapPointIndex - 1;\n        // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n        const snapPointDistance = isOverlaySnapPoint\n            ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1]\n            : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n        const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n        if (isOverlaySnapPoint) {\n            return 1 - percentageDragged;\n        }\n        else {\n            return percentageDragged;\n        }\n    }\n    return {\n        get isLastSnapPoint() {\n            return isLastSnapPoint;\n        },\n        get shouldFade() {\n            return shouldFade;\n        },\n        get activeSnapPointIndex() {\n            return activeSnapPointIndex;\n        },\n        get snapPointsOffset() {\n            return $state.snapshot(snapPointsOffset);\n        },\n        getPercentageDragged,\n        onRelease,\n        onDrag,\n    };\n}\nexport function isBottomOrRight(direction) {\n    if (direction === \"bottom\" || direction === \"right\")\n        return true;\n    return false;\n}\n", "export const isBrowser = typeof document !== \"undefined\";\nexport function isMobileFirefox() {\n    const userAgent = navigator.userAgent;\n    return (typeof window !== \"undefined\" &&\n        ((/Firefox/.test(userAgent) && /Mobile/.test(userAgent)) || // Android Firefox\n            /FxiOS/.test(userAgent)) // iOS Firefox\n    );\n}\nexport function isMac() {\n    return testPlatform(/^Mac/);\n}\nexport function isIPhone() {\n    return testPlatform(/^iPhone/);\n}\nexport function isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\nexport function isIPad() {\n    return (testPlatform(/^iPad/) ||\n        // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n        (isMac() && navigator.maxTouchPoints > 1));\n}\nexport function isIOS() {\n    return isIPhone() || isIPad();\n}\nexport function testPlatform(re) {\n    return typeof window !== \"undefined\" && window.navigator != null\n        ? re.test(window.navigator.platform)\n        : undefined;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nimport { watch } from \"runed\";\nimport { isBrowser, isIOS } from \"./internal/browser.js\";\nimport { on } from \"svelte/events\";\nconst KEYBOARD_BUFFER = 24;\nfunction chain(...callbacks) {\n    return (...args) => {\n        for (let callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\nconst visualViewport = isBrowser && window.visualViewport;\nexport function isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nexport function getScrollParent(node) {\n    if (isScrollable(node)) {\n        node = node.parentElement;\n    }\n    while (node && !isScrollable(node)) {\n        node = node.parentElement;\n    }\n    return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\",\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(opts) {\n    watch(opts.isDisabled, () => {\n        if (opts.isDisabled()) {\n            return;\n        }\n        preventScrollCount++;\n        if (preventScrollCount === 1) {\n            if (isIOS()) {\n                restore = preventScrollMobileSafari();\n            }\n        }\n        return () => {\n            preventScrollCount--;\n            if (preventScrollCount === 0) {\n                restore?.();\n            }\n        };\n    });\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    const onTouchStart = (e) => {\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) {\n            return;\n        }\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e) => {\n        // Prevent scrolling the window.\n        if (!scrollable ||\n            scrollable === document.documentElement ||\n            scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) {\n            return;\n        }\n        if ((scrollTop <= 0 && y > lastY) || (scrollTop >= bottom && y < lastY)) {\n            e.preventDefault();\n        }\n        lastY = y;\n    };\n    let onTouchEnd = (e) => {\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if (isInput(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = \"translateY(-2000px)\";\n            target.focus();\n            requestAnimationFrame(() => {\n                target.style.transform = \"\";\n            });\n        }\n    };\n    const onFocus = (e) => {\n        let target = e.target;\n        if (isInput(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n            target.style.transform = \"translateY(-2000px)\";\n            requestAnimationFrame(() => {\n                target.style.transform = \"\";\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if (visualViewport) {\n                    if (visualViewport.height < window.innerHeight) {\n                        // If the keyboard is already visible, do this after one additional frame\n                        // to wait for the transform to be removed.\n                        requestAnimationFrame(() => {\n                            scrollIntoView(target);\n                        });\n                    }\n                    else {\n                        // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                        // measure the correct position to scroll to.\n                        visualViewport.addEventListener(\"resize\", () => scrollIntoView(target), {\n                            once: true,\n                        });\n                    }\n                }\n            });\n        }\n    };\n    let onWindowScroll = () => {\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = chain(setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`)\n    // setStyle(document.documentElement, 'overflow', 'hidden'),\n    // setStyle(document.body, 'marginTop', `-${scrollY}px`),\n    );\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = chain(on(document, \"touchstart\", onTouchStart, { passive: false, capture: true }), on(document, \"touchmove\", onTouchMove, { passive: false, capture: true }), on(document, \"touchend\", onTouchEnd, { passive: false, capture: true }), on(document, \"focus\", onFocus, { capture: true }), on(window, \"scroll\", onWindowScroll));\n    return () => {\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n    // https://github.com/microsoft/TypeScript/issues/17827#issuecomment-391663310\n    let cur = element.style[style];\n    // @ts-expect-error - TS doesn't like dynamic keys on CSSStyleDeclaration\n    element.style[style] = value;\n    return () => {\n        // @ts-expect-error - TS doesn't like dynamic keys on CSSStyleDeclaration\n        element.style[style] = cur;\n    };\n}\nfunction scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while (target && target !== root) {\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = getScrollParent(target);\n        if (scrollable !== document.documentElement &&\n            scrollable !== document.body &&\n            scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            let targetBottom = target.getBoundingClientRect().bottom;\n            // Buffer is needed for some edge cases\n            const keyboardHeight = scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;\n            if (targetBottom > keyboardHeight) {\n                scrollable.scrollTop += targetTop - scrollableTop;\n            }\n        }\n        // @ts-expect-error - sh\n        target = scrollable.parentElement;\n    }\n}\nexport function isInput(target) {\n    return ((target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n        target instanceof HTMLTextAreaElement ||\n        (target instanceof HTMLElement && target.isContentEditable));\n}\n", "import { isSafari } from \"./internal/browser.js\";\nimport { onMount } from \"svelte\";\nimport { on } from \"svelte/events\";\nimport { watch } from \"runed\";\nlet previousBodyPosition = null;\n/**\n * This hook is necessary to prevent buggy behavior on iOS devices (need to test on Android).\n * I won't get into too much detail about what bugs it solves, but so far I've found that setting the body to `position: fixed` is the most reliable way to prevent those bugs.\n * Issues that this hook solves:\n * https://github.com/emilkowalski/vaul/issues/435\n * https://github.com/emilkowalski/vaul/issues/433\n * And more that I discovered, but were just not reported.\n */\nexport function usePositionFixed({ open, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles, }) {\n    let activeUrl = $state(typeof window !== \"undefined\" ? window.location.href : \"\");\n    let scrollPos = 0;\n    function setPositionFixed() {\n        // All browsers on iOS will return true here.\n        if (!isSafari())\n            return;\n        // If previousBodyPosition is already set, don't set it again.\n        if (previousBodyPosition === null && open.current && !noBodyStyles.current) {\n            previousBodyPosition = {\n                position: document.body.style.position,\n                top: document.body.style.top,\n                left: document.body.style.left,\n                height: document.body.style.height,\n                right: \"unset\",\n            };\n            // Update the dom inside an animation frame\n            const { scrollX, innerHeight } = window;\n            document.body.style.setProperty(\"position\", \"fixed\", \"important\");\n            Object.assign(document.body.style, {\n                top: `${-scrollPos}px`,\n                left: `${-scrollX}px`,\n                right: \"0px\",\n                height: \"auto\",\n            });\n            window.setTimeout(() => window.requestAnimationFrame(() => {\n                // Attempt to check if the bottom bar appeared due to the position change\n                const bottomBarHeight = innerHeight - window.innerHeight;\n                if (bottomBarHeight && scrollPos >= innerHeight) {\n                    // Move the content further up so that the bottom bar doesn't hide it\n                    document.body.style.top = `${-(scrollPos + bottomBarHeight)}px`;\n                }\n            }), 300);\n        }\n    }\n    function restorePositionSetting() {\n        // All browsers on iOS will return true here.\n        if (!isSafari())\n            return;\n        if (previousBodyPosition !== null && !noBodyStyles.current) {\n            // Convert the position from \"px\" to Int\n            const y = -parseInt(document.body.style.top, 10);\n            const x = -parseInt(document.body.style.left, 10);\n            // Restore styles\n            Object.assign(document.body.style, previousBodyPosition);\n            window.requestAnimationFrame(() => {\n                if (preventScrollRestoration.current && activeUrl !== window.location.href) {\n                    activeUrl = window.location.href;\n                    return;\n                }\n                window.scrollTo(x, y);\n            });\n            previousBodyPosition = null;\n        }\n    }\n    onMount(() => {\n        function onScroll() {\n            scrollPos = window.scrollY;\n        }\n        onScroll();\n        return on(window, \"scroll\", onScroll);\n    });\n    watch([() => modal.current, () => activeUrl], () => {\n        if (!modal.current)\n            return;\n        return () => {\n            if (typeof document === \"undefined\")\n                return;\n            // Another drawer is opened, safe to ignore the execution\n            const hasDrawerOpened = !!document.querySelector(\"[data-vaul-drawer]\");\n            if (hasDrawerOpened)\n                return;\n            restorePositionSetting();\n        };\n    });\n    watch([\n        () => open.current,\n        () => hasBeenOpened(),\n        () => activeUrl,\n        () => modal.current,\n        () => nested.current,\n    ], () => {\n        if (nested.current || !hasBeenOpened())\n            return;\n        // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n        if (open.current) {\n            // avoid for standalone mode (PWA)\n            const isStandalone = window.matchMedia(\"(display-mode: standalone)\").matches;\n            !isStandalone && setPositionFixed();\n            if (!modal.current) {\n                window.setTimeout(() => {\n                    restorePositionSetting();\n                }, 500);\n            }\n        }\n        else {\n            restorePositionSetting();\n        }\n    });\n    return { restorePositionSetting };\n}\n", "import { Context } from \"runed\";\nexport const DrawerContext = new Context(\"Drawer.Root\");\n", "import { afterSleep, afterTick, box, } from \"svelte-toolbelt\";\nimport { useSnapPoints } from \"./use-snap-points.svelte.js\";\nimport { isInput, usePreventScroll } from \"./use-prevent-scroll.svelte.js\";\nimport { usePositionFixed } from \"./use-position-fixed.svelte.js\";\nimport { BORDER_RADIUS, DRAG_CLASS, NESTED_DISPLACEMENT, TRANSITIONS, VELOCITY_THRESHOLD, WINDOW_TOP_OFFSET, } from \"./internal/constants.js\";\nimport { isIOS, isMobileFirefox } from \"./internal/browser.js\";\nimport { on } from \"svelte/events\";\nimport { dampenValue, getTranslate, isVertical, reset, set } from \"./helpers.js\";\nimport { watch } from \"runed\";\nimport { DrawerContext } from \"./context.js\";\nexport function useDrawerRoot(opts) {\n    let hasBeenOpened = $state(false);\n    let isDragging = $state(false);\n    let justReleased = $state(false);\n    let overlayNode = $state(null);\n    let drawerNode = $state(null);\n    let openTime = null;\n    let dragStartTime = null;\n    let dragEndTime = null;\n    let lastTimeDragPrevented = null;\n    let isAllowedToDrag = false;\n    let nestedOpenChangeTimer = null;\n    let pointerStart = 0;\n    let keyboardIsOpen = box(false);\n    let shouldAnimate = $state(!opts.open.current);\n    let previousDiffFromInitial = 0;\n    let drawerHeight = 0;\n    let drawerWidth = 0;\n    let initialDrawerHeight = 0;\n    let isReleasing = false;\n    const snapPointsState = useSnapPoints({\n        snapPoints: opts.snapPoints,\n        drawerNode: () => drawerNode,\n        activeSnapPoint: opts.activeSnapPoint,\n        container: opts.container,\n        direction: opts.direction,\n        fadeFromIndex: opts.fadeFromIndex,\n        overlayNode: () => overlayNode,\n        setOpenTime: (time) => {\n            openTime = time;\n        },\n        snapToSequentialPoint: opts.snapToSequentialPoint,\n        open: opts.open,\n        isReleasing: () => isReleasing,\n    });\n    usePreventScroll({\n        isDisabled: () => !opts.open.current ||\n            isDragging ||\n            !opts.modal.current ||\n            justReleased ||\n            !hasBeenOpened ||\n            !opts.repositionInputs.current ||\n            !opts.disablePreventScroll.current,\n    });\n    const { restorePositionSetting } = usePositionFixed({\n        ...opts,\n        hasBeenOpened: () => hasBeenOpened,\n    });\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    function onPress(event) {\n        if (!opts.dismissible.current && !opts.snapPoints.current)\n            return;\n        if (drawerNode && !drawerNode.contains(event.target))\n            return;\n        drawerHeight = drawerNode?.getBoundingClientRect().height || 0;\n        drawerWidth = drawerNode?.getBoundingClientRect().width || 0;\n        isDragging = true;\n        dragStartTime = new Date();\n        // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n        if (isIOS()) {\n            on(window, \"touchend\", () => (isAllowedToDrag = false), { once: true });\n        }\n        // Ensure we maintain correct pointer capture even when going outside of the drawer\n        event.target.setPointerCapture(event.pointerId);\n        pointerStart = isVertical(opts.direction.current) ? event.pageY : event.pageX;\n    }\n    function shouldDrag(el, isDraggingInDirection) {\n        let element = el;\n        const highlightedText = window.getSelection()?.toString();\n        const swipeAmount = drawerNode ? getTranslate(drawerNode, opts.direction.current) : null;\n        const date = new Date();\n        // Fixes https://github.com/emilkowalski/vaul/issues/483\n        if (element.tagName === \"SELECT\")\n            return false;\n        if (element.hasAttribute(\"data-vaul-no-drag\") || element.closest(\"[data-vaul-no-drag]\")) {\n            return false;\n        }\n        if (opts.direction.current === \"right\" || opts.direction.current === \"left\") {\n            return true;\n        }\n        // Allow scrolling when animating\n        if (openTime && date.getTime() - openTime.getTime() < 500) {\n            return false;\n        }\n        if (swipeAmount !== null) {\n            if (opts.direction.current === \"bottom\" ? swipeAmount > 0 : swipeAmount < 0) {\n                return true;\n            }\n        }\n        // Don't drag if there's highlighted text\n        if (highlightedText && highlightedText.length > 0) {\n            return false;\n        }\n        // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n        if (lastTimeDragPrevented &&\n            date.getTime() - lastTimeDragPrevented.getTime() < opts.scrollLockTimeout.current &&\n            swipeAmount === 0) {\n            lastTimeDragPrevented = date;\n            return false;\n        }\n        if (isDraggingInDirection) {\n            lastTimeDragPrevented = date;\n            // We are dragging down so we should allow scrolling\n            return false;\n        }\n        // Keep climbing up the DOM tree as long as there's a parent\n        while (element) {\n            // Check if the element is scrollable\n            if (element.scrollHeight > element.clientHeight) {\n                if (element.scrollTop !== 0) {\n                    lastTimeDragPrevented = new Date();\n                    // The element is scrollable and not scrolled to the top, so don't drag\n                    return false;\n                }\n                if (element.getAttribute(\"role\") === \"dialog\") {\n                    return true;\n                }\n            }\n            // Move up to the parent element\n            element = element.parentNode;\n        }\n        // No scrollable parents not scrolled to the top found, so drag\n        return true;\n    }\n    function onDrag(event) {\n        if (!drawerNode || !isDragging)\n            return;\n        // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n        const directionMultiplier = opts.direction.current === \"bottom\" || opts.direction.current === \"right\" ? 1 : -1;\n        const draggedDistance = (pointerStart - (isVertical(opts.direction.current) ? event.pageY : event.pageX)) *\n            directionMultiplier;\n        const isDraggingInDirection = draggedDistance > 0;\n        // Pre condition for disallowing dragging in the close direction.\n        const noCloseSnapPointsPreCondition = opts.snapPoints.current && !opts.dismissible.current && !isDraggingInDirection;\n        // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n        if (noCloseSnapPointsPreCondition && snapPointsState.activeSnapPointIndex === 0)\n            return;\n        // We need to capture last time when drag with scroll was triggered and have a timeout between\n        const absDraggedDistance = Math.abs(draggedDistance);\n        const wrapper = document.querySelector(\"[data-vaul-drawer-wrapper]\");\n        const drawerDimension = opts.direction.current === \"bottom\" || opts.direction.current === \"top\"\n            ? drawerHeight\n            : drawerWidth;\n        // Calculate the percentage dragged, where 1 is the closed position\n        let percentageDragged = absDraggedDistance / drawerDimension;\n        const snapPointPercentageDragged = snapPointsState.getPercentageDragged(absDraggedDistance, isDraggingInDirection);\n        if (snapPointPercentageDragged !== null) {\n            percentageDragged = snapPointPercentageDragged;\n        }\n        // Disallow close dragging beyond the smallest snap point.\n        if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n            return;\n        }\n        if (!isAllowedToDrag && !shouldDrag(event.target, isDraggingInDirection))\n            return;\n        drawerNode.classList.add(DRAG_CLASS);\n        // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n        isAllowedToDrag = true;\n        set(drawerNode, {\n            transition: \"none\",\n        });\n        set(overlayNode, {\n            transition: \"none\",\n        });\n        if (opts.snapPoints.current) {\n            snapPointsState.onDrag({ draggedDistance });\n        }\n        // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n        if (isDraggingInDirection && !opts.snapPoints.current) {\n            const dampenedDraggedDistance = dampenValue(draggedDistance);\n            const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n            set(drawerNode, {\n                transform: isVertical(opts.direction.current)\n                    ? `translate3d(0, ${translateValue}px, 0)`\n                    : `translate3d(${translateValue}px, 0, 0)`,\n            });\n            return;\n        }\n        const opacityValue = 1 - percentageDragged;\n        if (snapPointsState.shouldFade ||\n            (opts.fadeFromIndex.current &&\n                snapPointsState.activeSnapPointIndex === opts.fadeFromIndex.current - 1)) {\n            opts.onDrag.current?.(event, percentageDragged);\n            set(overlayNode, {\n                opacity: `${opacityValue}`,\n                transition: \"none\",\n            }, true);\n        }\n        if (wrapper && overlayNode && opts.shouldScaleBackground.current) {\n            // Calculate percentageDragged as a fraction (0 to 1)\n            const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n            const borderRadiusValue = 8 - percentageDragged * 8;\n            const translateValue = Math.max(0, 14 - percentageDragged * 14);\n            set(wrapper, {\n                borderRadius: `${borderRadiusValue}px`,\n                transform: isVertical(opts.direction.current)\n                    ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)`\n                    : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n                transition: \"none\",\n            }, true);\n        }\n        if (!opts.snapPoints.current) {\n            const translateValue = absDraggedDistance * directionMultiplier;\n            set(drawerNode, {\n                transform: isVertical(opts.direction.current)\n                    ? `translate3d(0, ${translateValue}px, 0)`\n                    : `translate3d(${translateValue}px, 0, 0)`,\n            });\n        }\n    }\n    $effect(() => {\n        window.requestAnimationFrame(() => {\n            shouldAnimate = true;\n        });\n    });\n    function onDialogOpenChange(o) {\n        if (!opts.dismissible.current && !o)\n            return;\n        if (o) {\n            hasBeenOpened = true;\n        }\n        else {\n            closeDrawer(true);\n        }\n        opts.open.current = o;\n    }\n    function onVisualViewportChange() {\n        if (!drawerNode || !opts.repositionInputs.current)\n            return;\n        const focusedElement = document.activeElement;\n        if (isInput(focusedElement) || keyboardIsOpen.current) {\n            const visualViewportHeight = window.visualViewport?.height || 0;\n            const totalHeight = window.innerHeight;\n            // This is the height of the keyboard\n            let diffFromInitial = totalHeight - visualViewportHeight;\n            const drawerHeight = drawerNode.getBoundingClientRect().height || 0;\n            // Adjust drawer height only if it's tall enough\n            const isTallEnough = drawerHeight > totalHeight * 0.8;\n            if (!initialDrawerHeight) {\n                initialDrawerHeight = drawerHeight;\n            }\n            const offsetFromTop = drawerNode.getBoundingClientRect().top;\n            // visualViewport height may change due to some subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n            if (Math.abs(previousDiffFromInitial - diffFromInitial) > 60) {\n                keyboardIsOpen.current = !keyboardIsOpen.current;\n            }\n            if (opts.snapPoints.current &&\n                opts.snapPoints.current.length > 0 &&\n                snapPointsState.snapPointsOffset &&\n                snapPointsState.activeSnapPointIndex) {\n                const activeSnapPointHeight = snapPointsState.snapPointsOffset[snapPointsState.activeSnapPointIndex] || 0;\n                diffFromInitial += activeSnapPointHeight;\n            }\n            previousDiffFromInitial = diffFromInitial;\n            // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n            if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n                const height = drawerNode.getBoundingClientRect().height;\n                let newDrawerHeight = height;\n                if (height > visualViewportHeight) {\n                    newDrawerHeight =\n                        visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);\n                }\n                // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n                if (opts.fixed.current) {\n                    drawerNode.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n                }\n                else {\n                    drawerNode.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n                }\n            }\n            else if (!isMobileFirefox()) {\n                drawerNode.style.height = `${initialDrawerHeight}px`;\n            }\n            if (opts.snapPoints.current &&\n                opts.snapPoints.current.length > 0 &&\n                !keyboardIsOpen.current) {\n                drawerNode.style.bottom = `0px`;\n            }\n            else {\n                // Negative bottom value would never make sense\n                drawerNode.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n            }\n        }\n    }\n    watch([\n        () => snapPointsState.activeSnapPointIndex,\n        () => opts.snapPoints.current,\n        () => snapPointsState.snapPointsOffset,\n        () => drawerNode,\n    ], () => {\n        if (!window.visualViewport)\n            return;\n        return on(window.visualViewport, \"resize\", onVisualViewportChange);\n    });\n    function cancelDrag() {\n        if (!isDragging || !drawerNode)\n            return;\n        drawerNode.classList.remove(DRAG_CLASS);\n        isAllowedToDrag = false;\n        isDragging = false;\n        dragEndTime = new Date();\n    }\n    function closeDrawer(fromWithin) {\n        cancelDrag();\n        opts.onClose?.current();\n        if (!fromWithin) {\n            handleOpenChange(false);\n            opts.open.current = false;\n        }\n        window.setTimeout(() => {\n            if (opts.snapPoints.current && opts.snapPoints.current.length > 0) {\n                opts.activeSnapPoint.current = opts.snapPoints.current[0];\n            }\n        }, TRANSITIONS.DURATION * 1000);\n    }\n    function resetDrawer() {\n        if (!drawerNode)\n            return;\n        const wrapper = document.querySelector(\"[data-vaul-drawer-wrapper]\");\n        const currentSwipeAmount = getTranslate(drawerNode, opts.direction.current);\n        set(drawerNode, {\n            transform: \"translate3d(0, 0, 0)\",\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n        });\n        set(overlayNode, {\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            opacity: \"1\",\n        });\n        // Don't reset background if swiped upwards\n        if (opts.shouldScaleBackground.current &&\n            currentSwipeAmount &&\n            currentSwipeAmount > 0 &&\n            opts.open.current) {\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...(isVertical(opts.direction.current)\n                    ? {\n                        transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                        transformOrigin: \"top\",\n                    }\n                    : {\n                        transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                        transformOrigin: \"left\",\n                    }),\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            }, true);\n        }\n    }\n    function onRelease(event) {\n        // We keep track of whether we are releasing or not\n        // because we need to differentiate release from outside click/escape keydown\n        isReleasing = true;\n        handleRelease(event);\n        afterTick(() => {\n            isReleasing = false;\n        });\n    }\n    function handleRelease(event) {\n        if (!isDragging || !drawerNode)\n            return;\n        drawerNode.classList.remove(DRAG_CLASS);\n        isAllowedToDrag = false;\n        isDragging = false;\n        dragEndTime = new Date();\n        const swipeAmount = getTranslate(drawerNode, opts.direction.current);\n        if (!event ||\n            (event.target && !shouldDrag(event.target, false)) ||\n            !swipeAmount ||\n            Number.isNaN(swipeAmount)) {\n            return;\n        }\n        if (dragStartTime === null)\n            return;\n        const timeTaken = dragEndTime.getTime() - dragStartTime.getTime();\n        const distMoved = pointerStart - (isVertical(opts.direction.current) ? event.pageY : event.pageX);\n        const velocity = Math.abs(distMoved) / timeTaken;\n        if (velocity > 0.05) {\n            // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n            justReleased = true;\n            setTimeout(() => {\n                justReleased = false;\n            }, 200);\n        }\n        if (opts.snapPoints.current) {\n            const directionMultiplier = opts.direction.current === \"bottom\" || opts.direction.current === \"right\" ? 1 : -1;\n            snapPointsState.onRelease({\n                draggedDistance: distMoved * directionMultiplier,\n                closeDrawer,\n                velocity,\n                dismissible: opts.dismissible.current,\n            });\n            opts.onRelease.current?.(event, true);\n            return;\n        }\n        // Moved upwards, don't do anything\n        if (opts.direction.current === \"bottom\" || opts.direction.current === \"right\"\n            ? distMoved > 0\n            : distMoved < 0) {\n            resetDrawer();\n            opts.onRelease.current?.(event, true);\n            return;\n        }\n        if (velocity > VELOCITY_THRESHOLD) {\n            closeDrawer();\n            opts.onRelease.current?.(event, false);\n            return;\n        }\n        const visibleDrawerHeight = Math.min(drawerNode.getBoundingClientRect().height ?? 0, window.innerHeight);\n        const visibleDrawerWidth = Math.min(drawerNode.getBoundingClientRect().width ?? 0, window.innerWidth);\n        const isHorizontalSwipe = opts.direction.current === \"left\" || opts.direction.current === \"right\";\n        if (Math.abs(swipeAmount) >=\n            (isHorizontalSwipe ? visibleDrawerWidth : visibleDrawerHeight) *\n                opts.closeThreshold.current) {\n            closeDrawer();\n            opts.onRelease.current?.(event, false);\n            return;\n        }\n        opts.onRelease.current?.(event, true);\n        resetDrawer();\n    }\n    watch(() => opts.open.current, () => {\n        // Trigger enter animation without using CSS animation\n        if (opts.open.current) {\n            set(document.documentElement, {\n                scrollBehavior: \"auto\",\n            });\n            openTime = new Date();\n        }\n        return () => {\n            reset(document.documentElement, \"scrollBehavior\");\n        };\n    });\n    function onNestedOpenChange(o) {\n        const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n        const initialTranslate = o ? -NESTED_DISPLACEMENT : 0;\n        if (nestedOpenChangeTimer) {\n            window.clearTimeout(nestedOpenChangeTimer);\n        }\n        set(drawerNode, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: isVertical(opts.direction.current)\n                ? `scale(${scale}) translate3d(0, ${initialTranslate}px, 0)`\n                : `scale(${scale}) translate3d(${initialTranslate}px, 0, 0)`,\n        });\n        if (!o && drawerNode) {\n            nestedOpenChangeTimer = window.setTimeout(() => {\n                const translateValue = getTranslate(drawerNode, opts.direction.current);\n                set(drawerNode, {\n                    transition: \"none\",\n                    transform: isVertical(opts.direction.current)\n                        ? `translate3d(0, ${translateValue}px, 0)`\n                        : `translate3d(${translateValue}px, 0, 0)`,\n                });\n            }, 500);\n        }\n    }\n    function onNestedDrag(_event, percentageDragged) {\n        if (percentageDragged < 0)\n            return;\n        const initialScale = (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth;\n        const newScale = initialScale + percentageDragged * (1 - initialScale);\n        const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n        set(drawerNode, {\n            transform: isVertical(opts.direction.current)\n                ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)`\n                : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n            transition: \"none\",\n        });\n    }\n    function onNestedRelease(_event, o) {\n        const dim = isVertical(opts.direction.current) ? window.innerHeight : window.innerWidth;\n        const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n        const translate = o ? -NESTED_DISPLACEMENT : 0;\n        if (o) {\n            set(drawerNode, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                transform: isVertical(opts.direction.current)\n                    ? `scale(${scale}) translate3d(0, ${translate}px, 0)`\n                    : `scale(${scale}) translate3d(${translate}px, 0, 0)`,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let bodyStyles;\n    function handleOpenChange(o) {\n        opts.onOpenChange.current?.(o);\n        if (o && !opts.nested.current) {\n            bodyStyles = document.body.style.cssText;\n        }\n        else if (!o && !opts.nested.current) {\n            afterSleep(TRANSITIONS.DURATION * 1000, () => {\n                document.body.style.cssText = bodyStyles;\n            });\n        }\n        if (!o && !opts.nested.current) {\n            restorePositionSetting();\n        }\n        setTimeout(() => {\n            opts.onAnimationEnd.current?.(o);\n        }, TRANSITIONS.DURATION * 1000);\n        if (o && !opts.modal.current) {\n            if (typeof window !== \"undefined\") {\n                window.requestAnimationFrame(() => {\n                    document.body.style.pointerEvents = \"auto\";\n                });\n            }\n        }\n        if (!o) {\n            // This will be removed when the exit animation ends (`500ms`)\n            document.body.style.pointerEvents = \"auto\";\n        }\n    }\n    watch(() => opts.modal.current, () => {\n        if (!opts.modal.current) {\n            window.requestAnimationFrame(() => {\n                document.body.style.pointerEvents = \"auto\";\n            });\n        }\n    });\n    function setOverlayNode(node) {\n        overlayNode = node;\n    }\n    function setDrawerNode(node) {\n        drawerNode = node;\n    }\n    return DrawerContext.set({\n        ...opts,\n        keyboardIsOpen,\n        closeDrawer,\n        setDrawerNode,\n        setOverlayNode,\n        onDrag,\n        onNestedDrag,\n        onNestedOpenChange,\n        onNestedRelease,\n        onRelease,\n        onPress,\n        onDialogOpenChange,\n        get shouldAnimate() {\n            return shouldAnimate;\n        },\n        get isDragging() {\n            return isDragging;\n        },\n        get overlayNode() {\n            return overlayNode;\n        },\n        get drawerNode() {\n            return drawerNode;\n        },\n        get snapPointsOffset() {\n            return snapPointsState.snapPointsOffset;\n        },\n        get shouldFade() {\n            return snapPointsState.shouldFade;\n        },\n        restorePositionSetting,\n        handleOpenChange,\n    });\n}\n", "<script lang=\"ts\">\n\timport { Dialog as DialogPrimitive } from \"bits-ui\";\n\timport { box } from \"svelte-toolbelt\";\n\timport type { RootProps } from \"./index.js\";\n\timport { noop } from \"../../internal/noop.js\";\n\timport { CLOSE_THRESHOLD, SCROLL_LOCK_TIMEOUT } from \"../../internal/constants.js\";\n\timport { useDrawerRoot } from \"../../use-drawer-root.svelte.js\";\n\n\tlet {\n\t\topen = $bindable(false),\n\t\tonOpenChange = noop,\n\t\tonDrag = noop,\n\t\tonRelease = noop,\n\t\tsnapPoints,\n\t\tshouldScaleBackground = false,\n\t\tsetBackgroundColorOnScale = true,\n\t\tcloseThreshold = CLOSE_THRESHOLD,\n\t\tscrollLockTimeout = SCROLL_LOCK_TIMEOUT,\n\t\tdismissible = true,\n\t\thandleOnly = false,\n\t\tfadeFromIndex = snapPoints && snapPoints.length - 1,\n\t\tactiveSnapPoint = $bindable(null),\n\t\tonActiveSnapPointChange = noop,\n\t\tfixed = false,\n\t\tmodal = true,\n\t\tonClose = noop,\n\t\tnested = false,\n\t\tnoBodyStyles = false,\n\t\tdirection = \"bottom\",\n\t\tsnapToSequentialPoint = false,\n\t\tpreventScrollRestoration = false,\n\t\trepositionInputs = true,\n\t\tonAnimationEnd = noop,\n\t\tcontainer = null,\n\t\tautoFocus = false,\n\t\tdisablePreventScroll = true,\n\t\t...restProps\n\t}: RootProps = $props();\n\n\tconst rootState = useDrawerRoot({\n\t\topen: box.with(\n\t\t\t() => open,\n\t\t\t(o) => {\n\t\t\t\topen = o;\n\t\t\t\trootState.handleOpenChange(o);\n\t\t\t}\n\t\t),\n\t\tcloseThreshold: box.with(() => closeThreshold),\n\t\tscrollLockTimeout: box.with(() => scrollLockTimeout),\n\t\tsnapPoints: box.with(() => snapPoints),\n\t\tfadeFromIndex: box.with(() => fadeFromIndex),\n\t\tnested: box.with(() => nested),\n\t\tshouldScaleBackground: box.with(() => shouldScaleBackground),\n\t\tactiveSnapPoint: box.with(\n\t\t\t() => activeSnapPoint,\n\t\t\t(v) => {\n\t\t\t\tactiveSnapPoint = v;\n\t\t\t\tonActiveSnapPointChange(v);\n\t\t\t}\n\t\t),\n\t\tonRelease: box.with(() => onRelease),\n\t\tonDrag: box.with(() => onDrag),\n\t\tonClose: box.with(() => onClose),\n\t\tdismissible: box.with(() => dismissible),\n\t\tdirection: box.with(() => direction),\n\t\tfixed: box.with(() => fixed),\n\t\tmodal: box.with(() => modal),\n\t\thandleOnly: box.with(() => handleOnly),\n\t\tnoBodyStyles: box.with(() => noBodyStyles),\n\t\tpreventScrollRestoration: box.with(() => preventScrollRestoration),\n\t\tsetBackgroundColorOnScale: box.with(() => setBackgroundColorOnScale),\n\t\trepositionInputs: box.with(() => repositionInputs),\n\t\tautoFocus: box.with(() => autoFocus),\n\t\tsnapToSequentialPoint: box.with(() => snapToSequentialPoint),\n\t\tcontainer: box.with(() => container),\n\t\tdisablePreventScroll: box.with(() => disablePreventScroll),\n\t\tonOpenChange: box.with(() => onOpenChange),\n\t\tonAnimationEnd: box.with(() => onAnimationEnd),\n\t});\n</script>\n\n<DialogPrimitive.Root\n\tbind:open={\n\t\t() => rootState.open.current,\n\t\t(o) => {\n\t\t\trootState.onDialogOpenChange(o);\n\t\t}\n\t}\n\t{...restProps}\n/>\n\n<style global>\n\t:global([data-vaul-drawer]) {\n\t\ttouch-action: none;\n\t\twill-change: transform;\n\t\ttransition: transform 0.5s cubic-bezier(0.32, 0.72, 0, 1);\n\t\tanimation-duration: 0.5s;\n\t\tanimation-timing-function: cubic-bezier(0.32, 0.72, 0, 1);\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"bottom\"][data-state=\"open\"]\n\t\t) {\n\t\tanimation-name: slideFromBottom;\n\t}\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"bottom\"][data-state=\"closed\"]\n\t\t) {\n\t\tanimation-name: slideToBottom;\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"top\"][data-state=\"open\"]\n\t\t) {\n\t\tanimation-name: slideFromTop;\n\t}\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"top\"][data-state=\"closed\"]\n\t\t) {\n\t\tanimation-name: slideToTop;\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"left\"][data-state=\"open\"]\n\t\t) {\n\t\tanimation-name: slideFromLeft;\n\t}\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"left\"][data-state=\"closed\"]\n\t\t) {\n\t\tanimation-name: slideToLeft;\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"right\"][data-state=\"open\"]\n\t\t) {\n\t\tanimation-name: slideFromRight;\n\t}\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-snap-points=\"false\"][data-vaul-drawer-direction=\"right\"][data-state=\"closed\"]\n\t\t) {\n\t\tanimation-name: slideToRight;\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-snap-points=\"true\"][data-vaul-drawer-direction=\"bottom\"]) {\n\t\ttransform: translate3d(0, var(--initial-transform, 100%), 0);\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-snap-points=\"true\"][data-vaul-drawer-direction=\"top\"]) {\n\t\ttransform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-snap-points=\"true\"][data-vaul-drawer-direction=\"left\"]) {\n\t\ttransform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-snap-points=\"true\"][data-vaul-drawer-direction=\"right\"]) {\n\t\ttransform: translate3d(var(--initial-transform, 100%), 0, 0);\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-delayed-snap-points=\"true\"][data-vaul-drawer-direction=\"top\"]\n\t\t) {\n\t\ttransform: translate3d(0, var(--snap-point-height, 0), 0);\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-delayed-snap-points=\"true\"][data-vaul-drawer-direction=\"bottom\"]\n\t\t) {\n\t\ttransform: translate3d(0, var(--snap-point-height, 0), 0);\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-delayed-snap-points=\"true\"][data-vaul-drawer-direction=\"left\"]\n\t\t) {\n\t\ttransform: translate3d(var(--snap-point-height, 0), 0, 0);\n\t}\n\n\t:global(\n\t\t\t[data-vaul-drawer][data-vaul-delayed-snap-points=\"true\"][data-vaul-drawer-direction=\"right\"]\n\t\t) {\n\t\ttransform: translate3d(var(--snap-point-height, 0), 0, 0);\n\t}\n\n\t:global([data-vaul-overlay][data-vaul-snap-points=\"false\"]) {\n\t\tanimation-duration: 0.5s;\n\t\tanimation-timing-function: cubic-bezier(0.32, 0.72, 0, 1);\n\t}\n\t:global([data-vaul-overlay][data-vaul-snap-points=\"false\"][data-state=\"open\"]) {\n\t\tanimation-name: fadeIn;\n\t}\n\t:global([data-vaul-overlay][data-state=\"closed\"]) {\n\t\tanimation-name: fadeOut;\n\t}\n\n\t:global([data-vaul-animate=\"false\"]) {\n\t\tanimation: none !important;\n\t}\n\n\t:global([data-vaul-overlay][data-vaul-snap-points=\"true\"]) {\n\t\topacity: 0;\n\t\ttransition: opacity 0.5s cubic-bezier(0.32, 0.72, 0, 1);\n\t}\n\n\t:global([data-vaul-overlay][data-vaul-snap-points=\"true\"]) {\n\t\topacity: 1;\n\t}\n\n\t:global([data-vaul-drawer]:not([data-vaul-custom-container=\"true\"])::after) {\n\t\tcontent: \"\";\n\t\tposition: absolute;\n\t\tbackground: inherit;\n\t\tbackground-color: inherit;\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-drawer-direction=\"top\"]::after) {\n\t\ttop: initial;\n\t\tbottom: 100%;\n\t\tleft: 0;\n\t\tright: 0;\n\t\theight: 200%;\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-drawer-direction=\"bottom\"]::after) {\n\t\ttop: 100%;\n\t\tbottom: initial;\n\t\tleft: 0;\n\t\tright: 0;\n\t\theight: 200%;\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-drawer-direction=\"left\"]::after) {\n\t\tleft: initial;\n\t\tright: 100%;\n\t\ttop: 0;\n\t\tbottom: 0;\n\t\twidth: 200%;\n\t}\n\n\t:global([data-vaul-drawer][data-vaul-drawer-direction=\"right\"]::after) {\n\t\tleft: 100%;\n\t\tright: initial;\n\t\ttop: 0;\n\t\tbottom: 0;\n\t\twidth: 200%;\n\t}\n\n\t:global(\n\t\t\t[data-vaul-overlay][data-vaul-snap-points=\"true\"]:not(\n\t\t\t\t\t[data-vaul-snap-points-overlay=\"true\"]\n\t\t\t\t):not([data-state=\"closed\"])\n\t\t) {\n\t\topacity: 0;\n\t}\n\n\t:global([data-vaul-overlay][data-vaul-snap-points-overlay=\"true\"]) {\n\t\topacity: 1;\n\t}\n\n\t:global([data-vaul-handle]) {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\topacity: 0.7;\n\t\tbackground: #e2e2e4;\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t\theight: 5px;\n\t\twidth: 32px;\n\t\tborder-radius: 1rem;\n\t\ttouch-action: pan-y;\n\t}\n\n\t:global([data-vaul-handle]:hover, [data-vaul-handle]:active) {\n\t\topacity: 1;\n\t}\n\n\t:global([data-vaul-handle-hitarea]) {\n\t\tposition: absolute;\n\t\tleft: 50%;\n\t\ttop: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\twidth: max(100%, 2.75rem); /* 44px */\n\t\theight: max(100%, 2.75rem); /* 44px */\n\t\ttouch-action: inherit;\n\t}\n\n\t/* This will allow us to not animate via animation, but still benefit from delaying unmount via Radix. */\n\n\t@keyframes -global-fake-animation {\n\t\tfrom {\n\t\t}\n\t\tto {\n\t\t}\n\t}\n\n\t@keyframes -global-fadeIn {\n\t\tfrom {\n\t\t\topacity: 0;\n\t\t}\n\t\tto {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t@keyframes -global-fadeOut {\n\t\tto {\n\t\t\topacity: 0;\n\t\t}\n\t}\n\n\t@keyframes -global-slideFromBottom {\n\t\tfrom {\n\t\t\ttransform: translate3d(0, var(--initial-transform, 100%), 0);\n\t\t}\n\t\tto {\n\t\t\ttransform: translate3d(0, 0, 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideToBottom {\n\t\tto {\n\t\t\ttransform: translate3d(0, var(--initial-transform, 100%), 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideFromTop {\n\t\tfrom {\n\t\t\ttransform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n\t\t}\n\t\tto {\n\t\t\ttransform: translate3d(0, 0, 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideToTop {\n\t\tto {\n\t\t\ttransform: translate3d(0, calc(var(--initial-transform, 100%) * -1), 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideFromLeft {\n\t\tfrom {\n\t\t\ttransform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n\t\t}\n\t\tto {\n\t\t\ttransform: translate3d(0, 0, 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideToLeft {\n\t\tto {\n\t\t\ttransform: translate3d(calc(var(--initial-transform, 100%) * -1), 0, 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideFromRight {\n\t\tfrom {\n\t\t\ttransform: translate3d(var(--initial-transform, 100%), 0, 0);\n\t\t}\n\t\tto {\n\t\t\ttransform: translate3d(0, 0, 0);\n\t\t}\n\t}\n\n\t@keyframes -global-slideToRight {\n\t\tto {\n\t\t\ttransform: translate3d(var(--initial-transform, 100%), 0, 0);\n\t\t}\n\t}\n\n\t@media (hover: hover) and (pointer: fine) {\n\t\t:global([data-vaul-drawer]) {\n\t\t\tuser-select: none !important;\n\t\t}\n\t}\n\n\t@media (pointer: fine) {\n\t\t:global([data-vaul-handle-hitarea]) {\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t}\n\t}\n</style>\n", "globalThis.vaulIdCounter ??= { current: 0 };\n/**\n * Generates a unique ID based on a global counter.\n */\nexport function useId(prefix = \"vaul-svelte\") {\n    globalThis.vaulIdCounter.current++;\n    return `${prefix}-${globalThis.vaulIdCounter.current}`;\n}\n", "import { watch } from \"runed\";\nimport { BORDER_RADIUS, TRANSITIONS, WINDOW_TOP_OFFSET } from \"./internal/constants.js\";\nimport { assignStyle, chain, isVertical } from \"./helpers.js\";\nimport { noop } from \"./internal/noop.js\";\nimport { DrawerContext } from \"./context.js\";\nexport function useScaleBackground() {\n    const ctx = DrawerContext.get();\n    let timeoutId = null;\n    const initialBackgroundColor = typeof document !== \"undefined\" ? document.body.style.backgroundColor : \"\";\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    watch([\n        () => ctx.open.current,\n        () => ctx.shouldScaleBackground.current,\n        () => ctx.setBackgroundColorOnScale.current,\n    ], () => {\n        if (ctx.open.current && ctx.shouldScaleBackground.current) {\n            if (timeoutId)\n                clearTimeout(timeoutId);\n            const wrapper = document.querySelector(\"[data-vaul-drawer-wrapper]\") ||\n                document.querySelector(\"[data-vaul-drawer-wrapper]\");\n            if (!wrapper)\n                return;\n            chain(ctx.setBackgroundColorOnScale.current && !ctx.noBodyStyles.current\n                ? assignStyle(document.body, { background: \"black\" })\n                : noop, assignStyle(wrapper, {\n                transformOrigin: isVertical(ctx.direction.current) ? \"top\" : \"left\",\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            }));\n            const wrapperStylesCleanup = assignStyle(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...(isVertical(ctx.direction.current)\n                    ? {\n                        transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    }\n                    : {\n                        transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    }),\n            });\n            return () => {\n                wrapperStylesCleanup();\n                timeoutId = window.setTimeout(() => {\n                    if (initialBackgroundColor) {\n                        document.body.style.background = initialBackgroundColor;\n                    }\n                    else {\n                        document.body.style.removeProperty(\"background\");\n                    }\n                }, TRANSITIONS.DURATION * 1000);\n            };\n        }\n    });\n}\n", "import {} from \"svelte\";\nimport { useRefById } from \"svelte-toolbelt\";\nimport { Dialog as DrawerPrimitive } from \"bits-ui\";\nimport { DrawerContext } from \"./context.js\";\nimport { watch } from \"runed\";\nimport { useScaleBackground } from \"./use-scale-background.svelte.js\";\nexport function useDrawerContent(opts) {\n    const ctx = DrawerContext.get();\n    let mounted = $state(false);\n    useRefById({\n        id: opts.id,\n        ref: opts.ref,\n        deps: () => [mounted, ctx.open.current],\n        onRefChange: (node) => {\n            if (!mounted) {\n                ctx.setDrawerNode(null);\n            }\n            else {\n                ctx.setDrawerNode(node);\n            }\n        },\n    });\n    let delayedSnapPoints = $state(false);\n    let pointerStart = null;\n    let lastKnownPointerEvent = null;\n    let wasBeyondThePoint = false;\n    const hasSnapPoints = $derived(ctx.snapPoints.current && ctx.snapPoints.current.length > 0);\n    useScaleBackground();\n    function isDeltaInDirection(delta, direction, threshold = 0) {\n        if (wasBeyondThePoint)\n            return true;\n        const deltaY = Math.abs(delta.y);\n        const deltaX = Math.abs(delta.x);\n        const isDeltaX = deltaX > deltaY;\n        const dFactor = [\"bottom\", \"right\"].includes(direction) ? 1 : -1;\n        if (direction === \"left\" || direction === \"right\") {\n            const isReverseDirection = delta.x * dFactor < 0;\n            if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {\n                return isDeltaX;\n            }\n        }\n        else {\n            const isReverseDirection = delta.y * dFactor < 0;\n            if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {\n                return !isDeltaX;\n            }\n        }\n        wasBeyondThePoint = true;\n        return true;\n    }\n    watch([() => hasSnapPoints, () => ctx.open.current], () => {\n        if (hasSnapPoints && ctx.open.current) {\n            window.requestAnimationFrame(() => {\n                delayedSnapPoints = true;\n            });\n        }\n        else {\n            delayedSnapPoints = false;\n        }\n    });\n    function handleOnPointerUp(e) {\n        pointerStart = null;\n        wasBeyondThePoint = false;\n        ctx.onRelease(e);\n    }\n    function onpointerdown(e) {\n        if (ctx.handleOnly.current)\n            return;\n        opts.onpointerdown.current?.(e);\n        pointerStart = { x: e.pageX, y: e.pageY };\n        ctx.onPress(e);\n    }\n    function onOpenAutoFocus(e) {\n        opts.onOpenAutoFocus.current?.(e);\n        if (!ctx.autoFocus.current) {\n            e.preventDefault();\n        }\n    }\n    function onInteractOutside(e) {\n        opts.onInteractOutside.current?.(e);\n        if (!ctx.modal.current || e.defaultPrevented) {\n            e.preventDefault();\n            return;\n        }\n        if (ctx.keyboardIsOpen.current) {\n            ctx.keyboardIsOpen.current = false;\n        }\n    }\n    function onFocusOutside(e) {\n        if (!ctx.modal.current) {\n            e.preventDefault();\n            return;\n        }\n    }\n    function onpointermove(e) {\n        lastKnownPointerEvent = e;\n        if (ctx.handleOnly.current)\n            return;\n        opts.onpointermove.current?.(e);\n        if (!pointerStart)\n            return;\n        const yPosition = e.pageY - pointerStart.y;\n        const xPosition = e.pageX - pointerStart.x;\n        const swipeStartThreshold = e.pointerType === \"touch\" ? 10 : 2;\n        const delta = { x: xPosition, y: yPosition };\n        const isAllowedToSwipe = isDeltaInDirection(delta, ctx.direction.current, swipeStartThreshold);\n        if (isAllowedToSwipe) {\n            ctx.onDrag(e);\n        }\n        else if (Math.abs(xPosition) > swipeStartThreshold ||\n            Math.abs(yPosition) > swipeStartThreshold) {\n            pointerStart = null;\n        }\n    }\n    function onpointerup(e) {\n        opts.onpointerup.current?.(e);\n        pointerStart = null;\n        wasBeyondThePoint = false;\n        ctx.onRelease(e);\n    }\n    function onpointerout(e) {\n        opts.onpointerout.current?.(e);\n        handleOnPointerUp(lastKnownPointerEvent);\n    }\n    function oncontextmenu(e) {\n        opts.oncontextmenu.current?.(e);\n        if (lastKnownPointerEvent) {\n            handleOnPointerUp(lastKnownPointerEvent);\n        }\n    }\n    const props = $derived({\n        id: opts.id.current,\n        \"data-vaul-drawer-direction\": ctx.direction.current,\n        \"data-vaul-drawer\": \"\",\n        \"data-vaul-delayed-snap-points\": delayedSnapPoints ? \"true\" : \"false\",\n        \"data-vaul-snap-points\": ctx.open.current && hasSnapPoints ? \"true\" : \"false\",\n        \"data-vaul-custom-container\": ctx.container.current ? \"true\" : \"false\",\n        \"data-vaul-animate\": ctx.shouldAnimate ? \"true\" : \"false\",\n        onpointerdown,\n        onOpenAutoFocus,\n        onInteractOutside,\n        onFocusOutside,\n        onpointerup,\n        onpointermove,\n        onpointerout,\n        oncontextmenu,\n        preventScroll: ctx.modal.current,\n    });\n    return {\n        get props() {\n            return props;\n        },\n        ctx,\n        setMounted: (value) => {\n            mounted = value;\n        },\n    };\n}\n", "<script lang=\"ts\">\n\timport { onMount } from \"svelte\";\n\n\tlet { onMounted }: { onMounted: (bool: boolean) => void } = $props();\n\n\tonMount(() => {\n\t\tonMounted(true);\n\t\treturn () => {\n\t\t\tonMounted(false);\n\t\t};\n\t});\n</script>\n", "<script lang=\"ts\">\n\timport { Dialog as DialogPrimitive, type WithoutChildrenOrChild } from \"bits-ui\";\n\timport { type WithChildren, box, mergeProps } from \"svelte-toolbelt\";\n\timport type { ContentProps } from \"./index.js\";\n\timport { noop } from \"../../internal/noop.js\";\n\timport { useId } from \"../../internal/use-id.js\";\n\timport { useDrawerContent } from \"../../use-drawer-content.svelte.js\";\n\timport Mounted from \"../utils/mounted.svelte\";\n\n\tlet {\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tonOpenAutoFocus = noop,\n\t\tonInteractOutside = noop,\n\t\tonFocusOutside = noop,\n\t\toncontextmenu = noop,\n\t\tonpointerdown = noop,\n\t\tonpointerup = noop,\n\t\tonpointerout = noop,\n\t\tonpointermove = noop,\n\t\tchildren,\n\t\t...restProps\n\t}: WithChildren<WithoutChildrenOrChild<ContentProps>> = $props();\n\n\tconst contentState = useDrawerContent({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\toncontextmenu: box.with(() => oncontextmenu ?? noop),\n\t\tonInteractOutside: box.with(() => onInteractOutside),\n\t\tonpointerdown: box.with(() => onpointerdown ?? noop),\n\t\tonpointermove: box.with(() => onpointermove ?? noop),\n\t\tonpointerout: box.with(() => onpointerout ?? noop),\n\t\tonpointerup: box.with(() => onpointerup ?? noop),\n\t\tonOpenAutoFocus: box.with(() => onOpenAutoFocus),\n\t\tonFocusOutside: box.with(() => onFocusOutside),\n\t});\n\n\tconst snapPointsOffset = $state.snapshot(contentState.ctx.snapPointsOffset);\n\n\tconst styleProp = $derived(\n\t\tsnapPointsOffset && snapPointsOffset.length > 0\n\t\t\t? {\n\t\t\t\t\t\"--snap-point-height\": `${snapPointsOffset[contentState.ctx.activeSnapPointIndex ?? 0]}px`,\n\t\t\t\t}\n\t\t\t: {}\n\t);\n\n\tconst mergedProps = $derived(\n\t\tmergeProps(restProps, contentState.props, { style: styleProp })\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t) as any;\n</script>\n\n<DialogPrimitive.Content {...mergedProps}>\n\t{@render children?.()}\n\t<Mounted onMounted={contentState.setMounted} />\n</DialogPrimitive.Content>\n", "import { useRefById } from \"svelte-toolbelt\";\nimport { DrawerContext } from \"./context.js\";\nexport function useDrawerOverlay(opts) {\n    const ctx = DrawerContext.get();\n    let mounted = $state(false);\n    useRefById({\n        id: opts.id,\n        ref: opts.ref,\n        deps: () => mounted,\n        onRefChange: (node) => {\n            if (!mounted) {\n                ctx.setOverlayNode(null);\n            }\n            else {\n                ctx.setOverlayNode(node);\n            }\n        },\n    });\n    const hasSnapPoints = $derived(ctx.snapPoints.current && ctx.snapPoints.current.length > 0);\n    const shouldRender = $derived(ctx.modal.current);\n    const props = $derived({\n        id: opts.id.current,\n        onmouseup: ctx.onRelease,\n        \"data-vaul-overlay\": \"\",\n        \"data-vaul-snap-points\": ctx.open.current && hasSnapPoints ? \"true\" : \"false\",\n        \"data-vaul-snap-points-overlay\": ctx.open.current && ctx.shouldFade ? \"true\" : \"false\",\n        \"data-vaul-animate\": ctx.shouldAnimate ? \"true\" : \"false\",\n    });\n    return {\n        get props() {\n            return props;\n        },\n        get shouldRender() {\n            return shouldRender;\n        },\n        setMounted: (value) => {\n            mounted = value;\n        },\n    };\n}\n", "<script lang=\"ts\">\n\timport { Dialog as DialogPrimitive, type WithoutChildrenOrChild } from \"bits-ui\";\n\timport { type WithChildren, box, mergeProps } from \"svelte-toolbelt\";\n\timport type { OverlayProps } from \"./index.js\";\n\timport { useId } from \"../../internal/use-id.js\";\n\timport { useDrawerOverlay } from \"../../use-drawer-overlay.svelte.js\";\n\timport Mounted from \"../utils/mounted.svelte\";\n\n\tlet {\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tchildren,\n\t\t...restProps\n\t}: WithChildren<WithoutChildrenOrChild<OverlayProps>> = $props();\n\n\tconst overlayState = useDrawerOverlay({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, overlayState.props));\n</script>\n\n{#if overlayState.shouldRender}\n\t<DialogPrimitive.Overlay {...mergedProps}>\n\t\t<Mounted onMounted={overlayState.setMounted} />\n\t\t{@render children?.()}\n\t</DialogPrimitive.Overlay>\n{/if}\n", "<script lang=\"ts\">\n\timport DrawerRoot from \"./drawer.svelte\";\n\timport type { RootProps } from \"./index.js\";\n\timport { noop } from \"../../internal/noop.js\";\n\timport { DrawerContext } from \"../../context.js\";\n\n\tlet {\n\t\topen = $bindable(false),\n\t\tactiveSnapPoint = $bindable(null),\n\t\tonOpenChange = noop,\n\t\tonDrag = noop,\n\t\t...restProps\n\t}: Omit<RootProps, \"nested\" | \"onRelease\" | \"onClose\"> = $props();\n\n\tconst rootState = DrawerContext.get();\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst rest = $derived(restProps) as any;\n</script>\n\n<DrawerRoot\n\tbind:activeSnapPoint\n\tbind:open\n\tnested\n\tonClose={() => rootState.onNestedOpenChange(false)}\n\tonDrag={(e, p) => {\n\t\trootState.onNestedDrag(e, p);\n\t\tonDrag(e, p);\n\t}}\n\tonOpenChange={(o) => {\n\t\tif (o) {\n\t\t\trootState.onNestedOpenChange(o);\n\t\t}\n\t\tonOpenChange(o);\n\t}}\n\tonRelease={rootState.onNestedRelease}\n\t{...rest}\n/>\n", "import { useRefById } from \"svelte-toolbelt\";\nimport { DrawerContext } from \"./context.js\";\nconst LONG_HANDLE_PRESS_TIMEOUT = 250;\nconst DOUBLE_TAP_TIMEOUT = 120;\nexport function useDrawerHandle(opts) {\n    const ctx = DrawerContext.get();\n    useRefById({\n        id: opts.id,\n        ref: opts.ref,\n        deps: () => ctx.open.current,\n    });\n    let closeTimeoutId = null;\n    let shouldCancelInteraction = false;\n    function handleStartInteraction() {\n        closeTimeoutId = window.setTimeout(() => {\n            // Cancel click interaction on a long press\n            shouldCancelInteraction = true;\n        }, LONG_HANDLE_PRESS_TIMEOUT);\n    }\n    function handleCancelInteraction() {\n        if (closeTimeoutId) {\n            window.clearTimeout(closeTimeoutId);\n        }\n        shouldCancelInteraction = false;\n    }\n    function handleCycleSnapPoints() {\n        // Prevent accidental taps while resizing drawer\n        if (ctx.isDragging || opts.preventCycle.current || shouldCancelInteraction) {\n            handleCancelInteraction();\n            return;\n        }\n        // Make sure to clear the timeout id if the user releases the handle before the cancel timeout\n        handleCancelInteraction();\n        if (!ctx.snapPoints.current || ctx.snapPoints.current.length === 0) {\n            if (!ctx.dismissible.current) {\n                ctx.closeDrawer();\n            }\n            return;\n        }\n        const isLastSnapPoint = ctx.activeSnapPoint.current ===\n            ctx.snapPoints.current[ctx.snapPoints.current.length - 1];\n        if (isLastSnapPoint && ctx.dismissible.current) {\n            ctx.closeDrawer();\n            return;\n        }\n        const currentSnapIndex = ctx.snapPoints.current.findIndex((point) => point === ctx.activeSnapPoint.current);\n        if (currentSnapIndex === -1 || currentSnapIndex === undefined)\n            return; // activeSnapPoint not found in snapPoints\n        const nextSnapPoint = ctx.snapPoints.current[currentSnapIndex + 1];\n        ctx.activeSnapPoint.current = nextSnapPoint;\n    }\n    function handleStartCycle() {\n        if (shouldCancelInteraction) {\n            handleCancelInteraction();\n            return;\n        }\n        window.setTimeout(() => {\n            handleCycleSnapPoints();\n        }, DOUBLE_TAP_TIMEOUT);\n    }\n    const props = $derived({\n        id: opts.id.current,\n        \"data-vaul-drawer-visible\": ctx.open.current ? \"true\" : \"false\",\n        \"data-vaul-handle\": \"\",\n        \"aria-hidden\": \"true\",\n        onclick: handleStartCycle,\n        onpointercancel: handleCancelInteraction,\n        onpointerdown: (e) => {\n            if (ctx.handleOnly.current)\n                ctx.onPress(e);\n            handleStartInteraction();\n        },\n        onpointermove: (e) => {\n            if (ctx.handleOnly.current)\n                ctx.onDrag(e);\n        },\n    });\n    return {\n        get props() {\n            return props;\n        },\n    };\n}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { HandleProps } from \"./index.js\";\n\timport { useId } from \"../../internal/use-id.js\";\n\timport { useDrawerHandle } from \"../../use-drawer-handle.svelte.js\";\n\n\tlet {\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tpreventCycle = false,\n\t\tchildren,\n\t\t...restProps\n\t}: HandleProps = $props();\n\n\tconst handleState = useDrawerHandle({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tpreventCycle: box.with(() => preventCycle),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, handleState.props));\n</script>\n\n<div {...mergedProps}>\n\t<span data-vaul-handle-hitarea=\"\" aria-hidden=\"true\">\n\t\t{@render children?.()}\n\t</span>\n</div>\n", "<script lang=\"ts\">\n\timport { Dialog } from \"bits-ui\";\n\timport { DrawerContext } from \"../../context.js\";\n\n\tconst ctx = DrawerContext.get();\n\n\tlet { to = ctx.container.current ?? undefined, ...restProps }: Dialog.PortalProps = $props();\n</script>\n\n<Dialog.Portal {to} {...restProps} />\n"],
  "mappings": "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",
  "names": ["document", "activeElement", "window", "document", "noop", "set", "reset", "prop", "activeSnapPointIndex", "set", "chain", "root", "set", "drawerHeight", "reset", "noop", "noop", "noop", "noop"]
}
