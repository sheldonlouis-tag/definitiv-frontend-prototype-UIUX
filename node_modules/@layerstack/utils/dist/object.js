import { get, mergeWith } from 'lodash-es';
import { entries, fromEntries, keys } from './typeHelpers.js';
import { toCamelCase } from './string.js';
export function isLiteralObject(obj) {
    return obj && typeof obj === 'object' && obj.constructor === Object;
}
export function isEmptyObject(obj) {
    return isLiteralObject(obj) && keys(obj).length === 0;
}
export function camelCaseKeys(obj) {
    return keys(obj).reduce((acc, key) => ((acc[toCamelCase(key ? String(key) : '')] = obj[key]), acc), {});
}
// https://codereview.stackexchange.com/questions/73714/find-a-nested-property-in-an-object
// https://github.com/dominik791/obj-traverse
export function nestedFindByPredicate(obj, predicate, childrenProp) {
    const getChildrenProp = propAccessor(childrenProp ?? 'children');
    if (predicate(obj)) {
        return obj;
    }
    else {
        const children = getChildrenProp(obj);
        if (children) {
            for (let o of children) {
                const match = nestedFindByPredicate(o, predicate, childrenProp);
                if (match) {
                    return match;
                }
            }
        }
    }
}
export function propAccessor(prop) {
    return typeof prop === 'function'
        ? prop
        : typeof prop === 'string'
            ? (d) => get(d, prop)
            : (x) => x;
}
/**
 * Produce a unique Id for an object (helpful for debugging)
 * See: https://stackoverflow.com/a/35306050/191902
 */
var objIdMap = new WeakMap(), objectCount = 0;
export function objectId(object) {
    if (!objIdMap.has(object))
        objIdMap.set(object, ++objectCount);
    return objIdMap.get(object);
}
export function distinctKeys(...objs) {
    return [...new Set(flatten(objs.map((x) => keys(x))))];
}
// Copied from `array.ts` to remove circular dependency
function flatten(items) {
    return items.reduce((prev, next) => prev.concat(next), []);
}
/**
 * Recursive merge objects
 * @param object The destination object
 * @param source  The source object
 * @returns
 */
export function merge(object, source) {
    return mergeWith(object, source, (objValue, srcValue) => {
        if (Array.isArray(srcValue)) {
            // Overwrite instead of merging by index with objValue (like standard lodash `merge` does)
            return srcValue;
        }
    });
}
/**
 * Remove properties from object based on expiration
 */
export function expireObject(object, expiry) {
    const now = new Date();
    if (expiry instanceof Date || typeof object !== 'object' || object == null) {
        // Expired
        if (expiry < now) {
            return null;
        }
        // Not expired
        return object;
    }
    // LoopIterate over the properties in `object`
    for (let [prop, propExpiry] of entries(expiry)) {
        if (propExpiry instanceof Date) {
            // Check if expired
            if (propExpiry < now) {
                if (prop === '$default') {
                    // Delete all properties which do not have explicit expiry to check
                    for (let objProp of keys(object)) {
                        if (!(objProp in expiry)) {
                            delete object[objProp];
                        }
                    }
                    // Remove expired `$default` property
                    // @ts-expect-error it's fine if the property doesn't exist in object
                    delete object[prop];
                }
                else {
                    // Remove expired property
                    // @ts-expect-error it's fine if the property doesn't exist in object
                    delete object[prop];
                }
            }
            else {
                // Keep value
            }
        }
        else {
            // Check expiry for each property in object.  Skip if prop not in object (expiry only)
            const value = object[prop];
            if (value && typeof value === 'object') {
                expireObject(value, propExpiry);
                // Remove property if empty object (all properties removed)
                if (isEmptyObject(value)) {
                    delete object[prop];
                }
            }
        }
    }
    return isEmptyObject(object) ? null : object;
}
/**
 * Remove properties from an object.  See also lodash `_.omit()`
 */
export function omit(obj, keys) {
    if (keys.length === 0) {
        return obj;
    }
    else {
        return fromEntries(entries(obj).filter(([key]) => !keys.includes(key)));
    }
}
/**
 * Remove `null` or `undefined` properties from an object
 */
export function omitNil(obj) {
    if (keys.length === 0) {
        return obj;
    }
    else {
        return fromEntries(entries(obj).filter(([key, value]) => value != null));
    }
}
/**
 * Pick properties from an object.  See also lodash `_.pick()`
 */
export function pick(obj, keys) {
    if (keys.length === 0) {
        return obj;
    }
    else {
        return fromEntries(keys.filter((key) => key in obj).map((key) => [key, obj[key]]));
    }
}
/**
 * Create new object with keys and values swapped.  Last value's key is used if duplicated
 */
export function keysByValues(obj) {
    return fromEntries(entries(obj).map(([key, value]) => [String(value), key]));
}
/**
 * Map keys of an object
 */
export function mapKeys(obj, fn) {
    return fromEntries(entries(obj).map(([key, value]) => [fn(key), value]));
}
/**
 * Map values of an object
 */
export function mapValues(obj, fn) {
    return fromEntries(entries(obj).map(([key, value]) => [key, fn(value)]));
}
