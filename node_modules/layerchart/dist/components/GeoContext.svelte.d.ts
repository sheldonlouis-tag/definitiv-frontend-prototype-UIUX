import { type GeoPermissibleObjects, type GeoProjection } from 'd3-geo';
import type { Snippet } from 'svelte';
export type GeoContextValue = {
    projection: GeoProjection | undefined;
};
export declare function getGeoContext(): GeoContextValue;
export declare function setGeoContext(geo: GeoContextValue): GeoContextValue;
export type GeoContextProps = {
    /**
     * A d3 projection function. Pass this in as an uncalled function, e.g.
     * `projection={geoAlbersUsa}`.
     */
    projection?: () => GeoProjection;
    fitGeojson?: GeoPermissibleObjects;
    /**
     * By default, the map fills to fit the $width and $height. If instead you want a
     * fixed-aspect ratio, like for a server-side rendered map, set that here.
     */
    fixedAspectRatio?: number;
    clipAngle?: number;
    clipExtent?: [[number, number], [number, number]];
    rotate?: {
        /** Lambda (Center Meridian) */
        yaw: number;
        /** Phi */
        pitch: number;
        /** Gamma */
        roll: number;
    };
    scale?: number;
    translate?: [number, number];
    center?: [number, number];
    /**
     * Apply TransformContext to the selected properties.  Typically `translate` or `rotate` are
     * mutually selected
     */
    applyTransform?: ('scale' | 'translate' | 'rotate')[];
    reflectX?: boolean;
    reflectY?: boolean;
    /**
     * Exposed to allow binding in Chart
     *
     * @bindable
     */
    geoContext?: GeoContextValue;
    children: Snippet<[{
        geoContext: GeoContextValue;
    }]>;
};
declare const GeoContext: import("svelte").Component<GeoContextProps, {}, "geoContext">;
type GeoContext = ReturnType<typeof GeoContext>;
export default GeoContext;
