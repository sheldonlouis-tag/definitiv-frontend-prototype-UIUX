export type CanvasPropsWithoutHTML = {
    /**
     * The `<canvas>` tag. Useful for bindings.
     *
     * @bindable
     */
    ref?: HTMLCanvasElement;
    /**
     * The `<canvas>`'s 2d context. Useful for bindings.
     *
     * @bindable
     */
    canvasContext?: CanvasRenderingContext2D;
    /**
     * Force the use of a software (instead of hardware accelerated) 2D canvas, which can
     * save memory when calling getImageData() frequently.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext#willreadfrequently
     *
     * @default false
     */
    willReadFrequently?: boolean;
    /**
     * The `z-index` style to apply to the layer.
     *
     * @default 0
     */
    zIndex?: number;
    /**
     *
     * Whether pointer events should be enabled on the canvas.
     *
     * - `false`: `pointer-events: none;` will be set on the entire layer.
     * - `true`: pointer events will operate normally.
     *
     * @default true
     */
    pointerEvents?: boolean;
    /**
     * The content to display if canvas is not supported or cannot be rendered.
     * This can either be a string or a snippet with custom markup.
     */
    fallback?: string | Snippet;
    /**
     * Translate children to center of the canvas (useful for radial layouts).
     *
     * @default false
     */
    center?: boolean | 'x' | 'y';
    /**
     * Ignore TransformContext.
     *
     * Useful to add static elements such as legends.
     *
     * @default false
     */
    ignoreTransform?: boolean;
    /**
     * Disable the hit canvas (useful when animations are playing)
     *
     * @default false
     */
    disableHitCanvas?: boolean;
    /**
     * Show the hit canvas for debugging purposes.
     *
     * @default false
     */
    debug?: boolean;
    children?: Snippet<[
        {
            ref: HTMLCanvasElement;
            canvasContext: CanvasRenderingContext2D | undefined;
        }
    ]>;
};
export type CanvasProps = CanvasPropsWithoutHTML & Without<HTMLCanvasAttributes, CanvasPropsWithoutHTML>;
type ComponentRender<T extends Element = Element> = {
    name: string;
    render: (ctx: CanvasRenderingContext2D, styleOverrides?: ComputedStylesOptions) => any;
    retainState?: boolean;
    events?: {
        click?: MouseEventHandler<T> | null;
        dblclick?: MouseEventHandler<T> | null;
        pointerenter?: PointerEventHandler<T> | null;
        pointerover?: PointerEventHandler<T> | null;
        pointermove?: PointerEventHandler<T> | null;
        pointerleave?: PointerEventHandler<T> | null;
        pointerout?: PointerEventHandler<T> | null;
        pointerdown?: PointerEventHandler<T> | null;
        touchmove?: TouchEventHandler<T> | null;
    };
    /**
     * Optional dependencies to track and invalidate the canvas context when they change.
     */
    deps?: () => any[];
};
export type CanvasContextValue = {
    /**
     * Register component to render.
     *
     * Returns method to unregister on component destroy
     */
    register<T extends Element>(component: ComponentRender<T>): () => void;
    invalidate(): void;
};
export declare function getCanvasContext(): CanvasContextValue;
/**
 * Handles the automatic registration of the component to the canvas context,
 * with dependency tracking and cleanup on destroy.
 */
export declare function registerCanvasComponent<T extends Element>(component: ComponentRender<T>): void;
import { type Snippet } from 'svelte';
import { type ComputedStylesOptions } from '../../utils/canvas.js';
import type { HTMLCanvasAttributes, MouseEventHandler, PointerEventHandler, TouchEventHandler } from 'svelte/elements';
import type { Without } from '../../utils/types.js';
declare const Canvas: import("svelte").Component<CanvasProps, {}, "ref" | "canvasContext">;
type Canvas = ReturnType<typeof Canvas>;
export default Canvas;
