import { Spring, Tween } from 'svelte/motion';
import { afterTick } from './afterTick.js';
/**
 * Extended Spring class that adds a type discriminator to help with
 * type narrowing in our motion system
 */
class MotionSpring extends Spring {
    type = 'spring';
    constructor(value, options) {
        super(value, options);
    }
}
/**
 * Extended Tween class that adds a type discriminator to help with
 * type narrowing in our motion system
 */
class MotionTween extends Tween {
    type = 'tween';
    constructor(value, options) {
        super(value, options);
    }
}
/**
 * MotionNone is a state container that provides the same interface as
 * Spring and Tween but without any animation logic. Values update immediately.
 *
 * This allows components to use a consistent API regardless of whether
 * animations are enabled or not.
 */
class MotionNone {
    type = 'none';
    #current = $state(null);
    #target = $state(null);
    constructor(value, _options = {}) {
        this.#current = value;
        this.#target = value;
    }
    /**
     * Updates the value immediately and returns a resolved promise
     * to maintain API compatibility with animated motion classes
     */
    set(value, _options = {}) {
        this.#current = value;
        this.#target = value;
        return Promise.resolve();
    }
    get current() {
        return this.#current;
    }
    get target() {
        return this.#target;
    }
    set target(v) {
        this.set(v);
    }
}
/**
 * Sets up automatic tracking between a source value and a motion state.
 * When the `controlled` option is `true`, the motion state will not update
 * automatically and will only update when explicitly set.
 */
function setupTracking(motion, getValue, options) {
    if (options.controlled)
        return;
    $effect(() => {
        motion.set(getValue());
    });
}
export function createMotion(initialValue, getValue, motionProp, options = {}) {
    const motion = parseMotionProp(motionProp);
    const motionState = motion.type === 'spring'
        ? new MotionSpring(initialValue, motion.options)
        : motion.type === 'tween'
            ? new MotionTween(initialValue, motion.options)
            : new MotionNone(initialValue);
    setupTracking(motionState, getValue, options);
    return motionState;
}
/**
 * Creates a controlled motion state that only updates when explicitly set
 * rather than automatically tracking changes to the source value
 */
export function createControlledMotion(initialValue, motionProp) {
    return createMotion(initialValue, () => initialValue, motionProp, { controlled: true });
}
/**
 * Creates a state tracker for animation completion
 * This helps track whether any motion transitions are currently in progress
 *
 * @returns an object with methods to handle animation promises and check current status
 */
export function createMotionTracker() {
    let latestIndex = 0;
    let current = $state(false);
    function handle(promise) {
        latestIndex += 1;
        if (!promise) {
            current = false;
            return;
        }
        let currIndex = latestIndex;
        current = true;
        promise
            .then(() => {
            if (currIndex === latestIndex) {
                current = false;
            }
        })
            .catch(() => { });
    }
    return {
        handle,
        get current() {
            return current;
        },
    };
}
/**
 * Extracts tween configuration from a motion prop
 * @returns Resolved tween configuration or undefined if not a tween
 */
export function extractTweenConfig(prop) {
    const resolved = parseMotionProp(prop);
    if (resolved.type === 'tween')
        return resolved;
}
/**
 * Parses and normalizes a motion configuration into a standard format
 *
 * @param config - The motion configuration to parse
 * @param propertyKey - Optional property key when config is a map of properties
 * @returns A standardized motion configuration object
 */
export function parseMotionProp(config, accessor) {
    if (typeof config === 'object' && 'type' in config && 'options' in config) {
        if (typeof config.options === 'object')
            return config;
        return { type: config.type, options: {} };
    }
    // Default to no animation if no configuration provided
    if (config === undefined)
        return { type: 'none', options: {} };
    // Case 1: string shorthand ('spring', 'tween', 'none')
    if (typeof config === 'string') {
        if (config === 'spring') {
            return { type: 'spring', options: {} };
        }
        else if (config === 'tween') {
            return { type: 'tween', options: {} };
        }
        return { type: 'none', options: {} };
    }
    // Case 2: Object with explicit type property
    if (typeof config === 'object' && 'type' in config) {
        if (config.type === 'spring') {
            const { type, ...options } = config;
            return { type: 'spring', options };
        }
        else if (config.type === 'tween') {
            const { type, ...options } = config;
            return { type: 'tween', options };
        }
        else {
            return { type: 'none', options: {} };
        }
    }
    // Case 3: Property map object, lookup by property key
    // We've already established config is an object at this point
    if (accessor) {
        const propConfig = config[accessor];
        if (propConfig !== undefined) {
            return parseMotionProp(propConfig);
        }
    }
    // Fallback to no animation
    return {
        type: 'none',
        options: {},
    };
}
