import { type ScaleBand, type ScaleTime } from 'd3-scale';
import { type MotionProp, type MotionOptions, type SpringOptions, type TweenOptions } from './motion.svelte.js';
import type { Accessor } from './common.js';
import type { OnlyObjects } from './types.js';
export type AnyScale<TInput extends SingleDomainType = any, TOutput extends SingleDomainType = any, TScaleArgs extends any[] | readonly any[] = any[]> = {
    (value: TInput): TOutput;
    domain(domain: TInput[] | readonly TInput[]): AnyScale<TInput, TOutput, TScaleArgs>;
    domain(): TInput[];
    range(range: TOutput[] | readonly TOutput[]): AnyScale<TInput, TOutput, TScaleArgs>;
    range(): TOutput[];
    rangeRound?: (range: TOutput[] | readonly TOutput[]) => AnyScale<TInput, TOutput, TScaleArgs>;
    copy: () => AnyScale<TInput, TOutput, TScaleArgs>;
    invert?: (value: TOutput) => TInput;
    invertExtent?: (value: TOutput) => [TInput, TInput];
    bandwidth?: () => number;
    ticks?: (count?: number) => TInput[];
    tickFormat?: (count?: number) => (value: TInput) => string;
    clamp?: (clamp: boolean) => AnyScale<TInput, TOutput, TScaleArgs>;
    interpolate?: (interpolate: (a: TOutput, b: TOutput) => (t: number) => TOutput) => AnyScale<TInput, TOutput, TScaleArgs>;
    nice?: (count?: number) => AnyScale<TInput, TOutput, TScaleArgs>;
    interpolator?(interpolator: (t: number) => TOutput): AnyScale<TInput, TOutput, TScaleArgs>;
    interpolator?(): (t: number) => TOutput;
    thresholds?: () => TInput[];
    quantiles?: () => TInput[];
};
export declare function isScaleBand(scale: AnyScale<any, any>): scale is ScaleBand<any>;
export declare function isScaleTime(scale: AnyScale<any, any>): scale is ScaleTime<any, any>;
export declare function getRange(scale: any): any[];
export type SingleDomainType = number | string | Date | null | undefined;
export type DomainType = (number | string | Date | null | undefined)[] | null | undefined;
export declare function createMotionScale<Domain, Range>(scale: AnyScale, motion: MotionProp | undefined, options: {
    defaultDomain?: Domain;
    defaultRange?: Range;
}): {
    readonly current: any;
    domain: (values: Domain) => Promise<void>;
    range: (values: Range) => Promise<void>;
};
/**
 * Implementation for missing `scaleBand().invert()`
 *
 *  See: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales
 *      https://github.com/d3/d3-scale/pull/64
 *      https://github.com/vega/vega-scale/blob/master/src/scaleBand.js#L118
 *      https://observablehq.com/@d3/ordinal-brushing
 * 			https://github.com/d3/d3-scale/blob/11777dac7d4b0b3e229d658aee3257ea67bd5ffa/src/band.js#L32
 * 			https://gist.github.com/LuisSevillano/d53a1dc529eef518780c6df99613e2fd
 */
export declare function scaleBandInvert(scale: ScaleBand<any>): (value: number) => any;
/**
 *  Generic way to invert a scale value, handling scaleBand and continuous scales (linear, time, etc).
 *  Useful to map mouse event location (x,y) to domain value
 */
export declare function scaleInvert(scale: AnyScale<any, any>, value: number): any;
/** Create new copy of scale with domain and range */
export declare function createScale(scale: AnyScale, domain: DomainType, range: any[] | readonly any[] | Function, context?: Record<any, any>): AnyScale<any, any, any[]>;
/**
 * Create a `scaleBand()` within another scaleBand()'s bandwidth
 * (typically a x1 of an x0 scale, used for grouping)
 */
export declare function groupScaleBand<Domain extends {
    toString(): string;
}>(scale: ScaleBand<Domain>, flatData: any[], groupBy: string, padding?: {
    inner?: number;
    outer?: number;
}): ScaleBand<string>;
/**
 * Animate d3-scale as domain and/or range are updated using tweened store
 */
export declare function tweenedScale<Domain, Range>(scale: any, tweenedOptions?: TweenOptions): {
    readonly current: any;
    domain: (values: Domain) => Promise<void>;
    range: (values: Range) => Promise<void>;
};
/**
 * Animate d3-scale as domain and/or range are updated using spring store
 */
export declare function springScale<Domain, Range>(scale: AnyScale, springOptions?: SpringOptions): {
    readonly current: any;
    domain: (values: Domain) => Promise<void>;
    range: (values: Range) => Promise<void>;
};
/**
 * Create a store wrapper around a d3-scale which interpolates the domain and/or range using `tweened()` or `spring()` stores.  Fallbacks to `writable()` store if not interpolating
 */
export declare function motionScale<Domain, Range>(scale: AnyScale, options: OnlyObjects<MotionOptions>): {
    readonly current: any;
    domain: (values: Domain) => Promise<void>;
    range: (values: Range) => Promise<void>;
};
export declare function makeAccessor<TData>(acc: Accessor<TData>): (d: TData) => any;
