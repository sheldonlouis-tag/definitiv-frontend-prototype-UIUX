import { unique } from '@layerstack/utils';
import { scaleBand } from 'd3-scale';
import { createControlledMotion, } from './motion.svelte.js';
import { Spring, Tween } from 'svelte/motion';
function isAnyScale(scale) {
    return typeof scale === 'function' && typeof scale.range === 'function';
}
export function isScaleBand(scale) {
    return typeof scale.bandwidth === 'function';
}
export function isScaleTime(scale) {
    const domain = scale.domain();
    return domain[0] instanceof Date || domain[1] instanceof Date;
}
export function getRange(scale) {
    if (isAnyScale(scale)) {
        return scale.range();
    }
    console.error("[LayerChart] Your scale doesn't have a `.range` method?");
    return [];
}
// this may need to become a getter for options so we can reactively update after mount
export function createMotionScale(scale, motion, options) {
    const domain = createControlledMotion(options.defaultDomain, motion);
    const range = createControlledMotion(options.defaultRange, motion);
    const motionScale = $derived.by(() => {
        // @ts-expect-error
        const scaleInstance = scale.domain ? scale : scale(); // support `scaleLinear` or `scaleLinear()` (which could have `.interpolate()` and others set)
        if (domain.current) {
            scaleInstance.domain(domain.current);
        }
        if (range.current) {
            scaleInstance.range(range.current);
        }
        return scaleInstance;
    });
    return {
        get current() {
            return motionScale;
        },
        domain: (values) => domain.set(values),
        range: (values) => range.set(values),
    };
}
/**
 * Implementation for missing `scaleBand().invert()`
 *
 *  See: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales
 *      https://github.com/d3/d3-scale/pull/64
 *      https://github.com/vega/vega-scale/blob/master/src/scaleBand.js#L118
 *      https://observablehq.com/@d3/ordinal-brushing
 * 			https://github.com/d3/d3-scale/blob/11777dac7d4b0b3e229d658aee3257ea67bd5ffa/src/band.js#L32
 * 			https://gist.github.com/LuisSevillano/d53a1dc529eef518780c6df99613e2fd
 */
export function scaleBandInvert(scale) {
    const domain = scale.domain();
    const eachBand = scale.step();
    const paddingOuter = eachBand * (scale.paddingOuter?.() ?? scale.padding()); // `scaleBand` uses paddingOuter(), while `scalePoint` uses padding() for outer paddding - https://github.com/d3/d3-scale#point_padding
    return function (value) {
        const index = Math.floor((value - paddingOuter / 2) / eachBand);
        return domain[Math.max(0, Math.min(index, domain.length - 1))];
    };
}
/**
 *  Generic way to invert a scale value, handling scaleBand and continuous scales (linear, time, etc).
 *  Useful to map mouse event location (x,y) to domain value
 */
export function scaleInvert(scale, value) {
    if (isScaleBand(scale)) {
        return scaleBandInvert(scale)(value);
    }
    else {
        return scale.invert?.(value);
    }
}
/** Create new copy of scale with domain and range */
export function createScale(scale, domain, range, context) {
    const scaleCopy = scale.copy();
    if (domain) {
        scaleCopy.domain(domain);
    }
    if (typeof range === 'function') {
        scaleCopy.range(range(context));
    }
    else {
        scaleCopy.range(range);
    }
    return scaleCopy;
}
/**
 * Create a `scaleBand()` within another scaleBand()'s bandwidth
 * (typically a x1 of an x0 scale, used for grouping)
 */
export function groupScaleBand(scale, flatData, groupBy, padding) {
    //
    const groupKeys = unique(flatData.map((d) => d[groupBy]));
    let newScale = scaleBand().domain(groupKeys).range([0, scale.bandwidth()]);
    if (padding) {
        if (padding.inner) {
            newScale = newScale.paddingInner(padding.inner);
        }
        if (padding.outer) {
            newScale = newScale.paddingOuter(padding.outer);
        }
    }
    return newScale;
}
/**
 * Animate d3-scale as domain and/or range are updated using tweened store
 */
export function tweenedScale(scale, tweenedOptions = {}) {
    const tweenedDomain = new Tween(undefined, tweenedOptions);
    const tweenedRange = new Tween(undefined, tweenedOptions);
    const tweenedScale = $derived.by(() => {
        const scaledInstance = scale.domain ? scale : scale();
        if (tweenedDomain.current) {
            scaledInstance.domain(tweenedDomain.current);
        }
        if (tweenedRange.current) {
            scaledInstance.range(tweenedRange.current);
        }
        return scaledInstance;
    });
    return {
        get current() {
            return tweenedScale;
        },
        domain: (values) => tweenedDomain.set(values),
        range: (values) => tweenedRange.set(values),
    };
}
/**
 * Animate d3-scale as domain and/or range are updated using spring store
 */
export function springScale(scale, springOptions = {}) {
    const domainState = new Spring(undefined, springOptions);
    const rangeState = new Spring(undefined, springOptions);
    const sprungScale = $derived.by(() => {
        // @ts-expect-error - TODO: investigate/fix
        const scaledInstance = scale.domain ? scale : scale();
        if (domainState.current) {
            scaledInstance.domain(domainState.current);
        }
        if (rangeState.current) {
            scaledInstance.range(rangeState.current);
        }
        return scaledInstance;
    });
    return {
        get current() {
            return sprungScale;
        },
        domain: (values) => domainState.set(values),
        range: (values) => rangeState.set(values),
    };
}
/**
 * Create a store wrapper around a d3-scale which interpolates the domain and/or range using `tweened()` or `spring()` stores.  Fallbacks to `writable()` store if not interpolating
 */
export function motionScale(scale, options) {
    const domainState = createControlledMotion(undefined, options);
    const rangeState = createControlledMotion(undefined, options);
    const tweenedScale = $derived.by(() => {
        // @ts-expect-error
        const scaleInstance = scale.domain ? scale : scale(); // support `scaleLinear` or `scaleLinear()` (which could have `.interpolate()` and others set)
        if (domainState.current) {
            scaleInstance.domain(domainState.current);
        }
        if (rangeState.current) {
            scaleInstance.range(rangeState.current);
        }
        return scaleInstance;
    });
    return {
        get current() {
            return tweenedScale;
        },
        domain: (values) => domainState.set(values),
        range: (values) => rangeState.set(values),
    };
}
function canBeZero(val) {
    if (val === 0)
        return true;
    return val;
}
export function makeAccessor(acc) {
    if (!canBeZero(acc))
        return null;
    if (Array.isArray(acc)) {
        return (d) => acc.map((k) => {
            // @ts-expect-error - TODO: Fix these types
            return typeof k !== 'function' ? d[k] : k(d);
        });
    }
    else if (typeof acc !== 'function') {
        // @ts-expect-error - TODO: Fix these types
        return (d) => d[acc];
    }
    return acc;
}
